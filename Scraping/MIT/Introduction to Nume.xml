<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/</course_url>
    <course_title>Introduction to Numerical Analysis for Engineering (13.002J)</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Mathematics </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>Linear Systems of Equations: Cramer&#8217;s Rule
Gaussian Elimination</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_3/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3Systems of Linear Equations
Gaussian Elimination
Reduction
Step 0 Linear System of Equations</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3Systems of Linear Equations
Cramer&#8217;s Rule
Cramer&#8217;s Rule, n=2Linear System of Equations
Example, n=2
Cramer&#8217;s rule inconvenient for n&gt;3</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3Systems of Linear Equations
Gaussian Elimination
Example, n=2
Cramer&#8217;s Rule - ExactGaussian Elimination
2-digit Arithmetic
1% error100% error
n=3
a = [ [0.01 1.0]' [-1.0 0.01]']
b= [1 1]'
r=a^(-1) * b
x=[0 0];
m21=a(2,1)/a(1,1);
a(2,1)=0;
a(2,2) = radd(a(2,2),-m21*a(1,2),n);
b(2)   = radd(b(2),-m21*b(1),n);
x(2)   = b(2)/a(2,2);
x(1)   = (radd(b(1), -a(1,2)*x(2),n))/a(1,1);
x'tbt.mtbt.m</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Example, n=2
Cramer&#8217;s Rule - Exact2-digit ArithmeticMultiply Equation 1 by 200
1% error100% error
Infinity-Norm NormalizationEquations must be normalized for 
partial pivoting to ensure stability
This Equilibration is made by 
normalizing the matrix to unit normTwo-Norm Normalization</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3Systems of Linear Equations
Gaussian Elimination
Reduction
Step 1
ij</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Pivotal ElementsReduction
Step kPartial Pivoting by Columns
New Row k
New Row i
Required at each step!</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 3Introduction to Numerical Analysis for Engineers
&#8226; Systems of Linear Equations
Mathews
&#8211; Cramer&#8217;s Rule
&#8211; Gaussian Elimination 3.3-3.5
&#8226; Numerical implementation
3.3-3.4
&#8226; Numerical stability
&#8211; Partial Pivoting
&#8211; Equilibration
&#8211; Full Pivoting
&#8226; Multiple right hand sides
&#8226; Computation count
&#8226; LU factorization 3.5
&#8226; Error Analysis for Linear Systems 3.4
&#8211; Condition Number
&#8226; Special Matrices
&#8211; Iterative Methods 3.6
&#8226; Jacobi&#8217;s method
&#8226; Gauss-Seidel iteration
&#8226; Convergence</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Example, n=2
Cramer&#8217;s Rule - ExactPartial Pivoting by Columns
Interchange Rows 
2-digit Arithmetic
1% error1% error
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3&#8226; Partial Pivoting
&#8211; Equilibrate system of equations
&#8211; Pivoting by Columns
&#8211; Simple book-keeping
&#8226; Solution vector in original order
&#8226; Full Pivoting
&#8211; Does not require equilibration
&#8211; Pivoting by both row and columns
&#8211; More complex book-keeping
&#8226; Solution vector re-orderedSystems of Linear Equations
Gaussian Elimination
Numerical Stability
Partial Pivoting is simplest and most common
Neither method guarantees stability </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Reduction
Step n-1Reduction
Step k
Back-Substitution</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Example, n=2
Cramer&#8217;s Rule - ExactVariable Transformation
2-digit Arithmetic
1% error
100% error
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3&#8226; System of equations must be well conditioned
&#8211; Investigate condition number
&#8226; Tricky, because it requires matrix inversion (next class)
&#8211; Consistent with physics
&#8226; E.g. don&#8217;t couple domains that are physically uncoupled
&#8211; Consistent units
&#8226; E.g. don&#8217;t mix meter and Pm in unknowns
&#8211; Dimensionless unknowns
&#8226; Normalize all unknowns consistently
&#8226; Equilibration and Partial Pivoting, or Full PivotingSystems of Linear Equations
Gaussian Elimination
How to Ensure Numerical Stability</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3Systems of Linear Equations
Gaussian Elimination
Pivotal ElementsStep k
 Partial Pivoting by Columns
Row k
Row i
Required at each step!</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 3
Systems of Linear Equations
Gaussian Elimination
Example, n=2
Cramer&#8217;s Rule - ExactInterchange Unknowns
2-digit Arithmetic
1% error
Pivoting by Rows
Full Pivoting
Find largest numerical value in sa me row and column and interchange
Affects  ordering of unknowns</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Error Propagation
Error Estimation
Condition Numbers</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_2/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
Error Propagation
Euler&#8217;s Method
Differential Equation
Example
Discretization
Finite Difference (forward)
Recurrence
Central Finite Difference euler.m
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Error Propagation
Expectation of Errors
Truncation
Error Expectation
RoundingAddition
Standard Error
Standard Error better measure
of expected errors
2
n</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Error Propagation
Error Cancellation
Function of one variable
Max. error
Stand. errorError cancellation
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
Error Analysis
Number Representation
Absolute Error
Relative ErrorAddition and Subtraction
Multiplication and Division
Relative ErrorUnboundedAbsolute Error
BoundedRelative ErrorShift mantissa of largest number
Result has exponent of largest number
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
m Mantissa
b Base
e ExponentFloating Number Representation
Examples
Convention
Decimal
Binary
Decimal
Binary
General
Max mantissa
Min mantissa
Max exponent
Min exponent
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
Error Propagation
Example
Multiplication
=&gt;=&gt;
=&gt;
=&gt;Error Propagation Formula
Relative Errors Add for Multiplication</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Introduction to Numerical Analysis for 
Engineers
&#8226; Fundamentals of Digital Computing
&#8211; Digital Computer Models
&#8211; Convergence, accuracy and stability
&#8211; Number representation
&#8211; Arithmetic operations
&#8211; Recursion algorithms
&#8226; Error Analysis 
&#8211; Error propagation &#8211; numerical stability
&#8211; Error estimation
&#8211; Error cancellation
&#8211; Condition numbers</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Error Propagation
Spherical Bessel Functions
Forward Recurrence
Backward Recurrence
Forward Recurrence
Miller&#8217;s algorithm
N ~ x+20
Unstable
Stable</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Error Propagation
'y~f &#8217;(x)'x
'x = x - x
x xAbsolute Errors
Function of one variable
General Error Propagation Formula</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
Error Propagation
Condition Number
x = x(1 + D)x x
y = y(1 + E)y yy = f(x)
Problem ill-conditioned
Error cancellation exampleProblem Condition Number
Well-conditioned problem</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2
Error Propagation
Condition Number
Problem Condition Number
4 Significant Digits
Algorithm Condition NumberKis algorith condition number , which 
may be much larger  than the Kdue
to limited number  representation.
Solution
&#8226;Higher precision
&#8226;Rewrite algorithm PA
Well-conditioned Algorithm</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 2Error Propagation
Spherical Bessel Functions
Differential Equation
Solutions
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Ordinary Differential Equations (cont.)
Boundary Value Problems: Finite Difference Methods</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_11/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Boundary Value Problems
Direct Finite Difference Methods
Differential Equation
xy
a b
Boundary
Conditions
Discretization
Finite Differences h
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Introduction to Numerical Analysis for Engineers
&#8226; Ordinary Differential Equations 9
&#8211; Initial Value Problems 9.1
&#8226; Euler&#8217;s Method 9.2
&#8226; Taylor Series Methods 9.4
&#8211; Error analysis
&#8226; Runge-Kutta Methods 9.5
&#8211; Systems of differential equations  9.7
&#8211; Boundary Value Problems 9.8
&#8226; Shooting method 9.8
&#8226; Direct Finite Difference methods 9.9Mathews</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Boundary Value Problems
Finite Difference Methods
Forced Vibration of a String
f(x,t)
Harmonic excitation
f(x,t) = f(x) cos(Zt)
Differential Equation
Boundary ConditionsDiscrete Difference Equations
Matrix Form
Tridiagonal MatrixFinite Difference
Symmetric, positive defin ite: No pivoting neededy(x,t)xi</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Boundary Value Problems
Direct Finite Difference Methods
Boundary value Problem
Finite Differences
Substitute Finite Differences
Difference Equations
N-1 equations, N-1 unknowns
Matrix Equations
Linear Differential Equations
Solve using standard linear system solver-1</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Initial Value Problems
Higher Order Differential Equations
Differential Equation
Initial
ConditionsConvert to 1stOrder System
Matrix form
Solved using e.g. Runge-Kutta (ode45)</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11Boundary Value Problems
Shooting Method
Differential Equation
xy
a b
Boundary
Conditions
&#8216;Shooting&#8217; Method
Initial value Problem
Solve by Runge-Kutta
&#8216;Shooting&#8217; Iteration
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 11
Boundary Value Problems
Finite Difference Methods
Boundary Conditions with Derivatives
Difference EquationsCentral DifferenceNN+1 N-1
General Boundary Conditions
Add extra point - N equations, N unknowns
Finite Difference Representation O(h  )4
O(h  )2Central Difference
O(h  )3 Backward Difference</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Linear Systems: Iterative Methods
Convergence of Iterative Schemes</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_6/</lecture_pdf_url>
      <lectureno>6</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 6vib_string.m
o = 0.5
Exact Solution Iterative Solutions</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 6Linear Systems of Equations
Iterative Methods
x
x
xxxxx
x xx
0
000
00Sparse, Full-bandwidth Systems
0000
0
0000Rewrite Equations
Iterative, Recursive Methods
Gauss-Seidels&#8217;s Method
Jacobi&#8217;s Method</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 6vib_string.m
n=99;
L=1.0;
h=L/(n+1);
k=2*pi;
kh=k*h
x=[h:h:L-h]';
a=zeros(n,n);
f=zeros(n,1);
o=1
a(1,1) =kh^2 - 2;
a(1,2)=o;
for i=2:n-1
a(i,i)=a(1,1);
a(i,i-1) = o;
a(i,i+1) = o;
end
a(n,n)=a(1,1);
a(n,n-1)=o;
nf=round((n+1)/3);
nw=round((n+1)/6);
nw=min(min(nw,nf-1),n-nf);
figure(1)
hold off
nw1=nf-nw;
nw2=nf+nw;
f(nw1:nw2) = h^2*hanning(nw2-nw1+1);
subplot(2,1,1); plot(x,f,'r');
% exact solution
y=inv(a)*f;
subplot(2,1,2); plot(x,y,'b');% Iterative solution using Jacobi and Gauss-Seidel
b=-a;
c=zeros(n,1);
for i=1:n
b(i,i)=0;
for j=1:n
b(i,j)=b(i,j)/a(i,i);
c(i)=f(i)/a(i,i);
end
end
nj=100;
xj=f;
xgs=f;
figure(2)
nc=6
col=['r' 'g' 'b' 'c' 'm' 'y']
hold off
for j=1:nj
xj=b*xj+c;
xgs(1)=b(1,2:n)*xgs(2:n) + c(1);
for i=2:n-1
xgs(i)=b(i,1:i-1)*xgs(1:i-1) + b(i,i+1:n)*xgs(i+1:n) +c(i);
end
xgs(n)= b(n,1:n-1)*xgs(1:n-1) +c(n);
cc=col(mod(j-1,nc)+1);
subplot(2,1,1); plot(x,xj,cc); hold on;
subplot(2,1,2); plot(x,xgs,cc); hold on;
hold on
endOff-diagonal values</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 6vib_string.m
o=1.0
Exact Solution Iterative Solutions
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 6Linear Systems of Equations
Iterative Methods
Sufficient Convergence Condition
Sufficient Convergence Condition
Jacobi&#8217;s Method
Diagonal Dominance
Stop Criterion for Iteration
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 6Introduction to Numerical Analysis for Engineers
&#8226; Systems of Linear Equations Mathews
&#8211; Cramer&#8217;s Rule
&#8211; Gaussian Elimination 3.3-3.5
&#8226; Numerical implementation
3.3-3.4
&#8226; Numerical stability
&#8211; Partial Pivoting
&#8211; Equilibration
&#8211; Full Pivoting
&#8226; Multiple right hand sides
&#8226; Computation count
&#8226; LU factorization 3.5
&#8226; Error Analysis for Linear Systems 3.4
&#8211; Condition Number
&#8226; Special Matrices
&#8211; Iterative Methods 3.6
&#8226; Jacobi&#8217;s method
&#8226; Gauss-Seidel iteration
&#8226; Convergence</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 6Linear Systems of Equations
Iterative Methods
Convergence
Iteration &#8211; Matrix form
Decompose Coefficient Matrix
with
/
/
Jacobi&#8217;s Method
Iteration Matrix form
Convergence Analysis
Sufficient Convergence Condition</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Linear Systems: Tri-diagonal Systems
Special Matrices</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_5/</lecture_pdf_url>
      <lectureno>5</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Tri-diagonal Systems
General Tri-diagonal Systems
LU Factorization
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 5Introduction to Numerical Analysis for Engineers
&#8226; Systems of Linear Equations Mathews
&#8211; Cramer&#8217;s Rule
&#8211; Gaussian Elimination 3.3-3.5
&#8226; Numerical implementation
3.3-3.4
&#8226; Numerical stability
&#8211; Partial Pivoting
&#8211; Equilibration
&#8211; Full Pivoting
&#8226; Multiple right hand sides
&#8226; Computation count
&#8226; LU factorization 3.5
&#8226; Error Analysis for Linear Systems 3.4
&#8211; Condition Number
&#8226; Special Matrices
&#8211; Iterative Methods 3.6
&#8226; Jacobi&#8217;s method
&#8226; Gauss-Seidel iteration
&#8226; Convergence</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 500q
=00Banded Coefficient Matrix
Gaussian Elimination
With Pivoting 
q
Linear Systems of Equations
Special Matrices</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Special Matrices
Symmetric, Positive Definite Coefficient Matrix
No pivoting needed
Choleski Factorization 
where</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5
00q
00pLinear Systems of Equations
Special Matrices
Banded Coefficient Matrix
Gaussian Elimination
No Pivoting
= =</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 500q
qp pBanded Coefficient Matrix
Compact StorageLinear Systems of Equations
Special Matrices
0
0
n2Diagonal
n(p+2q+1)q
i
ji
j -i</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Tri-diagonal Systems
LU Factorization
Reduction
Forward Substitution
Back Substitution
LU Factorization: 2*(n-1) operations
Forward substitution: n-1 operations
Back substitution: n-1 operations
Total: 4(n-1) ~ O(n) operations</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Special Matrices
Sparse and Banded Coefficient Matrix
&#8216;Skyline&#8217; Systems 
&#8230;..
&#8230;..&#8230;..
&#8230;..
Skyline storage applicable when no pivoting is needed, e.g. for banded, 
symmetric, and positive definite matr ices: FEM and FD methods.  Skyline 
solvers are usually based on Choleski factorization&#8216;Skyline&#8217;
Storage
Pointers 149111620
00</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Tri-diagonal Systems
y(x,t)xiForced Vibration of a String
f(x,t)
Harmonic excitation
f(x,t) = f(x) cos(Zt)
Differential Equation
Boundary ConditionsDiscrete Difference Equations
Matrix Form
Tridiagonal MatrixFinite Difference
Symmetric, positive definite: No pivoting needed</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 5Linear Systems of Equations
Special Matrices
General, Banded Coefficient Matrix 
00p
q
psuper- diagonals
qsub-diagonals
w = p+q+1 bandwidth
bis half- bandwidthBanded Symmetric Matrix </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Interpolation of Functions by Polynomials
Lagrange Interpolation
Triangular Family</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_8/</lecture_pdf_url>
      <lectureno>8</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Introduction to Numerical Analysis for Engineers
&#8226; Interpolation 4.1-4.4
&#8211; Lagrange interpolation 4.3
&#8211; Triangular families 4.4
&#8211; Newton&#8217;s iteration method 4.4
&#8211; Equidistant Interpolation 4.4
&#8226; Numerical Differentiation 6.1-6.2
&#8226; Numerical Integration 7.1-7.3
&#8211; Error of numerical integrationMathews</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Triangular Families of Polynomials
Polynomial Evaluation
Horner&#8217;s Scheme
Remainder &#8211; Interpolation Error</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Polynomial Interpolation
Taylor Series
Remainder
Requirement
xf(x)
f(x)p(x)
Ill-conditioned for large n
Polynomial is unique, but how do 
we calculate the coefficients?</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Purpose of numerical Interpolation
1. Compute intermediate values of a sampled function
2. Numerical differentiation &#8211; foundation for Finite 
Difference and Finite Element methods
3. Numerical Integration
Given:
Find
 for
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8
Numerical Interpolation
Newton&#8217;s Iteration Formula
Standard triangular family of polynomials
Divided DifferencesNewton&#8217;s Computational Scheme
2
3
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Lagrange Polynomials
xf(x)
1
k-3 k-2 k-1kk+1k+2
Difficult to program
Difficult to estimate errors
Divisions are expensive
Important for numerical integration </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Polynomial Interpolation
xf(x)
Interpolation functionInterpolationPolynomial Interpolation
Coefficients: Linear System of Equations</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Polynomial Interpolation
Linear InterpolationExamples
xf(x)
xf(x)
Quadratic Interpolation</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Newton&#8217;s Iteration Formula
xf(x)
xf(x)
1 01234
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Triangular Families of Polynomials
Ordered Polynimials
whereSpecial form convenient 
for interpolation
Coefficients
found by recursion
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 8Numerical Interpolation
Equidistant Newton Interpolation
Divided Differences
Stepsize ImpliedEquidistant Sampling
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 8Numerical Interpolation
Newton&#8217;s Iteration Formula
function[a] = interp_test(n)
%n=2
h=1/n
xi=[0:h:1]
f=sqrt(1-xi.*xi) .* (1 - 2*xi +5*(xi.*xi));
%f=1-2*xi+5*(xi.*xi)-4*(xi.*xi.*xi);
c=newton_coef(h,f)
m=101
x=[0:1/(m-1):1];
fx=sqrt(1-x.*x) .* (1 - 2*x +5*(x.*x));
%fx=1-2*x+5*(x.*x)-4*(x.*x.*x);
y=newton(x,xi,c);
hold off; b=plot(x,fx,'b'); set(b,'LineWidth',2);
hold on; b=plot(xi,f,'.r') ; set(b,'MarkerSize',30); 
b=plot(x,y,'g'); set(b,'LineWidth',2);
yl=lagrange(x,xi,f);
b=plot(x,yl,'xm'); set(b,'Markersize',5);
b=legend('Exact','Samples','Newton','Lagrange')
b=title(['n = ' num2str(n)]); set(b,'FontSize',16);
function[y] = newton(x,xi,c) 
% Computes Newton polynomial
% with coefficients c
n=length(c)-1
m=length(x)
y=c(n+1)*ones(1,m);
for i=n-1:-1:0
cc=c(i+1);
xx=xi(i+1);
y=cc+y.*(x-xx);
endfunction[c] = newton_coef(h,f)
% Computes Newton Coefficients 
% for equidistant sampling h
n=length(f)-1
c=f; c_old=f; fac=1;
for i=1:n
fac=i*h;
for j=i:n
c(j+1)=(c_old(j+1)-c_old(j))/fac;
end
c_old=c;
end</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Numerical Differentiation and Integration
Error Estimates</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_9/</lecture_pdf_url>
      <lectureno>9</lectureno>
      <slides>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9Numerical Integration
Trapezoidal Rule
Simpson&#8217;s Rulexf(x)
h
xf(x)
h hn=2n=1</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9
xf(x)
h hn=2Numerical Differentiation
Second order
Second Derivatives
n=3 Central DifferenceForward Difference n=2 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9Numerical Differentiation
Taylor Series
First order
xf(x)
hn=1</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9
Numerical Integration
Error Analysis
xf(x)
h h
Trapezoidal Rule
Local Absolute Error
Global ErrorSimpson&#8217;s Rule
Local Error
Global Error
Local Error
N Intervals</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9Introduction to Numerical Analysis for Engineers
&#8226; Interpolation 4.1-4.4
&#8211; Lagrange interpolation 4.3
&#8211; Triangular families 4.4
&#8211; Newton&#8217;s iteration method 4.4
&#8211; Equidistant Interpolation 4.4
&#8226; Numerical Differentiation 6.1-6.2
&#8226; Numerical Integration 7.1-7.3
&#8211; Error of numerical integrationMathews</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 9
Numerical Integration
xf(x)
a bLagrange Interpolation
Equidistant Sampling
Integration Weights (Cote&#8217;s Numbers)
Properties</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Introduction
Computer Architecture
Number Representations
Recursion</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_1/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1Recursion
Horner&#8217;s Scheme
% Horners scheme 
% for evaluating polynomials
a=[ 1 2 3 4 5 6 7 8 9 10 ];
n=length(a) -1 ;
z=1;
b=a(1);
% Note index shift for a
for i=1:n
b=a(i+1)+ z*b;
end
p=bEvaluate polynomial
Horner&#8217;s Scheme
General order n
Recurrence relation
&gt;&gt; horner
p =
55
&gt;&gt;horner.m</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1Introduction to Numerical Analysis for Engineers
&#8226; Fundamentals of Digital Computing
&#8211; Digital Computer Models
&#8211; Convergence, accuracy and stability
&#8211; Number representation
&#8211; Arithmetic operations
&#8211; Recursion algorithms
&#8226; Error Analysis 
&#8211; Error propagation &#8211; numerical stability
&#8211; Error estimation
&#8211; Error cancellation
&#8211; Condition numbers</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1
Arithmetic Operations
Number Representation
Absolute Error
Relative ErrorAddition and Subtraction
Multiplication and Division
Relative ErrorUnboundedAbsolute Error
BoundedRelative ErrorShift mantissa of largest number
Result has exponent of largest number
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1Recursion
Order of Operations Matter
0 1N=20; sum=0; sumr=0;
b=1; c=1; x=0.5;
xn=1;
% Number of significant digits in computations
dig=2;
ndiv=10;
for i=1:N
a1=sin(pi/2-pi/(ndiv*i));
a2=-cos(pi/(ndiv*(i+1)));
% Full matlab precision
xn=xn*x;
addr=xn+b*a1;
addr=addr+c*a2;
ar(i)=addr;
sumr=sumr+addr;
z(i)=sumr;
% additions with dig significant digits
add=radd(xn,b*a1,dig);
add=radd(add,c*a2,dig);
% add=radd(b*a1,c*a2,dig);
% add=radd(add,xn,dig);
a(i)=add;
sum=radd(sum,add,dig);
y(i)=sum;
end
sumr
'      i       delta      Sum    delta(approx) Sum(approx)'
res=[[1:1:N]' ar' z' a' y']
hold off
a=plot(y,'b'); set(a,'LineWidth',2);
hold on
a=plot(z,'r'); set(a,'LineWidth',2);
a=plot(abs(z-y)./z,'g'); set(a,'LineWidth',2);
legend([ num2str(dig) ' digits'],'Exact','Error');recur.m
Result of small,  but significant 
term &#8216;destroyed&#8217; by subsequent 
addition and subtraction of almost 
equal, large numbers.
Remedy:
Change order of additions</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1recur.m
&gt;&gt; recur
b = 1; c = 1; x = 0.5;
dig=2
i       delta      Sum    delta(approx) Sum(approx)
res =
1.0000    0.4634    0.4634    0.5000    0.5000
2.0000    0.2432    0.7065    0.2000    0.7000
3.0000    0.1226    0.8291    0.1000    0.8000
4.0000    0.0614    0.8905    0.1000    0.9000
5.0000    0.0306    0.9212         0    0.9000
6.0000    0.0153    0.9364         0    0.9000
7.0000    0.0076    0.9440         0    0.9000
8.0000    0.0037    0.9478         0    0.9000
9.0000    0.0018    0.9496         0    0.9000
10.0000    0.0009    0.9505         0    0.9000
11.0000    0.0004    0.9509         0    0.9000
12.0000    0.0002    0.9511         0    0.9000
13.0000    0.0001    0.9512         0    0.9000
14.0000    0.0000    0.9512         0    0.9000
15.0000    0.0000    0.9512         0    0.9000
16.0000   -0.0000    0.9512         0    0.9000
17.0000   -0.0000    0.9512         0    0.9000
18.0000   -0.0000    0.9512         0    0.9000
19.0000   -0.0000    0.9512         0    0.9000
20.0000   -0.0000    0.9512         0    0.9000
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1
m Mantissa
b Base
e ExponentFloating Number Representation
Examples
Convention
Decimal
Binary
Decimal
Binary
General
Max mantissa
Min mantissa
Max exponent
Min exponent
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1Digital Computer Models
x
w(x,t)
x w(x,t)
nnxn
mContinuous Model
Discrete ModelDifferential Equation
Difference Equation
System of Equations
Linear System of Equations
Eigenvalue Problems
Non-trivial Solutions
Root findingDifferentiation
Integration
Solving linear 
equations
Accuracy and Stability =&gt; Convergence</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 1Recursion
Numerically evaluate square-root
Initial guess
Test
Mean of guess and  its reciprocal
Recursion Algorithma=26;
n=10;
g=1;
sq(1)=g;
for i=2:n
sq(i)= 0.5*(sq(i-1) + a/sq(i-1));
end
hold off
plot([0 n],[sqrt(a) sqrt(a)],'b')
hold on
plot(sq,'r')
plot(a./sq,'r-.')
plot((sq-sqrt(a))/sqrt(a),'g')
grid onMATLAB script 
sqr.m
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Roots of Non-linear Equations: Bisection
Newton-Ralphson Iteration</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_7/</lecture_pdf_url>
      <lectureno>7</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
General Method
Example: Cube root
Rewrite
Convergence
Converges more rapidly for small 
n=10;
g=1.0;
C=-0.21;
sq(1)=g;
for i=2:n
sq(i)= sq(i-1) + C*(sq(i-1)^3 -a);
end
hold off
f=plot([0 n],[a^(1./3.) a^(1/3.)],'b')
set(f,'LineWidth',2);
hold on
f=plot(sq,'r')
set(f,'LineWidth',2);
f=plot( (sq-a^(1./3.))/(a^(1./3.)),'g')
set(f,'LineWidth',2);
legend('Exact','Iteration','Error');
f=title(['a = ' num2str(a) ', C = ' num2str(C)])
set(f,'FontSize',16);
grid on
cube.m</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
Bisection
xf(x)Algorithm
n = n+1
yes
no Less efficient than Newton-Raphson and 
Secant methods, but o ften used to isolate 
interval with root and obtain approximate 
value. Then followed by N-R or Secant 
method for accurate root.   </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
General Method
Converging, but how close?
General Convergence RuleAbsolute error</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
Secant Method
1. In Newton-Raphson we hav e to evaluate 2 functions
2. may not be given in closed, anal ytical form, i.e. it may be a 
result of a numerical algorithm
Approximate Derivative
Secant Method Iteration
Only 1 function call per iteration: 
xf(x)
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
Newton-Raphson Method
Newton-Raphson IterationFast Convergence
Convergence CriteriaNon-linear Equation
xf(x)
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Newton-Raphson Method
Example &#8211; Square Root
Newton-Raphson
Same as Heron&#8217;s formulaa=26;
n=10;
g=1;
sq(1)=g;
for i=2:n
sq(i)= 0.5*(sq(i-1) + a/sq(i-1));
end
hold off
plot([0 n],[sqrt(a) sqrt(a)],'b')
hold on
plot(sq,'r')
plot(a./sq,'r-.')
plot((sq-sqrt(a))/sqrt(a),'g')
grid onsqr.m
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Newton-Raphson Method
a=10;
n=10;
g=0.19;
sq(1)=g;
for i=2:n
sq(i)=sq(i-1) - sq(i-1)*(a*sq(i-1) -1) ;
end
hold off
plot([0 n],[1/a 1/a],'b')
hold on
plot(sq,'r')
plot((sq-1/a)*a,'g')
grid on
legend('Exact','Iteration','Error');
title(['x = 1/' num2str(a)])div.m
Newton-RaphsonApproximate Guess
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Secant Method
Convergence Speed
Absolute Error
Taylor Series &#8211; 2ndorder
Relative ErrorError Exponent
1
Error improvement for each function call
Newton-RaphsonSecant Method
Exponents called Efficiency Index</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Introduction to Numerical Analysis for Engineers
&#8226; Roots of Non-linear Equations 2.1-2.4
&#8211; Heron&#8217;s formula
&#8211; Stop criteria
&#8211; General method 2.1-2.3
&#8226; Convergence
&#8226; Examples
&#8211; Newton-Raphson&#8217;s Method 2.4
&#8226; Convergence Speed
&#8226; Examples
&#8211; Secant Method 2.4
&#8226; Convergence and efficiency
&#8226; Examples
&#8211; Multiple roots 2.4
&#8211; Bisection 2.2Mathews</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
General Method
xy
xy
Mean-value Theorem
Convergent
&gt;
Divergentx
xxx0 1
10y=xy=x
y=g(x)y=g(x)
ConvergenceConvergence</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
General Method
Convergence
xy
Define ksuch that if
then
Apply successively
Convergence
Convergence Criteria</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Multiple Roots
xf(x)Newton-Raphson
=&gt;
Convergence
Slower convergence the higher  the order of the rootp-order Root
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
Bisection
Algorithm
n = n+1
yes
no% Root finding by bi-section
f=inline(' a*x -1','x','a');
a=2
figure(1); clf; hold on
x=[0 1.5]; eps=1e-3;
err=max(abs(x(1)-x(2)),abs(f(x(1),a)-f(x(2),a)));
while (err&gt;eps &amp; f(x(1),a)*f(x(2),a) &lt;= 0)
xo=x; x=[xo(1) 0.5*(xo(1)+xo(2))];
if ( f(x(1),a)*f(x(2),a) &gt; 0 )
x=[0.5*(xo(1)+xo(2)) xo(2)]
end
x
err=max(abs(x(1)-x(2)),abs(f(x(1),a)-f(x(2),a)));
b=plot(x,f(x,a),'.b'); set(b,'MarkerSize',20);
grid on;
end
bisect.m</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Example &#8211; Square root
Heron&#8217;s Principlea=2;
n=6;
g=2;
% Number of Digits
dig=5;
sq(1)=g;
for i=2:n
sq(i)= 0.5*radd(sq(i-1),a/sq(i-1),dig);
end
'      i       value   '
[ [1:n]' sq']
hold off
plot([0 n],[sqrt(a) sqrt(a)],'b')
hold on
plot(sq,'r')
plot(a./sq,'r-.')
plot((sq-sqrt(a))/sqrt(a),'g')
grid onheron.m
i       value
1.0000    2.0000
2.0000    1.5000
3.0000    1.4167
4.0000    1.4143
5.0000    1.4143
6.0000    1.4143Guess root 
Mean is better guess 
Iteration Formula 
( )/2( )/2</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Stop-criteria
Unrealistic stop-criteria
Realistic stop-criteria
Machine
Accuracy
xf(x)
&#8216;flat&#8217; f(x)G xf(x)
&#8216;steep&#8217; f(x)G
Cannot require Cannot requireUse combination of the two criteria</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7
Roots of Nonlinear Equations
General Method
Non-linear Equation
Goal: Converging series
Rewrite Problem
Example
Iteration% f(x) = x^3 - a = 0
% g(x) = x + C*(x^3 - a)
a=2;
n=10;
g=1.0;
C=-0.1;
sq(1)=g;
for i=2:n
sq(i)= sq(i-1) + C*(sq(i-1)^3 -a);
end
hold off
plot([0 n],[a^(1./3.) a^(1/3.)],'b')
hold on
plot(sq,'r')
plot( (sq-a^(1./3.))/(a^(1./3.)),'g')
grid oncube.mExample: Cube root
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 7Roots of Nonlinear Equations
Newton-Raphson Method
Convergence Speed
Taylor Expansion
Second Order Expansion
Relative Error
Quadratic Convergence
General Convergence Rate
Convergence Exponent
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Minimization Problems
Least Square Approximation
Optimization</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_12/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Least Square Approximation
Parameter estimation
Example
Island Survey
AB
CE
D
F
Normal Equation
Residual VectorMeasured Altitude Differences
Points D, E, and F at sea level. Find altitude
of inland points A, B, and C.
A=[ [1 0 0 -1 0 -1]' [0 1 0 1 -1 0]' [0 0 1 0 1 1]']
b=[1 2 3 1 2 1]';
C=A'*A
c=A'*b
% Least square solution
z=inv(C)*c
% Residual
r=b-A*z
rn=sqrt(r'*r)lstsq.m</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Least Square Approximation
mmeasurements
nunknowns
m&gt;n
m
nn model parameters
m measurementsLinear Measurement Model Overdetermined System
Least Square Solution
Minimize Residual Norm
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Least Square Approximation
A
Theorem
)
Proof
Normal Equation
Symmetric n x n matrix. Non-
singular if columns of A are 
linearly independentq.e.d</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Introduction to Numerical Analysis for Engineers
&#8226; Minimization Problems 5
&#8226; Least Square Approximation
&#8211; Normal Equation
&#8211; Parameter Estimation
&#8211; Curve fitting
&#8226; Optimization Methods
&#8211; Simulated Annealing
&#8226; Traveling salesman problem
&#8211; Genetic AlgorithmsMathews</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 12Simulated Annealing
Example: Traveling Salesman Problem
% Travelling salesman problem
% Create random city distribution
n=20; x=random('unif',-1,1,n,1); y=random('unif',-1,1,n,1);
gam=1; mu=sign(x);
% End up where you start. Add starting point to end
x=[x' x(1)]'; y=[y' y(1)]'; mu=[mu' mu(1)]'; 
figure(1); hold off; g=plot(x,y,'.r'); set(g,'MarkerSize',20);
c0=cost(x,y,mu,gam); k=1; % Boltzman constant
nt=50; nr=200; % nt: temp steps. nr: city switches each T 
cp=zeros(nr,nt);
iran=inline('round(random(d,1.5001,n+0.4999))','d','n');
for i=1:nt
T=1.0 -(i-1)/nt
for j=1:nr
% switch two random cities
ic1=iran('unif',n); ic2=iran('unif',n);
xs=x(ic1); ys=y(ic1); ms=mu(ic1);
x(ic1)=x(ic2); y(ic1)=y(ic2); mu(ic1)=mu(ic2);
x(ic2)=xs; y(ic2)=ys; mu(ic2)=ms;
p=random('unif',0,1); c=cost(x,y,mu,gam);
if (c &lt; c0 | p &lt; exp(-(c-c0)/(k*T))) % accept
c0=c;
else                      % reject and switch back
xs=x(ic1); ys=y(ic1); ms=mu(ic1);
x(ic1)=x(ic2); y(ic1)=y(ic2); mu(ic1)=mu(ic2);
x(ic2)=xs; y(ic2)=ys; mu(ic2)=ms;
end
cp(j,i)=c0;
end
figure(2); plot(reshape(cp,nt*nr,1)); drawnow;
figure(1); hold off; g=plot(x,y,'.r'); set(g,'MarkerSize',20); 
hold on; plot(x,y,'b'); 
g=plot(x(1),y(1),'.g'); set(g,'MarkerSize',30);
p=plot([0 0],[-1 1],'r--'); set(g,'LineWidth',2); drawnow;
endsalesman.m function [c] = cost(x,y,mu,gam)
n=length(x);
c=0;
for i=1:n-1
c =c+sqrt((x(i+1)-x(i))^2 
+(y(i+1)-y(i))^2)
+ gam*(mu(i+1)-mu(i));
endcost.m
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12
% Quadratic data model
fxy='a*x.^2+b'
f=inline(fxy,'x','a','b');
x=[0:0.01:1]; x=reshape([x' x']',1,2*length(x));
n=length(x); y=zeros(n,1);
a=5;  b=3;
% Generate noisy data
amp=0.05*(max(f(x,a,b))-min(f(x,a,b)));
for i=1:n
y(i) =f(x(i),a,b)+random('norm',0,amp);
end
figure(1); clf; hold off; p=plot(x,y,'.r');
set(p,'MarkerSize',10)
% Non-linear, quadrati model
A=ones(n,2); A(:,1)=f(x,1,0)'; bb=y;
%Normal matrix
C=A'*A; c=A'*bb;
z=inv(C)*c
% Residuals
r=bb-A*z; rn=sqrt(r'*r)/n
hold on; p=plot(x,f(x,z(1),z(2)),'b'); set(p,'LineWidth',2)
% Linear model
A(:,1)=x';
C=A'*A; c=A'*bb;
z=inv(C)*c
% Residuals
r=bb-A*z; rn=sqrt(r'*r)/n
hold on; p=plot(x,z(1)*x+z(2),'g'); set(p,'LineWidth',2)
p=legend('Data','Non-linear','Linear'); set(p,'FontSize',14);Least Square Approximation
Curve Fitting
curve.m</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Optimization Problems
Non-linear Models
Minimimize Overall Error
xE(c)
Measured values Model ParametersNon-linear models
iGlobal
MinimumLocal
Minimum
Non-linear models often have multiple, local minima. A locally linear, least square 
approximation may therefore find a local minimum instead of the global minimum.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Minimization Problems
Data Modeling &#8211; Curve Fitting
Linear Model
Minimimize Overall ErrorNon-linear Model
Objective: Find c that minimizes error</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Simulated Annealing
Example: Traveling Salesman Problem
Objective:
Visit N cities across the US in arbitrary 
order, in the shortest time possible.
Metropolis Algorithm
1. Configuration: Cities I = 1,2, &#8230;N. Order 
can vary
2. Rearrangements: Ch ange the order of 
any two cities.
3. Cost function : Distance traveled, 
number of Mississippi crossings.
4. Annealing schedule. Experimentation 
with &#8216;cooling&#8217; schedule . T held constant 
for e.g. 100 re-order ings (heat-bath 
method).
Penalty for crossing MississippiCost function: Distance Traveled
East:    = 1
West:    = -1
Adapted by MIT OCW.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 12Optimization Algorithms
Simulated Annealing
Analogy: Freezing of a Liquid
High temperature T
Low temperature T
Crystal: Minimum energy of system. 
Slow cooling -&gt; global minimum: crystal .
Fast cooling -&gt; local minimum: glass .
Boltzman Probability Distribution
Energy probabilistically dist ributed among all states. 
Higher energy states possible even at low temperature!
Optimization Problem: Minimize residual &#8216;energy&#8217;
Simulated thermodynamic system changes 
its energy from      to       with probability
Lower energy always accepted
Higher energy accept ed with probability p:
Allows escape from local minimum
Elements of Metropolis algorithm
1. Description of possib le system configurations
2. Random number generator for changing parameters
3. Cost function &#8211; &#8216;energy&#8217; E
4. Control parameter &#8211; &#8216;temperature&#8217; T.</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Linear Systems: Gaussian Elimination
Pivoting
LU Factorization
Error Analysis</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_4/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture  4Introduction to Numerical Analysis for Engineers
&#8226; Systems of Linear Equations Mathews
&#8211; Cramer&#8217;s Rule
&#8211; Gaussian Elimination 3.3-3.5
&#8226; Numerical implementation
3.3-3.4
&#8226; Numerical stability
&#8211; Partial Pivoting
&#8211; Equilibration
&#8211; Full Pivoting
&#8226; Multiple right hand sides
&#8226; Computation count
&#8226; LU factorization 3.5
&#8226; Error Analysis for Linear Systems 3.4
&#8211; Condition Number
&#8226; Special Matrices
&#8211; Iterative Methods 3.6
&#8226; Jacobi&#8217;s method
&#8226; Gauss-Seidel iteration
&#8226; Convergence</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Systems of Linear Equations
Pivoting in LU Factorization
Before reduction, step k
Pivoting if
elseInterchange rows iandk
Pivot element vectorForward substitution, step k
Interchange rows iandk</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Systems of Linear Equations
LU Factorization
==
Upper triangularLower triangularGE Reduction directly yields LU factorization
Compact storage
Lower diagonal implied</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 4Linear Systems of Equations
Error Analysis
Vector and Matrix Norm
Properties
Perturbed Right-hand Side
Subtract original equation
Relative Error Magnification
Condition Number</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Linear Systems of Equations
Error Analysis
Linear systems
How is the relative error of x 
dependent on errors in b?
Example
Small changes in b give large changes in x
The system is ill-Conditioned
Function of one variable
Condition number
The condition number K is a 
measure of the amplification of the 
relative error by the function f(x)</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4
Well-Conditioned System
n=4
a = [ [0.0001 1.0]' [1.0 1.0]']
b= [1 2]'
ai=inv(a);
a_nrm=max( abs(a(1,1)) + abs(a(1,2)) , 
abs(a(2,1)) + abs(a(2,2)) )
ai_nrm=max( abs(ai(1,1)) + abs(ai(1,2)) , 
abs(ai(2,1)) + abs(ai(2,2)) )
k=a_nrm*ai_nrm
r=ai * b
x=[0 0];
m21=a(2,1)/a(1,1);
a(2,1)=0;
a(2,2) = radd(a(2,2),-m21*a(1,2),n);
b(2)   = radd(b(2),-m21*b(1),n);
x(2)   = b(2)/a(2,2);
x(1)   = (radd(b(1), -a(1,2)*x(2),n))/a(1,1);
x'tbt7.m
Well-conditioned system4-digit Arithmetic
Algorithmically ill-conditioned</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 4
Linear Systems of Equations
Error Analysis
Vector and Matrix Norm
PropertiesPerturbed Coefficient Matrix
Subtract unperturbed equation
Relative Error Magnification
Condition Number
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Ill-Conditioned System
n=4
a = [ [1.0 1.0]' [1.0 1.0001]']
b= [1 2]'
ai=inv(a);
a_nrm=max( abs(a(1,1)) + abs(a(1,2)) , 
abs(a(2,1)) + abs(a(2,2)) )
ai_nrm=max( abs(ai(1,1)) + abs(ai(1,2)) , 
abs(ai(2,1)) + abs(ai(2,2)) )
k=a_nrm*ai_nrm
r=ai * b
x=[0 0];
m21=a(2,1)/a(1,1);
a(2,1)=0;
a(2,2) = radd(a(2,2),-m21*a(1,2),n);
b(2)   = radd(b(2),-m21*b(1),n);
x(2)   = b(2)/a(2,2);
x(1)   = (radd(b(1), -a(1,2)*x(2),n))/a(1,1);
x'tbt6.m
Ill-conditioned system</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods for Engineers 13.002 Lecture 4
After reduction step i-1:ij
Above and on diagonal
Below diagonalUnchanged after step i-1
Become and remain 0in step j
Systems of Linear Equations
LU Factorization
Change in reduction steps 1-i-1:
Total change above diagonal
Total change below diagonal
Define
=&gt;
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Systems of Linear Equations
Gaussian Elimination
k p n-kReduction
Step k
nkComputation Count
Reduction Step k
Operations
Total Computation Count
Reduction
Back SubstitutionMultiple Right-hand Sides
Reduction for each right -hand side inefficient. 
However, RHS may be result of iteration and unknown a priori 
(e.g. Euler&#8217;s method) -&gt;  LU Factorization</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4
Systems of Linear Equations
LU Factorization
&#8216;Matrix product&#8217;
= x
i
j
Below diagonal
kkSum stops at diagonal
0
000
= xi
jAbove diagonal
kk
0
000
Lower triangular Upper triangular
00
00</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 4Systems of Linear Equations
LU Factorization
The coefficient Matrix   A  is decomposed as
where       is a lower triangular matrix
and        is an upper triangular matrix
Then the solution is performed in two simple steps
1.
2.Forward substitution
Back substitution
How to determine      and       ?
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Ordinary Differential Equations
Initial Value Problems: Euler and Runge-Kutta Methods</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/2-993j-introduction-to-numerical-analysis-for-engineering-13-002j-spring-2005/resources/lect_10/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10
Euler&#8217;s Method
Differential Equation
Example
Discretization
Finite Difference (forward)
Recurrence
euler.m
Ordinary Differential Equations
Initial Value Problems
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10
Ordinary Differential Equations
Initial Value Problems
Differential Equation
non-linear in yNon-Linear Differential EquationLinear Differential Equation
Linear differential equations can often be solved analytically
Non-linear equations require numerical solutionxy
a b</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10
Euler&#8217;s Method
Recurrence
Initial Value Problems
Runge-Kutta Methods
h=1.0;
x=[0:0.1*h:10];
y0=0;
y=0.5*x.^2+y0;
figure(1); hold off
a=plot(x,y,'b'); set(a,'Linewidth',2);
% Euler's method, forward finite difference
xt=[0:h:10]; N=length(xt);
yt=zeros(N,1); yt(1)=y0;
for n=2:N
yt(n)=yt(n-1)+h*xt(n-1);
end
hold on; a=plot(xt,yt,'xr'); set(a,'MarkerSize',12);
% Runge Kutta
fxy='x'; f=inline(fxy,'x','y');
[xrk,yrk]=ode45(f,xt,y0);
a=plot(xrk,yrk,'.g'); set(a,'MarkerSize',30);
a=title(['dy/dx = ' fxy ', y_0 = ' num2str(y0)])
set(a,'FontSize',16);
b=legend('Exact',['Euler, h=' num2str(h)],
'Runge-Kutta (Matlab)'); set(b,'FontSize',14);rk.m
4thOrder Runge-Kutta
Matlab ode45 automaticall y ensures convergence
Matlab inefficient for large pr oblems &#8211;&gt; Convergence Analysis</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Initial Value Problems
Taylor Series Methods
Error Analysis
Example &#8211; Euler&#8217;s Method
Exact solution
Derivative Bounds
Error Bound
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Initial Value Problems
Taylor Series Methods
Error Analysis
O(h)Derivative Bounds
Error Estimates and Convergence
Euler&#8217;s Method</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Introduction to Numerical Analysis for Engineers
&#8226; Ordinary Differential Equations 9
&#8211; Initial Value Problems 9.1
&#8226; Euler&#8217;s Method 9.2
&#8226; Taylor Series Methods 9.4
&#8211; Error analysis
&#8226; Runge-Kutta Methods 9.5
&#8211; Systems of differential equations  9.7
&#8211; Boundary Value Problems 9.8
&#8226; Shooting method 9.8
&#8226; Direct Finite Difference methods 9.9Mathews</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Initial Value Problems
Runge-Kutta Methods
Initial Value Problem
2ndOrder Runge-Kutta
4thOrder Runge-Kuttaxy
mid-point
Predictor-corrector method</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Initial Value Problems
Taylor Series Methods
Example
Euler&#8217;s MethodGeneral Taylor Series Method
Example &#8211; Euler&#8217;s Method
Error Analysis?</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Numerical Methods  for Engineers 13.002 Lecture 10Initial Value Problems
Taylor Series Methods
Taylor Series
Partial DerivativesDerivatives
+
Truncate series to ktermsInitial Value Problem
Choose Step Size h
Recursion Algorithm
with
Local Error
Discretization</text>
        </slide>
      </slides>
    </lecture>
    <videos>
      <video>
        <video_url/>
        <video_title/>
        <transcript>
          <slice>
            <text_slice/>
            <time_slice/>
          </slice>
        </transcript>
      </video>
    </videos>
  </lectures>
</doc>
