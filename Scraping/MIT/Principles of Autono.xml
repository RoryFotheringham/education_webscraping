<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/</course_url>
    <course_title>Principles of Autonomy and Decision Making</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Science </list>
      <list>Computer Science </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>Mathematical programming II: the simplex method [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec17/</lecture_pdf_url>
      <lectureno>17</lectureno>
      <slides>
        <slide>
          <slideno>8</slideno>
          <text>Duality polyhedragraphs
Each vertex has at least nneighbors.
One can draw a graph of neighboring vertices.
Ideally, one could search this graph for the vertex that maximizes the
objective.
Remember that if a corner does not have any adjacent corner thatprovides a better solution, then that corner is in fact the optimum.
Use an informed (greedy) algorithm to search for the max.
Frazzoli (MIT) Lecture 17: The Simplex Method November 10, 2010 8 / 32David Eppstein . CC by-sa.
 This content is excluded
from our Creative Commons
 license. For more information, 
http://ocw.mit.edu/fairuse.
.
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
[IOR] Chapter 4.
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 2 / 32</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 17: The Simplex Method
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 10, 2010
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 1 / 32</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 1=4
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Outline
1Geometric Interpretation
2Algebraic Procedure
The tableau
Algorithm
Degeneracy
Finding a feasible initial solution
Analysis
3Intro to interior point methods
Frazzoli (MIT) Lecture 17: The Simplex Method November 10, 2010 12 / 32</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Outline
1
Geometric Interpretation
Geometric Interpretation
2
Algebraic Procedure
3
Intro to interior point methods
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 3 / 32</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Simplex algorithm: analysis
With nvariables, each bounded in [0 ;1], there are 2 ncorner point
feasible solutions
Pathological examples force examination of all of these
Each pivot (Gaussian elimination) takes O(mn) time
Simplex algorithm is exponential in worst-case analysis, yet is
remarkably successful in practice
In fact, linear programming can be solved in polynomial time by
interior point methods.
Recently these have become competitive in practice with simplex.
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 25 / 32</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Simplex method by example
Recalling the tableau form:
choose the column with the
\most negative" entry in row
zero ( z).
choose the row that limits the
most the increase in the
corresponding variable.
(smallest positive ratio test.)
Then PIVOT on the
intersection, that is, clear
everything in the yellow-shaded
column, leaving only a 1 in the
orange-shaded cell, by
manipulating the matrix
(without changing the solution
of the equation!)
x1
x2
x3
x4
x5
b
z
-3
-5
0
r1
1
1
4
r2
2
1
12
r3
3
2
1
18
x1
x2
x3
x4
x5
b
z
-3
0
5/2
30
r1
1
1
4
r2
1
1/2
6
r3
3
0
-1
1
6
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 15 / 32</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 8
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Outline
1
Geometric Interpretation
2
Algebraic Procedure
3
Intro to interior point methods
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 26 / 32</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 4
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Example, contd
Since we want the articial variable(s) to be non-zeroto ensure
feasibilitywe initialize the tableau to get 0s in the articial variablecolumns in the objective function:
x1 x2 x3x4x5x6b
z3- 3 M5-2M M -M
r11 1 4
r2 2 1 12
r332 -111
Now proceed in the usual wayremembering that Mstands for very
large number
x1 x2 x3x4x5x6b
z3- 3 M5-2M M -M
r11 1 4
r2 2 1 12
r332 -111
Frazzoli (MIT) Lecture 17: The Simplex Method November 10, 2010 21 / 32</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 1
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 2
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 1=2
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>The barrier interior-point method: example
x1x2
1 0.5 0 0.5 1 1.5 2 2.5 3 3.5 410123456
t= 1=8
Frazzoli (MIT)Lecture 17: The Simplex MethodNovember 10, 2010 31 / 32</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Introduction [BW, EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec01a/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides>
        <slide>
          <slideno>19</slideno>
          <text>22
43Outline
1./.notdef.g0001Trends in Computing 
2./.notdef.g0001Examples of autonomous systems 
3./.notdef.g0001Autonomous systems architectures 
4./.notdef.g0001Principles = modeling + inference + search 
5./.notdef.g0001More examples 
6./.notdef.g0001Course logistics and schedule
7./.notdef.g0001Projects and programming 
43 Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>7
13Remote Agent on Deep Space One 
1./.notdef.g0001Commanded by giving goals 
2./.notdef.g0001Reasoned from
commonsense models
3./.notdef.g0001Closed loop on goals 
Diagnosis
&amp; Repair /.notdef.g0002
Mission
Manager /.notdef.g0002Executive /.notdef.g0002
Planner/ /.notdef.g0002
Scheduler /.notdef.g0002Remote Agent /.notdef.g0002
[Williams &amp; Nayak, AAAI 95; /.notdef.g0002
 Muscettola et al, AIJ 00]/.notdef.g0002
13 Brian Williams, Fall  10 
14A Goal sets engine A state to thrusting, and 
the agent . . .
Exec: determines that valves on/.notdef.g0002
engine B will achieve thrust, /.notdef.g0001
and plans needed actions./.notdef.g0002Deduces that a valve /.notdef.g0002
failed - stuck closed/.notdef.g0002Plans actions/.notdef.g0002
to open/.notdef.g0002
six valves/.notdef.g0002
Deduces that/.notdef.g0002
thrust is off, and /.notdef.g0001
the engine is healthy/.notdef.g0002
Estimates Modes 
Estimates Modes Reconfigures Modes Reconfigures Modes 
A new Goal: /.notdef.g0002
Sets engine B to thrust, /.notdef.g0002
14</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>20
39Modeling Goal Behavior 
using Qualitative State Plans 
Remain in [safe region]Remain in 
[bloom region]
e1e5Remain in 
[mapping region] e2 e3 e4End in 
[pickup region][50,70] [40,50][0,300]
Obstacle 1
Obstacle 2Mapping
Region
Bloom
RegionPickupRegionRemain in bloom region  for between 50 and 
70 seconds. Afterwards, remain in mapping 
region  for between 40s and 50s . End in the 
pickup region .Avoid obstacles  at all times. 
Complete the mission within 300s 
Approach : Frame as Model-Predictive Control/.notdef.g0002
using Mixed Logic or Integer / Linear Programming./.notdef.g0002
Leaute &amp; Williams, AAAI 05 Aqualitative state plan is a model-based program that is /.notdef.g0001
unconditional, timed , and hybrid and/.notdef.g0001
provides exibility instate andtime./.notdef.g0002
39 Brian Williams, Fall  10 
4040Modeling Goal-directed Planning 
as a Mathematical Program 
min
UJ(X,U)+H(xT)
s.t.
/.notdef.g0002
t=0T
/.notdef.g0002
i=0N
/.notdef.g0003
j=0M
htiTxt/.notdef.g0001gtij
Constraints/.notdef.g0001Dynamics/.notdef.g0001
(Discrete time)/.notdef.g0001Costfunction  (e.g. fuel consumption)/.notdef.g0002
State vector (e.g. position of vehicle) /.notdef.g0002
Control inputs /.notdef.g0002Mixed Logic or Integer/.notdef.g0001
Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>11 
21
CDIO Capstone: 
Moretta
Hofmann /.notdef.g0002
PhD - Chekov/.notdef.g000221 Brian Williams, Fall  10 
22
 MBARI Dorado-class AUV: 
/.notdef.g00016000m rated
/.notdef.g000120 hour operation
/.notdef.g0001Multibeam Sonars 
/.notdef.g00013+ knots speed 
Challenges:
/.notdef.g0001Long mission duration 
/.notdef.g0001Limited communication 
/.notdef.g0001GPS unavailable 
/.notdef.g0001Uncertainty
/.notdef.g0001tides and currents 
/.notdef.g0001estimation error 
3. Science Explorers  
22 Brian Williams, Fall  10 
Courtesy of Andreas Hofmann. Used with permission.
Graph  source unknown. All rights reserved. This content
is excluded from our Creative Commons license. For moreinformation, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>9Courtesy JPL/.notdef.g0002
18Describe Tasks as
Temporal Plans over Qualitative Poses 
Input:
Qualitative
State Plan 
Hofmann PhD - Chekov/.notdef.g000218 Brian Williams, Fall  10 
Courtesy of Andreas Hofmann. Used with permission.Image of hilly terrain removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>6
11 Williams Research: Model-based 
Programming of Autonomous Systems 
Robust, mission-directed agents: 
1./.notdef.g0001Self-repairing agents 
2./.notdef.g0001Agents that are agile 
3./.notdef.g0001Science explorers
11 Brian Williams, Fall  10 
12
Cassini Maps Titan   /.notdef.g0001 7 year cruise  
/.notdef.g0001 ~ 150 - 300  
  ground operators  
/.notdef.g0001~ 1 billion $  
/.notdef.g0001 7 years to build  1. Self-Repairing Agents  
/.notdef.g0001150 million $  
/.notdef.g00012 year build  
/.notdef.g0001 0 ground ops  Affordable Missions 
 Source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/fairuse .</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>14
/g0/g1/g2/g3/g4/g5/g6/g7/g6/g9/g10/g11/g12/g13/g14/g15/g6/g17/g18/g10/g10
27 /.notdef.g0002
Remove one ball from red bin /.notdef.g0002
Remove one ball from blue bin /.notdef.g0002
Remove one ball from green bin /.notdef.g0002Remove one ball from pink bin /.notdef.g0002Swap black striped ball /.notdef.g0002
/.notdef.g0001 Right Robot picks up and 
offers ball. /.notdef.g0002
/.notdef.g0001 Robots perform hand-to-hand 
swap. /.notdef.g0002
Swap red striped ball /.notdef.g0002
/.notdef.g0001 Left Robot picks up and offers 
ball. /.notdef.g0002
/.notdef.g0001 Robots perform hand-to-hand 
swap. /.notdef.g0002
  tstart /.notdef.g0002
  tnish /.notdef.g0002(Someone) Remove one ball from red bin /.notdef.g0002
Remove one ball from red bin /.notdef.g0002
L[32,39]  V R[ 42,55] /.notdef.g0002
OR /.notdef.g0002Agents choose and/.notdef.g0002
schedule activities/.notdef.g0002
Brian Williams, Fall  10 /.notdef.g0002
/g0/g1/g2/g3/g4/g5/g6/g7/g6/g9/g10/g11/g12/g13/g14/g15/g6/g17/g18/g10/g10
/.notdef.g0001/g0 /g1/g4/g3/g6/g14/g6 /g3/g13/g2/g10
/.notdef.g0001/g0/g13/g17/g9/g3/g12/g17/g10/g13/g9 /g13/g11/g9/g13/g10/g6 /g3/g10
/g17/g12/g13/g11/g6/g3/g13/g12/g10/g9/g6/g10
/g9/g12/g13/g14/g14/g13/g9/g12/g8/g13/g10/g0/g13/g6/g2/g1/g17/g12/g7 /g10/g10
28 /.notdef.g0002Brian Williams, Fall  10 /.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>19
37Outline
1./.notdef.g0001Trends in Computing 
2./.notdef.g0001Examples of autonomous systems 
3./.notdef.g0001Autonomous systems architectures 
4./.notdef.g0001Principles = modeling + inference + search 
5./.notdef.g0001More examples 
6./.notdef.g0001Course logistics and schedule 
7./.notdef.g0001Projects and programming 
37 Brian Williams, Fall  10 
38
Modeling Example: 
Robust, Goal-directed
Deep Sea Exploration 
Model-based Executive 
Observations Commands 
Remain in mapping region  for at least 
100s , then remain in bloom region  for at 
least 50s, then return to pickup region .
Avoid obstacles  at all times 
Qualitative State Plan 
Plant
Leaute &amp; Williams, AAAI 05 Optimal
Robust
38 Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>21
41Specify Building Blocks using 
Declarative Programming 
/.notdef.g0001Mathematical Programming 
/.notdef.g0001Constraint Programming 
/.notdef.g0001Logic Programming 
/.notdef.g0001Agent Programming 
/.notdef.g0001Model-based programming 
/.notdef.g0001Timed concurrent constraint programming 
/.notdef.g0001Golog
/.notdef.g0001Temporal logic programming 
41 Brian Williams, Fall  10 
42Solve Declarative Programs using: 
Search + Inference 
Search: try taking the subway, or 
try taking the bus. 
Inference: It takes 35 minutes to get to MIT,
            20 min subway + 15 min walking. 
42 Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>10
19Brian Williams, Fall  10 19
20Maintaining
Temporal Synchronization 
Disturbance without/.notdef.g0002
temporal coordination/.notdef.g0002Disturbance with/.notdef.g0002
temporal coordination/.notdef.g0002Hofmann /.notdef.g0002
PhD - Chekov/.notdef.g000220 Brian Williams, Fall  10 Courtesy of Andreas Hofmann. Used with permission.
Courtesy of Andreas Hofmann. Used with permission.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>12
23
Robust, Goal-directed
Deep Sea Exploration 
Command script  00:00 Go to x1,y1
00:20 Go to x2,y2
00:40 Go to x3,y3

04:10 Go to xn,yn
PlantCommands 
Leaute &amp; Williams, AAAI 05 23 Brian Williams, Fall  10 
24
Robust, Goal-directed
Deep Sea Exploration 
Model-based Executive 
Observations Commands 
Remain in mapping region  for at least 
100s , then remain in bloom region  for at 
least 50s, then return to pickup region .
Avoid obstacles  at all times 
Qualitative State Plan 
Plant
Leaute &amp; Williams, AAAI 05 Optimal
Robust
24 Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>17
33Utility-Based Agents 
33
34Deliberative Agents 
World Model/.notdef.g0002
34
Courtesy of Stuart Russell and Peter Norvig. Used with permission.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>15
29Vecna Bear/.notdef.g0002
29 Brian Williams, Fall  10 
30Outline
1./.notdef.g0001Trends in Computing 
2./.notdef.g0001Examples of autonomous systems 
3./.notdef.g0001Autonomous systems architectures 
4./.notdef.g0001Principles = modeling + inference + search 
5./.notdef.g0001More examples 
6./.notdef.g0001Course logistics and schedule 
7./.notdef.g0001Projects and programming 
30 Brian Williams, Fall  10 Image of Vecna's Bear Robot removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>18
35
Reflexive Agents 
35
36Plan/.notdef.g0002
Execute/.notdef.g0002Monitor &amp;/.notdef.g0002
Diagnosis/.notdef.g0002Locate in/.notdef.g0002
World/.notdef.g0002
Plan Routes/.notdef.g0002Map /.notdef.g000216.410/13 Canonical 
Agent Architecture 
Maneuver and Track/.notdef.g0002Communicate and Interpret Goals /.notdef.g0002
36 Brian Williams, Fall  10 Courtesy of Stuart Russell and Peter Norvig. Used with permission.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>8
15 Courtesy JPL/.notdef.g0002
2. Agile Agents  
15 Brian Williams, Fall  10 
1616 Brian Williams, Fall  10 Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>13
25Example Execution 
250
Remain in [safe region]Remain in 
[bloom region]
e1e5Remain in 
[mapping region] e2 e3 e4End in 
[pickup region][50,70] [40,50][0,300]
T(e1)=0
T(e2)=70T(e3)=110 T(e4)=150T(e5)=230
Blackmore PhD/.notdef.g000225
2626 Brian Williams, Fall  10 Courtesy of Lars Blackmore. Used with permission.
Image of NASA Athlete rover removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1
116.410 and 16.412: 
Principles of Autonomy
and Decision Making 
Prof Brian Williams, Prof Emilio Frazzoli and Sertac Karaman
September, 8th, 2010
1 Brian Williams, Fall  10 
2Brian Williams, Fall  10 2Assignments
/.notdef.g0001Homework:
/.notdef.g0001Class signup, return at end of class; 
/.notdef.g0001Problem Set #1: Java warm up
Out Today,
Due next Wednesday, September 15th
/.notdef.g0001Reading:
/.notdef.g0001Today: [AIMA] Ch. 2, [JINS] Ch. 1-3,5 
/.notdef.g0001Monday: search [AIMA] Ch. 3 .1-4</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2
3Outline
1./.notdef.g0001Trends in Computing 
2./.notdef.g0001Examples of autonomous systems - Williams
3./.notdef.g0001Autonomous systems architectures 
4./.notdef.g0001Principles = modeling + inference + search 
5./.notdef.g0001More examples  Frazzoli
6./.notdef.g0001Course logistics and schedule 
7./.notdef.g0001Projects and programming 
3 Brian Williams, Fall  10 
4Human Brain 
/.notdef.g0001100 Billion neurons 
/.notdef.g0001On average, connected to 1 K others 
/.notdef.g0001Neurons are slow. Firing rates &lt; 100 Hz. 
/.notdef.g0001Can be classified into 
/.notdef.g0001Sensory
/.notdef.g0001Motor
/.notdef.g0001Central
/.notdef.g0001(reasoning,
 problem solving,
language..)
4 Brian Williams, Fall  10 Images of brain activity removed due
to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>16
31Agent Paradigms 
31 Brian Williams, Fall  10 
32Goal-Oriented Agents 
32
Courtesy of Stuart Russell and Peter Norvig. Used with permission.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3
5Trends in Biological and 
Machine Evolution - Moravec 
/.notdef.g00011 neuron = 1000 instructions/sec 
/.notdef.g0001Human brain then processes 10^14 IPS 
/.notdef.g00011 synapse = 1 byte of information 
/.notdef.g0001Human brain then has 10^14 bytes of storage 
/.notdef.g0001In 2000, we had10^9 IPS and 10^9 bytes on a 
desktop machine 
/.notdef.g0001In 25 years, assuming Moores law we obtain 
human level computing power 
5 Brian Williams, Fall  10 
10Outline
1./.notdef.g0001Trends in Computing 
2./.notdef.g0001Examples of autonomous systems - Williams
3./.notdef.g0001Autonomous systems architectures 
4./.notdef.g0001Principles = modeling + inference + search 
5./.notdef.g0001More examples - Frazzoli
6./.notdef.g0001Course logistics and schedule 
7./.notdef.g0001Projects and programming 
10 Brian Williams, Fall  10</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Constraints III: conflict-directed back jumping
Introduction to operator-based planning [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec07a/</lecture_pdf_url>
      <lectureno>7</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text>10  CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhWhy backtrack to D? 
D/.notdef.g0002not F Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhVariables and Instantiation Order 
Checking back 
Why backtrack to D? 
D/.notdef.g0002not F 
B/.notdef.g0002not F Example of a CSP</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12  CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhD/.notdef.g0002not F Variables and Instantiation Order 
Checking back Moving Forward 
ConfSet[F] = {               } D,
CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhVariables and Instantiation Order 
Checking back 
D/.notdef.g0002not F 
B/.notdef.g0002not F Moving Forward 
ConfSet[F] = {               } D,B,</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1Solving Constraint Programs using  
Conflicts and Backjumping  
6/30/11 1
Brian C. Williams 
16.410-13
September 29th, 2010 Slides draw upon material from: 
Prof. Patrick Prosser, Glasow University 
 2 Search Performance on N Queens  
/.notdef.g0001Standard Search 
/.notdef.g0001Backtracking
/.notdef.g0001BT with Forward Checking
/.notdef.g0001Dynamic Variable Ordering 
/.notdef.g0001Iterative Repair 
/.notdef.g0001Conflict-directed Back 
Jumping/.notdef.g0001A handful of queens 
/.notdef.g0001About 15 queens 
/.notdef.g0001About 30 queens 
/.notdef.g0001About 1,000 queens 
/.notdef.g0001About 10,000,000 queens 
(except truly hard problems) 1
23
4Q
Q
Q
Q</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17  1
2
3
4
5
6{2,1, 0}Backing Up: Conflict-directed Back Jumping 
Backtrack when v[h] domain exhausted: 
/.notdef.g0001 Jump to deepest var g in ConfSet[h]. 
/.notdef.g0001 Update ConfSet[g] with ConfSet[h] / g. 
/.notdef.g0001 Reset Domains, ConfSets below g. 
/.notdef.g0001 Move forward: try next g assignments. {0}
1
2
3
4
5
6Backing Up: Conflict-directed Back Jumping 
Backtrack when v[h] domain exhausted: 
/.notdef.g0001 Jump to deepest var g in ConfSet[h]. 
/.notdef.g0001 Update ConfSet[g] with ConfSet[h] / g. 
/.notdef.g0001 Reset Domains, ConfSets below g. 
/.notdef.g0001 Move forward: try next g assignments. {1, 0} OP ST
Image by MIT OpenCourseWare .
STOP 
Image by MIT OpenCourseWare .</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20   39 To Solve CSP &lt;X,D,C&gt; We Combine:  
1. /.notdef.g0001Reasoning - Arc consistency via constraint propagation  
/.notdef.g0001Eliminates values that are shown locally to not be a part  
of any solution. 
2. /.notdef.g0001Search
/.notdef.g0001Explores consequences of committing to particular 
assignments.
Methods That Incorporate Search: 
/.notdef.g0001Standard Search 
/.notdef.g0001Back Track Search (BT) 
/.notdef.g0001BT with Forward Checking (FC) 
/.notdef.g0001Dynamic Variable Ordering (DV)
/.notdef.g0001Iterative Repair (IR)
/.notdef.g0001Conflict-directed Back Jumping (CBJ)</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19  
CBJ: Dechter Formulation 
Conflict-directed Back Jumping: 
Supporting definitions 
Pseudocode for conflict-directed backjumping
removed due to copyright restrictions.
Supporting definitions (earlier constraint, earlier minimalconflict set, jumpback set) removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14  1
2
3
4
5
6{2,1, ?}
{4,1,0}Backing Up: Conflict-directed Back Jumping 
Backtrack when v[i] domain exhausted: 
/.notdef.g0001 Jump to deepest var h in ConfSet[i]. 
/.notdef.g0001 Update ConfSet[h]. {0}
1
2
3
4
5
6{2,1, ?}
{4,1,0}Add {1, 0} to confset[4] Backing Up: Conflict-directed Back Jumping 
Backtrack when v[i] domain exhausted: 
/.notdef.g0001 Jump to deepest var h in ConfSet[i]. 
/.notdef.g0001 Update ConfSet[h] with ConfSet[i] / h. {0}STOP 
Image by MIT OpenCourseWare .
STOP 
Image by MIT OpenCourseWare .</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13  CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhVariables and Instantiation Order 
Checking back 
D/.notdef.g0002not F 
B/.notdef.g0002not F 
C/.notdef.g0002not F Moving Forward 
ConfSet[F] = {               } D,B,C
1
2
3
4
5
6 {4,1,0}{2,0}conflict sets  Backing Up: Conflict-directed Back Jumping 
Backtrack when v[i] domain exhausted: 
/.notdef.g0001 Jump to deepest var h in ConfSet[i]. {0}
STOP 
Image by MIT OpenCourseWare .</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back 
Why did it backtrack to E? 
That was dumb! Example of a CSP</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15  1
2
3
4
5
6{2,1, 0}
{4,1,0}Backing Up: Conflict-directed Back Jumping 
Backtrack when v[i] domain exhausted: 
/.notdef.g0001 Jump to deepest var h in ConfSet[i]. 
/.notdef.g0001 Update ConfSet[h] with ConfSet[i] / h. 
/.notdef.g0001 Reset Domains, ConfSets below h. 
/.notdef.g0001 Move forward: try next h assignments. {0}
 When jumping back from v[i] to v[h],
1. /.notdef.g0001 Update conflict sets: 
confSet[h] := confSet[h] /.notdef.g0001 confSet[i] \ {h} 
confSet[i] := {0} 
/.notdef.g0001 This means: 
  if we later jump back  from v[h],
  jump back to a variable that is
  in conflict with v[h] orwith v[i].
2. /.notdef.g0001 Throw away everything CBJ knows about v[i].
3. /.notdef.g0001 Reset all variables from v[h+1] to v[i] (i.e. domain and confSet)Backing Up: Conflict-directed Back Jumping STOP 
Image by MIT OpenCourseWare .</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11  CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
VhVariables and Instantiation Order 
Checking back 
Why backtrack to D? 
D/.notdef.g0002not F 
B/.notdef.g0002not F 
C/.notdef.g0002not F 
F or F or Fnot D/.notdef.g0001F
not B /.notdef.g0001F
not C/.notdef.g0001F
not D  or not B  or not C Its safe to remove the
deepest assignment .Example of a CSP 
p
a
s
t
f
u
t
u
r
ecurrent  variable  
v[i] conflict with v[h]past variable  
 v[h] 
Move down like Backtrack Search: 
/.notdef.g0001 Instantiate v[i] := x, for next x in D[i] 
/.notdef.g0001 Check constraint (v[i],v[h]), if fails 
/.notdef.g0001 say v[i] is in conflict with v[h] 
/.notdef.g0001 add h to the set confSet[i] confSet[i] denotes past 
variables that conflict with values in the domain of v[i]
{v[1]  v[h] }Moving Forward:</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 3 Back Jumping  
Backtracking  At dead end, backup to the most recent variable .
Backjumping  At dead end, backup to the most recent variable  that 
eliminated  some value  in the domain  of the dead end variable .
Example of a CSP 
CE
DB
FA
GHVa 
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back 
Slide progression due to Prosser [4C presentation, 2003]</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9CE
DB
FA
GH
1 = red 
2 = blue 
3 = green E1
E2
E3
E4What would have happened if we had
the E* intermediate variables? 
i.e. it falls back on E4, then E3, towards E? Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back 
Why did it backtrack to E? 
That was dumb! 
Whats better and why? Example of a CSP</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back 
Fast forward /.notdef.g0001..Example of a CSP</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back 
Find solution using 
BacktrackingExample of a CSP 
CE
DB
FA
GHVa
Vb
Vc
VdVe 
Vf
Vg
Vh1 = red 
2 = blue 
3 = green Variables and Instantiation Order 
Checking back Example of a CSP</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Constraints I: constraint programming [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec05/</lecture_pdf_url>
      <lectureno>5</lectureno>
      <slides>
        <slide>
          <slideno>24</slideno>
          <text>49 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R,G,B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V1, V2  V3 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1 &gt; V3 V1(G) 
Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1  V2 none 
V1 &gt; V3 V1(G) R,G,B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V1, V2 V3, V2&gt; V1, V3 &gt; V1 
IF 
THEN An element of a variable s domain is removed , 
add all arcs to that variable  to the examination queue . 
50 
25</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Alternative formulations for 
variables and values 
VARIABLES DOMAINS 
A. 1 var per Term All legal combinations of 4 courses, 
(Fall 1) (Spring 1) all of fered during that term. (Fall 2) (Spring 2) . . . 
B. 1 var per Term-Slot 
subdivide each term All courses of fered during that term. 
into 4 course slots: 
(Fall 1,1) (Fall 1, 2) 
(Fall1, 3) (Fall 1, 4) 
C. 1 var per Course Terms or term-slots. 
Term-slots make it easier to express 
the constraint limiting the number of 
courses per term. 75 
For pairs of courses that 
must be ordered . Prerequisite  
after 
Courses of fered only during certain terms  Filter domain 
Term-slots not equal 
Limit # courses  Use term-slots only once Encoding Constraints 
Assume:  Variables = Courses,  Domains = term-slots 
Constraints: 
1.00 16.410 At least 1 
term 
before 
At least 
1 term 
for all pairs of vars. 
term not equal 
Avoid time conflicts  For course pairs offered at 
same or overlapping times 
Brian Williams, Fall  10 76 
38</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Algorithmic Design Paradigm 
Solving CSPs involves a combination of: 
1. Inference 
 Solve partially by eliminating values  that 
cant be  part of any solution (constraint propagation ). 
 Make implicit  constraints explicit .
2. Search
 Try alternative  assignments against constraints. 
Inference : Waltz constraint propagation for visual interpretation 
generalizes to arc-consistency and the AC-3  algorithm. 
Brian Williams, Fall  10 31 
Directed Arc Consistency 
Idea: Eliminate values  of a variable domain
that can never satisfy a specified  constraint  (an arc).
X1 {&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,1&gt;} X2 
1 . 
2 . 
3 . 
4 . . 1 
. 2 
. 3 
. 4 
Definition : arc &lt;xi, xj&gt; is arc consistent if &lt;xi, xj&gt; and &lt;xj, xi&gt; are 
directed arc consistent. 
Brian Williams, Fall  10 32 
16</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Full Arc-Consistency via AC-3 (Waltz CP) 
AC-3 (CSP) 
Input:  A constraint satisfaction problem CSP = &lt;X, D, C&gt;. 
Output : CSP , the largest arc-consistent subset of CSP. 
Constraint Processing, 1. for every cij  C, by R. Dechter 
2. queue  queue  {&lt;xi, xj&gt;, &lt;xj, xi&gt;} pgs 58-9 
3. endfor 
4./.notdef.g0001 while queue  {} 
5. select and delete arc &lt;xi, xj&gt; from queue 
6.  Revise(xi, xj) 
7. if Revise(xi, xj) caused a change in Di 
8. then queue  queue  {&lt;xk, xi&gt; | k i,k j} 
9. endif 
Brian Williams, Fall  10 10. /.notdef.g0001 endwhile 39 
Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Each undirected  arc denotes two directed  arcs. 
Brian Williams, Fall  10 40 
20</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>7 Line Labeling as Constraint Programming 
depth 
discontinuity surface 
orientation 
discontinuity 
Huffman Clowes (1971): 
Interpretation of opaque, trihedral solids with no surface marks. 18 vertex labelings that are 
physically realizable + + 
+ + Convex 
Edge + Concave 
Edge 
+ 
+ + + 
Waltz (1972):  Compute labeling through local propagation. Constraints
Outline 
 Interpreting line diagrams 
 Constraint modeling 
 Constraint propagation 
 Constraint satisfaction problems (CSP) 
aka constraint programs (CP). 
 Solving CSPs 
 Case study: Scheduling (Appendix) 
Brian Williams, Fall  10 8 
4</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Modeling: Systematically derive 
all realizable junction types 
 Case 1: View seven filled octants from the only empty  octant. 
_ 
_ 
_ 
Brian Williams, Fall  10
 11
12 Modeling: Systematically derive 
all realizable junction types 
 Case 2a: View one filled octant from all empty upper  octants. 
L R 
+ 
++L RL + 
R + 
Brian Williams, Fall  10 
6</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Full Arc-Consistency via AC-1 
AC-1 (CSP) 
Input:  A constraint satisfaction problem CSP = &lt;X, D, C&gt;. 
Output : CSP , the largest arc-consistent subset of CSP. 
1./.notdef.g0001 repeat 
2. /.notdef.g0001 for every cij  C, For every arc, 
3.  Revise( xi, xj) prune head 
4.  Revise( xj, xi) and tail domains. 
5. endfor Constraint Processing, 
6./.notdef.g0001 until no domain is changed. by R. Dechter 
pgs 57 
Brian Williams, Fall  10 37 
Full Arc Consistency 
via Constraint Propagation
Definition : arc &lt;xi, xj&gt; is directed arc consistent  if 
 ai  Di,  aj  Dj such that &lt;ai, aj&gt;  Cij
Constraint Propagation :
To achieve (directed) arc consistency  over CSP:
1. For every  arc Cij in CSP, with tail domain Di, call Revise .
2. Repeat  until quiescence: 
If an element was deleted from Di, then 
repeat Step 1 (AC-1) 
OR call Revise on each arc with head Di (AC-3)
 (use FIFO Q, remove duplicates) 
Brian Williams, Fall  10 38 
19</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Revise: A directed arc consistency procedure 
Definition : arc &lt;xi, xj&gt; is directed arc consistent  if 
 ai  Di, aj  Dj such that &lt;ai, aj&gt;  Cij
Revise ( xi, xj) 
Input:  Variables xi and xj with domains Di and Dj and constraint relation Rij. 
Output : pruned Di, such that xi is directed arc-consistent  relative to xj. 
1./.notdef.g0001 for each ai  Di
2. if there is no aj  Dj such that &lt;ai, aj&gt;  Rij
3.   then delete  ai from Di.
4. endif
5./.notdef.g0001 endfor
Constraint Processing, 
by R. Dechter 
pgs 54-6 
Brian Williams, Fall  10 35 
Full Arc Consistency over All Constraints 
via Constraint Propagation 
Definition : arc &lt;xi, xj&gt; is directed arc consistent  if 
 ai  Di,  aj  Dj such that &lt;ai, aj&gt;  Cij
Constraint Propagation :
To achieve (directed) arc consistency  over CSP:
1. For every  arc Cij in CSP, with tail domain Di, call Revise .
2. Repeat  until quiescence: 
If an element was deleted from Di, then 
repeat Step 1 (AC-1) 
Brian Williams, Fall  10 36 
18</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>18 17 Propagate starting with the 
background borders 
+ 
+ 
+ + + 
+ + + 
+ + + 
+ + 
-+ 
+ -
-- -- --
--+ + 
+ 
Brian Williams, Fall  10 
Without background borders, 
interpretations become unstable. 
Brian Williams, Fall  10 
9</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Outline 
 Interpreting line diagrams 
 Constraint satisfaction problems (CSP) 
aka constraint programs (CP). 
 Solving CSPs 
 Case study: Scheduling (appendix) 
Brian Williams, Fall  10 19 
20 Constraint Satisfaction Problems 
Variables 
Constraints Two positions on a line (vertical, 
horizontal, diagonal) cannot both be Q Domains Queen 1-4 or blank Chessboard positions 1 
2 
3 
4 
1 2 3 4 Q 4 Queens Problem: 
Place 4 queens on a 4x4 
chessboard so that no 
queen can attack another . 
How do we formulate? Q 
Q Q 
Brian Williams, Fall  10 
10</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1  V2 none V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V1  V3, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 47 
Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1  V2 none 
V1 &gt; V3 V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V3 &gt; V1, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 48 
24</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1 &gt; V2 V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V2 &gt; V1, V1  V3, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 43 
Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1 &gt; V2 none V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V2 &gt; V1, V1  V3, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 44 
22</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>63 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2 &gt; V1 none 
V1 &gt; V2 
64 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2 &gt; V1 none 
V1 &gt; V2 V1(R) 
32</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>57 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V2, V2 &gt; V1 , V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 V2(G) 
58 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V2 &gt; V1 , V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 V2(G) 
V3 &gt; V2 
29</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Outline
 Interpreting line diagrams 
 Constraint modeling 
 Constraint propagation 
 Constraint satisfaction problems (CSP) 
aka constraint programs (CP). 
 Solving CSPs 
 Case study: Scheduling (Appendix) 
Brian Williams, Fall  10 15 
16 C 
B A D 
C 
B 
A D 
+ + 
++ +
-
-+
++ + + 
--
-
+ + + -
--Solution: Label Lines by 
Propagating Constraints 
+ + 
+ 
+ -
Brian Williams, Fall  10 
8</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Outline 
 Interpreting line problems 
 Constraint satisfaction problems (CSP) 
aka constraint programs (CP). 
 Solving CSPs 
 Arc-consistency and propagation 
 Analysis of constraint propagation (next lecture) 
 Search (next lecture) 
 Case study: Scheduling (appendix) 
Brian Williams, Fall  10 29 
Good News / Bad News 
Good News -very general  &amp; interesting family of 
problems. 
-Problem formulation used extensively  in 
autonomy  and decision making  applications. 
Bad News includes NP-Hard  (intractable ?) problems 
Brian Williams, Fall  10 30 
15</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>59 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V2 &gt; V1 , V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 V2(G) 
V3 &gt; V2 none 
60 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V2 &gt; V1 , V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
30</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1 &gt; V2 none 
V2 &gt; V1 V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V1  V3, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 45 
Constraint Propagation Example AC-3 
Different-color constraint Graph Coloring 
Initial Domains R,G,B
 G R, G V1 
V2 V3 
Arc examined Value deleted 
V1 &gt; V2 none 
V2 &gt; V1 none V1 
Arcs to examine R,G,B
 G R, G V2 V3 
V1  V3, V2  V3 
 Delete unmentioned tail values  Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. 46 
23</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Next: To Solve CSPs we combine 
arc consistency and search 
1. Arc consistency (Constraint propagation), 
 Eliminates  values that are shown locally  to not be  a 
part of any solution. 
2. Search 
 Explores consequences  of committing  to particular 
assignments . 
Methods Incorporating Search: 
 Standard Search 
 BackT rack Search (BT) 
 BT with Forward Checking (FC) 
 Dynamic V ariable Ordering (DVO) 
 Iterative Repair 
Brian Williams, Fall  10
 Backjumping (BJ) 71 
Outline 
 Interpreting line diagrams 
 Constraint satisfaction problem (CSPS) 
aka constraint programs (CP). 
 Solving CSPs 
 Case study: Scheduling (appendix) 
Brian Williams, Fall  10 72 
36</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Constraint Programming:  
Modeling, Arc Consistency  
  and Propagation  
 1  
Brian C. Williams 
16.410-13 
September 22nd, 2010 
Slides draw material from:&#13;
6.034 notes, by Tomas Lozano Perez&#13;
AIMA, by Stuart Russell &amp; Peter Norvig&#13;
Constraint Processing, by Rina Dechter&#13;
Brian Williams, Fall  10  
Brian Williams, Fall  10  2 Assignments  
Assignment:  
Problem Set #2 due today, Wed. Sept. 22nd, 2010. 
Problem Set #3: Analysis, Path Planning and Constraint 
Programming, out today, due Wed., Sept. 29th, 2010. 
Reading:  
Today: [AIMA] Ch. 6.1, 24.3-5; Constraint Modeling.  
Monday: [AIMA] Ch. 6.2-5; Constraint Satisfaction. 
To Learn More: Constraint Processing , by Rina Dechter 
Ch. 2: Constraint Networks 
Ch. 3: Consistency Enforcing and Propagation</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>51 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V2  V3, V2 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1 &gt; V3 V1(G) 
V3 &gt; V1 
52 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V2  V3, V2 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1 &gt; V3 V1(G) 
V3 &gt; V1 none 
26</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>41 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 
R,G,B
 G R, G V2 V3 V1 Graph Coloring 
Initial Domains 
Arcs to examine 
V1  V2, V1  V3, V2  V3 
 Introduce queue of arcs  to be examined. 
 Start by adding all arcs  to the queue. Arc examined Value deleted 
42 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 
R,G,B
 G R, G V2 V3 V1 Graph Coloring 
Initial Domains 
Arcs to examine 
V1  V2, V1  V3, V2  V3 
 Vi  Vj denotes two arcs, between Vi and Vj. 
 Vi &gt; Vj denotes an arc from Vi to Vj. Arc examined Value deleted 
21</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>53 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V2  V3, V2 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1 V3 V1(G) 
54 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V2, V2 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 
27</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>61 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2 &gt; V1 
62 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2 &gt; V1 none 
31</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>A general class of CSPs 
Finite Domain, Binary CSPs Depict as a Constraint Graph 
 each constraint  relates at Nodes (vertices) are 
most two variables. variables. 
 each variable domain  is finite . Arcs (edges) are binary 
constraints. 
Property : all n-ary  CSPs are 
reducible to binary  CSPs. 
Binary 
constraint 
arc Unary constraints 
just cut down domains Unary constraint arc Variable Vi with 
values in domain Di 
Brian Williams, Fall  10 27 
Example: Graph Coloring
Pick colors for map regions, 
without coloring adjacent regions 
with the same color 
Variables regions 
Domains allowed colors 
Constraints adjacent regions must have dif ferent colors 
Brian Williams, Fall  10 28 
14</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>65 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V2 &gt; V1, V3 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2 &gt; V1 none 
V1 &gt; V2 V1(R) 
66 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R V2 V3 V1 
Arcs to examine 
V2 &gt; V1, V3 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2  V1 V1(R) 
33</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Good Encodings Are Essential: 4 Queens 
Place queens so that no 1
queen can attack another . 2
3 
What is a better encoding? 4 
12 34 Q Q 
Q Q 
Assume one queen per column. 
 Determine what row each queen should be in. 
Variables Q1, Q2, Q3, Q4, 
Domains {1, 2, 3, 4} 
Constraints Qi&lt;&gt; Qj On dif ferent rows 
|Qi - Qj | &lt;&gt; |i-j| Stay of f the diagonals 
Example C1,2 = {(1,3) (1,4) (2,4) (3,1) (4,1) (4,2)} 
25 Brian Williams, Fall  10
Good Encodings Are Essential: 4 Queens
Place queens so that no 1 
queen can attack another . 2 
3 Variables Q1, Q2, Q3, Q4, 4 Q Q 
Q Q 
12 34 Domains {1, 2, 3, 4} 
Constraints Qi&lt;&gt; Qj On dif ferent rows 
|Qi- Qj | &lt;&gt; |i-j| Stay of f the diagonals 
Example: C1,2 = {(1,3) (1,4) (2,4) (3,1) (4,1) (4,2)} 
What is C13? 
Brian Williams, Fall  10 26 
13</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Conventions 
 List scope in subscript. 
 Specify one constraint per scope. 
Example : Provide one A and two Bs. 
 C = {CAB}
 CAB = {&lt;1,2&gt;} 
 C = {CA,CB}
 CA = {&lt;1&gt;} 
CB = {&lt;2&gt;} 
Brian Williams, Fall  10 23 
24 Good Encodings Are Essential: 4 Queens 
Variables 
Constraints Two positions on a line (vertical, 
horizontal, diagonal) cannot both be Q Domains Queen 1-4 or blank Chessboard positions 1 
2 
3 
4 
1 2 3 4 Q 4 Queens Problem: 
Place 4 queens on a 4x4 
chessboard so that no 
queen can attack another . 
How big is the encoding? Q 
Q Q 
Brian Williams, Fall  10 
12</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Outline 
 Interpreting line diagrams 
 Constraint satisfaction problems (CSP) 
[aka constraint programs (CP)]. 
 Solving CSPs 
 Case study: Scheduling (Appendix) 
Brian Williams, Fall  10 3 
Outline 
 Interpreting line diagrams 
 Constraint modeling 
 Constraint propagation 
 Constraint satisfaction problems (CSP) 
aka constraint programs (CP) 
 Solving CSPs 
 Case study: Scheduling (Appendix) 
Brian Williams, Fall  10 4 
2</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>55 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V3, V2 &gt; V1 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 V2(G) 
56 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
R, B
 G R, G V2 V3 V1 
Arcs to examine 
V3 &gt; V2, V2 &gt; V1 , V1 &gt; V2 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2 &gt; V3 V2(G) 
28</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>13 Modeling: Systematically derive 
all realizable junction types 
 Case 2b: View one filled  octant from all empty lower  octants. 
L R 
L R + R L 
Brian Williams, Fall  10
 14 All Junctions 
L Junctions Fork Junctions Arrow Junctions T Junctions + + 
+ + 
+ ---
-
+ 
+ 
+ -
--+ --
+ 
Brian Williams, Fall  10 
7</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Modeling: Make Simplifying Assumptions 
1.	Limited line interpretations: 
No shadows  or cracks . 
2.	Three-faced vertices: 
Intersection of exactly three object faces 
(e.g., no pyramid tops). 
3.	General position: 
Small perturbations  of selected viewing points can not 
lead to a change in junction type. 
Brian Williams, Fall  10 9 
Modeling: Systematically derive 
all realizable junction typesConsider: 
 a three face vertex, which divides space into octants , 
 (not guaranteed to be at right angles) , and 
 all possible fillings  of octants, 
viewed from all  empty octants. 
Brian Williams, Fall  10 10 
5</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Arc Consistency 
X X &lt; Y Y 
1 . 
2 . 
3 . . 1 
. 2 
. 3 
Brian Williams, Fall  10 33 
Directed Arc Consistency 
X1 {&lt;1,3&gt;,&lt;1,4&gt;,&lt;2,1&gt;} X2 
1 . 
2 . 
3 . 
4 . . 1 
. 2 
. 3 
. 4 
Definition : arc &lt;xi, xj&gt; is directed arc consistent  if 
 for every ai in Di, 
 there exists  some aj in Dj such that 
 assignment &lt;ai,aj&gt; satisfies constraint  Cij, 
  ai  Di,  aj  Dj such that &lt;ai, aj&gt;  Cij 
  denotes for all,  denotes there exists and  denotes in. 
Brian Williams, Fall  10 34 
17</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Real World Example: Scheduling as a CSP
Choose time of activities: 
 Observations by the Hubble telescope. 
5 
 Jobs performed on machine tools. 4
3
 Classes taken for degree. 2
1
Variables are activities time 
Domains Are possible start times (or chunks of time) 
Constraints 1. Activities that use the same 
resource cannot overlap in time, and 
2. Prerequisites are satisfied. 
Brian Williams, Fall  10 73 activity 
Case Study: Course Scheduling 
Given: 
 32 required courses (8.01, 8.02, . . . . 16.410), and 
 8 terms (Fall 1, Spring 1, . . . . , Spring 4). 
Find:  a legal schedule. 
Constraints  Pre-requisites satisfied, 
 Courses of fered only during certain terms, 
A limited number of courses can be taken per  
term (say 4), and 
Avoid time conflicts between courses. 
Note, traditional CSPs  are not for expressing (soft) preferences 
e.g. minimize dif ficulty , balance subject areas, etc. 
But see recent research on valued CSPs! 74 
37</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>67 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
B
 G R V2 V3 V1 
Arcs to examine 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . V3 &gt; V1Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2  V1 V1(R) 
V2 &gt; V1 
68 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
B
 G R V2 V3 V1 
Arcs to examine 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue . V3 &gt; V1 Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2  V1 V1(R) 
V2 &gt; V1 none 
34</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>69 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
B
 G R V2 V3 V1 
Arcs to examine 
 Delete unmentioned tail values 
IF An element of a variable s domain is removed , 
THEN add all arcs to that variable  to the examination queue .Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2  V1 V1(R) 
V2 &gt; V1 none 
V3 &gt; V1 
70 Constraint Propagation Example AC-3 
R,G,B
 G R, G Different-color constraint V1 
V2 V3 Graph Coloring 
Initial Domains 
B
 G R V2 V3 V1 
Arcs to examine 
IF examination queue is empty 
THEN arc (pairwise) consistent . Arc examined Value deleted 
V1  V2 none 
V1  V3 V1(G) 
V2  V3 V2(G) 
V2  V1 V1(R) 
V2 &gt; V1 none 
V3 &gt; V1 none 
35</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>5 Labeling Line Diagrams for 
Visual Interpretation 
Input: Line drawing (a graph) 
Physical constraints 
Output: Consistent assignment of line (edge) types 
depth 
discontinuity surface 
orientation 
discontinuity 
reflectance 
discontinuity 
Huffman Clowes (1971): Interpret opaque, trihedral solids 
Step 1: Label line types. + 
+ + + 
Convex 
Edge + Concave 
Edge 
Brian Williams, Fall  10
Requirement: 
Labeling must extend to complex objects
Brian Williams, Fall  10
6
3</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>21 C 
B A D 
C 
B 
A D 
+ + 
++ +
-
-+
++ + + 
--
-
+ + + -
--Variables: ? 
Domains: ? 
Constraints: ? 
Brian Williams, Fall  10
Constraint Satisfaction Problems (CSP) 
Input:  A Constraint Satisfaction Problem  is a triple &lt;V,D,C&gt;,  where: 
 V is a set of variables  Vi 
 D is a set of variable domains , 
 The domain of variable Vi is denoted Di 
 C = is a set of constraints  on assignments to V 
 Each constraint Ci = &lt;Si,Ri&gt; specifies allowed variable assignments. 
 Si the constraints scope , is a subset of variables V. 
 Ri the constraints relation , is a set of assignments to Si. 
Output:  A full assignment to V , from elements of Vs domain, 
such that all constraints in C are satisfied . 
Example : Provide one A and two Bs. 
 V = {A,B}, each with domain Di = {1,2} 
 C = {&lt;{A,B}, {&lt;1,2&gt;, &lt;1,1&gt;}&gt; one A
 &lt;{A,B}, {&lt;1,2&gt;, &lt;2,2&gt;}&gt;} two Bs  
 Output:  &lt;1,2&gt; Brian Williams, Fall  10 (for example) 
22 
11</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Inferring state in an uncertain world I: introduction to hidden Markov models [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec20/</lecture_pdf_url>
      <lectureno>20</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text>Whack-the-mole 3/3
Doing the calculations:
p1= (1 ;0;0);
p2=T0p1= (0 :1;0:4;0:5);
p3=T0p2= (0 :17;0:34;0:49);
p4=T0p3= (0 :153 ;0:362 ;0:485);
. . .
p1= lim t!1 T0tp1
= (0 :1579 ;0:3553 ;0:4868).
x1
0:17
x2
0:34
x3
0:49
0:1
0.4
0.5
0.4
0.6
0.4
0.6
Under some technical conditions, the state distribution of a Markov
chain converge to a stationary distribution p1, such that
p1=T0p1:
The stationary distribution can be computed as the eigenvector of the
matrix T0associated with the unit eigenvalue (how do we know that
Thas a unit eigenvalue?), normalized so that the sum of its
components is equal to one.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Whack-the-mole 3/3
Doing the calculations:
p1= (1 ;0;0);
p2=T0p1= (0 :1;0:4;0:5);
p3=T0p2= (0 :17;0:34;0:49);
p4=T0p3= (0 :153 ;0:362 ;0:485);
. . .
p1= lim t!1 T0tp1
= (0 :1579 ;0:3553 ;0:4868).
x1
0:16
x2
0:36
x3
0:49
0:1
0.4
0.5
0.4
0.6
0.4
0.6
Under some technical conditions, the state distribution of a Markov
chain converge to a stationary distribution p1, such that
p1=T0p1:
The stationary distribution can be computed as the eigenvector of the
matrix T0associated with the unit eigenvalue (how do we know that
Thas a unit eigenvalue?), normalized so that the sum of its
components is equal to one.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Whack-the-mole 3/3
Doing the calculations:
p1= (1 ;0;0);
p2=T0p1= (0 :1;0:4;0:5);
p3=T0p2= (0 :17;0:34;0:49);
p4=T0p3= (0 :153 ;0:362 ;0:485);
. . .
p1= lim t!1 T0tp1
= (0 :1579 ;0:3553 ;0:4868).
x1
0:1
x2
0:4
x3
0:5
0:1
0.4
0.5
0.4
0.6
0.4
0.6
Under some technical conditions, the state distribution of a Markov
chain converge to a stationary distribution p1, such that
p1=T0p1:
The stationary distribution can be computed as the eigenvector of the
matrix T0associated with the unit eigenvalue (how do we know that
Thas a unit eigenvalue?), normalized so that the sum of its
components is equal to one.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Whack-the-mole 3/3
Doing the calculations:
p1= (1 ;0;0);
p2=T0p1= (0 :1;0:4;0:5);
p3=T0p2= (0 :17;0:34;0:49);
p4=T0p3= (0 :153 ;0:362 ;0:485);
. . .
p1= lim t!1 T0tp1
= (0 :1579 ;0:3553 ;0:4868).
x1
1
x2
0
x3
0
0:1
0.4
0.5
0.4
0.6
0.4
0.6
Under some technical conditions, the state distribution of a Markov
chain converge to a stationary distribution p1, such that
p1=T0p1:
The stationary distribution can be computed as the eigenvector of the
matrix T0associated with the unit eigenvalue (how do we know that
Thas a unit eigenvalue?), normalized so that the sum of its
components is equal to one.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Outline
1Markov Chains
2Hidden Markov Models
3Problem 1: Evaluation
4Problem 2: Explanation
Filtering
Smoothing
Decoding and Viterbi's algorithm
E. Frazzoli (MIT) Lecture 20: HMMs November 22, 2010 17 / 32</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
Lecture notes
[AIMA] Ch. 15.1-3, 20.3.
Paper on Stellar: L. Rabiner, \A tutorial on Hidden Markov Models..."
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 2 / 32</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Whack-the-mole 3/3
Doing the calculations:
p1= (1 ;0;0);
p2=T0p1= (0 :1;0:4;0:5);
p3=T0p2= (0 :17;0:34;0:49);
p4=T0p3= (0 :153 ;0:362 ;0:485);
. . .
p1= lim t!1 T0tp1
= (0 :1579 ;0:3553 ;0:4868).
x1
. . .
x2
. . .
x3
. . .
0:1
0.4
0.5
0.4
0.6
0.4
0.6
Under some technical conditions, the state distribution of a Markov
chain converge to a stationary distribution p1, such that
p1=T0p1:
The stationary distribution can be computed as the eigenvector of the
matrix T0associated with the unit eigenvalue (how do we know that
Thas a unit eigenvalue?), normalized so that the sum of its
components is equal to one.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Whack-the-mole example
Let us assume that that every time the mole surfaces, we can hear it,
but not see it (it's dark outside)
our hearing is not very precise, and has the following measurement
probabilities:
M=2
40:6 0:2 0:2
0:2 0:6 0:2
0:2 0:2 0:63
5
Let us assume that over three times the mole surfaces, we make the
following measurements: (1, 3, 3)
Compute the distribution of the states of the mole, as well as its most
likely state trajectory.
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 21 / 32</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Outline
1
Markov Chains
Example: Whack-the-mole
2
Hidden Markov Models
3
Problem 1: Evaluation
4
Problem 2: Explanation
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 3 / 32</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Whack-THE-mole
A mole has burrowed a network of underground tunnels, with Nopenings
at ground level. We are interested in modeling the sequence of openings at
which the mole will poke its head out of the ground. The probability
distribution of the \next" opening only depends on the present location of
the mole.
Three holes:
X=fx1;x2;x3g.
Transition probabilities:
T=2
40:1 0:4 0:5
0:4 0 0:6
0 0:6 0:43
5
x1
x2
x3
0:1
0.4
0.5
0.4
0.6
0.4
0.6
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 6 / 32</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Outline
1
Markov Chains
2
Hidden Markov Models
3
Problem 1: Evaluation
Forward and backward algorithms
4
Problem 2: Explanation
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 12 / 32</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 20: Intro to Hidden Markov Models
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 22, 2010
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 1 / 32</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Outline
1
Markov Chains
2
Hidden Markov Models
3
Problem 1: Evaluation
4
Problem 2: Explanation
E. Frazzoli (MIT)Lecture 20: HMMsNovember 22, 2010 9 / 32</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Planning I: operator-based planning and plan graphs
Planning II: plan extraction and analysis [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec08a/</lecture_pdf_url>
      <lectureno>8</lectureno>
      <slides>
        <slide>
          <slideno>10</slideno>
          <text>11  Outline
/.notdef.g0001Graph Plan 
/.notdef.g0001Problem Statement 
/.notdef.g0001Planning Graph Construction 
/.notdef.g0001Plan Extraction
Graph Plan Algorithm 
/.notdef.g0001Phase 1  Plan Graph Expansion 
/.notdef.g0001Graph includes all plans that are complete and consistent. 
/.notdef.g0001Graph prunes many infeasible plans. 
/.notdef.g0001Phase 2 - Solution Extraction 
/.notdef.g0001Graph frames a kind of constraint satisfaction problem (CSP).
/.notdef.g0001Extraction selects actions to perform at each time point,
by assigning variables and by testing consistency.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19    noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001 /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001Mutual Exclusion: Actions 
0 Prop        0 Action              1  Prop             1 Action           2 Prop 1. /.notdef.g0001Inconsistent effects. 
2. /.notdef.g0001Effect interferes  
  with precondition. 
3. /.notdef.g0001Competing needs. 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001 /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001Mutual Exclusion: Actions 
0 Prop        0 Action              1  Prop             1 Action           2 Prop 1. /.notdef.g0001Inconsistent effects. 
2. /.notdef.g0001Effect interferes  
  with precondition. 
3. /.notdef.g0001Competing needs.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14  Graph Properties 
/.notdef.g0001Plan graphs are constructed in polynomial 
time and are of polynomial in size. 
/.notdef.g0001Plan graphs do not eliminate all infeasible 
plans.
/.notdef.g0002 /.notdef.g0001Plan generation requires focused search.
Constructing the Planning Graph 
(Reachability)
/.notdef.g0001Initial proposition layer 
/.notdef.g0001Contains propositions that hold in the initial state.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4Representing States 
7/.notdef.g0001State
/.notdef.g0001A consistent conjunction of propositions (positive literals). 
/.notdef.g0001E.g., (and (cleanhands) (quiet) (dinner) (present) (noGarbage)) 
/.notdef.g0001All unspecified propositions are false.
/.notdef.g0001Initial State 
/.notdef.g0001Problem state at time i = 0. 
/.notdef.g0001E.g., (and (cleanHands) (quiet)). 
/.notdef.g0001Goal State
/.notdef.g0001A partial state. 
/.notdef.g0001E.g., (and (noGarbage) (dinner) (present)). 
/.notdef.g0001A Plan moves a system from its initial state to a final state 
that extends the goal state. 
Representing Operators 
8(:operator cook   :precondition (cleanHands) 
      :effect (dinner)) 
Preconditions :  Propositions that must be true to apply 
the operator. 
/.notdef.g0001A conjunction of propositions (no negated propositions). 
Effects : Propositions that the operator changes,
given that the preconditions are satisfied. 
/.notdef.g0001A conjunction of propositions (called adds ) and
their negation (called deletes ).}</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
quiet/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1      Prop at 2 (noop dinner) 
(noop present) Example of a Complete Plan
Initial Conditions :       (and (cleanHands) (quiet)) 
Goal :        (and (noGarbage) (dinner) (present)) 
A Complete Consistent Plan 
Given an initial state that holds at time 0, and goal propositions,  
a plan is a solution iff it is: 
 Complete: 
/.notdef.g0001 The goal propositions all hold in the final state. 
/.notdef.g0001The preconditions of every operator at time i, 
   are satisfied by propositions at time i.
 Consistent: 
/.notdef.g0001 The operators at any time i can be executed inany order ,
  without one of these operators undoing :
/.notdef.g0001thepreconditions of another operator at time i.
/.notdef.g0001 the effects of another operator at time i.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2Simple Spacecraft Problem  
Observation-1/.notdef.g0001
target/.notdef.g0001
instruments/.notdef.g0001
Observation-2/.notdef.g0001
Observation-3/.notdef.g0001Observation-4/.notdef.g0001
/.notdef.g0001calibrated/.notdef.g0001pointing/.notdef.g0001
Propositions: Target Pointed To, Camera Calibrated?, Has Image? 
Operators: Calibrate, Turn to Y, and Take Image. 
Outline
/.notdef.g0001Graph Plan 
/.notdef.g0001Problem Statement 
/.notdef.g0001Planning Graph Construction 
/.notdef.g0001Plan Extraction Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12  Example: Planning Graph and Solution 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001carry
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001
0 Prop        0 Action              1  Prop             1 Action           2 Prop 
Example: Planning Graph and Solution 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001
0 Prop        0 Action              1  Prop             1 Action           2 Prop</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13  Graph Plan Algorithm 
/.notdef.g0001Phase 1  Plan Graph Expansion 
/.notdef.g0001Graph includes all plans that are complete and consistent. 
/.notdef.g0001Graph prunes many infeasible plans. 
/.notdef.g0001Phase 2 - Solution Extraction 
/.notdef.g0001Graph frames a kind of constraint satisfaction problem (CSP).
/.notdef.g0001Extraction selects actions to perform at each time point,
by assigning variables and by testing consistency. 
/.notdef.g0001Repeat Phases 1 and 2 for planning graphs with an 
increasing numbers of action layers. 
Planning Graphs Prune 
Initial state reachability:
Prunes partial states and actions at each time 
i that are not reachable from the initial state, 
Consistency:
Prunes pairs of propositions and actions
that are mutually inconsistent at time I, and
Goal state reachability:
plans that cannot reach the goals.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5(Parameterized) Operator Schemata 
/.notdef.g0001Instead of defining many operator instances:
pickup-A  and pickup-B  and  
/.notdef.g0001Define a schema:
(:operator pick-up
     :parameters  ((?ob1 - block)) 
     :precondition  (and (clear ?ob1)
   (on-table ?ob1)
   (arm-empty)) 
:effect  (and (not (clear ?ob1)) 
 (not (on-table ?ob1)) 
             (not (arm-empty)) 
 (holding ?ob1))) 
Example Problem: Dinner Date
Initial Conditions :     (:init (cleanHands) (quiet)) 
Goal :        (:goal (noGarbage) (dinner) (present)) 
Actions :
(:operator carry :precondition
:effect  (and (noGarbage) (not (cleanHands))) 
(:operator dolly :precondition
:effect  (and (noGarbage) (not (quiet))) 
(:operator cook :precondition (cleanHands)
:effect  (dinner)) 
(:operator wrap :precondition (quiet)
:effect  (present)) 
+ noops 
Plan:                   (Cook, Wrap, Carry)</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20    noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001 /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001Mutual Exclusion: Actions 
0 Prop        0 Action              1  Prop             1 Action           2 Prop 1. /.notdef.g0001Inconsistent effects. 
2. /.notdef.g0001Effect interferes  
  with precondition. 
3. /.notdef.g0001Competing needs. 
Layer 1: Complete Action Mutexs 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001 /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
0 Prop        0 Action              1  Prop             1 Action           2 Prop 1. /.notdef.g0001Inconsistent effects. 
2. /.notdef.g0001Effect interferes  
  with precondition. 
3. /.notdef.g0001Competing needs.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21  Mutual Exclusion: Proposition Layer 
Propositions P,Q are inconsistent at i
/.notdef.g0001ifno valid plan could possibly contain both at i, 
/.notdef.g0004 /.notdef.g0001if at i, all ways to achieve P exclude 
each way to achieve Q. 
41   P/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  Q/.notdef.g0001A1/.notdef.g0001
/.notdef.g0001
/.notdef.g0001A2/.notdef.g0001M/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
N/.notdef.g0001
Layer 1: Add Proposition Mutexs 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001 /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
0 Prop        0 Action              1  Prop             1 Action           2 Prop Do all goal 
propositions
appear non-mutex? 
No proposition mutexs.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6Visualizing Actions 
11 (:operator cook :precondition (cleanHands)
:effect  (dinner)) 
(:operator carry :precondition
:effect  (and (noGarbage) (not (cleanHands))) 
carry/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001cook/.notdef.g0001  dinner/.notdef.g0001 cleanHands /.notdef.g0001
Visualizing Actions 
12 /.notdef.g0001Persistence actions (No-ops) 
/.notdef.g0001Every literal has a no-op action,
which maintains it from time i to i+1.
           (:operator noop-P :precondition (P):effect  (P)) 
Noop-P/.notdef.g0001  P/.notdef.g0001   P/.notdef.g0001
In Blum &amp; Furst: (&amp; lecture) Only persist positive literals. 
AIMA: Persists negative literals as well .
either approach okay for PSet.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10  /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1      Prop at 2 (noop dinner) 
(noop present) Example of a
Complete Consistent Plan
Initial Conditions :  (and (cleanHands) (quiet)) 
Goal :        (and (noGarbage) (dinner) (present)) 
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1      Prop at 2 (noop dinner) 
(noop present) Example of a
Complete Inconsistent Plan
Initial Conditions :  (and (cleanHands) (quiet)) 
Goal :        (and (noGarbage) (dinner) (present)) 
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001(noop garb) 
(noop cleanH)</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22  Round 2: Extending The Planning Grap h
  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001dolly/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook/.notdef.g0001
/.notdef.g0001/.notdef.g0001wrap/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001
0 Prop        0 Action              1  Prop             1 Action           2 Prop 
Outline
/.notdef.g0001Graph Plan 
/.notdef.g0001Problem Statement 
/.notdef.g0001Planning Graph Construction 
/.notdef.g0001Plan Extraction</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001  dinner/.notdef.g0001/.notdef.g0001
/.notdef.g0001
  present/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 noop-dinner
noop-present/.notdef.g0001Sets of concurrent actions that are performed at each time [i] 
/.notdef.g0001Concurrent actions can be interleaved in any order. 
/.notdef.g0004 /.notdef.g0001If actions a and b occur at time i, then it must be valid to 
perform either a followed by b, OR b followed by a. Representing Plans: &lt; Actions[i]  &gt; 
A Complete Consistent Plan 
Given an initial state that holds at time 0, and goal propositions,  
a plan is a solution iff it is: 
 Complete: 
/.notdef.g0001 The goal propositions all hold in the final state .
/.notdef.g0001Thepreconditions of every operator at time i, 
   are satisfied bypropositions at time i.
 Consistent:</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3Graph Plan 
/.notdef.g0001Developed in 1995 by Avrim Blum and Merrick Furst, at CMU. 
/.notdef.g0001The Plan Graph compactly encodes all possible plans. 
/.notdef.g0001has been a key to scaling up to realistic problems. 
/.notdef.g0001Plan Graph representation used for: 
/.notdef.g0001An encoding method for formulating planning as a CSP.
/.notdef.g0001Relaxed planning as an admissible heuristic (state space search + A*). 
/.notdef.g0001Approach has been extended to reason with temporally extended 
actions, metric and non-atomic preconditions and effects.
Approach: Graph Plan 
1. /.notdef.g0001Construct compact constraint encoding of state 
space from operators and the initial state.
-Planning Graph
2. /.notdef.g0001Generate plan by searching for a consistent 
subgraph that achieves the goals. 
Proposition
Init State ActionTime 1 PropositionTime 1 ActionTime 2</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Reasoning in an uncertain world [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec19a/</lecture_pdf_url>
      <lectureno>19</lectureno>
      <slides>
        <slide>
          <slideno>21</slideno>
          <text>3/6/00	
&#13;
22	
&#13;Computing Probabilistic Queries 
Let X = &lt;S, O&gt; 
Belief Assessment: S = &lt;Si, Y&gt; 
b(Si) = P(Si | o)  
Most Probable Explanation (MPE): 
s* = arg max P(s | o) for all s  DS 
Maximum Aposteriori Hypothesis (MAP): S = &lt;A, Y&gt; 
Given A  S 
   a* = arg max P(a | o) for all a  DA 
11/17/10  copyright Brian Williams, 2005-10  43  
Outline 
Motivation 
Set Theoretic View of Propositional Logic 
From Propositional Logic to Probabilities 
Probabilistic Inference 
General Queries and Inference Methods  
Bayes Net Inference 
Model-based Diagnosis   (Optional) 
11/17/10  copyright Brian Williams, 2005-10  44</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>3/6/00/nonmarkingreturn
21/nonmarkingreturnExploit Distribution During Elimination (Method 4) 
Bayes Net Chain Rule: Xi is independent 
of its ancestors, given its parents. 
11/17/10  copyright Brian Williams, 2005-10  41  Earthquake Burglary 
Alarm 
JohnCall Nap TV 
MaryCall Issue: Size of P(X) is exponential in |X| 
Soln:  Move sums inside product. 
Compute Conditional Probability via 
Elimination (Method 5) 
11/17/10  copyright Brian Williams, 2005-10  42  B {raining, dry} 
B
{cloudy,  
sunny} .197
.003.20
.60P(A,B) 
.2 .8 P(B) P(A | B) .197/.2 
.003/.2 .20/.8 
.60/.8 Note: The denominator is constant for all ai in A 
Example: P(A | B)?</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>3/6/00/nonmarkingreturn
5/nonmarkingreturnEstimate Dynamically with a Bayes Filter 
Localizing a Robot within a Topological Map 
x1
x2:p(x2|x1,a)= .9 
x3:p(x3|x1,a)=.05 
x4:p(x4|x1,a)=.05 
Observations can 
be features such 
as corridor features, 
junction features, etc.
 Source unknown.  All rights reserved. This content is excluded from our Creative Commons 
license. For more information, see http://ocw.mit.edu/fairuselicense. For more information, see http://ocw.mit.edu/fairuse .An action
is taken
Posterior beliefafter an action 
Posterior beliefafter sensing  State Space 
Initial belief 
P(St | o1:t): 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>3/6/00/nonmarkingreturn
19/nonmarkingreturnProduct Rule + Conditional Independence (Method 2) 
11/17/10  copyright Brian Williams, 2005-10  37  If A is conditionally independent of C given B  
(i.e., A C | B), then: 
Suppose A  B, C | E and B  C | E, find P(A, B, C | E): 
Product rule 
Independence 
Product Rule for Bayes Nets  
Xi is independent of its 
ancestors, given its parents: 
11/17/10  copyright Brian Williams, 2005-10  38  Earthquake Burglary 
Alarm 
JohnCall Nap TV 
MaryCall 
Product rule 
Independence</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>3/6/00	
&#13;
10	
&#13;Set Theoretic Semantics:  P implies Q 
11/17/10  copyright Brian Williams, 2005-10  19  M(not R)                                       M(R) M(Q) Q implies R is True iff  Q and not R is inconsistent U 
Q implies R is True iff  M(Q and not R)   Axioms of Sets over Universe U 1.A  B  B  A   Commutativity 2.A  (B  C)  A  (B  C)  Associativity 3.A  (B  C)  A  B  A  C Distributivity 4.~ (~A)  A    ~ Elimination 5.~ (A  B)  (~ A)  (~ B)  De Morgans 6.A  (~A)       7.A  U  A    Identity 11/17/10  copyright Brian Williams, 2005-10  20   propositional logic axioms follow from these axioms.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>3/6/00/nonmarkingreturn
20/nonmarkingreturnComputing Probabilistic Queries 
Let X = &lt;S; O&gt; 
Belief Assessment: 
b(Si) = P(Si  | e) 
Most Probable Explanation (MPE): 
s*= arg max P(s | o) for all s  DS
Maximum Aposteriori Hypothesis (MAP): 
Given A  S 
   a*= arg max P(s | o) for all a  DA
Solution : Some combination of 
1. Start with joint distribution. 
2. Eliminate some variables (marginalize ).
3. Condition on observations. 
4. Find assignment maximizing probability. 
11/17/10  copyright Brian Williams, 2005-10  39  
Eliminate Variables by Marginalizing (Method 3) 
11/17/10  copyright Brian Williams, 2005-10  40  B {raining, dry} 
A
{cloudy,  
sunny} .197
.003.20
.60P(A, B) 
.2 .8 P(B) .397
.603
P(A) Given P(A, B)  
        find P(A) :</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>3/6/00	
&#13;
7	
&#13;Set Theoretic Semantics:  S  True 
11/17/10  copyright Brian Williams, 2005-10  13  M(True)  Universe U U 
Set Theoretic Semantics:  S  not Q 
11/17/10  copyright Brian Williams, 2005-10  14  M(not Q)                               M(Q) M(not Q)  U  M(Q) U</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>3/6/00/nonmarkingreturn
18/nonmarkingreturnComputing Joint Distributions P(X) for 
Bayesian Networks 
11/17/10  copyright Brian Williams, 2005-10  35  Earthquake Burglary 
Alarm 
JohnCall Nap TV 
MaryCall 
Answer 
How do we compute joint distribution P(J,M,T,A,N,B,E)? Joint Distribution:   
Assigns probabilities to  
  every interpretation. 
 Queries computed from joint. 
Product (Chain) Rule (Method 1) 
P(S=no) 0.80
P(S=light) 0.15
P(S=heavy) 0.05 Smoking =  no light heavy 
P(C=none) 0.96 0.88 0.60
P(C=benign) 0.03 0.08 0.30
P(C=malig) 0.01 0.04 0.10
      Smoking 
/ Cancer none benign malig 
no 0.768 0.024 0.008
light 0.132 0.012 0.006
heavy 0.03 0.015 0.005
11/17/10  copyright Brian Williams, 2005-10  36  P(C| S) : 
P(S) : 
P(C, S): = 0.96 x 0.80 C (Cancer)  {none, benig, malig} 
S (Smoking) {no, light, heavy}</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>3/6/00	
&#13;
8	
&#13;Set Theoretic Semantics:  S  Q and R 
11/17/10  copyright Brian Williams, 2005-10  15                      M(R) M(Q)                             M(Q and R) M(Q and R)  M(Q)  M(R) U 
Set Theoretic Semantics:  False 
11/17/10  copyright Brian Williams, 2005-10  16  M(False)   U</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>3/6/00	
&#13;
16	
&#13;Common Inference Methods and Approximations used 
to Answer Queries 
1. Product (chain) rule. 
2. Product rule + conditional independence. 
3. Eliminate variables by marginalizing. 
4. Exploiting distribution during elimination. 
5. Conditional probability via elimination. 
6. Conditional probability via Bayes Rule. 
Approximations: 
1. Uniform Likelihood Assumption 
2. Nave Bayes Assumption 
11/17/10  copyright Brian Williams, 2005-10  31  
Outline 
Motivation 
Set Theoretic View of Propositional Logic 
From Propositional Logic to Probabilities 
Probabilistic Inference 
General Queries and Inference Methods  
Bayes Net Inference 
Model-based Diagnosis   (Optional) 
11/17/10  copyright Brian Williams, 2005-10  32</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>3/6/00	
&#13;
2	
&#13;Notation 
S, Q, R, P   Logical sentences 
    Background theory (a sentence).  
not, and ( ), or (v), implies ( ), if and only if  ( iff, ). 
    Standard logical connectives where iff  if and only if. 
M(S), entails,   Models of sentence S, entails, false. 
A, B, C   Sets. 
U,    Universe of all elements, empty set. 
, , ~, -    Set union, intersection, inverse and difference. 
    Equivalent to.  
V:    Variable or vector of variables. 
Vi:    The ith variable of vector V. 
V, vi:     A particular assignment to V; short form for V= v, Vi = vi. 
Vt:   V at time t. 
Vi:j:   A sequence of V from time i to time j. 
11/17/10  copyright Brian Williams, 2005-10  3 
Notation 
S:   States or state vector. 
O:   Observables or observation vector. 
X:   Mode or mode vector. 
S0, S1   Stuck at 0/1 mode. 
Prefix ( k) L Returns the first k elements of list L. 
Sort L by R  Sorts list L in increasing order based on relation R. 
si   ith sample in sample space U. 
P(X)   The probability of X occurring. 
P(X|Y)   The probability of X, conditioned on Y occurring. 
A  C | B)  A is conditionally independent  of C given B.  
11/17/10  copyright Brian Williams, 2005-10  4</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>3/6/00	
&#13;
1	
&#13;11/17/10  copyright Brian Williams, 2005-10  1 
Brian C. Williams 
16.410/16.413 November 17
th, 2010 
Brian C. Williams, copyright 2000-09 Introduction to  
Probabilistic Reasoning 
Assignment 
Homework: 
Problem Set #8: Linear Programming,  
due today, Wednesday, November 16th. 
Problem Set #9: Probabilistic Reasoning,  
out today, due Wednesday, November 24th. 
Readings: 
Today: Review of Probabilities and Probabilistic Reasoning. 
AIMA Chapter 13. 
AIMA Chapter 14, Sections. 1-5. 
Monday: HMMs, localization &amp; mapping  
AIMA Chapter 15, Sections. 1-3. 
11/17/10  copyright Brian Williams, 2005-10  2 Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>3/6/00	
&#13;
4	
&#13;Due to the unknown mode, there tends to be  an exponential number of diagnoses. U	
&#13;Candidates with	
&#13;UNKNOWN failure 	
&#13;modes	
&#13;Good	
&#13;G	
&#13;Candidates with	
&#13;KNOWN failure 	
&#13;modes	
&#13;Good	
&#13;F1	
&#13;Fn	
&#13;G	
&#13;U	
&#13;U 
11/17/10  7 1. Introduce fault models.  More constraining, hence more easy to rule out.  Increases size of candidate space. 2. Enumerate most likely diagnoses Xi based on probability.         Prefix (k) ( Sort {Xi} by decreasing P(Xi | O) ) Most of the probability mass is covered by a few diagnoses. copyright Brian Williams, 2005-10  
11/17/10 copyright Brian Williams, 2005-10  8 Idea: Include known fault modes (S0 = stuck at 0, S1=stuck at 1,)  as well as Unknown. Diagnoses: (42 of 64 candidates) Fully Explained Failures: [A=G, B=G, C=S0] [A=G, B=S1, C=S0] [A=S0, B=G, C=G]           . . . Faults Isolated, No Explanation:  [A=G, B=G, C=U] [A=G, B=U, C=G] [A=U, B=G, C=G] Partially Explained: [A=G, B=U, C=S0] [A=U, B=S1, C=G] [A=S0, B=U, C=G]          . . . X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;in in out  0	
&#13;out</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>3/6/00	
&#13;
15	
&#13;Outline 
Motivation 
Set Theoretic View of Propositional Logic 
From Propositional Logic to Probabilities 
Probabilistic Inference 
General Queries and Inference Methods  
Bayes Net Inference 
Model-based Diagnosis   (Optional) 
11/17/10  copyright Brian Williams, 2005-10  29  
Types of Probabilistic Queries 
Let X = &lt;S; O&gt; 
Belief Assessment 
b(Si) = P( Si | o) 
Most Probable Explanation (MPE) 
s* = arg max P(s | o) for all s  DS 
Maximum Aposteriori Hypothesis (MAP) 
Given A  S 
   a* = arg max P(a | o) for all a  DA 
Maximum Expected Utility (MEU) 
Given decision variables D 
   d* = arg max x u(x)P(x | d ) for all d  DD 
11/17/10  copyright Brian Williams, 2005-10  30</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>3/6/00	
&#13;
11	
&#13;Outline Motivation Set Theoretic View of Propositional Logic From Propositional Logic to Probabilities Degrees of Belief Discrete Random Variables Probabilistic Inference 11/17/10  copyright Brian Williams, 2005-10  21  Why Do We Need Degrees of Belief? 
11/17/10  copyright Brian Williams, 2005-10  22  Given theory , sentence Q .  M(Q) M()  is never true.  M(Q) M()  must be true.  
entailment unsatisfiable satisfiable  could be true.   M(Q) M()  M(Q) M() Q = One of the valves to  Engine A is stuck closed. Q = All of the components in the propulsion system are broken in a way never seen before.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>3/6/00	
&#13;
12	
&#13;Degrees of Belief 
 P()=P(si)si
11/17/10  copyright Brian Williams, 2005-10  23  Probability P: Events  [0,1]  is a measure of the likelihood that an Event is true. Sample Space U  {si}:  like interpretations.  mutually exclusive,  collectively exhaustive,  finest grained events.  P defined over si  U. Events:  like propositions.    , Q,   Q      Q                                 Q   U
Like counting weighted models in logic. Axioms of Probability P: Events  Reals 1.For any event A, P(A)  0. 2.P(U) = 1. 3.If A  B = , then P(A  B) = P(A) + P(B). All conventional probability theory follows. 11/17/10  copyright Brian Williams, 2005-10  24</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3/6/00	
&#13;
3	
&#13;Outline 
Motivation 
Set Theoretic View of Propositional Logic 
From Propositional Logic to Probabilities 
Probabilistic Inference 
General Queries and Inference Methods  
Bayes Net Inference 
Model-based Diagnosis   (Optional) 
11/17/10  copyright Brian Williams, 2005-10  5 
Multiple Faults Occur 
three shorts, tank-line and 
pressure jacket burst, panel flies off. 
Lecture 16: Framed as CSP. 
How do we compare the space of 
alternative diagnoses? 
How do we explain the cause of 
failure? 
How do we prefer diagnoses that 
explain failure? 
11/17/10  copyright Brian Williams, 2005-10  6 
 	
&#13;
APOLLO 13 	
&#13;Image source: NASA.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>3/6/00	
&#13;
6	
&#13;Outline Motivation Set Theoretic View of Propositional Logic From Propositional Logic to Probabilities Probabilistic Inference 
11/17/10  copyright Brian Williams, 2005-10  11  Propositional Logic  Set Theoretic Semantics 
11/17/10  copyright Brian Williams, 2005-10  12  Universe of all interpretations (U)      M(S) models of S Given sentence S:</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>3/6/00	
&#13;
9	
&#13;Set Theoretic Semantics:  Q or R 
11/17/10  copyright Brian Williams, 2005-10  17                          M(R) M(Q)                         M(Q or R) M(Q or R)  M(Q)  M(R) U 
Set Theoretic Semantics:  Q implies R 
11/17/10  copyright Brian Williams, 2005-10  18  M(R) M(Q) Q implies R is True iff  Q entails R U 
M(Q implies R)  M(Q)  M(R)</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>3/6/00/nonmarkingreturn
14/nonmarkingreturnDegree of Belief 
11/17/10  copyright Brian Williams, 2005-10  27  Given theory , sentence Q .  
M(Q) M() is inconsistent.  
M(Q) 
M() must be true.   could be true.  
 M(Q) M()
P(Q | )= 01 P(Q, )
P()
Representing Sample Space  
Using Discrete Random Variables 
11/17/10  copyright Brian Williams, 2005-10  28  Discrete Random Variable X : 
 Domain DX = {x1, x2,  xn}
mutually exclusive, collectively exhaustive. 
 P(X):  DX [0, 1] 
P(xi) = 1 
Y {cloudy, 
         sunny} .197
.003Joint Distribution over X1,  Xn:
 Domain          DXi
 P(X1,  Xn):  DXi [0, 1] 
Notation :P ( x1,  xn) P(X1 = x1 ^ . ^ Xn = xn)Z {raining, dry} .20
.60</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>3/6/00	
&#13;
23	
&#13;Estimating States of Dynamic Systems  
(next week) 
Given sequence of commands and observations: 
Infer current distribution of (most likely) states. 
Infer most likely trajectories. 
11/17/10  copyright Brian Williams, 2005-10  45  S	
&#13; T</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>3/6/00	
&#13;
13	
&#13;Conditional Probability:  P(Q | ) 
11/17/10  copyright Brian Williams, 2005-10  25  P(sj | ) = P(sj) / P()  if sj         0   otherwise      =   P(sj, )                      P() Is Q true given ? What is P(Q given )?      Q                                 Q   U
Conditional Probability:  P(Q | ) 
11/17/10  copyright Brian Williams, 2005-10  26  Is Q true given ? What is P(Q given )?      Q                                 Q   U</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>3/6/00/nonmarkingreturn
17/nonmarkingreturnBayesian Network  
Input: Directed acyclic graph: 
 Nodes denote random variables. 
 Arcs tails denote parents P of child C. 
 Conditional probability P(C | P) for each node. 
Output : Answers to queries given earlier. 
11/17/10  copyright Brian Williams, 2005-10  33  Earthquake Burglary 
Alarm 
JohnCall Nap TV 
MaryCall  P(M | A, N) 
Conditional Independence  
for a Bayesian Network  
11/17/10  copyright Brian Williams, 2005-10  34  Earthquake Burglary 
Alarm 
JohnCall Nap TV 
MaryCall 
M B, E, T, J | N, A 
A variable is conditionally independent of
  its non-descendants , given its parents .Answer 
P(M | N, A , B, E, T, J) = P( M | N, A )</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Model-based reasoning I: propositional logic and satisfiability [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec10/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>32</slideno>
          <text>/.notdef.g0001/.notdef.g000233 Propositional Satisfiability using DPLL 
[Davis, Logmann, Loveland, 1962]
Initially :
/.notdef.g0002Unit propagate. 
Repeat :
1./.notdef.g0002Assign trueorfalse to an 
unassigned proposition. 
2./.notdef.g0002Unit propagate .
3./.notdef.g0002Backtrack as soon as a 
clause is violated. 
4./.notdef.g0002Satisfiable if assignment 
is complete. 
Brian Williams, Fall 10 65 Propagate:/.notdef.g0001
C = F/.notdef.g0001B = F/.notdef.g0001A/.notdef.g0001
F/.notdef.g0001Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C satisfied
satisfied
satisfied
Initially :
/.notdef.g0002Unit propagate. 
Repeat :
1./.notdef.g0002Assign trueorfalse to an 
unassigned proposition. 
2./.notdef.g0002Unit propagate. 
3./.notdef.g0002Backtrack as soon as a 
clause is violated. 
4./.notdef.g0002Satisfiable if assignment 
is complete. 
Brian Williams, Fall 10 66 Propagate:/.notdef.g0001
C = F/.notdef.g0001B = F/.notdef.g0001A/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001Propagate:/.notdef.g0001B = T/.notdef.g0001C = T/.notdef.g0001Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C satisfiedsatisfied
satisfiedPropositional Satisfiability using DPLL 
[Davis, Logmann, Loveland, 1962]</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>/.notdef.g0001/.notdef.g00024   Find a truth assignment that satisfies logical sentence T: 
/.notdef.g0002Reduce sentence T to clausal form. 
/.notdef.g0002Perform search similar to MAC = (BT+CP) 
[Davis, Logmann &amp; Loveland, 1962] 
Propositional satisfiability testing :
           1990:  100 variables / 200 clauses (constraints) 
           1998:  10,000 - 100,000 vars / 10^6 clauses 
2010:   millions 
    Novel applications :
           e.g. diagnosis, planning, software verification, circuit
testing, machine learning, and protein folding 
Brian Williams, Fall 10 7Propositional Satisfiability 
What Formal Languages Exist for 
Describing Constraints? 
/.notdef.g0002Algebra values of variables 
/.notdef.g0002Probability degree of belief 
/.notdef.g0002Propositional logic truth of facts 
/.notdef.g0002Temporal logic time, /.notdef.g0001.
/.notdef.g0002Modal logics knowledge, belief /.notdef.g0001
/.notdef.g0002First order logic facts,objects,relations
Brian Williams, Fall 10 8</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>/.notdef.g0001/.notdef.g000216 Example: Determining the Truth of 
a Sentence 
(True implies 
True)
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 31 
Example: Determining the Truth of a Sentence 
(notTrue or 
True)
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 32</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>/.notdef.g0001/.notdef.g000228 Unit Clause Resolution 
Idea:Apply arc consistency (AC-3) to binary clauses
Unit clause resolution (aka unit propagation rule) :
If all literals are false save L, then assign true to L: 
/.notdef.g0002(not A)    (not B)    (A or B or C)
                   C 
/.notdef.g0002Unit propagation = repeated application of rule. 
Brian Williams, Fall 10 55 ABClause : (not A or B)
T
FTF
Unit Propagation Examples 
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
/.notdef.g0002C4: A 
Brian Williams, Fall 10 56 C4/.notdef.g0001A/.notdef.g0001True/.notdef.g0001C1/.notdef.g0001B/.notdef.g0001True/.notdef.g0001C3/.notdef.g0001C/.notdef.g0001True/.notdef.g0001Satisfied
SatisfiedSatisfied
Satisfied
Support</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>/.notdef.g0001/.notdef.g000235 Outline
/.notdef.g0002Propositional Logic 
/.notdef.g0002Propositional Satisfiability 
/.notdef.g0002Backtrack Search 
/.notdef.g0002Unit Propagation 
/.notdef.g0002DPLL: Unit Propagation + Backtrack Search
/.notdef.g0002Empirical, Average Case Analysis 
/.notdef.g0002Appendices
Brian Williams, Fall 10 69 
Brian Williams, Fall 10 70 /g0/g1/g2/g3/g4/g5/g6/g6/g8/g9/g10/g8/g12/g13/g14/g15
/g0
/g0/g12 /g0/g0
/g0 /g1/g2/g3 /g9/g8/g9/g10/g8/g9/g10 /g1/g12/g6/g5/g6/g16/g2/g9/g16/g20/g1/g2/g3 /g1/g25/g10 /g5/g6/g0/g0/g0/g0/g0/g0/g0/g12/g0 /g0 /g0/g0/g1/g8/g9/g1/g10/g10/g6/g0/g0/g0/g0/g0/g0/g0/g0
/g0/g0/g8/g3/g1 /g2 /g8
/g0/g0/g8/g3/g1 /g2 /g8
/g0/g0/g8/g3/g1 /g2
Courtesy of Bart Selman. Used with permission.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>/.notdef.g0001/.notdef.g000226 Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 51 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001
T/.notdef.g0001 F/.notdef.g0001B/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001F/.notdef.g0001 T/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001satisfied
satisfied
violated
Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 52 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001
T/.notdef.g0001 F/.notdef.g0001B/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001F/.notdef.g0001 T/.notdef.g0001
C/.notdef.g0001
T/.notdef.g0001 F/.notdef.g0001 satisfiedsatisfiedsatisfied</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>/.notdef.g0001/.notdef.g000213 Example: Determining the Truth of 
a Sentence 
(True implies 
   [(False  if and only if False ) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 25 
Example: Determining the Truth of a Sentence 
(True implies 
   [(False  implies False ) and ( False  implies False )) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 26</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>/.notdef.g0001/.notdef.g000237 Intuition
/.notdef.g0002At low ratios: 
/.notdef.g0002few clauses (constraints) 
/.notdef.g0002many assignments 
/.notdef.g0002easily found 
/.notdef.g0002At high ratios: 
/.notdef.g0002many clauses 
/.notdef.g0002inconsistencies easily detected 
Brian Williams, Fall 10 73 
Phase Transitions for
Different Numbers of Variables 
Brian Williams, Fall 10 74 FFrraaccttiioonnooffFFoorrmmuullaaeeUUnnssaattiisseedd
22
UUNNSSAATT
PPhhaassee
SSAATT
PPhhaassee2200110000
224444005500
11
00
3300..2211..00
00..4400..6600..88
MM//NN44 55 66 77
Courtesy of Bart Selman. Used with permission.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>/.notdef.g0001/.notdef.g000245 Move Conjunctions Out: 
Engine Example 
(not (mode(E1) = ok) or 
((not (thrust(E1) = on) or(flow(V1) = on andflow(V2) = on)) and
    (not (flow(V1) = on) or not (flow(V2) = on) or thrust(E1) = on))) and 
(mode(E1) = ok or mode(E1) = unknown) and 
(not (mode(E1) = ok) or not (mode(E1) = unknown))
(not (mode(E1) = ok) or 
   (((not (thrust(E1) = on) orflow(V1) = on) and
      (not (thrust(E1) = on) orflow(V2) = on)) and
    (not (flow(V1) = on) or not (flow(V2) = on) or thrust(E1) = on))) and (mode(E1) = ok or mode(E1) = unknown) and 
(not (mode(E1) = ok) or not (mode(E1) = unknown))
Brian Williams, Fall 10 89 
Move Conjunctions Out: 
Engine Example 
(not (mode(E1) = ok) or
   (((not (thrust(E1) = on) or flow(V1) = on) and
      (not (thrust(E1) = on) or flow(V2) = on)) and
    (not (flow(V1) = on) or not (flow(V2) = on) or thrust(E1) = on))) and
(mode(E1) = ok or mode(E1) = unknown) and 
(not (mode(E1) = ok) or not (mode(E1) = unknown))
(not (mode(E1) = ok) ornot (thrust(E1) = on) or flow(V1) = on) and
(not (mode(E1) = ok) ornot (thrust(E1) = on) or flow(V2) = on)) and
(not (mode(E1) = ok) ornot (flow(V1) = on) or not (flow(V2) = on)
   or thrust(E1) = on) and
(mode(E1) = ok or mode(E1) = unknown) and 
(not (mode(E1) = ok) or not (mode(E1) = unknown))
Brian Williams, Fall 10 90</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>/.notdef.g0001/.notdef.g00021
Propositional Logic and 
Satisfiability
Brian C. Williams 
16.410-13
October 13th, 2010Slides draw upon
material from: 
Prof. Bart Selman 
Cornell University 
Assignments
/.notdef.g0002Assignment:
/.notdef.g0002Problem Set #5: Activity Planning,
due today Wednesday, October 13th, 2010. 
/.notdef.g0002Problem Set #6: Propositional Logic and Satisfiability, 
out today; due October 27th, 2010 (in 2 weeks). 
/.notdef.g0002Reading:
/.notdef.g0002Today: [AIMA] Ch. 7, 8 
/.notdef.g0002Monday: TBD
/.notdef.g0002Exam:
/.notdef.g0002Mid-Term - October 20th.
Brian Williams, Fall  10 2</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>/.notdef.g0001/.notdef.g000240 GSAT
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or Not A 
/.notdef.g0002C3: or B or Not C 
Brian Williams, Fall 10 79 C1 violated/.notdef.g0001 A/.notdef.g0001True/.notdef.g0001
B/.notdef.g0001False/.notdef.g0001
C/.notdef.g0001False/.notdef.g0001
Satised/.notdef.g0001False/.notdef.g0001
Satised/.notdef.g0001True/.notdef.g0001
C1,C2,C3 violated/.notdef.g0001True/.notdef.g00011./.notdef.g0002Init: Pick random assignment 
2./.notdef.g0002Check effect of flipping each 
assignment, counting violated 
clauses.
3./.notdef.g0002Pick assignment with fewest 
violations,
4./.notdef.g0002End if consistent, Else goto 2 
GSAT
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or Not A 
/.notdef.g0002C3: or B or Not C 
Brian Williams, Fall 10 80 Satised/.notdef.g0001 A/.notdef.g0001True/.notdef.g0001
B/.notdef.g0001True/.notdef.g0001
C/.notdef.g0001False/.notdef.g00011./.notdef.g0002Init: Pick random assignment 
2./.notdef.g0002Check effect of flipping each 
assignment, counting violated 
clauses.
3./.notdef.g0002Pick assignment with fewest 
violations,
4./.notdef.g0002End if consistent, Else goto 2 
Problem: Pure hill climbers get stuck in local minima.
Solution: Add random moves to get out of minima (WalkSAT)</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>/.notdef.g0001/.notdef.g000211 Example: Determining the Truth of 
a Sentence 
(True implies 
   [(False  if and only if ( True and False )) and 
    (True or False ) and 
    not ( True and False )])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 21 
Example: Determining the Truth of a Sentence 
(True implies 
   [(False  if and only if ( True and False )) and 
    (True or False ) and 
    not False ])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 22</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>/.notdef.g0001/.notdef.g00027Propositional Sentences: 
Engine Example 
(mode(E1) = ok or mode(E1) = unknown) and 
not (mode(E1) = ok and mode(E1) = unknown) and 
(mode(E1) = ok implies 
   (thrust(E1) = on if and only if
      flow(V1) = on and flow(V2) = on)) 
Brian Williams, Fall 10 13 E1V1 V2
Outline
/.notdef.g0002Propositional Logic 
/.notdef.g0002Syntax
/.notdef.g0002Semantics
/.notdef.g0002Reduction to Clauses
/.notdef.g0002Propositional Satisfiability 
/.notdef.g0002Empirical, Average Case Analysis 
/.notdef.g0002Appendices
Brian Williams, Fall 10 14</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>/.notdef.g0001/.notdef.g000210 Example: Determining the Truth of 
a Sentence 
(mode(E1) = ok implies 
   [(thrust(E1) = on if and only if (flow(V1) = on and flow(V2) = on)) and 
    (mode(E1) = ok or mode(E1) = unknown) and 
    not (mode(E1) = ok and mode(E1) = unknown)]) 
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 19 
Example: Determining the Truth of 
a Sentence 
(True implies 
   [(False  if and only if ( True and False )) and 
    (True or False ) and 
    not ( True and False )])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 20</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>/.notdef.g0001/.notdef.g000222 1./.notdef.g0002Apply systematic, complete procedure 
/.notdef.g0002BT + unit propagation, shortest clause heuristic 
/.notdef.g0002[Davis, Logmann, &amp; Loveland 1962; Crawford &amp; Auton 1997; 
Nayak &amp; Williams, 1997]
2./.notdef.g0002Apply stochastic, incomplete procedure 
/.notdef.g0002 [Minton et al. 90; Selman et. al 1993]  see Appendix 
3./.notdef.g0002Apply exhaustive clausal resolution
/.notdef.g0002 [Davis, Putnam 1960; Dechter Rish 1994] 
Brian Williams, Fall 10 43 Testing Satisfiability of &lt;P, /.notdef.g0001 &gt; 
1./.notdef.g0002Apply systematic, complete procedure 
/.notdef.g0002BT + unit propagation, shortest clause heuristic 
 [Davis, Logmann, &amp; Loveland 1962] 
/.notdef.g0002State-of-the-art implementations:
/.notdef.g0002ntab [Crawford &amp; Auton, 1997] 
/.notdef.g0002itms [Nayak &amp; Williams, 1997] 
/.notdef.g0002many others! See SATLIB 1998 / Hoos &amp; Stutzle
2./.notdef.g0002Apply stochastic, incomplete procedure (Appendix) 
/.notdef.g0002MinConflict [Minton et a. 90] 
/.notdef.g0002GSAT/WalkWat [Selman et. al 1993)] see Appendix 
3./.notdef.g0002Apply exhaustive clause resolution (Not Covered) 
/.notdef.g0002 [Davis, Putnam, 1960] 
Brian Williams, Fall 10 44 Testing Satisfiability of &lt;P, /.notdef.g0001 &gt;</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>/.notdef.g0001/.notdef.g000218 Satisfiable
A sentence is satisfiable if there is an interpretation
(a truth assignment) that makes the clause true. 
/.notdef.g0002(not A or B) is satisfiable. 
/.notdef.g0002(A implies not B) and (A implies B) is unsatisfiable. 
Valid
A sentence is valid if it is true for all interpretations. 
/.notdef.g0002Is   (not A or A or B)  valid?
Yes, it is valid over all possible interpretations. 
/.notdef.g0002Is  (A or B)  valid with respect to the interpretations
{A=true, B=false} and {A=false, B=false}?
Brian Williams, Fall 10 35 Satisfiability versus Validity 
Outline
/.notdef.g0002Propositional Logic 
/.notdef.g0002Syntax
/.notdef.g0002Semantics
/.notdef.g0002Reduction to Clauses
/.notdef.g0002Propositional Satisfiability 
/.notdef.g0002Appendices
Brian Williams, Fall 10 36</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>/.notdef.g0001/.notdef.g000227 Clausal Backtrack Search: 
Recursive Formulation 
Procedure:  BT(/.notdef.g0002, A)
Input : A cnf theory /.notdef.g0002,
       An assignment Ato some propositions in /.notdef.g0002.
Output : true if /.notdef.g0002is satisfiable; false otherwise. 
If a clause in /.notdef.g0002isviolated , Return false ;
Else If all propositions in /.notdef.g0002areassigned by A, Return true;
Else Q=some proposition in /.notdef.g0002 unassigned  by A;
Return (BT( /.notdef.g0002,A[Q=True]) or
  BT( /.notdef.g0002,A[Q=False ]))
Brian Williams, Fall 10 53 
Outline
/.notdef.g0002Propositional Logic 
/.notdef.g0002Propositional Satisfiability 
/.notdef.g0002Backtrack Search 
/.notdef.g0002Unit Propagation 
/.notdef.g0002DPLL: Unit Propagation + Backtrack Search
/.notdef.g0002Empirical, Average Case Analysis 
/.notdef.g0002Appendices
Brian Williams, Fall 10 54</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>/.notdef.g0001/.notdef.g000223 Outline
/.notdef.g0002Propositional Logic 
/.notdef.g0002Propositional Satisfiability 
/.notdef.g0002Backtrack Search 
/.notdef.g0002Unit Propagation 
/.notdef.g0002DPLL: Unit Propagation + Backtrack Search
/.notdef.g0002Empirical, Average Case Analysis 
/.notdef.g0002Appendices
Brian Williams, Fall 10 45 
Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 46 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001satisfied
satisfied
satisfied</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>/.notdef.g0001/.notdef.g000236 Brian Williams, Fall 10 71 /g0/g1/g2/g3/g4/g5/g6/g3/g8/g9/g10/g11/g12
/g0/g1/g0
/g0/g0/g0/g0
/g0/g1 /g2/g3/g4/g5/g4 /g7/g5/g9/g10/g1 /g12/g13/g14/g13 /g16/g2/g4/g16/g20/g1/g22/g3/g1/g25/g10/g14/g13/g0/g0/g0/g0/g1/g0/g0/g1/g0/g0/g22/g4/g25/g1/g25/g3/g10/g3/g2/g10
/g0 /g0/g5/g9/g1 /g10/g10/g13
/g0/g1/g0/g0/g0/g5/g3 /g1 /g22/g5
/g0/g0/g5/g3 /g1 /g22/g5
/g0/g0/g5/g3 /g1 /g22
/g0/g0/g2 /g5/g13/g1 /g2
/g0 /g3/g2/g3 /g4/g14/g10/g10/g8/g5/g10 /g14/g10/g13 /g1 /g15/g8/g5/g1 /g15 /g20/g5/g22/g14/g3 /g14/g13 /g27/g12/g14/g5/g31/g32/g32/g31/g0/g1/g0/g31/g1/g0/g0/g31/g0/g0/g0/g0/g0/g0/g0
/g0/g0/g0/g0/g0/g0/g0/g0
Courtesy of Bart Selman. Used with permission. 
Brian Williams, Fall 10 72 7 8 9 106 5 4 3 2 1
Ratio of constraints to variables (Alpha)LessMoreComputational effort
Solvable Impossible
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>/.notdef.g0001/.notdef.g00022Hidden Failures Require Reasoning 
from a Model:STS-93
Brian Williams, Fall 10 3
/.notdef.g0001/.notdef.g0002Symptoms:/.notdef.g0001
/.notdef.g0002Engine temp sensor high/.notdef.g0001
/.notdef.g0002LOX level low/.notdef.g0001
/.notdef.g0002GN&amp;C detects low thrust/.notdef.g0001
/.notdef.g0002H2 level possibly low /.notdef.g0001
/.notdef.g0001/.notdef.g0002Problem :Liquid hydrogen leak/.notdef.g0001
/.notdef.g0001/.notdef.g0002Effect: /.notdef.g0001
/.notdef.g0002LH2 used to cool engine/.notdef.g0001
/.notdef.g0002Engine runs hot/.notdef.g0001
/.notdef.g0002Consumes more LOX /.notdef.g0001
How Do We Reason About Complex 
Systems using Commonsense Models? 
Brian Williams, Fall 10 4Helium tank/.notdef.g0001
Fuel tank/.notdef.g0001 Oxidizer tank/.notdef.g0001
Main/.notdef.g0001
Engines/.notdef.g0001Flow1 = zero/.notdef.g0001Pressure2= nominal/.notdef.g0001
Acceleration = zero/.notdef.g0001Model-based Reasoning: 
/.notdef.g0002 Reason from a single
   model to operate,
   diagnose, repair/.notdef.g0001
/.notdef.g0002Model using Logic .
/.notdef.g0002Reason using Sat.Task: Monitor engine operation 
/.notdef.g0002 You open the valves, and 
   observe . . . 
/.notdef.g0002 Is the engine ok? 
/.notdef.g0002 Could the valve in red be 
   stuck closed? 
Pressure1 = nominal/.notdef.g0001Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>/.notdef.g0001/.notdef.g000238 Brian Williams, Fall 10 75 
Phase Transitions: 2, 3 4, 5 and 6-SAT 
Required Appendices 
You are responsible for reading and 
knowing this material: 
1./.notdef.g0002Local Search using
Min_Conflict and GSAT 
2./.notdef.g0002Reduction to Clausal Form Courtesy of Bart Selman. Used with permission.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>/.notdef.g0001/.notdef.g000241 
Required Appendices 
You are responsible for reading and 
knowing this material: 
1./.notdef.g0002 Local Search using
Min_Conflict and GSAT 
2./.notdef.g0002Reduction to Clausal Form 
Reduction to Clausal Form: 
Engine Example 
(mode(E1) = ok implies 
   (thrust(E1) = on iff flow(V1) = on and flow(V2) = on)) and 
(mode(E1) = ok or mode(E1) = unknown) and 
not (mode(E1) = ok and mode(E1) = unknown)
Brian Williams, Fall 10 82 not (mode(E1) = ok) or not (thrust(E1) = on) or flow(V1) = on; 
not (mode(E1) = ok) or not (thrust(E1) = on) or flow(V2) = on; 
not (mode(E1) = ok) or not (flow(V1) = on) or not (flow(V2) = on) or 
    thrust(E1) = on; mode(E1) = ok or mode(E1) = unknown; not (mode(E1) = ok) or not (mode(E1) = unknown);</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>/.notdef.g0001/.notdef.g000242 Reducing Propositional Formula 
to Clauses (CNF) 
1) Eliminate IFF and Implies :
/.notdef.g0002E1 iff E2 =&gt;  (E1 implies E2) and (E2 implies E1) 
/.notdef.g0002E1 implies E2  =&gt;  not E1 or E2 
Brian Williams, Fall 10 83 
Eliminate IFF: Engine Example 
(mode(E1) = ok implies 
(thrust(E1) = on iff(flow(V1) = on and flow(V2) = on))) and
(mode(E1) = ok or mode(E1) = unknown) and 
not (mode(E1) = ok and mode(E1) = unknown)
(mode(E1) = ok implies 
((thrust(E1) = on implies (flow(V1) = on and flow(V2) = on)) and
    ((flow(V1) = on and flow(V2) = on) implies thrust(E1) = on)))  and 
(mode(E1) = ok or mode(E1) = unknown) and 
not (mode(E1) = ok and mode(E1) = unknown)
Brian Williams, Fall 10 84</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>/.notdef.g0001/.notdef.g000215 Example: Determining the Truth of 
a Sentence 
(True implies 
   [(True and True) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 29 
Example: Determining the Truth of a Sentence 
(True implies 
   [True and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 30</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>/.notdef.g0001/.notdef.g000244 Move Negations In: 
Engine Example 
(not (mode(E1) = ok) or 
   ((not (thrust(E1) = on) or (flow(V1) = on and flow(V2) = on)) and
    (not(flow(V1) = on and flow(V2) = on) ) or thrust(E1) = on))) and 
(mode(E1) = ok or mode(E1) = unknown) and 
not(mode(E1) = ok and mode(E1) = unknown)
(not (mode(E1) = ok) or 
   ((not (thrust(E1) = on) or (flow(V1) = on and flow(V2) = on)) and
(not(flow(V1) = on) or not(flow(V2) = on) ) or thrust(E1) = on) ) and 
(mode(E1) = ok or mode(E1) = unknown) and 
(not (mode(E1) = ok) or not(mode(E1) = unknown) ))
Brian Williams, Fall 10 87 
Reducing Propositional Formula 
to Clauses (CNF) 
3) Move conjunctions out  using distributivity:
/.notdef.g0002E1or(E2andE3)   =&gt;   (E1 orE2)and(E1orE3)
Brian Williams, Fall 10 88</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>/.notdef.g0001/.notdef.g000221 Propositional Satisfiability 
Input : A Propositional Satisfiability Problem is
a pair &lt;P, /.notdef.g0002 &gt;, where:
/.notdef.g0002Pis a finite set of propositions.
/.notdef.g0002/.notdef.g0002 is a propositional sentence over P 
/.notdef.g0002We assume it is reduced to a set of clauses.
Output : True iff there exists a model of/.notdef.g0002.
Brian Williams, Fall 10 41 Is an instance of a CSP: 
/.notdef.g0002Variables : Propositions
/.notdef.g0002Domain : {True, False} 
/.notdef.g0002Constraints : Clauses
Models of &lt;P, /.notdef.g0001 &gt; 
/.notdef.g0002Aninterpretation  is a truth assignment to all propositions P.
/.notdef.g0002Amodel  is an interpretation such that all clauses are 
satisfied:
/.notdef.g0002A clause is satisfied  iff at least one literal is true. 
/.notdef.g0002A clause is violated  iff all literals are false. 
Example: C1: Not A or B 
C2: Not C or A 
C3: Not B or C
Brian Williams, Fall 10 42</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>/.notdef.g0001/.notdef.g000225 Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 49 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001
T/.notdef.g0001 F/.notdef.g0001satisfied
satisfiedviolated
Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 50 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001
T/.notdef.g0001 F/.notdef.g0001B/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001F/.notdef.g0001
satisfiedsatisfiedviolated</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>/.notdef.g0001/.notdef.g000224 Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 47 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001satisfied
violated
satisfied
Propositional Satisfiability using 
Backtrack Search 
/.notdef.g0002Assign true or false to an 
unassigned proposition. 
/.notdef.g0002Backtrack as soon as a 
clause is violated. 
Example :
/.notdef.g0002C1: Not A or B 
/.notdef.g0002C2: Not C or A 
/.notdef.g0002C3: Not B or C 
Brian Williams, Fall 10 48 A/.notdef.g0001
F/.notdef.g0001
F/.notdef.g0001B/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001 T/.notdef.g0001T/.notdef.g0001
C/.notdef.g0001
F/.notdef.g0001satisfied
satisfied
violated</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>/.notdef.g0001/.notdef.g000212 Example: Determining the Truth of 
a Sentence 
(True implies 
   [(False  if and only if ( True and False )) and 
    (True or False ) and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 23 
Example: Determining the Truth of a Sentence 
(True implies 
   [(False  if and only if False ) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 24</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>/.notdef.g0001/.notdef.g000214 Example: Determining the Truth of 
a Sentence 
(True implies 
   [(not False  or False ) and (not False  or False )) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 27 
Example: Determining the Truth of a Sentence 
(True implies 
   [(True or False ) and ( True or False )) and 
True and 
True])
Interpretation:
mode(E1) = ok is True
thrust(E1) = on is False
flow(V1) = on is True
 flow(V2) = on is False
mode(E1) = unknown is False
Brian Williams, Fall 10 28</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Global path planning II: sampling-based algorithms for motion planning [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec15/</lecture_pdf_url>
      <lectureno>15</lectureno>
      <slides>
        <slide>
          <slideno>32</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Complexity
How can we measure complexity for an algorithm that does not necessarily
terminate?
Treat the number of samples as \the size of the input." (Everything else
stays the same)
Also, complexity per sample: how much work (time/memory) is needed to
process one sample.
Useful for comparison of sampling-based algorithms.
Cannot compare with deterministic, complete algorithms.
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 10 / 30</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Sampling-based algorithms
A recently proposed class of motion planning algorithms that has been very
successful in practice is based on (batch or incremental) sampling methods:
solutions are computed based on samples drawn from some distribution.
Sampling algorithms retain some form of completeness, e.g., probabilistic or
resolution completeness.
Incremental sampling methods are particularly attractive:
Incremental-sampling algorithms lend themselves easily to real-time, on-line
implementation.
Applicable to very general dynamical systems.
Do not require the explicit enumeration of constraints.
Adaptively multi-resolution methods
(i.e., make your own grid as you go along, up to the necessary resolution).
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 5 / 30</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>The Motion Planning problem
Get from point A to point B avoiding obstacles
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 2 / 30</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 15: Sampling-Based Algorithms for Motion Planning
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 3, 2010
Reading: LaValle, Ch. 5
S. Karaman and E. Frazzoli, 2011
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 1 / 30</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Rapidly-exploring Random Trees (RRTs)
E. Frazzoli (MIT)L15: Sampling-Based Motion PlanningNovember 3, 2010 15 / 30</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Dynamic programming and machine learning II: Markov decision processes, policy iteration [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec23/</lecture_pdf_url>
      <lectureno>23</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
Lecture notes
[AIMA] Ch. 17.1-3.
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 2 / 22</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Policy Iteration example 4/5
Back to the 10x10 grid:
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 15 / 22</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Policy Iteration example 3/5
Back to the 10x10 grid:
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 14 / 22</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Policy Iteration example 2/5
Back to the 10x10 grid:
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 13 / 22</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Policy Iteration example 1/5
Back to the 10x10 grid:
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 12 / 22</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 23: Markov Decision Processes
Policy Iteration
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
December 1, 2010
Frazzoli (MIT)Lecture 23: MDPsDecember 1, 2010 1 / 22</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Inferring state in an uncertain world II: hidden Markov models, the Baum-Welch algorithm [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec21/</lecture_pdf_url>
      <lectureno>21</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 21: Intro to Hidden Markov Models
the Baum-Welch algorithm
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 24, 2010
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 1 / 23</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
Lecture notes
[AIMA] Ch. 15.1-3, 20.3.
Paper on Stellar: L. Rabiner, \A tutorial on Hidden Markov Models..."
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 2 / 23</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Example: Finding Keyser S oze 1
Let us consider the following problem.
The elusive leader of a dangerous criminal organization (e.g., Keyser S oze,
from the movie \The Usual Suspects" ) is known to travel between two cities
(say, Los Angeles and New York City)
The FBI has no clue about his whereabouts at the initial time (e.g., uniform
probability being at any one of the cities).
The FBI has no clue about the probability that he would stay or move to the
other city at each time period:
fromnto
LA
NY
LA
0.5
0.5
NY
0.5
0.5
At each time period the FBI could get sighting reports (or evidence of his
presence in a city), including a non-sighting null report. An estimate of the
probability of getting such reports is
wherenreport
LA
NY
null
LA
0.4
0.1
0.5
NY
0.1
0.5
0.4
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 15 / 23</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Outline
1
Decoding and Viterbi's algorithm
2
Learning and the Baum-Welch algorithm
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 13 / 23</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Outline
1
Decoding and Viterbi's algorithm
2
Learning and the Baum-Welch algorithm
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 3 / 23</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Example: Finding Keyser S oze 3
Using smoothing:
t
LA
NY
1
0.5556
0.4444
2
0.8000
0.2000
3
0.8000
0.2000
. . .
. . .
. . .
18
0.8000
0.2000
19
0.8000
0.2000
20
0.1667
0.8333
The sequence of point-wise most likely states is:
(LA;LA;LA;LA;NY;LA;NY;NY;NY;LA;
NY;NY;NY;NY;NY;LA;LA;LA)
The new question is: given all the data, can we improve on our model,
in such a way that the observations are more consistent with it?
E. Frazzoli (MIT)Lecture 21: HMMsNovember 24, 2010 17 / 23</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Model-based reasoning III: OpSat and conflict-directed A* [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec13/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>43</slideno>
          <text>10/27/10 
44 Outline Using conflicts in backtrack search Dependency-directed backtracking Conflict learning Conflict-directed backjumping 
11/02/09 copyright Brian Williams, 2000-10 87 Using Conflicts to Guide Search: Dependency-directed Search [Stallman &amp; Sussman, 1978] Input:   Constraint satisfaction problem. Output:   Satisfying assignment. Repeat while a next candidate assignment exists. Generate candidate assignment c. Check candidate c against conflicts. If c is a superset of a conflict, Then loop to the next candidate. Check consistency of c. If inconsistent,  Then extract and record a conflict from c. Else return c as a solution.   Like a Graphplan memo, but generalizes an inconsistent solution. 11/02/09 copyright Brian Williams, 2000-10 88</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>10/27/10 
12 10/27/10 23 A* Search Function A*(problem, h)   returns the best solution or failure. Problem pre-initialized.   f(x)  g[problem](x) + h(x)   loop do     if Nodes[problem] is empty  then return failure     node  Remove-Best(Nodes[problem], f)     new-nodes   Expand(node, problem)     for each new-node in new-nodes          then Nodes[problem]  Enqueue(Nodes[problem], new-node, f )     if Goal-Test[problem] applied to State(node) succeeds        then return node end Terminate when . . . 
Brian Williams, Fall  05 24 S D A 2 4 Expand Vertices More Than Once  0 path length S A D 2 1 4 G The shortest path from S to G   is (G D A S). 1 edge cost 
D is reached first using  path (D S). Suppose we expanded only the  first path that visits each vertex X?</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>10/27/10 
36 Outline  Model-based Diagnosis Optimal CSPs Conflict-directed A* Generating the Best Kernel Performance Comparison 
10/27/10 72 Problem  Parameters Constraint-based A* (no conflicts) Conflict-directed A* Mean CD-CB Ratio Dom Size Dec Vars Clau-ses Clau -se  lngth Nodes Expanded Queue Size Nodes Expand Queue Size Conflicts used Nodes Expanded Queue  Size 5 10 10 5 683 1,230 3.3 6.3 1.2   4.5%   5.6% 5 10 30 5 2,360 3,490 8.1 17.9 3.2   2.4%   3.5% 5 10 50 5 4,270 6,260 12.0 41.3 2.6   0.83%   1.1% 10 10 10 6 3,790 13,400 5.7 16.0 1.6   2.0%   1.0% 10 10 30 6 1,430 5,130 9.7 94.4 4.2   4.6%   5.8% 10 10 50 6 929 4,060 6.0 27.3 2.3   3.5%   3.9% 5 20 10 5 109 149 4.2 7.2 1.6 13.0% 13.0% 5 20 30 5 333 434 6.4 9.2 2.2   6.0%   5.4% 5 20 50 5 149 197 5.4 7.2 2.0 12.0% 11.0% Performance: With and Without Conflicts</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>10/27/10 
4 New Hypothesis Exposes Additional Conflicts 
Pressure1 = nominal	
&#13;Pressure2= nominal	
&#13;Acceleration = zero	
&#13;Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Another conict, try removing both.	
&#13;Final Hypothesis Resolves all Conflicts  Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Pressure1 = nominal	
&#13;Flow1 = zero	
&#13;Pressure2= nominal	
&#13;Flow2 = positive	
&#13;Acceleration = zero	
&#13;Implementation: Conict-directed A* search.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>10/27/10 
42 10/27/10 83 Child Expansion For Finding Multiple Solutions 
If Unresolved Conflicts: If All Conflicts Resolved: A2=U	
&#13;A1=U	
&#13;X1=U	
&#13;X2=G	
&#13;X2=U	
&#13; (A2=G  A1=G  X1=G)	
&#13;Conflict     { } 
Select unresolved conflict. Each child adds a constituent kernel. Select unassigned variable yi. Each child adds an assignment from Di. 
10/27/10 84 A1=U Intelligent Expansion  Below a Kernel 
Order assignments by  decreasing utility. A2=G  A2=U	
&#13;Select Unassigned Variable. Expand best child. Continue expanding best descendents. When leaf visited,, expand all next best ancestors.  (why?) A2=G	
&#13;A3=G	
&#13;X1=G	
&#13;X2=G	
&#13;A2=U	
&#13;A3=U	
&#13;X1=U	
&#13;X2=U	
&#13;{}</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>10/27/10 
1 
 Optimal Satisfiability and  
Conflict-directed A* 
Brian C. Williams 
16.410 / 16.413 
October 27th, 2010 
Brian C. Williams, copyright 2000 
Assignment 
Remember: 
Problem Set #6 Propositional Logic, due Today. 
16:413 Project Part 1: Sat-based Activity Planner,  
due Wednesday, November 3rd. 
Problem Set #7 Diagnosis, Conflict-directed A* and RRTs ,  
due Wednesday, November 10th. 
Reading 
 Today: Brian C. Williams, and Robert Ragno , "Conflict-directed A* and its 
Role in Model-based Embedded Systems," Special Issue on Theory and 
Applications of Satisfiability  Testing, Journal of Discrete Applied Math , 
January 2003.  
11/02/09 copyright Brian Williams, 2000-10 2 Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>10/27/10 
17 Brian Williams, Fall  05 33 Branch and Bound  
0 C S B G A D 2 5 4 2 3 2 5 1 2 1 0 1 3 Heuristic Values of g in Red Edge cost in Green  Maintain the best solution found thus far (incumbent).  Prune all subtrees worse than the incumbent.  Any search order allowed (DFS, Reverse-DFS, BFS, Hill w BT).  S B C D D G G C G C A 0 4 5 8 7 10 8 10 10 7 Incumbent:  cost U =  path P = , (), 10, (S B G) 8 (S A D G) 10 
Brian Williams, Fall  05 34 Simple Optimal Search  Using Branch and Bound 1.Initialize Q with partial path (S); Incumbent U = , P = (); 2.If Q is empty, return Incumbent U and P, Else, remove a partial path N from Q; 3.If f(N) &gt;= U, Go to Step 2. 4.If head(N) = G, then U = f(N) and P = N  (a better path to the goal) 5.(Else) Find all children of head(N) (its neighbors in &lt;V,E&gt;) and  create one-step extensions from N to each child. 6.Add extended paths to Q. 7.Go to Step 2. Let &lt;V,E&gt; be a Graph   Let Q be a list of simple partial paths in &lt;V,E&gt; Let S be the start vertex in &lt;V,E&gt; and Let G be a Goal vertex in &lt;V,E&gt;. Let f = g + h  be an admissible heuristic function. U and P are the cost and path of the best solution thus far (Incumbent).</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10/27/10 
10 Brian Williams, Fall  05 19 start goal  A* biases uniform cost towards the goal by using h.  f = g + h  g = distance from start.  h = estimated distance           to goal. A B x xBest-first Search with Uniform Cost spreads evenly from the start. 
A* finds an optimal solution  if h never over estimates. Then h is called admissible Greedy goes for the goal, but forgets its past. 
Brian Williams, Fall  05 20 A*  
0 C S B G A D 2 5 4 2 3 2 5 1 2 1 0 1 3 Heuristic Value h in Red Edge cost in Green  Best-first Search with Q ordered by admissible f = g + h. S B C D D G G C G C A 0 4 5 8 7 10 8 10 10 7 10</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>10/27/10 
3 Isolate Conflicting Information Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Flow 1= zero	
&#13;The red component modes conict with the model and observations.	
&#13;
Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Flow 1= zero	
&#13;Leap to the Next Most Likely Hypothesis that Resolves the Conflict 
The next hypothesis must remove the conict.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>10/27/10 
15 Brian Williams, Fall  05 29 8 9 uv15 7 xy20 10 5792346sShortest Paths can be  Grown From Shortest Paths  The length of shortest path s p u  v    is (s,v) = (s,u) + w(u,v) such that      &lt;u,v&gt;  E   (s,v)  (s,u) + w(u,v). Dynamic Programming Principle: "

Given the shortest path to 
U
, dont extend other paths to 
U
;  
delete them (expanded list). "

When A* 
dequeues 
the 
first partial path 
with head node 
U
,  
this path is guaranteed to be the shortest path from S to U. 
10/27/10 30 A* Search Function A*(problem, h)   returns the best solution or failure. Problem pre-initialized.   f(x)  g[problem](x) + h(x)   loop do     if Nodes[problem] is empty  then return failure     node  Remove-Best(Nodes[problem], f)     state  State(node)     remove any n from Nodes[problem] such that State(n) = state     Expanded[problem]  Expanded[problem]  {state}      new-nodes   Expand(node, problem)     for each new-node in new-nodes        unless State(new-node) is in Expanded[problem]         then Nodes[problem]  Enqueue(Nodes[problem], new-node, f )     if Goal-Test[problem] applied to State(node) succeeds        then return node end Dynamic Programming Principle  . . .</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>10/27/10 
31 10/27/10 61 Test: A1=U  A2=U  A3=G  X1=G  X2=G A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A2 
A3 
X1 
X2 
10/27/10 62 Test: A1=U  A2=U  A3=G  X1=G  X2=G 0	
&#13;0	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;1	
&#13;1	
&#13;
A3 
X1 
X2 Consistent! 
A2</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>10/27/10 
27 10/27/10 53 {  } A1=?  A2=?  A3=?  X1=?  X2=?            A1=G  A2=G  A3=G  X1=G  2=G Select best value for unassigned variables Extracting the kernels best state  
10/27/10 54 Conflicts / Constituent Kernels none Best Kernel:  {} Best Candidate: A1=G  A2=G  A3=G  X1=G  X2=G  ? First Iteration A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A2 
A3 
X1 
X2</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>10/27/10 
26 10/27/10 51 Assume Independent Failures: PG(mi) &gt;&gt; PU(mi) Psingle &gt;&gt; Pdouble PU(A2) &gt; PU(A1) &gt; PU(A3) &gt; PU(X1) &gt; PU(X2) Example: Diagnosis A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A2 
A3 
X1 
X2 
10/27/10 52 Conflicts / Constituent Kernels none Best Kernel:  {} Best Candidate:  ? First Iteration A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A2 
A3 
X1 
X2</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>10/27/10 
34 10/27/10 67 Admissible h(): Cost of best state that extends partial assignment                 A1=?  A3=?  X1=?  X2=?                x PA1=G x PA3=G x PX1=G x PX2=G  Select best value of unassigned variables. f =  g   +   h PA2=u A2=U 
10/27/10 68 Admissible Heuristic h Let g = &lt;G,gi,Y&gt; describe a multi-attribute utility fn Assume the preference for one attribute xi is independent of another xk Called Mutual Preferential Independence: For all u, v Y If gi(u)  gi(v) then for all w G(gi(u),gk(w))  G(gi(v),gk(w)) An Admissible h: Given a partial assignment, to X  Y h selects the best value of each unassigned variable Z = X  Y          h(Y) = G({gzi_max| ziZ, max    gzi(vij))})                                                             vijDzi A candidate always exists satisfying h(Y).</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>10/27/10 
22 10/27/10 43 Increasing Cost Infeasible 
Conflict 3 Conflict 2 Conflict 1 Conflict-directed A*  
Feasible 
10/27/10 44 Solving Optimal CSPs Through Generate and Test Generate	
&#13;Candidate	
&#13;Test	
&#13;Candidate	
&#13;Consistent?	
&#13;Keep	
&#13;(Optional) Update	
&#13;Cost	
&#13;Below	
&#13;Threshold?	
&#13;Extract	
&#13;Conict	
&#13;Done	
&#13;Yes	
&#13;No	
&#13;Yes	
&#13;No	
&#13;Leading Candidates	
&#13;Based on Cost	
&#13;Conflict-directed A* Constraint Solver</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>10/27/10 
7 10/27/10 13 Multi Attribute Utility Functions g(Y) = G(g1(y1), g2(y2), . . .) where  G(u1, u2  un) = G(u1,G(u2  un))  G(u1) = G(u1, IG) Example: Diagnosis  gi(yi=modeij) = P(yi = modeij)  G(u1,u2) = u1 x u2  IG = 1 
10/27/10 14 Mutual Preferential Independence (MPI) Assignment 1 is preferred over 2  if g(1) &lt; g(2).  For any set of decision variables W  Y,  our preference between two assignments to W is independent of the assignment to the remaining variables W  Y.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>10/27/10 
35 10/27/10 69 Terminate when all conflicts resolved Function Goal-Test-Kernel (node, problem)   returns True IFF node is a complete decision state.   if forall K in Constituent-Kernels(Conflicts[problem]),        State[node] contains a kernel in K     then return True  else return False 
10/27/10 70 Next Best Kernel of Known Conflicts Function Next-Best-Kernel (OCSP)   returns the next best cost kernel of Conflicts[OCSP].   f(x)  G[OCSP] (g[OCSP](x), h[OCSP](x))   loop do     if Nodes[OCSP] is empty  then return failure     node  Remove-Best(Nodes[OCSP], f)     add State[node] to Visited[OCSP]     new-nodes   Expand-Conflict(node, OCSP)     for each new-node  new-nodes        unless  n  Nodes[OCSP] such that State[new-node] = State[n]                   OR State[new-node]  Visited[problem]         then Nodes[OCSP]  Enqueue(Nodes[OCSP], new-node, f )     if Goal-Test-Kernel[OCSP] applied to State[node] succeeds        Best-Kernels[OCSP]             Add-To-Minimal-Sets(Best-Kernels[OCSP], best-kernel)        if best-kernel  Best-Kernels[OCSP]          then return State[node] end An instance of A*</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>10/27/10 
8 10/27/10 15 MPI Example: Diagnosis If A1 = G is more likely than A1 = U, then         {A1 = G, A2 = G, A3 = U, X1 = G, X2 = G}  is preferred to         {A1 = U, A2 = G, A3 = U, X1 = G, X2 = G}. Outline  Model-based Diagnosis Optimal CSPs Informed Search  A*  Branch and Bound Conflict-directed A*</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>10/27/10 
5 Outline Model-based Diagnosis Optimal CSPs Informed Search Conflict-directed A*  
10/27/10 10 Constraint Satisfaction Problem CSP = &lt;X, DX,C&gt; variables X with domain DX. Constraint C(X): DX  {True, False}. Problem: Find X in DX s.t. C(X) is True. R,G,B  G R, G Different-color constraint V1 V2 V3</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>10/27/10 
6 10/27/10 11 Optimal CSP OCSP= &lt;Y, g, CSP&gt; Decision variables Y with domain DY. Utility function g(Y): DY  . CSP over variables &lt;X;Y&gt;. Find leading arg max g(Y)                         Y  Dy  s.t.  X  DX s.t. C(X,Y) is True.  g: multi-attribute utility with preferential independence,       value constraint,   CSP: propositional state logic, simple temporal problem,            mixed logic-linear program,  
10/27/10 12 CSPs Are Frequently Encoded in Propositional State Logic (mode(E1) = ok implies    (thrust(E1) = on if and only if flow(V1) = on and flow(V2) = on)) and    (mode(E1) = ok or mode(E1) = unknown) and    not (mode(E1) = ok and mode(E1) = unknown) E1 V1 V2</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>10/27/10 
40 10/27/10 79 Expand Node to Resolve Conflict function Expand-Conflict(node, OCSP)   return Expand-Conflict-Best-Child(node, OCSP)                   Expand-Next-Best-Sibling (node, OCSP) function Expand-Conflict-Best-Child(node, OCSP)   if for all K in Constituent-Kernels([OCSP])       State[node] contains a kernel  K   then return {}   else return Expand-Constituent-Kernel(node,OCSP)  function Expand-Constituent-Kernel(node, OCSP)    K   = smallest uncovered set  Constituent-Kernels([OCSP])    C    {yi = vij | {yi = vij} in K, yi = vij is consistent with State[node]}    Sort C such that for all i  from 1 to |C| - 1,       Better-Kernel?(C[i],C[i+1], OCSP) is True    Child-Assignments[node]   C    yi = vij   C[1], which is the best kernel in K consistent with State[node]    return {Make-Node({yi = vij}, node)} 
10/27/10 80 Expand Node to Resolve Conflict function Expand-Next-Best-Sibling(node, OCSP)    if Root?[node]       then return {}       else {yi = vij}  Assignment[node]               {yk = vkl}  next best assignment in consistent                               child-assignments[Parent[node]] after {yi = vij}          if no next assignment {yk = vkl}             or Parent[node] already has a child with {yk = vkl}             then return {}             else return {Make-Node({yk = vkl}, Parent[node])}</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>10/27/10 
14 Brian Williams, Fall  05 27 S D D A 2 5 3 Expand Vertices More Than Once  0 path length S A D 2 1 4 G The shortest path from S to G   is (G D A S). 1 edge cost 
D is reached first using  path (D S). This prevents path (D A S) from being expanded. Suppose we expanded only the  first path that visits each vertex X? 10 G 
The suboptimal path (G D S)  is returned. Eliminate the Visited List. Return solution when taken off queue. 
Brian Williams, Fall  05 28 8 9 u v 1 5 7 x y 2 0 10 5 7 9 2 3 4 6 s Shortest Paths Contain  Only Shortest Paths 
 Subpaths of shortest paths are shortest paths.  s p v = &lt;s, x, u, v&gt; Shortest, then .  s p u = &lt;s, x, u&gt; Shortest  s p x = &lt;s, x&gt;  Shortest  x p v = &lt;x, u, v&gt; Shortest  x p v = &lt;x, u&gt;  Shortest  u p v = &lt;u, v&gt;  Shortest</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>10/27/10 
19 10/27/10 37 Increasing Cost Feasible Infeasible Conflict-directed A*  
10/27/10 38 Increasing Cost Feasible Infeasible Conflict 1 Conflict-directed A*</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>10/27/10 
13 Brian Williams, Fall  05 25 S D A 2 5 D 3 Expand Vertices More Than Once  0 path length S A D 2 1 4 G The shortest path from S to G   is (G D A S). 1 edge cost 
D is reached first using  path (D S). This prevents path (D A S) from being expanded. Suppose we expanded only the  first path that visits each vertex X? 
Brian Williams, Fall  05 26 S D D A 2 5 3 Expand Vertices More Than Once  0 path length S A D 2 1 4 G The shortest path from S to G   is (G D A S). 1 edge cost 
D is reached first using  path (D S). This prevents path (D A S) from being expanded. Suppose we expanded only the  first path that visits each vertex X? 10 G</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>10/27/10 
28 10/27/10 55 Test: A1=G  A2=G  A3=G  X1=G  X2=G A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A2 
A3 
X1 
X2 
10/27/10 56 Test: A1=G  A2=G  A3=G  X1=G  X2=G A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A2 
A3 
X1 
X2 0	
&#13;1	
&#13;1	
&#13;Symptom	
&#13;Extract Conflict and Constituent Kernels:       [A1=G  A2=G  X1=G]         A1=U  A2=U  X1=U</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>10/27/10 
16 Outline  Model-based Diagnosis Optimal CSPs Informed Search  A*  Branch and Bound Conflict-directed A*  
Brian Williams, Fall  05 32 Branch and Bound  
0 C S B G A D 2 5 4 2 3 2 5 1 2 1 0 1 3 Heuristic Value h in Red Edge cost in Green  Maintain the best solution found thus far (incumbent).  Prune all subtrees worse than the incumbent. S B C D D G G C G C A 0 4 5 8 7 10 8 10 10 7 Incumbent:  cost U =  path P = , (), 8 (S A D G) 10</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>10/27/10 
25 10/27/10 49 {X1=U} A1=?  A2=U  A3=?  X1=?  X2=?            A1=G  A2=U  A3=G  X1=G  X2=G Select best utility value for unassigned variables (Why?). Extracting a kernels best state  
10/27/10 50 Next Best State Resolving Conflicts function Next-Best-State-Resolving-Conflicts(OCSP)   best-kernel  Next-Best-Kernel(OCSP)   if best-kernel = failure     then return failure     else return kernel-Best-State[problem](best-kernel)  end function Kernel-Best-State(kernel)   unassigned  all variables not assigned in kernel   return kernel  {Best-Assignment(v) | v  unassigned} End function Terminate?(OCSP)   return True iff Solutions[OCSP] is non-empty Algorithm for only finding the first solution, multiple later.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>10/27/10 
11 10/27/10 21 A* Search: State of Search Problem:   State Space Search Problem.    Initial State. Expand(node)  Children of Search Node = adjacent states. Goal-Test(node)  True if search node at a goal-state. Nodes  Search Nodes to be expanded. Expanded  Search Nodes already expanded. Initialize  Search starts at , with no expanded nodes. g(state)   Cost to state h(state)   Admissible Heuristic - Optimistic cost to go. Search Node:  Node in the search tree. State   State the search is at. Parent  Parent in search tree. Nodes[Problem]: Enqueue(node, f ) Adds node to those to be expanded. Remove-Best(f) Removes best cost queued node according to f. 
10/27/10 22 A* Search Function A*(problem, h)   returns the best solution or failure. Problem pre-initialized.   f(x)  g[problem](x) + h(x)   loop do     node  Remove-Best(Nodes[problem], f)     new-nodes   Expand(node, problem)     for each new-node in new-nodes          then Nodes[problem] Enqueue(Nodes[problem], new-node, f ) end Expand Best-first</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>10/27/10 
20 10/27/10 39 Increasing Cost Feasible Infeasible Conflict 1 Conflict-directed A*  
10/27/10 40 Increasing Cost Feasible Infeasible Conflict 2 Conflict 1 Conflict-directed A*</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>10/27/10 
38 Outline  Model-based Diagnosis Optimal CSPs Conflict-directed A* Generating the Best Kernel Performance Comparison Appendix: Intelligent Tree Expansion Extending to Multiple Solutions Review of A* 
10/27/10 76 A2=U	
&#13;X1=U	
&#13;A1=U	
&#13;Order constituents by  decreasing utility. { } &gt; &gt; Expand Only Best Child &amp; Sibling 
Traditionally all children expanded. Only need child containing best candidate. Child with best estimated cost f = g+h. A2=U  A1=U  X1=U	
&#13;Constituent kernels</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>10/27/10 
21 10/27/10 41 Increasing Cost Feasible Infeasible Conflict 2 Conflict 1 Conflict-directed A*  
10/27/10 42 Increasing Cost Feasible Infeasible 
Conflict 3 Conflict 2 Conflict 1 Conflict-directed A*</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>10/27/10 
30 10/27/10 59 Test: A1=G  A2=U  A3=G  X1=G  X2=G 1	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;1	
&#13;0	
&#13;
A1 
A3 
X1 
X2 Extract Conflict:   [A1=G  A3=G  X1=G  X2=G]         A1=U  A3=U  X1=U  X2=U 
10/27/10 60 Conflicts  Constituent Kernels A1=U  A2=U  X1=U A1=U  A3=U  X1=U  X2=U Best Kernel:  A1=U Best Candidate:  A1=U  A2=G  A3=G  X1=G  X2=G Third Iteration PG(mi) &gt;&gt; PU(mi) Psingle &gt;&gt; Pdouble PU(A2) &gt; PU(A1) &gt;  PU(A3) &gt; PU(X1) &gt; PU(X2) 111010111A	
&#13;BCD	
&#13;EFGX	
&#13;Y	
&#13;Z10
A1 
A3 
X1 
X2</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>10/27/10 
45 Procedure Dependency_directed_Backtracking(&lt;X,D,C&gt;) Input:   A constraint network R = &lt;X, D, C&gt; Output: A solution, or notification that the network is inconsistent.    i  1;  ai = {}; conflicts = {}         Initialize variable counter, assignments,    Di  Di;    Copy domain of first variable.    while 1  i  n       instantiate xi  Select-DDB-Value(); Add to assignments ai.       if xi is null     No value was returned,          i   i - 1;      then backtrack       else          i   i + 1;      else step forward and          Di  Di;              copy domain of next variable  end while     if i = 0       return inconsistent    else       return ai , the instantiated values of {xi, , xn} end procedure 11/02/09 copyright Brian Williams, 2000-10 89 Procedure Select-DDB-Value() Output: A value in Di consistent with ai-1, or null, if none.    while Di is not empty       select an arbitrary element a  Di and remove a from Di;       ai  ai-1, {xi = a};       if for every c in conflicts, not (ai superset c)          if consistent(ai-1, xi = a )              return a;          else conflicts  conflicts                                         minimal inconsistent subset of ai-1;    end while    return null end procedure 11/02/09 copyright Brian Williams, 2000-10 90</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>10/27/10 
23 10/27/10 45 Conflict-directed A* Function Conflict-directed-A*(OCSP)   returns the leading minimal cost solutions.   Conflicts[OCSP]  {}   OCSP  Initialize-Best-Kernels(OCSP)   Solutions[OCSP]  {}   loop do     decision-state  Next-Best-State-Resolving-Conflicts(OCSP)     new-conflicts  Extract-Conflicts(CSP[OCSP], decision-state)     Conflicts[OCSP]         Eliminate-Redundant-Conflicts(Conflicts[OCSP]  new-conflicts) end Conflict-guided Expansion 
10/27/10 46 Conflict-directed A* Function Conflict-directed-A*(OCSP)   returns the leading minimal cost solutions.   Conflicts[OCSP]  {}   OCSP  Initialize-Best-Kernels(OCSP)   Solutions[OCSP]  {}   loop do     decision-state  Next-Best-State-Resolving-Conflicts(OCSP)     if no decision-state returned or       Terminate?(OCSP)       then return Solutions[OCSP]     if Consistent?(CSP[OCSP ], decision-state)       then add decision-state to Solutions[OCSP]     new-conflicts  Extract-Conflicts(CSP[OCSP], decision-state)     Conflicts[OCSP]         Eliminate-Redundant-Conflicts(Conflicts[OCSP]  new-conflicts) end</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>10/27/10 
18 Outline  Model-based Diagnosis Optimal CSPs Informed Search Conflict-directed A*  
10/27/10 36 Increasing Cost Feasible Infeasible A*</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>10/27/10 
29 10/27/10 57 Conflicts  Constituent Kernels A1=U  A2=U  X1=U Best Kernel:  A2=U      (why?) Best Candidate:  A1=G  A2=U  A3=G  X1=G  X2=G Second Iteration PG(mi) &gt;&gt; PU(mi) Psingle &gt;&gt; Pdouble PU(A2) &gt; PU(A1) &gt;  PU(A3) &gt; PU(X1) &gt; PU(X2) 110A	
&#13;B	
&#13;CD	
&#13;EFGX	
&#13;Y	
&#13;Z111010111
A1 
A2 
A3 
X1 
X2 
10/27/10 58 Test: A1=G  A2=U  A3=G  X1=G  X2=G A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;
A1 
A3 
X1 
X2</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>10/27/10 
9 Brian Williams, Fall  05 17 C S B G A D 2 5 4 2 3 2 5 1 Informed Search  
Problem:   Given graph &lt;V,E&gt; with weight function w: E , and vertices S, G in V,   Find a path S p G with the shortest path length (S,G) where  w(p) =  w(vi-1,vi).  (u,v) = min {w(p) : u p v } g = 8 S D B A C G C G D C G 2 5 6 4 9 9 8 6 10 8 0 Extend search tree nodes to include path length g 
Brian Williams, Fall  05 18 A B x xstart goal Best-first Search with Uniform Cost spreads evenly from the start.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Game theory II: differential games [SK]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec25/</lecture_pdf_url>
      <lectureno>25</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text>Game Theory (Recap)
Zero-sum Two-player Sequential games
Key characteristics
Two players
Zero-sum reward
Sequential moves
(from a nite set)
Perfect information
Terminates in a nite
number of steps
We have used alpha-beta pruning to solve such games.
Today, we will study non-cooperative dynamic games .
S. Karaman ( MIT) L25: Differential Games December 8, 2010 6 / 32</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Types of differential games: Payoff structures
Zero-sum games
Payoffs of the players sum up to zero (or, equivalently a constant), i.e.,
L1(u1;u2) +L2(u1;u2) =0:
This can be extended to multiple players easily.
Examples of zero-sum games:
Pursuit-evasion, dog ght (?).
Generally, management science examples are non-zero sum.
Markets (determine market clearing prices), Choosing divident rates (to
keep shareholders happy), Supply chain management (game against
demand rates).
S. Karaman ( MIT) L25: Differential Games December 8, 2010 17 / 32</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Open-loop vs. Closed-loop
Lady in the lake
A lady is swimming in a circular-shaped lake. Right when
she is in the middle a man comes nearby with the intention
of catching her when she comes out.
The man can not swim.
The lady can swim slower than the man can run
The lady can run faster than the man.
Man wins if he captures the lady; lady wins if she escapes.
ManLake
Lady
In this case, open-loop strategies do not make sense (at least for the
man).
What is a closed-loop strategy for the lady to wins?
S. Karaman ( MIT) L25: Differential Games December 8, 2010 21 / 32
Lake
Lady
Man
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Dynamic Games Literature
Dynamic games has a very rich literature.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 9 / 32Images of book covers removed due to copyright restrictions:
Isaacs, Rufus. Differential Games: A Mathematical Theory with Applications to Warfare, Pursuit,
Control and Optimization. Dover, 1999. ISBN: 9780486406824.
Basar, Tamer, and Geert Jan Olsder. Dynamic Noncooperative Game Theory. 2nd ed.
SIAM, 1999. ISBN: 9780898714296.
Dockner, Engelbert, Steffen Jorgensen, Ngo Van Long, and Gerhard Sorger. Differential Games in Economics
and Management Science. Cambridge University Press, 2001. ISBN: 9780521637329.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Incremental Sampling-based Methods
10 5 0 5 10051015
(a)
10 5 0 5 10051015
(b)
10 5 0 5 10051015
(c)
10 5 0 5 10051015
(d)
S. Karaman ( MIT) L25: Differential Games December 8, 2010 28 / 32</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Outline
Game theory and sequential games (recap previous lecture)
Dynamical (control) systems and optimal control
Dynamic Game Theory
Numerical Methods
A special case: Pursuit-evasion.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 3 / 32</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Dynamic games
Dynamic games:
Actions available to each agent depends on its current state
which evolves according to a certain dynamical system.
Sets of states/actions is usually a continuum.
Inmany cases, the agents involved in the game are subject to dynamics.
Some (major/relevant) application areas:
Dogght
Aircraft landing subject to wind (or other) disturbance
Airtrafc control
Economics &amp; Management Science
S. Karaman ( MIT) L25: Differential Games December 8, 2010 7 / 32</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 25: Differential Games
Sertac Karaman
Massachusetts Institute of Technology
December. 8, 2010
S. Karaman ( MIT) L25: Differential Games December 8, 2010 1 / 32</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>History of Dynamic Games
Introduction of dynamic games is attributed to
Rufus Isaacs (1951).
Book: R. Isaacs, Differential Games: A
mathematical theory with applications to warfare
and pursuit, control and optimization, 1965.
Later the theory was developed by many
contributors including A. Merz and J. Breakwell.
More recent contributions by T. Basar and
coworkers.
Book: Basar and Olsder, Dynamic
Noncooperative Game Theory, 1982.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 8 / 32</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Incremental Sampling-based Methods
10 5 0 5 10051015
(e)
10 5 0 5 10051015
(f)
10 5 0 5 10051015
(g)
10 5 0 5 10051015
(h)
S. Karaman ( MIT) L25: Differential Games December 8, 2010 29 / 32</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Incremental Sampling-based Methods
Probabilistic Soundness
The probability that the solution returned by the algorithm is sound
converges to one as the number of samples approaches innity.
Probabilistic Completeness
The probability that the algorithm returns a solution, if one exists,
converges to one as the number of samples approaches innity.
The algorithm is incremental and sampling-based:
An approximate solution is computed quickly and improved if the time allows.
The approach is amenable to real-time computation,
Also, computationally effective extensions to high dimensional state-spaces,
May be valuable in online settings.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 31 / 32</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Conclusions
In this lecture, we have studied dynamic games:
Description of time: Discrete-time, Continuous-time.
Information patterns: Open-loop, Closed-loop (feedback).
Payoff structures: Zero-sum, Nonzero-sum games.
Equilibrium concepts: Nash, Saddle-point, and Stackelberg.
Simple examples: Lady in the lake, Homicidal chauffeur.
Numerical solutions: Direct methods, Indirect methods.
Incremental sampling-based algorithms
S. Karaman ( MIT) L25: Differential Games December 8, 2010 32 / 32</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Incremental Sampling-based Methods
Evader
Pursuer
Evader
Pursuer
S. Karaman ( MIT) L25: Differential Games December 8, 2010 30 / 32</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Effects of dynamics
Homicidal Chauffeur
A homicidal driver wants to kill a pedestrian. The pedestrian is slow but much
more agile.
Driver is modeled by a Dubins car.
The pedestrian is a single integrator with bounded velocity.
R.Isaacs
!"#$%&amp;%'()&amp;*(+,,-+./($-012+,+343((&amp;3
!"#$%%&amp;$'()*+,"!"##$%$&amp;'"()*(+$,"-./012345678"
R.Isaacs
!"#$%&amp;%'()&amp;*(+,,-+./($-012+,+343((&amp;3
!"#$%%&amp;$'()*+,"!"##$%$&amp;'"()*(+$,"-./012345678"
S. Karaman ( MIT) L25: Differential Games December 8, 2010 22 / 32RAND Corporation, Games of Pursuit, P-257, 1951. Reprinted with permission.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Incremental Sampling-based Methods
Problem description
Open-loop information structure :
The players pick open-loop controls and let the dynamical system evolve.
Stackelberg equilibrium :
The evader picks her strategy rst, the pursuer observes
the evader and picks his strategy accordingly.
We can think of this as an unbalanced information structure :
Evaders information structure: open-loop
Pursuers information structure: closed-loop
Also, assume that the pursuer is in a stable equilibrium.
A motivating example : Aircraft avoiding missiles.
Missiles detected by the satellite, but not
directly observed by the airplane.
The airplane must nd a safe way
through the eld.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 26 / 32Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Types of differential games: Equilibria concepts
Stackelberg Equilibrium
Stackelberg equilibrium
One player is the leader announces her strategy rst,
the followers play accordingly.
From the leaders point of view:
max
u1min
u2J(u1;u2):
Most markets works according to this rules.
Coca Cola sets the price, all others follow.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 20 / 32</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Dynamical Control Systems
Almost all engineering systems have a certain set of inputs.
The behavior of the system is determined
by its current state and the inputs.
Discrete-time dynamical control systems
Difference equation: x [t+1] =f(x[t];u[t]).
Continuous-time dynamical control systems
Differential equation: _x(t) =f(x(t);u(t));x(t)2X;u(t)2U.
From now on we will only discuss continuous-time systems, although the
discussion can easily be extended to discrete-time systems
S. Karaman ( MIT) L25: Differential Games December 8, 2010 11 / 32 Source unknown.  All rights reserved. This content is excluded 
from our Creative Commons license. For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Computational Methods
Direct methods :
Formulate a mathematical program and solve.
How shall we handle the min-max type of objective function?
Bilevel programming is one promising approach.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 23 / 32Image removed due to copyright restrictions: Figure 3, Ehtamo, H., and T. Raivio. 
"On Applied Nonlinear and Bilevel Programming for Pursuit-Evasion Games." 
Journal of Optimization Theory and Applications 108, no. 1 (2001): 65-96.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Computational Methods
Indirect methods :
Using necessary and sufcient conditions, write down a partial differential
equation (PDE) that the solution must satisfy .
Solve this PDE using level sets, multiple-shooting, collocation, etc.
Computational Techniques for the Verification
of Hybrid Systems
CLAIRE J. TOMLIN, IAN MITCHELL, ALEXANDRE M. BAYEN, ANDMEEKO OISHI
PROCEEDINGS OF THE IEEE, VOL. 91, NO. 7, JULY 2003
S. Karaman ( MIT) L25: Differential Games December 8, 2010 24 / 32Source: Figures 4 and 6. Tomlin, Claire, Ian Mitchell, Alexandre Bayen, and Meeko Oishi. 
"Computational Techniques for the Verification of Hybrid Systems." Proceedings of the IEEE 91, no. 7 (2003): 986-1001. Copyright  2003 IEEE. Used with permission.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Game theory (Recap)
Zero-sum Games
Gains/losses of each player is balanced by the gains/losses of the all the other players.
Cooperative vs. non-cooperative.
Cooperative if groups of players may enforce binding agreements.
Nash equilibrium
No player can gain more by unilaterally changing strategy.
An example
Remember the prisoners dilemma:
Player B cooperates
Player B defects
Player A cooperates
(-1,-1)
(-10, 0)
Player A defects
(0,-10)
(-5,-5)
Non-zero sum.
Cooperation could have been enforced; otherwise may or may not arise.
S. Karaman ( MIT) L25: Differential Games December 8, 2010 5 / 32</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Dynamic programming and machine learning I: Markov decision processes [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec22/</lecture_pdf_url>
      <lectureno>22</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
Lecture notes
[AIMA] Ch. 17.1-3.
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 2 / 16</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Value iteration example
After 50 iterations:
0
0
0
0
0
0
0
0
0
0
0
0.44
0.54
0.59
0.82
1.15
0.85
1.09
1.52
0
0
0.59
0.69
0
0
1.52
0
0
2.13
0
0
0.75
0.90
0
0
2.12
2.55
2.98
3.00
0
0
0.95
1.18
0
2.00
2.70
3.22
3.80
3.88
0
0
1.20
1.55
1.87
2.41
2.92
3.51
4.52
5.00
0
0
1.15
1.47
1.74
2.05
2.25
0
5.34
6.47
0
0
0.99
1.26
1.49
1.72
1.74
0
6.69
8.44
0
0
0.74
0.99
1.17
1.34
1.27
0
7.96
9.94
0
0
0
0
0
0
0
0
0
0
0
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 14 / 16</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Value iteration example
After 1 iteration:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.75
0
0
0
0
0
0
0
0
0.75
1
0
0
0
0
0
0
0
0
0
0
0
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 12 / 16</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Value iteration example
After 2 iterations:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0.51
0
0
0
0
0
0
0
0
0.56
1.43
0
0
0
0
0
0
0
0
1.43
1.9
0
0
0
0
0
0
0
0
0
0
0
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 12 / 16</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Some remarks
In a Markov Decision Process, both transition probabilities and
rewards only depend on the present state, not on the history of the
state. In other words, the future states and rewards are independent
of the past, given the present.
A Markov Decision Process has many common features with Markov
Chains and Transition Systems.
In a MDP:
Transitions and rewards are stationary.
The state is known exactly. (Only transitions are stochastic.)
MDPs in which the state is not known exactly (HMM + Transition
Systems) are called Partially Observable Markov Decision Processes
(POMDP's): these are very hard problems.
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 6 / 16</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 22: Markov Decision Processes I
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 29, 2010
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 1 / 16</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Outline
1
Markov Decision Processes
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 3 / 16</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Value iteration example
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 13 / 16</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Value iteration example
Initial condition:
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
Frazzoli (MIT)Lecture 22: MDPsNovember 29, 2010 12 / 16</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Model-based reasoning II: diagnosis and mode estimation [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec12a/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>28</slideno>
          <text>3/6/00	
&#13;
29	
&#13;Conflict:                   {A1=G, A2=G, X1=G} A1=U  A2=U  X1=U  Constituent Kernels:  {A1=U, A2=U, X1=U} Mapping Conflicts to  Constituent Kernels (A1=G  A2=G  X1=G)  
 Constituent_Kernels(c){li|c(li)}10/25/10  57  copyright Brian Williams, 2000-10  From Conflicts to Kernels 
Constituent Kernel: An assignment a that resolves one conict Ci.	
&#13;	
&#13;{A2=U} resolves {A1=G, A3=G, X1=G, X2=G}.	
&#13;Kernel: A minimal set of assignments A that resolve all conflicts C.	
&#13;	
&#13;{A2=U, X2=U} resolves {A1=G, A3=G, X1=G, X2=G}, and	
&#13;	
&#13;{A2=U, X2=U} resolves {A1=G, A2=G, X1=G}. 110ABCDEFGXYZ111010111
A1  
A2  
A3  
X1  
X2  A	
&#13;B	
&#13;C	
&#13;D	
&#13;E11101FG	
&#13;X	
&#13;Y	
&#13;Z01
A1  
A3 
X1  ? ? ? 
10/25/10  58  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>3/6/00/nonmarkingreturn
9/nonmarkingreturnHidden Failures Require Reasoning from 
a Model:  
STS-93
10/25/10  copyright Brian Williams, 2000-10  17  
STS-93 Symptoms:/nonmarkingreturn
Engine temp sensor high/nonmarkingreturn
LOX level low/nonmarkingreturn
GN&amp;C detects low thrust/nonmarkingreturn
H2 level possibly low /nonmarkingreturn
Problem :Liquid hydrogen leak/nonmarkingreturn
Effect: /nonmarkingreturn
LH2 used to cool engine/nonmarkingreturn
Engine runs hot/nonmarkingreturn
Consumes more LOX /nonmarkingreturnIssue 1: Diagnosing hidden 
failures requires reasoning 
from a model.
Model-based Diagnosis 
Input: Observations of a system with symptomatic behavior, 
and a model  of the system.  
Output: Diagnoses  that account for the symptoms .
10/25/10  copyright Brian Williams, 2000-10  18  1/nonmarkingreturnSymptom/nonmarkingreturn 1/nonmarkingreturn
0/nonmarkingreturnA/nonmarkingreturn
B/nonmarkingreturn
C/nonmarkingreturnD/nonmarkingreturn
E/nonmarkingreturnF/nonmarkingreturn
G/nonmarkingreturnX/nonmarkingreturn
Y/nonmarkingreturnZ/nonmarkingreturn1/nonmarkingreturn
1/nonmarkingreturn
1/nonmarkingreturn0/nonmarkingreturn
1/nonmarkingreturn0/nonmarkingreturn
1/nonmarkingreturn
1/nonmarkingreturn1/nonmarkingreturn
A1  
A2  
A3  
X1  
X2  
A1  
X1  Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>3/6/00	
&#13;
16	
&#13;
Issue 3: Multiple Faults Occur 
Three shorts, tank-line and 
pressure jacket burst, and panel flies off. 
 Diagnosis = mode assignment. 
Solve by divide &amp; conquer: 
1. Diagnose each symptom. 
2. Summarize conflicts. 
3. Combine diagnoses. 
 	
&#13;
APOLLO 13 	
&#13;
10/25/10  31  
copyright Brian Williams, 2000-10 
Solution: Identify all Combinations  
of Consistent Unknown Modes 
Candidate:   Assignment of G or U to each component. And(i): 
G(i):  
  Out(i) = In1(i) AND In2(i) 
U(i): 
Candidate = {A1=G, A2=G, A3=G, X1=G, X2=G}	
&#13;A	
&#13;
B	
&#13;
C	
&#13;
D	
&#13;
E	
&#13;1	
&#13;
1	
&#13;
1	
&#13;
0	
&#13;
1	
&#13;F	
&#13;
G	
&#13;X	
&#13;
Y	
&#13;
Z	
&#13;0	
&#13;
1	
&#13;
A1  
A2  
A3  
X1  
X2  
10/25/10  32  copyright Brian Williams, 2000-10  Image source: NASA.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>3/6/00/nonmarkingreturn
4/nonmarkingreturnThe program assigns EngineA = Thrusting ,
and the model-based executive . . . .       
Determines that valves/nonmarkingreturn
on the backup engine B /.null
will achieve thrust, and /.null
plans needed actions./nonmarkingreturnDeduces that a valve /nonmarkingreturn
failed - stuck closed/nonmarkingreturnPlans actions/nonmarkingreturn
to open/nonmarkingreturn
six valves/nonmarkingreturn
Deduces that/nonmarkingreturn
thrust is off, and /.null
the engine is healthy/nonmarkingreturn
Prog: EngineB = Thrusting 
10/25/10  7 copyright Brian Williams, 2000-10  
Deductive   Controller 
Commands/nonmarkingreturnObservations/nonmarkingreturnPlant/nonmarkingreturnState goals/nonmarkingreturn State estimates/nonmarkingreturn
Mode/nonmarkingreturn
Estimation:/nonmarkingreturn
Tracks likely /nonmarkingreturn
States/nonmarkingreturnMode/nonmarkingreturn
Reconguration:/nonmarkingreturn
Tracks least-cost/nonmarkingreturn
state goals/nonmarkingreturnOptimal CSP:/nonmarkingreturn
  arg min f(x)/nonmarkingreturn  s.t. C(x) is satisable/nonmarkingreturn
        D(x) is unsatisable/nonmarkingreturn
arg min Pt(Y| Obs) /nonmarkingreturn
s.t. (X,Y)  O(m) is consistent /nonmarkingreturnarg max Rt(Y) /nonmarkingreturn
s.t. (X,Y) entails G(X,Y) /nonmarkingreturn
s.t. (X,Y) is consistent /nonmarkingreturn
s.t. Y is reachable /nonmarkingreturnMode Reconguration:/nonmarkingreturn
Select a least cost set of commandable 
component modes that entail the current goal, and are consistent./nonmarkingreturnMode Estimation:/nonmarkingreturn
Select a most likely set of next component modes that are consistent with the model and past observations./nonmarkingreturn
10/25/10  8 copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>3/6/00	
&#13;
12	
&#13;Model: Abductive,  Model-based Diagnosis  
X   mode variables, one for each component c. Dc    modes of component c = domain of mc  M. Y   state variables, with domains DY. (X, Y)  model constraints. O  observed variables O  M u Y. Partitioned into Input I and Response R variables. 10/25/10  copyright Brian Williams, 2000-10  23  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;Xor(i): G(i):    Out(i) = In1(i) xor In2(i) Stuck_0(i):   Out(i) = 0 A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;
A1  
A3  
X1  
X2  
A2  
Output: Abductive,  Model-based Diagnosis  
Obs = &lt;Inp; Rsp&gt; Assignment to I and R, respectively. Candidate Ci:   Assignment of modes to X. Diagnosis Di:   A candidate such that                                 Di  Inp   entails Rsp. 10/25/10  copyright Brian Williams, 2000-10  24  Diagnosis = {X1=G, X2=G, A1=S0, A2=G, A3=G}	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;Candidate = {X1=G, X2=G, A1=G, A2=G, A3=G}	
&#13;Xor(i): G(i):    Out(i) = In1(i) xor In2(i) Stuck_0(i):   Out(i) = 0 A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;
A1  
A3  
X1  
X2  
A2</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>3/6/00	
&#13;
13	
&#13;Abductive Diagnosis  
by Generate and Test 
Given: exhaustive fault models, structure and observations. 
Generate: candidate mode assignment Ci. 
Test: Ci as an abductive diagnosis:  
1. Find Rsp entailed by Ci, given Inp. 
2. Compare observed and predicted Rsp: 
Disagree:   Discard 
Agree:    Keep 
No prediction:      Discard 
Exonerate: component if none of its fault models agree. 
10/25/10  copyright Brian Williams, 2000-10  25  Problem:  
 Fault models are typically incomplete. 
 May incorrectly exonerate faulty components. 
Outline 
Self-Repairing Agents 
Formulating Diagnosis 
Explaining failures 
Handling unknown failures 
Multiple faults 
Partial explanation 
Execution monitoring 
Diagnosis from Conflicts 
10/25/10  copyright Brian Williams, 2000-10  26</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>3/6/00/nonmarkingreturn
18/nonmarkingreturnIssue 4: The cause of failure is often needed to plan a 
recovery strategy ( Partial Explanation ).
Issue 5: Component mode estimates are needed to 
confirm correct behavior (Execution Monitoring).
courtesy of NASA/nonmarkingreturn
10/25/10  35  copyright Brian Williams, 2000-10  
Incorporating Failure Modes:  
Mode Estimation  
Inverter(i): 
G(i): Out(i) = not(In(i)) 
S1(i): Out(i) = 1 
S0(i): Out(i) = 0 
U(i): X/nonmarkingreturn Y/nonmarkingreturnA/nonmarkingreturn B/nonmarkingreturn C/nonmarkingreturn0/nonmarkingreturn 0/nonmarkingreturn
Nominal, Fault and Unknown Modes/nonmarkingreturn Isolates unknown./nonmarkingreturn
 Explains./nonmarkingreturnSherlock
[de Kleer &amp; Williams, IJCAI 89] 
10/25/10  36  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>3/6/00	
&#13;
6	
&#13;Compare Most Likely Candidate to Observations Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Flow1 = zero	
&#13;Pressure1 = nominal	
&#13;Pressure2= nominal	
&#13;Acceleration = zero	
&#13;It is most likely that all components are okay. 	
&#13;10/25/10  11  copyright Brian Williams, 2000-10  Isolate Conflicting Information Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Flow 1= zero	
&#13;The red component modes conict with the model and observations. 	
&#13;10/25/10  12  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>3/6/00	
&#13;
42	
&#13;Procedure Single_Fault_Test_Candidates(C,M, Obs) Input:  Candidates C, Model Md, Observation Obs Output: The set of consistent single-fault diagnoses.     Diagnoses   {}, Conflicts  {}    For each Ci in C       If Ci is a superset of some Conflictj in Conflicts          Then inconsistent candidate Ci, ignore.      Else Conflicti = Test_Candidate(Ci, M, Obs)      If Conflicti = Consistent         Then add Ci to Diagnoses      Else add Conflicti to Conflicts return Diagnoses 10/25/10  copyright Brian Williams, 2000-10  83  Test Candidates, Collect Conflicts 
10/25/10  copyright Brian Williams, 2000-10  84  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13; First candidate {A1=U, }  Suspend A1s constraints  Test consistency Candidates:  {{A1=U}, {A3=U}, {X1=U}, {X2=U}} Diagnoses:  
 consistent {{A1=U}} 
A1  
A2  
A3  
X1  
X2  0	
&#13; Add to diagnoses</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>3/6/00	
&#13;
25	
&#13;Example Diagnoses  X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;0	
&#13;1	
&#13;Diagnoses: [S1(A),G(B),U(C)]     (42 total) Kernel Diagnoses: [U(C)] X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;0	
&#13;?	
&#13;?	
&#13;Sherlock [de Kleer &amp; Williams, IJCAI 89] 
10/25/10  49  copyright Brian Williams, 2000-10  [S0(C)] [U(B),G(C] [S1(B),G(C)] [U(A),G(B),G(C)] [S0(A),G(B),G(C)] Outline Self-Repairing Agents Formulating Diagnosis Diagnosis from Conflicts Kernels Conflicts Candidate Generation Conflict Recognition 10/25/10  copyright Brian Williams, 2000-10  50</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>3/6/00	
&#13;
22	
&#13;Solution: Diagnosis as  
Hypothesis Testing 
1.Generate candidates Ci, given symptoms. 
Use Backtrack Search over mode variables X. 
2.Test if candidates account for all symptoms. 
Use DPLL to find assignment to Y such that 
Ci  Obs  (X,Y) is satisfiable . 
Set of diagnoses should be complete. 
Set of diagnoses should exploit all  
available information. 
10/25/10  copyright Brian Williams, 2000-10  43  
Outline 
Self-Repairing Agents 
Formulating Diagnosis 
Diagnosis from Conflicts 
Kernels 
Conflicts 
Candidate Generation 
Conflict Recognition 
10/25/10  copyright Brian Williams, 2000-10  44</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>3/6/00	
&#13;
19	
&#13;Example Diagnoses  X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;0	
&#13;1	
&#13;Diagnosis: [S1(A),G(B),U(C)] 
Sherlock [de Kleer &amp; Williams, IJCAI 89] 10/25/10  37  copyright Brian Williams, 2000-10  
Diagnoses: (42 of 64 candidates) Fully Explained Failures [G(A),G(B),S0(C)] [G(A),S1(B),S0(C)] [S0(A),G(B),G(C)] . . .   Fault Isolated, But Unexplained  [G(A),G(B),U(C)] [G(A),U(B),G(C)] [U(A),G(B),G(C)] Partial Explained [G(A),U(B),S0(C)] [U(A),S1(B),G(C)] [S0(A),U(B),G(C)] . . .  X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;0	
&#13;in in out 
10/25/10  38  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>3/6/00	
&#13;
14	
&#13;Issue 2: Failures are Often Novel 
10/25/10  copyright Brian Williams, 2000-10  27   Mars Observer  
 Mars Climate Orbiter 
 Mars Polar Lander 
 Deep Space 2 
Image credit: NASA/JPL.
10/25/10  copyright Brian Williams, 2000-10  28  
Failure models are never completely known. 
 Source unknown. All rights reserved. This content is excluded from our Creative 
Commons license. For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>3/6/00	
&#13;
35	
&#13;Add-Kernel(Kernel, Kernels){    // Add Kernel to Kernels while preserving minimality.    If       Then return Kernels       Else {          New_Kernels = {};           For each k in Kernels{          Unless              Add_To_End(k, New_Kernels)};          return }} 10/25/10  copyright Brian Williams, 2000-10  69   kKernels. kKernel
 Kernelk {Kernel}New_Kernels
Diagnoses: (42 of 64 candidates) Fully Explained Failures [G(A),G(B),S0(C)] [G(A),S1(B),S0(C)] [S0(A),G(B),G(C)] . . .   Fault Isolated, But Unexplained  [G(A),G(B),U(C)] [G(A),U(B),G(C)] [U(A),G(B),G(C)] Partial Explained [G(A),U(B),S0(C)] [U(A),S1(B),G(C)] [S0(A),U(B),G(C)] . . .  X	
&#13;Y	
&#13;A	
&#13;B	
&#13;C	
&#13;0	
&#13;0	
&#13;in in out 
10/25/10  70  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>3/6/00	
&#13;
8	
&#13;Final Candidate Resolves all Conflicts  Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Pressure1 = nominal	
&#13;Flow1 = zero	
&#13;Pressure2= nominal	
&#13;Flow2 = positive	
&#13;Acceleration = zero	
&#13;Implementation: Conict-directed A* search.	
&#13;10/25/10  15  copyright Brian Williams, 2000-10  Outline Self-Repairing Agents Formulating a Diagnosis Diagnosis from Conflicts 
10/25/10  copyright Brian Williams, 2000-10  16</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>3/6/00	
&#13;
40	
&#13;Finding Single Fault Diagnosis 
10/25/10  copyright Brian Williams, 2000-10  79  A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1. Generate initial candidates:	
&#13;Assume all components okay and test consistency.	
&#13;If inconsistent, conict kernels denote single fault candidates.	
&#13;2. Check consistency of each candidate: 	
&#13;Prune candidate if superset of a conict.	
&#13;Else check consistency and record conict if inconsistent.	
&#13;F	
&#13;0	
&#13;1	
&#13;HT [Davis &amp; Shrobe] Dart [Genesereth] Sophie [de Kleer &amp; Brown] Early 80s  
A1  
A2  
A3  
X1  
X2  
Procedure Single_Fault_w_Conflicts(Md, M, Obs) Input:   A model Md, Mode variables M, and observations Obs.  Output: A set of consistent, single fault diagnoses.    All_Good  { Mi=G | Mi  M};  Assume all components are okay,    Conflict  Test_Candidate(All_Good, Md, Obs)     If Conflict = Consistent       Return All_Good    Else      Cands    Generate single fault candidates            {{Mi=U}  Z=G | Mi=G  Conflict, Z = M - {Mi } };       Diagnoses  Test_Candidates(Cands, Md, Obs)       Return Diagnoses 10/25/10  copyright Brian Williams, 2000-10  80</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>3/6/00	
&#13;
21	
&#13;Constraint Modeling and 
Consistency Testing  
10/25/10  copyright Brian Williams, 2000-10  41    Propositional Logic: 
 Complete:  DPLL.    (Titan) 
 Incomplete: Unit propagation.  (Livingstone/DS1) 
 Finite Domain Constraints: 
 Complete:  Backtracking with forward checking. 
 Incomplete: AC-3 / Waltz constraint propagation. 
  Algebraic Constraints:           (GDE/Sherlock/GDE+/XDE) 
 Complete:  Gaussian Elimination. 
 Incomplete:   Sussman/Steele Constraint Propagation. 
 Propagate newly assigned values through equations  
   that mention the newly assigned variables.  
To propagate, use assigned values of constraint to  
  deduce unknown value(s) of constraint. 
X {1,0}    X=1  X=0	
&#13;
	
&#13;    [X=1  X=0]	
&#13;Models in 
Propositional State Logic 
And(i): 
G(i):  
  Out(i) = In1(i) AND In2(i) 
U(i): 
Or(i): 
G(i):  
  Out(i) = In1(i) OR In2(i) 
U(i): i=G  {[In1(i)=1  In2(i)=1] iff Out(i)=1} 
(i=G)  (In1(i)=1)  Out(i)=1 
(i=G)  (In2(i)=1)  Out(i)=1 
(i=G)  (In1(i)=0)  (In2(i)=0)   Out(i)=0 i=G  {[In1(i)=1  In2(i)=1] iff Out(i)=1} 
10/25/10  42  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>3/6/00	
&#13;
37	
&#13;Outline Self-Repairing Agents Formulating Diagnosis Diagnosis from Conflicts Kernels Conflicts Candidate Generation Conflict Recognition 10/25/10  copyright Brian Williams, 2000-10  73  Recognizing Conflicts within GDE 
10/25/10  copyright Brian Williams, 2000-10  74  1 {}	
&#13;A	
&#13;
A1  
A2  
A3  
X1  
X2  1 {}	
&#13;B	
&#13;1 {}	
&#13;C	
&#13;0 {}	
&#13;D	
&#13;1 {}	
&#13;A	
&#13;0 {}	
&#13;F	
&#13;1 {A1=G,A2=G,X1=G}	
&#13;
1 {}	
&#13;G	
&#13;X	
&#13;1 {A1=G}	
&#13;
Z	
&#13;1 {A3=G}	
&#13;0 {A2=G}	
&#13;Y	
&#13;1 {A1=G,X1=G}	
&#13;0 {A1=G,A3=G,X1=G,X2=G}	
&#13;Conflict 1 
Conflict 2 General Diagnostic Engine [de Kleer &amp; Williams, 87]</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>3/6/00	
&#13;
41	
&#13;Generate Candidates From Symptom 
10/25/10  copyright Brian Williams, 2000-10  81  Symptom: 	
&#13;G is observed 1, but predicted 0	
&#13;Conict:	
&#13;{A1=G, A3=G, X1=G, X2=G} is inconsistent	
&#13;Candidates: 	
&#13;{{A1=U}, {A3=U}, {X1=U...}, {X2=U}}	
&#13;Symptom	
&#13;1	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;1	
&#13;0	
&#13;
A1  
A2  
A3  
X1  
X2  
Generate Candidates From Symptom 
10/25/10  copyright Brian Williams, 2000-10  82  Symptom: 	
&#13;G is observed 1, but predicted 0	
&#13;Conict:	
&#13;{A1=G, A3=G, X1=G, X2=G} is inconsistent	
&#13;Candidates: 	
&#13;{{A1=U}, {A3=U}, {X1=U...}, {X2=U}}	
&#13;Symptom	
&#13;1	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;0	
&#13;1	
&#13;1	
&#13;0	
&#13;
A1  
A2  
A3  
X1  
X2</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>3/6/00	
&#13;
44	
&#13;Test Candidates, Collect Conflicts 
10/25/10  copyright Brian Williams, 2000-10  87  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13; Fourth candidate {X2=U, }  Superset of conflict?   Eliminate candidate Candidates: 	
&#13;{{X2=U}}	
&#13;Diagnoses:	
&#13;{{A1=U}, {X1=U}}	
&#13;Conicts:	
&#13;{{A1=G, A2=G, X1=G}}	
&#13;
Yes, since A1=G, A2=G and X1=G 
A1  
A2  
A3  
X1  
X2  Test Candidates, Collect Conflicts 
10/25/10  copyright Brian Williams, 2000-10  88  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13; Return diagnoses A1 or X1 broken Candidates: 	
&#13;{}	
&#13;Diagnoses:	
&#13;{{A1=U}, {X1=U}}	
&#13;Conicts:	
&#13;{{A1=G, A2=G, X1=G}}	
&#13;
A1  
A2  
A3  
X1  
X2</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>3/6/00	
&#13;
20	
&#13;Mode Estimation 
Candidate Ci:    Assignment of modes to X. Obs:    Assignment to O. Diagnosis Di:    Candidate consistent with Model and Obs:         Di  Obs  (X,Y) is satisfiable. And(i):    G(i):    Out(i) = In1(i) AND In2(i)    U(i): Diagnosis = {A1=G, A2=U A3=G, X1=G. X2=U}	
&#13;ALL components have unknown Mode U,  whose assignment is never mentioned in any constraint. Mode, State, Observation Variables:  X, Y , O Model:     (X,Y) = components + structure A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;
A1  
A3 
X1  1	
&#13;0	
&#13;1	
&#13;
10/25/10  39  copyright Brian Williams, 2000-10  Mode Estimation And(i):    G(i):    Out(i) = In1(i) AND In2(i)    U(i):  All behaviors associated with modes.  ALL components have unknown Mode U, whose assignment is never mentioned in any constraint. Given: Mode, State, Observation Variables:  X, Y , O Model:     (X,Y) = components + structure A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;
A1  
A3 
X1  1	
&#13;0	
&#13;1	
&#13;
 D,obs{XDX|YDXst Obs(X,Y)}10/25/10  40  copyright Brian Williams, 2000-10  Return:</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>3/6/00	
&#13;
1	
&#13;
Mode Estimation and  
Model-based Diagnosis 
10/25/10  copyright Brian Williams, 2000-10  1 Brian C. Williams  
16.410 / 16.413  
October 25th, 2010 
Brian C. Williams, copyright 2000-10 
Assignment 
Remember: 
Problem Set #6 Propositional Logic,  
due this Wednesday, October 27th. 
16:413 Project Part 1: Sat-based Activity Planner,  
due Wednesday, November 3rd. 
Reading 
 Today: Johan de Kleer  and Brian C. Williams, "Diagnosing Multiple 
Faults," Artificial Intelligence, 32:100-117, 1987. 
 Wednesday: Brian C. Williams, and Robert Ragno, "Conflict-directed A* 
and its Role in Model-based Embedded Systems," Special Issue on Theory 
and Applications of Satisfiability Testing, Journal of Discrete Applied 
Math, January 2003.  
10/25/10  copyright Brian Williams, 2000-10  2 Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>3/6/00	
&#13;
7	
&#13;Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Flow 1= zero	
&#13;Leap to the Next Most Likely Candidate that Resolves the Conflict 
The next candidate must remove the conict. 	
&#13;10/25/10  13  copyright Brian Williams, 2000-10  New Candidate Exposes Additional Conflicts 
Pressure1 = nominal	
&#13;Pressure2= nominal	
&#13;Acceleration = zero	
&#13;Helium tank	
&#13;Fuel tank	
&#13;Oxidizer tank	
&#13;Main	
&#13;Engines	
&#13;Another conict, try removing both.	
&#13;10/25/10  14  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3/6/00/nonmarkingreturn
3/nonmarkingreturnControl Sequencer 
Deductive   Controller System Model/nonmarkingreturn
Commands/nonmarkingreturn Observations/nonmarkingreturnControl Program
Plant/nonmarkingreturnTitan Model-based Executive /nonmarkingreturn RMPL Model-based Program /nonmarkingreturn
State goals/nonmarkingreturn State estimates/nonmarkingreturnGenerates target goal states/nonmarkingreturn
conditioned on state estimates/nonmarkingreturn
Mode/nonmarkingreturn
Estimation/nonmarkingreturnMode/nonmarkingreturn
Reconguration/nonmarkingreturnTracks/nonmarkingreturn
likely /.null
plant states/nonmarkingreturnTracks least /.null
cost goal states/nonmarkingreturn/circle6 Executes concurrently /nonmarkingreturn
/circle6  Preempts /nonmarkingreturn
/circle6 Queries (hidden) states /nonmarkingreturn
/circle6  Asserts (hidden) state /nonmarkingreturnOrbitInsert()::  
(do-watching ((EngineA = Firing) OR  
                         (EngineB = Firing))  
(parallel  
(EngineA = Standby)
(EngineB = Standby)
(Camera = Off)
           (do-watching (EngineA = Failed)
                 (when-donext ( (EngineA = Standby) AND  
                                            (Camera = Off) )
(EngineA = Firing) ))
           (when-donext ( (EngineA = Failed) AND  
                                      (EngineB = Standby) AND  
                                      (Camera = Off) )
(EngineB = Firing) )))
inflow iff outflow 10/25/10  5 copyright Brian Williams, 2000-10  
Model-based Programming  
of a Saturn Orbiter 
Turn camera off and /nonmarkingreturn
engine on/nonmarkingreturn
EngineA EngineB 
Science Camera OrbitInsert()::  
 do-watching (EngineA = Thrusting OR  
                        EngineB = Thrusting)  
parallel {  
EngineA = Standby;
EngineB = Standby;
Camera = Off;
           do-watching (EngineA = Failed)
                 {when-donext (EngineA = Standby) AND  
                                          Camera = Off)
EngineA = Thrusting} ;
           when-donext (EngineA = Failed AND  
                                   EngineB = Standby AND  
                                   Camera = Off)
EngineB = Thrusting }
10/25/10  6 copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>3/6/00	
&#13;
17	
&#13;Solution: Identify all Combinations  of Consistent Unknown Modes 
Candidate:   Assignment of G or U to each component. Diagnosis:  Candidate consistent with model and observations. And(i): G(i):    Out(i) = In1(i) AND In2(i) U(i): Diagnosis = {A1=G, A2=U, A3=G, X1=G, X2=U}	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;
A1  
A3  
X1  1	
&#13;0	
&#13;1	
&#13;
10/25/10  33  copyright Brian Williams, 2000-10  Outline Self-Repairing Agents Formulating Diagnosis Explaining failures Handling unknown failures Multiple faults Partial explanation  Execution monitoring Diagnosis from Conflicts 10/25/10  copyright Brian Williams, 2000-10  34</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>3/6/00	
&#13;
38	
&#13;Recognizing Conflicts within GDE 
10/25/10  copyright Brian Williams, 2000-10  75  1 {}	
&#13;A	
&#13;
A1  
A2  
A3  
X1  
X2  1 {}	
&#13;B	
&#13;1 {}	
&#13;C	
&#13;0 {}	
&#13;D	
&#13;0	
&#13;0	
&#13;0	
&#13;1	
&#13;1 {}	
&#13;A	
&#13;0	
&#13;0 {}	
&#13;F	
&#13;1 {A1=G,A2=G,X1=G}	
&#13;
1 {}	
&#13;G	
&#13;0	
&#13;0 {A2=G,X1=G}{A3=G,X1=G,X2=G}	
&#13;X	
&#13;1 {A1=G}	
&#13;
0 {A1=G,X1=G,X2=G} 	
&#13;Z	
&#13;1 {A3=G}{A2=G,X2=G}	
&#13;0 {A2=G}{A3=G,X2=G}	
&#13;Y	
&#13;1 {A1=G,X1=G}	
&#13;
General Diagnostic Engine [de Kleer &amp; Williams, 87] Summary: Mode Estimation A failure is a discrepancy between the model and observations of an artifact. Mode estimation supports diagnosis of  unknown failures, multiple faults, partial explanation and execution monitoring. Mode estimates are encoded compactly using kernels. Symptoms are used to recognize conflicts, which are merged to produce kernels.  Conflict-directed search is at the foundation of  fast satisfiability and optimization. 10/25/10  copyright Brian Williams, 2000-10  76</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>3/6/00	
&#13;
11	
&#13;How Should Diagnoses  Account for Symptoms? Abductive Diagnosis: Given symptoms,  find diagnoses that predict observations. 
10/25/10  copyright Brian Williams, 2000-10  21  1	
&#13;0	
&#13;1	
&#13;Symptom	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13; Fault Model: A1s output is stuck at 0.  Abductive diagnosis needs exhaustive fault models. 0	
&#13;0	
&#13;1	
&#13;1	
&#13;
A1  
A2  
A3  
X1  
X2  
A1  
Input: Abductive,  Model-based Diagnosis  
Model   Structure. Model of normal behavior for each component. Model for every component failure mode. Observations Obs Inputs and Response. 10/25/10  copyright Brian Williams, 2000-10  22  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;Xor(i): G(i):    Out(i) = In1(i) xor In2(i) Stuck_0(i):   Out(i) = 0 0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;
A1  
A3  
X1  
X2  
A2</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>3/6/00	
&#13;
39	
&#13;Outline Self-Repairing Agents Formulating Diagnosis Diagnosis from Conflicts Appendix: Single Fault Diagnosis 
10/25/10  copyright Brian Williams, 2000-10  77  
Single Fault Diagnoses = {A1=U}         {X1=U}	
&#13;Single Fault Diagnosis 
{A1=U, A2=U, X1=U} 	
&#13;	
&#13;constituents of Conict 1. 	
&#13;{A1=U, A3=U, X1=U, X2=U}   	
&#13;constituents of Conict 2. 	
&#13;{A1=G, A2=G, X1=G} 	
&#13;	
&#13;	
&#13;	
&#13;Conict 1.	
&#13;{A1=G, A3=G, X1=G, X2=G}	
&#13;	
&#13;	
&#13;Conict 2.	
&#13;The single fault diagnoses are the  intersections of the conflict constituent kernels.  
10/25/10  78  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>3/6/00	
&#13;
15	
&#13;How Should Diagnoses  Account for Novel Symptoms? Consistency-based Diagnosis: Given symptoms,  find diagnoses that are consistent with symptoms. Suspending Constraints:  For novel faults, make  no presumption about faulty component behavior. 
10/25/10  copyright Brian Williams, 2000-10  29  1	
&#13;0	
&#13;1	
&#13;Symptom	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;
A1  
A2  
A3  
X1  
X2  [Davis, 84] [Geneserth, 84] [deKleer &amp; Brown, 83] Outline Self-Repairing Agents Formulating Diagnosis Explaining failures Handling unknown failures Multiple faults Partial explanation Execution monitoring Diagnosis from Conflicts 10/25/10  copyright Brian Williams, 2000-10  30</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>3/6/00	
&#13;
10	
&#13;Solution: Diagnosis as  
Hypothesis Testing 
1.Generate candidates, given symptoms. 
2.Test if candidates account for all symptoms. 
Set of diagnoses should be complete . 
Set of diagnoses should exploit all  
available information. 
10/25/10  copyright Brian Williams, 2000-10  19  
Outline 
Self-Repairing Agents 
Formulating Diagnosis 
Explaining failures 
Handling unknown failures 
Multiple faults 
Partial explanation 
Execution monitoring 
Diagnosis from Conflicts 
10/25/10  copyright Brian Williams, 2000-10  20</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>3/6/00	
&#13;
28	
&#13;Outline Self-Repairing Agents Formulating Diagnosis Diagnosis from Conflicts Kernels Conflicts Candidate Generation Conflict Recognition 10/25/10  copyright Brian Williams, 2000-10  55  From Conflicts to Kernels 
Constituent Kernel: An assignment a that resolves one conict Ci.	
&#13;	
&#13;{A2=U} resolves {A1=G, A3=G, X1=G, X2=G}. 	
&#13;	
&#13;a entails  Ci.	
&#13;110ABCDEFGXYZ111010111
A1  
A2  
A3  
X1  
X2  A	
&#13;B	
&#13;C	
&#13;D	
&#13;E11101FG	
&#13;X	
&#13;Y	
&#13;Z01
A1  
A3 
X1  ? ? ? 
10/25/10  56  copyright Brian Williams, 2000-10</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>3/6/00	
&#13;
43	
&#13;Test Candidates, Collect Conflicts 
10/25/10  copyright Brian Williams, 2000-10  85  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13; Second candidate {A3=U, }  Suspend A3s constraints  Test consistency Candidates:  {{A3=U}, {X1=U}, {X2=U}} Diagnoses: {{A1=U}} Conflicts: {{A1=G, A2=G, X1=G}} 1	
&#13;1	
&#13;1	
&#13;0	
&#13; inconsistent  Extract conflict     {A1=G, A2=G, X1=G}  Intersect candidates 
A1  
A2  
A3  
X1  
X2  Test Candidates, Collect Conflicts 
10/25/10  copyright Brian Williams, 2000-10  86  1	
&#13;1	
&#13;1	
&#13;0	
&#13;1	
&#13;A	
&#13;B	
&#13;C	
&#13;D	
&#13;E	
&#13;F	
&#13;G	
&#13;X	
&#13;Y	
&#13;Z	
&#13;0	
&#13;1	
&#13;1	
&#13;1	
&#13; Third candidate {X1=U, }  Superset of conflict?   Suspend X1s constraints  Test consistency  1	
&#13;0	
&#13;consistent Candidates: 	
&#13;{{X1=U}, {X2=U}}	
&#13;Diagnoses:	
&#13;{{A1=U}}	
&#13;Conicts:	
&#13;{{A1=G, A2=G, X1=G}}	
&#13;
No, since X1 = U, not X1=G 
A1  
A2  
A3  
X1  
X2</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>3/6/00	
&#13;
2	
&#13;Outline 
Self-Repairing Agents 
Model-based Programming 
Diagnosis as Conflict-directed Search 
Formulating a Diagnosis 
Diagnosis from Conflicts 
10/25/10  copyright Brian Williams, 2000-10  3 
10/25/10  copyright Brian Williams, 2000-10  4 sense	
&#13;P(s)	
&#13;WORLD	
&#13;
observations	
&#13; actions	
&#13;
AGENT	
&#13; Self-Repairing Agent:	
&#13;
 Monitors &amp; Diagnoses	
&#13;
 Repairs &amp; Avoids	
&#13;
 Probes and Tests 	
&#13;Plant	
&#13;
act 
Symptom-directed</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Mathematical programming III: (mixed-integer) linear programming for vehicle routing and motion planning [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec18/</lecture_pdf_url>
      <lectureno>18</lectureno>
      <slides>
        <slide>
          <slideno>22</slideno>
          <text>Arbitrarily shaped obstacles
If you have obstacles of arbitrary
shapes, you can approximate their
convex hull arbitrarily well with linear
constraints. At least one of them must
be applied (\or")
Non-convex obstacles can be split up
into convex pieces, and the same
technique can be applied.
In 3d, the lines become planes,
polygons become polyhedra, but the
idea remains the same.
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 23 / 31</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Optimal solution
InfantryInfantry
TechnicalsSAMsSAMsTechnicals
Armor
MedicalSEADUAV1UAV2Primary baseAlternate baseMedicalSEADSEADUAV1UAV1
UAV1
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 13 / 31</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Vehicle Routing Problems
We have already studied a basic problem in robotics and automation,
i.e., the computation of a shortest path between a start and a goal
location.
In many applications, e.g., UAV mission planning problems, it is of
interest to compute paths for one or more vehicles to reach a number
of locations, while optimizing some performance criterion.
Vehicle Routing Problems are essentially shortest path problems for
multiple vehicles and/or multiple destinations, subject to a variety of
constraints or performance objectives.
VRPs come in a large number of varieties, we will look at some
examples.
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 4 / 31</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Sub-tour elimination in practice
Sub-tour elimination constraints are exponentially many.
In practice, one can attempt to solve the problem without sub-tour
elimination constraints. If the solution contains subtours, add
constraints eliminating those subtours, and repeat.
In each case, if the integrality constraint is relaxed, the problem is a
LP. If the solution of the LP is integral and contains no subtour, that
solution is optimal.
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 8 / 31</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Avoiding static obstacles
What if there is an obstacle (i.e., the
space station) in the path of the
spacecraft?
Need to enforce collision avoidance
constraints.
Collision avoidance constraints are not
convex, and they cannot be written as a
LP.
In a LP, all constraints are and, i.e.,
they all must hold at the same time.
Similar conclusions hold for moving
obstacles, plume impingement
constraints, etc., as well as for
multi-vehicle collision avoidance.
(1,2)(4,3)
x1[i]1,orx1[i]4,orx2[i]2,orx2[i]3.(i{0,...,N})
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 21 / 31</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Receding horizon output
3DiscretizingFixed Arrival Time
DiscretizingFixed Arrival TimeReformulated as LP
Receding Horizon
Start SsGoal SgReceding Horizon
Start SsGoal Sg
Look ahead Thorand plan with mixed fuel-distance cost function
3DiscretizingFixed Arrival Time
DiscretizingFixed Arrival TimeReformulated as LP
Receding Horizon
Start SsGoal SgReceding Horizon
Start SsGoal Sg
Look ahead Thorand plan with mixed fuel-distance cost function
4Receding Horizon
Start SsGoal Sg
After Treplansteps (1&lt;=Treplan&lt;=Thor) plan again to a horizon of Thor.Receding Horizon
Start SsGoal Sg
Repeat until goal reached.
Consider Weighted Cost Function and a finite receding horizonCant solve continuous problem numerically so we must discretizeit.Using a finite horizon T with N discrete time steps
Estimate of remaining costConvert to Linear Form
Examples Adand Bd
4Receding Horizon
Start SsGoal Sg
After Treplansteps (1&lt;=Treplan&lt;=Thor) plan again to a horizon of Thor.Receding Horizon
Start SsGoal Sg
Repeat until goal reached.
Consider Weighted Cost Function and a finite receding horizonCant solve continuous problem numerically so we must discretizeit.Using a finite horizon T with N discrete time steps
Estimate of remaining costConvert to Linear Form
Examples Adand Bd
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 20 / 31</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>A Complex multi-UAV Mission
InfantryInfantry
TechnicalsSAMsSAMsTechnicals
Armor
MedicalSEADUAV1UAV2Primary baseAlternate base
Mission specs
Infantry unit pinned down by
insurgents in an urban area.
Egress routes blocked by technicals,
protected by SAM units.
Help infantry unit to reach a base
with a medic in minimum
time/minimum total &#13;ight time.
Friendly units
Two UAVs capable of taking out
ground targets, but vulnerable to
SAMs.
One SEAD UAV.
One armored unit.
One medical unit.
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 11 / 31</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 18: (Mixed-Integer) Linear Programming
for Vehicle Routing and Motion Planning
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 15, 2010
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 1 / 31</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Remarks on MILPs
Pros :
Very general formulation: you can write a very large class of motion planning
problems in this way.
The problems \look" like LPs.
Very powerful commercial solvers available: Ilogs CPLEX can solve many of
these problems quickly.
In some cases, amenable to real-time implementation
(Prof. How and his student have demonstrated real-time MILP-based planning
on UAVs)
Cons :
Too general formulation: any problem can be converted into a MILP (!)
With generality comes complexity: MILPS are NP-hard (i.e., require exponential
time to solve, in the worst case).
The dimension of the MILP can grow very quickly with the number of time
steps/obstacles/vehicles.
The number of \or" constraints, i.e., of integer variables, is the key complexity
driver.
In general:
Non-convex optimization problems are hard.
Approximation algorithms can come in handy: e.g., relaxations
In certain conditions, approximations actually provide the optimal solution!
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 31 / 31</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Example
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
!
0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.800.10.20.30.40.50.60.70.80.91
1
2
345
678910
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 10 / 31</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Branch and Bound Algorithm
/negationslashSpr 2006  16.323  1616  
(B): min (c T x + dT z) s.t. Ax + Bz b 
x,z 
x X 
zi = 1 
= i 0 zj 1, j 
3. Solve a subp roblem.  Three possible  outcomes:  
 Solution found . 0, 1}. Then this is a feasibl e zj  {  
solution to the original  problem.  Update the upp er bound  
JUJU := min {, Jsub}. 
 Solution found. zj  /0, 1}. If JsubJU , then  do not  {
need  to expl ore more. Prune  the branch . Otherwi se, branch  
further.  
 zi= 0zi= 1InfeasibleInteger solution!JU Worse than JUzj= 0zj= 1Infeasible . Prune  the branch.  
Figure  4: Branch ing and  prun ing.  
 The prunin g process  elimi nates  the need  to exami ne all possibl e inte-
ger solutions. 
 So diers from  a full enumer ation  met hod in that not  all feasibl e 
solutions need  be eval uated   might it might  be neces sary 
Ma y 9, 2006  
As in graph search, branch and bound may eliminate the need to
explore all the possible choices for the integer variables.
This and similar methods are at the basis of most state-of-the-art
open-source and commercial solvers, e.g., GLPK, LP
SOLVE, and
ILOG CPLEX.
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 30 / 31</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings
Lecture notes
[IOR] Chapter 11.
Frazzoli (MIT)Lecture 18: (MI)LP for Motion PlanningNovember 15, 2010 2 / 31</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Foundations I: state space search [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec02/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides>
        <slide>
          <slideno>30</slideno>
          <text>31 Brian Williams, Fall  10 61 C S B G A D Q 1 (S) 2 3 4 5 1 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Brian Williams, Fall  10 62 C S B G A D Q 1 (S) 2 (A S) 3 4 5 1 Added paths in blue Depth-First Pick first element of Q;  Add path extensions to front of Q</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 Brian Williams, Fall  10 89 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 5 6 1 2 3 
Brian Williams, Fall  10 90 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 (C A S) (D A S) (G B S)* G,C,D,B,A,S 5 6 1 2 3 * We could stop here, when the first path to the goal is generated.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41 Brian Williams, Fall  10 81 Testing for the Goal  This algorithm stops (in step 3) when head(N) = G.  We could have performed this test in step 6 as each extended path is added to Q.  This would catch termination earlier and be perfectly correct for all the searches we have covered so far.  However, performing the test in step 6 will be incorrect for the optimal search algorithms that we look at later.  We have chosen to leave the test in step 3  to maintain uniformity with these future searches. 
Brian Williams, Fall  10 82 Problem Solving as  State Space Search Problem Formulation (modeling) Formal Representation Reasoning Algorithms A generic search algorithm description Depth-first search example Handling cycles Breadth-first search example</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Brian Williams, Fall  10 63 C S B G A D Q 1 (S) 2 (A S) (B S) 3 4 5 1 Added paths in blue Depth-First Pick first element of Q;  Add path extensions to front of Q 
Brian Williams, Fall  10 64 Simple Search Algorithm Let Q be a list of partial paths,  Let S be the start node and  Let G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; 2.If Q is empty, fail.  Else, pick a partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else:  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add all extended paths to Q d)Go to step 2</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 Brian Williams, Fall  10 71 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 (C D A S)(G D A S)  (B S) 1 2 3 4 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Brian Williams, Fall  10 72 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 (C D A S)(G D A S)  (B S) 6 (G D A S)(B S) 1 2 3 4 Depth-First Pick first element of Q;  Add path extensions to front of Q</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Brian Williams, Fall  10 105 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 (B S) (C A S) (D A S) 4 (C A S) (D A S) (D B S) (G B S)* 5 (D A S) (D B S) (G B S) 6 (D B S) (G B S) (C D A S) (G D A S) 7 (G B S) (C D A S) (G D A S)(C D B S)(G D B S) 1 2 3 4 5 6 7</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Brian Williams, Fall  09 17 Problem: Compensating for Error Online 1 2 3 8 4 7 6 5  Policy, (v)  e, dictates how to act in all states.  Policy  corresponds to a shortest path tree from all vertices to the destination. 
18 How do we Map Path Planning to State Space Search? Start position 
Goal position Vehicle translates, but no rotation</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 25 Voronoi Diagrams Lines equidistant from CSpace obstacles 
Brian Williams, Fall 03 26 Roadmaps: Approximate Fixed Cell</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>47 Brian Williams, Fall  10 93 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 (C A S) (D A S) (G B S)* G,C,D,B,A,S 5 (D A S) (G B S) G,C,D,B,A,S 6 (G B S) G,C,D,B,A,S 1 2 3 4 5 6 
Brian Williams, Fall  10 94 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 (C A S) (D A S) (G B S)* G,C,D,B,A,S 5 (D A S) (G B S) G,C,D,B,A,S 6 (G B S) G,C,D,B,A,S 1 2 3 4 5 6</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 21 Start position 
Goal position 2. Map From Continuous Problem to Graph Search: Create Visibility Graph 
22 3. Find Shortest Path (e.g., A*) Start position 
Goal position</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 Brian Williams, Fall  10 95 Depth-first with Visited List Pick first element of Q;  Add path extensions to front of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A, B, S 3 (C A S) (D A S) (B S) C,D,B,A,S 4 (D A S) (B S) C,D,B,A,S 5 (G D A S) (B S) G,C,D,B,A,S 1 2 3 4 5 
Brian Williams, Fall  10 96 Depth First Search (DFS) S D B A C G C G D C G S D B A C G C G D C G Breadth First Search (BFS) For each search type, where do we place the children on the queue? Depth-first:    Add path extensions to front of Q    Pick first element of Q Breadth-first:    Add path extensions to back of Q    Pick first element of Q</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Brian Williams, Fall  10 39 A Problem Solver Searches  through all Simple Paths C S B G A D S D A C G 
Brian Williams, Fall  10 40 A Search Tree Denotes All Simple Paths C S B G A D S D B A C G C G D C G Enumeration is:  Complete  Systematic  Sound</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Brian Williams, Fall  10 37 Formalizing State Space Search 
C S B G A D Input: A search problem S =  &lt;g, S, G&gt; where  graph g = &lt;V , E&gt;,   start vertex S in V , and  goal vertex G in V .  Output: A simple path P = &lt;S, v2,  G&gt; in g from S to G. 
Brian Williams, Fall  10 38 Simple Paths of Graph g = &lt;V, E&gt; C S B G A D 
A simple path is a path that has no cycles. A cycle is a subpath where start = end (i.e., repeated vertices). A (directed) path P of graph g is     a sequence of vertices &lt;v1,  vn&gt; in V      such that each successive pair &lt;vi,vi+1&gt; is a (directed) edge in E start end &lt;S, A, D, C&gt;</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 Brian Williams, Fall  10 35 Specifying a Graph: G = &lt;V, E&gt; 
a c d e b Vertices V = {a, b, c, d, e} Edges E = {&lt;a, b&gt;, &lt;a, c&gt;,                      &lt;b, e&gt;,                     &lt;c, b&gt;, &lt;c,d&gt;,                     &lt;e, d&gt;}  Notation:  &lt;a, b,  n&gt;   an ordered list of elements a, b   {a, b,  n}    an unordered set of distinguished elements. 
Brian Williams, Fall  10 36 Examples of Graphs  San Fran Boston LA  Dallas  Wash DC Roadmap 
A B C A B C 
A B C A B C 
Put C on B Put C on A Put B on C Put C on A A B C Put A on C Planning Actions (graph of possible states of the world)</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Brian Williams, Fall  10 47 Classes of Search Blind  Depth-First     Systematic exploration of whole tree (uninformed) Breadth-First     until the goal is found.   Iterative-Deepening Heuristic  Hill-Climbing     Use heuristic measure of goodness (informed) Best-First     of a node.   Beam   Optimal   A*           Use path length measure.  Find (informed)  Branch&amp;Bound    shortest path. 
Brian Williams, Fall  10 48 Depth First Search (DFS) 
S D B A C G C G D C G Local Rule: After visiting node  Visit its children before its siblings  Visit its children left to right 1 2 3 4 5 6 7 8 9 10 11 S A D C G C B D C G G</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44 Brian Williams, Fall  10 87 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 4 5 6 1 2 
Brian Williams, Fall  10 88 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 5 6 1 2</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 Brian Williams, Fall  10 91 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 (C A S) (D A S) (G B S)* G,C,D,B,A,S 5 6 1 2 3 4 
* We could stop here, when the first path to the goal is generated. 
Brian Williams, Fall  10 92 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 (B S) (C A S) (D A S) C,D,B,A,S 4 (C A S) (D A S) (G B S)* G,C,D,B,A,S 5 (D A S) (G B S) G,C,D,B,A,S 6 1 2 3 4 5</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Brian Williams, Fall  10 97 What You Should Know Most problem solving tasks may be formulated as state space search. State space search is formalized using graphs, simple paths, search trees, and pseudo code. Depth-first and breadth-first search are framed, among others, as instances of a generic search strategy. Cycle detection is required to achieve efficiency and completeness. 
Brian Williams, Fall  10 98 Appendix</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Brian Williams, Fall  10 33 Problem Formulation: A Graph In Degree (2) Out Degree (1) Directed Graph (one-way streets) b 
Undirected Graph (two-way streets) b Degree (3) 
Brian Williams, Fall  10 34 Problem Formulation: A Graph 
Directed Graph (one-way streets) a c d e b 
Undirected Graph (two-way streets) a c e d b Connected graph    Path between all vertices. Complete graph    All vertices are adjacent. 
Sub graph    Subset of vertices    edges between vertices in Subset Clique    A complete subgraph    (All vertices are adjacent). Strongly connected graph    Directed path between all vertices.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26 Brian Williams, Fall  10 51 Problem Solving as  State Space Search Problem Formulation (Modeling) Formal Representation Reasoning Algorithms A generic search algorithm description Depth-first search example Handling cycles Breadth-first search example 
Brian Williams, Fall  10 52 Solve &lt;g = &lt;V, E&gt;, S, G&gt;  using State Space Search Search States: All simple paths &lt;S, v&gt;  in g starting at S Initial State: &lt;S&gt; Operator: Extend a path &lt;S,  v&gt; to &lt;S,  v, u&gt;  for each &lt;v, u&gt; in E call u a child of v Goal: A simple path &lt;S, , G&gt; in g</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Brian Williams, Fall  10 49 Breadth First Search (BFS) 
S D B A C G C G D C G Local Rule: After visiting node  Visit its siblings, before its children  Visit its children left to right 1 2 4 8 9 5 3 6 10 11 7 S A D C G C B D C G G 
Brian Williams, Fall  10 50 Elements of Algorithm Design Algorithm Description: (Today) stylized pseudo code, sufficient to analyze and implement the algorithm (implementation next Wednesday). Algorithm Analysis: (Wednesday &amp; Monday) Time complexity:  how long does it take to find a solution? Space complexity:  how much memory does it need to perform search? Soundness:  when a solution is returned, is it guaranteed to be correct? Completeness:  is the algorithm guaranteed to find a solution when there is one?</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Brian Williams, Fall  10 5 Problem Solving as  State Space Search Problem Formulation (Modeling) Problem solving as state space search Formal Representation Graphs and search trees Reasoning Algorithms Depth and breadth-first search 
Brian Williams, Fall  10 6 Most Agent Building Block Implementations Use Search Robust Operations: Activity Planning Diagnosis Repair Scheduling Resource Allocation Mobility: Path Planning Localization Map Building Control Trajectory Design</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 Brian Williams, Fall  10 79 How Do We Modify The Simple Search Algorithm? Let Q be a list of partial paths,  Let S be the Start node and  Let G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; as only entry;  2.If Q is empty, fail.  Else, pick some partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add to Q all the extended paths d)Go to step 2 
Brian Williams, Fall  10 80 Simple Search Algorithm Let Q be a list of partial paths,  Let S be the start node and  Let G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; as only entry; set Visited = {} 2.If Q is empty, fail.  Else, pick some partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else  a)Remove N from Q b)Find all children of head(N) not in Visited and  create a one-step extension of N to each child c)Add to Q all the extended paths d)Add children of head(N) to Visited e)Go to step 2</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 Brian Williams, Fall  10 99 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 3 4 5 6 7 1 
Brian Williams, Fall  10 100 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 4 5 6 7 1 2 
Added paths in blue</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Brian Williams, Fall  10 103 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 (B S) (C A S) (D A S) 4 (C A S) (D A S) (D B S) (G B S)* 5 (D A S) (D B S) (G B S) 6 7 1 2 3 4 5 
Brian Williams, Fall  10 104 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 (B S) (C A S) (D A S) 4 (C A S) (D A S) (D B S) (G B S)* 5 (D A S) (D B S) (G B S) 6 (D B S) (G B S) (C D A S) (G D A S) 7 1 2 3 4 5 6</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>34 Brian Williams, Fall  10 67 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 5 1 2 3 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Added paths in blue 
Brian Williams, Fall  10 68 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 1 2 3 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Added paths in blue</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Brian Williams, Fall  10 9 Problem Solving as  State Space Search Formulate Goal State Astronaut, Fox, Goose &amp; Grain below crevasse. Formulate Problem States Astronaut, Fox, Goose &amp; Grain  above or below the crevasse. Operators Move: Astronaut drives rover and 1 or 0 items to other side of crevasse. Initial State Astronaut, Fox, Goose &amp; Grain above crevasse. Generate Solution Sequence of Operators (or States) Move(goose,astronaut), Move(astronaut), . . . 
Brian Williams, Fall  10 10 Astronaut Goose Grain Fox Astronaut Goose Grain Fox Grain Fox Astronaut Goose Goose Grain Astronaut Fox 
Goose Fox Astronaut Grain Goose Grain Fox Astronaut</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Brian Williams, Fall  10 53 Solve &lt;g = &lt;V, E&gt;, S, G&gt;  using State Space Search How do we maintain the search state?  An ordering on partial paths yet to be expanded    (called a queue Q). How do we perform search?   Repeatedly: 1. Select next partial path from Q.  2. Expand it. 3. Add expansions to Q.  Terminate when goal G is found. S D B A C G C G D C G 
Brian Williams, Fall  10 54 Simple Search Algorithm: Preliminaries  A partial path from S to D is listed in reverse order,   e.g., &lt;D, A, S&gt;     The head of a partial path is its most recent visited node,   e.g., D.  The Q is a list of partial paths,   e.g. (&lt;D, A, S&gt;, &lt;C, A, S&gt; &gt;. S D B A C G C G D C G</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Brian Williams, Fall  10 55 Simple Search Algorithm Let Q be a list of partial paths,        S be the Start node and        G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; 2.If Q is empty, fail.  Else, pick a partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else:  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add all extended paths to Q d)Go to step 2 
Brian Williams, Fall  10 56 Problem Solving as  State Space Search Problem Formulation (Modeling) Formal Representation Reasoning Algorithms A generic search algorithm description Depth-first search example Handling cycles Breadth-first search example</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39 Brian Williams, Fall  10 77 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 (C D A S)(G D A S)  (B S) 6 (G D A S)(B S) 1 2 3 4 Depth-First 
 C visited multiple times  Multiple paths to C, D &amp; G  How much wasted effort can be incurred in the worst case? Effort can be wasted in more mild cases 
Brian Williams, Fall  10 78 How Do We Avoid Repeat Visits?  Idea:  Keep track of nodes already visited.  Do not place expanded path on Q if head is a visited node. Does this maintain correctness?  Any goal reachable from a node that was visited a second time would be reachable from that node the first time. Does this always improve efficiency?    Visits only a subset of the original paths, such that   each node appears at most once at the head of a visited path.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Brian Williams, Fall 03 27 Roadmaps: Approximate Fixed Cell  
Brian Williams, Fall 03 28 Roadmaps: Approximate Variable Cell</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 Brian Williams, Fall  10 101 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 (B S) (C A S) (D A S) 4 5 6 7 1 2 3 Added paths in blue 
Brian Williams, Fall  10 102 Breadth-First (without Visited list) Pick first element of Q;  Add path extensions to end of Q C S B G A D Q 1 (S) 2 (A S) (B S) 3 (B S) (C A S) (D A S) 4 (C A S) (D A S) (D B S) (G B S)* 5 6 7 1 2 3 4 
Added paths in blue Revisited nodes in pink * We could have stopped here, when the first path to the goal was generated.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 23 Start position 
Goal position Resulting Solution 
24 A Visibility Graph is a Kind of Roadmap Start position 
Goal position What are the strengths / weaknesses of roadmaps? What are some other types of roadmaps?</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Brian Williams, Fall  10 31 Problem Solving as  State Space Search Problem Formulation (Modeling) Problem solving as state space search Formal Representation Graphs and search trees Reasoning Algorithms Depth and breadth-first search 
Brian Williams, Fall  10 32 Problem Formulation: A Graph Operator Edge State Vertex 
Directed Graph (one-way streets) Undirected Graph (two-way streets) neighbors (adjacent) Tail Vertex  of Edge Head Vertex  of Edge h t</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Brian Williams, Fall  10 14 
  Swaggert &amp; Lovell assemble 
emergency rig for Apollo 13 
lithium hydroxide unit.  Languages for Expressing  
States and Operators for Complex Tasks 
Image source: NASA.Brian Williams, Fall  10 13 Formulation Example: 8-Puzzle 
States:  
Operators:  
Initial and  
Goal States: 5 4 
6 1 
7 3 8 
2 1 2 
8 3 
7 6 4 
5 
Start Goal 
integer location for each tile AND  ?? 
move empty square up, down, left, right 
as shown above</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21 Brian Williams, Fall  10 41 Search Trees 
A tree T is a directed graph, such that   there exists exactly one undirected path between any pair of vertices. In degree of each vertex is 1 think of a tree as a family tree 
Brian Williams, Fall  10 42 Search Trees Root Branch (Edge) Node (Vertex) 
Leaf think of a tree as a family tree</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Brian Williams, Fall  10 59 Depth-First Pick first element of Q;  Add path extensions to front of Q C S B G A D Q 1 (S) 2 3 4 5 1 
Brian Williams, Fall  10 60 Simple Search Algorithm Let Q be a list of partial paths,        S be the Start node and        G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; 2.If Q is empty, fail.  Else, pick a partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else:  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add all extended paths to Q d)Go to step 2</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Brian Williams, Fall  10 73 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 (C D A S)(G D A S)  (B S) 6 (G D A S)(B S) 1 2 3 4 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Brian Williams, Fall  10 74 Simple Search Algorithm Let Q be a list of partial paths,  Let S be the start node and  Let G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; 2.If Q is empty, fail.  Else, pick a partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else:  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add all extended paths to Q d)Go to step 2</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Brian Williams, Fall  10 75 Problem Solving as  State Space Search Problem Formulation (Modeling) Formal Representation Reasoning Algorithms A generic search algorithm description Depth-first search example Handling cycles Breadth-first search example 
Brian Williams, Fall  10 76 C S B G A D Issue: Starting at S and moving top to bottom,  will depth-first search ever reach G?</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15 Brian Williams, Fall 03 29 Roadmaps: Exact Cell Decomposition  
Brian Williams, Fall 03 30 How do we handle large state spaces?  Start position 
Goal position RRT, Ta 
RRT, Tb Rapid exploring Random Trees</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Brian Williams, Fall  10 45 Search Trees 
Descendants think of a tree as a family tree 
Brian Williams, Fall  10 46 Problem Solving as  State Space Search Problem Formulation (Modeling) Problem solving as state space search Formal Representation Graphs and search trees Reasoning Algorithms Depth and breadth-first search</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Brian Williams, Fall  10 83 Breadth First Search (BFS) 
S D B A C G C G D C G 1 2 4 8 9 5 3 6 10 11 7 S A D C G C B D C G G Idea: After visiting node  Visit its children left to right  Visit its siblings, before its children Assume we remove the first element of Q, Where to Q do we add the path extensions? 
Brian Williams, Fall  10 84 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 3 4 5 6 1</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 19 1. Create Configuration Space 
Idea: Transform to equivalent  problem of navigating a point. Start position 
Goal position Vehicle translates, but no rotation 
20 2. Map From Continuous Problem to Graph Search: Create Visibility Graph Start position 
Goal position</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Brian Williams, Fall  10 43 Search Trees Parent 
Child Siblings 
think of a tree as a family tree 
Brian Williams, Fall  10 44 Search Trees Ancestors 
think of a tree as a family tree</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Brian Williams, Fall  10 3 Recap - Course Objectives 1.Understand the major types of agents and architectures:  goal-directed vs utility-based  deliberative vs reactive  model-based vs model-free 2. Learn the modeling and algorithmic building blocks for creating agents: Model problem in an appropriate  formal representation. Specify, analyze, apply and implement reasoning algorithms to solve the problem formulations. 
Brian Williams, Fall  10 4 Plan&#13;Execute&#13;Monitor &amp;&#13;Diagnosis&#13;Locate in&#13;World&#13;Plan Routes&#13;Map&#13;Maneuver and Track&#13;Mission Goals&#13;Recap  Agent Architectures 
Functions: Robust, coordinated operation + mobility It Begins with State Space Search!</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4Brian Williams, Fall  10 7
Example: Outpost 
Logistics Planning 
Brian Williams, Fall  10 8Early AI: What are the universal problem solving methods? Astronaut
Goose
Grain
Fox
RoverCan the astronaut get its supplies
safely across a Lunar crevasse?
/.notdef.g0001 Astronaut + 1 item  
  allowed in the rover. 
/.notdef.g0001 Goose alone eats Grain 
/.notdef.g0001 Fox alone eats Goose 
Simple Trivial Image produced for NASA by John Frassanito and Associates.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Brian Williams, Fall  10 69 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 1 2 3 4 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Added paths in blue 
Brian Williams, Fall  10 70 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 (D A S) (B S) 5 (C D A S)(G D A S)  (B S) 1 2 3 4 Depth-First Pick first element of Q;  Add path extensions to front of Q</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Brian Williams, Fall  10 11 Astronaut Goose Grain Fox Grain Fox Astronaut Goose Astronaut Goose Grain Fox Goose Fox Astronaut Grain Astronaut Grain Fox Goose Astronaut Goose Grain Fox Goose Grain Astronaut Fox 
Astronaut Goose Fox Grain Grain Astronaut Goose Fox 
Fox Astronaut Goose Grain Goose Astronaut Fox Grain Goose Grain Fox Astronaut Astronaut Grain Goose Fox Astronaut Fox Goose Grain Astronaut Goose Grain Fox Astronaut Goose Grain Fox 
Brian Williams, Fall  10 12 Astronaut Goose Grain Fox Grain Fox Astronaut Goose Astronaut Grain Fox Goose Goose Astronaut Fox Grain Astronaut Goose Grain Fox Astronaut Goose Grain Fox Grain Astronaut Goose Fox 
Fox Astronaut Goose Grain Goose Fox Astronaut Grain Goose Grain Astronaut Fox 
Astronaut Goose Fox Grain Astronaut Grain Goose Fox Astronaut Fox Goose Grain 
Goose Grain Fox Astronaut Astronaut Goose Grain Fox Astronaut Goose Grain Fox</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
Brian Williams, Fall  10 1 Problem Solving as State Space Search Brian C. Williams 16.410-13 Sept 13th, 2010 Slides adapted from:&#13;6.034 Tomas Lozano Perez,&#13;Russell and Norvig AIMA&#13;
Brian Williams, Fall  10 2 Assignments Remember:  Problem Set #1: Java warm up   Out last Wednesday,   Due this Wednesday, September 15th Reading:  Today: Solving problems through search [AIMA] Ch. 3.1-4 Wednesday: Asymptotic Analysis Lecture 2 Notes of 6.046J;                        Recurrences, Lecture 12 Notes of 6.042J.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Brian Williams, Fall  10 65 C S B G A D Q 1 (S) 2 (A S) (B S) 3 4 5 1 Added paths in blue 2 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Brian Williams, Fall  10 66 C S B G A D Q 1 (S) 2 (A S) (B S) 3 (C A S) (D A S) (B S) 4 5 1 2 Depth-First Pick first element of Q;  Add path extensions to front of Q 
Added paths in blue</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 Brian Williams, Fall  10 85 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 3 4 5 6 1 
Brian Williams, Fall  10 86 Breadth-First with Visited List Pick first element of Q;  Add path extensions to end of Q C S B G A D Q Visited 1 (S) S 2 (A S) (B S) A,B,S 3 4 5 6 1</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Brian Williams, Fall  10 57 Depth First Search (DFS) 
S D B A C G C G D C G 1 2 3 4 5 6 7 8 9 10 11 S A D C G C B D C G G Assume we remove the first element of Q, Where to Q do we add the path extensions? Idea: After visiting node  Visit its children left to right  (or top to bottom)  Visit its children before its siblings 
Brian Williams, Fall  10 58 Simple Search Algorithm Let Q be a list of partial paths,        S be the start node and        G be the Goal node. 1.Initialize Q with partial path &lt;S&gt; 2.If Q is empty, fail.  Else, pick a partial path N from Q 3.If head(N) = G, return N    (goal reached!) 4.Else:  a)Remove N from Q b)Find all children of head(N) and  create a one-step extension of N to each child c)Add all extended paths to Q d)Go to step 2</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Foundations III: soundness and completeness of search [SK]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec04/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>9/20/10
6Envelopegame
Probabili(esdonotwork! 
Iputanamount$Nand$2Nintotwodierentenvelopes
(youdonotknowN).
Iopenoneofthem,ithas$X.
Wouldyoupicktheopenoneortheother?
Reasoning1:(Ipickoneatrandom)
seeinginsideanenvelopedoesnotmaler
Reasoning2:(Ipickthesecondone)
IfIgetthisenvelope,Iget$X.
IfIgettheotherenvelope,Iget,onaverage:
(1/2)X/2+(1/2)2X=(5/4)X
Unexpectedhangingparadox
Induc(ondoesnotwork! 
Ajudgetellsacriminalthat
thecriminalwillbehangedonaweekdayatnoonnextweek,hewillnotknowwhenhewillbehanged,itwillbeatotalsurprise.
Criminalsreasoning:
HecannotbehangedonaFriday(byThursdayawernoon,he
willknowitwontbeasurprise).
Then,hecannotbehangedonThursdayeither.
Then,hecannotbehangedatallSohefeelssafe.
(HewashangedonWed.atnoonitwasatotalsurprise)
WhatwentwrongwithcriminalsdeducVon?</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>9/20/10
30PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 59
SoundnessandCompleteness
Theorems
Theorem1(Soundness) :
Simplesearchalgorithmissound.
Proof :bycontradicVon
60</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making 
Fall 2010 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>9/20/10
35ProofofCompleteness
Theorem2(Completeness) :
Simplesearchalgorithmiscomplete.
Needtoprove :
IfthereisapathtoreachfromStoG,thenthe
algorithmreturnsonepaththatdoesso.
69
PseudoCodeForSimpleSearch
Let g be a Graph    G be the Goal vertex of g.   
      S be the start vertex of g    Q be a list of simple partial paths in GR,  
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  
d) Add children of head(N) to Visited; 
e) Go to step 2. 
70</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>9/20/10
39ProofofCompleteness
Lemma2 :IfavertexvisreachablefromS,
thenvisplacedintothevisitedlistawera
nitenumberofsteps.
Corollary :Inthemodiedalgorithm,Gis
placedintothevisitedqueue.
Projectbacktotheoriginalalgorithm:
Thisisexactlywhen theoriginalalgorithm
terminates
ProofofCompleteness
Theorem2(Completeness) :
Simplesearchalgorithmiscomplete.
Proof :FollowsfromLemma2evaluatedinthe
originalalgorithm.
78</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>9/20/10
SoundnessandCompleteness
Theorems
Theorem1(Soundness) :
Simplesearchalgorithmissound.
Letusprove3lemmasbeforeprovingthistheorem.
33
Alemmatowardstheproof
Lemma1 :If&lt;v1,v2,,vk&gt;isapathinthe
queueatanygivenVme,thenvk=S.
Proof :(byinvariance)
Basecase :IniVally,thereisonly&lt;S&gt;inthequeue.
Hence,the invariantholds.
Induc(onstep :Letscheckthatthe invariant
conVnuestoholdineverystepofthealgorithm.
17</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>9/20/10
18PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
35
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 36</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>9/20/10
1529SomeOtherNoVonsofSoundnessandCompletenessProbabilisJcCompleteness:ThealgorithmreturnsasoluVon,ifoneexists,withprobabilityapproachingtooneasthenumberofiteraVonsincreases.IfthereisnosoluVon,itmayrunforforever.ProbabilisJcSoundness:TheprobabilitythatthesoluVonreportedsolvestheproblemapproachesone,asthenumberofiteraVonsincreases.AsymptoJcOpJmality:Thealgorithmdoesnotnecessarilyreturnanop(malsoluVon,butthecostofthesoluVonreportedapproachestheopVmalasthenumberofiteraVonsincreases.
BrianWilliams,Fall1030Problem:StateSpaceSearch
C S B G A D Input:AsearchproblemS=&lt;g,S,G&gt;wheregraphg=&lt;V,E&gt;,startvertexSinV,andgoalvertexGinV.Output:AsimplepathP=&lt;S,v2,G&gt;ingfromStoG.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>9/20/10
19PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 37
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue(apathisremoved)
38</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>9/20/10
37ProofofCompleteness
Themodiedalgorithmterminateswhenthe
queueisempty.
Letusproveafewlemmasregardingthe
behaviorofthemodiedalgorithm
ProofofCompleteness
Lemma1 :Apaththatistakenoutofthequeueisnot
placedintothequeueagainatalaterstep.
Proof :(usinglogicaldeduc(on)
Anotherwaytostatethis :Ifp=&lt;v0,v1,,vk&gt;isapath
thatistakenoutofthequeue, thenp=&lt;v0,v1,,vk&gt;is
notplacedintothequeueatalaterstep.
Assumethatp=&lt;v0,v1,,vk&gt;istakenoutofthe
queue.
Then,pmustbeplacedintothequeueatanearlier
step.
Then,v0mustbeinthevisitedlistatthisstep.
Then,p=&lt;v0,v1,,vk&gt;cannotplacedintothequeue
atalaterstep,sincev0isinthevisitedlist.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>9/20/10
40PseudoCodeForSimpleSearch
Let g be a Graph    G be the Goal vertex of g.   
      S be the start vertex of g    Q be a list of simple partial paths in GR,  
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  
d) Add children of head(N) to Visited; 
e) Go to step 2. 
79
SummarizeCompletenessand
Soundness
Hence,wehaveproventwotheorems:
Theorem1(Soundness) :
Simplesearchalgorithmissound.
Theorem2(Completeness) :
Simplesearchalgorithmiscomplete.
Soundnessandcompletenessisarequirementformostalgorithms,
althoughwewilltheirrelaxaVonsquiteowen</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>9/20/10
20PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Severalpathsadded,eachsaJsfytheinvariantsinceNsaJsesit.
39
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 40</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>9/20/10
23PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 45
PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 46</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>9/20/10
7TheaxiomaVcmethod
InventedbyEuclidaround300BC(in
Alexandria,Egypt).
5axiomsofgeometrymenVonedinhis
work Elements.
StarVngfromthese axioms, 
Euclidestablishedmany proposi2ons
byproviding proofs.
EuclidofAlexandria
Oldestsurvivingcopy
ofthe Elements ona
papyrusfoundin
Oxyrhynchus,Egypt .EuclidstatuteinOxford
TheaxiomaVcmethod
AdeniVonofa proof:
Anysequenceof logicaldeduc(ons from
axioms andpreviouslyproven proposi(ons/
statements thatconcludeswiththe
proposiVoninquesVon.
Therearemanytypesof proposi2ons:
Theorem :Importantresults,mainresults
Lemma:apreliminaryproposiVonforproving
laterresults
Corollary :Aneasy(butimportant)conclusion,
anawerthoughtofatheorem.
EuclidofAlexandria
EuclidstatuteinOxfordImages are in the public domain.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>9/20/10
Whatyoushouldknow
ThedeniVonsofa proposiVon ,proof ,
theorem ,lemma,andcorollary .
Prooftechniquessuchasproofby
contradicVon ,inducVon ,invariance proofs.
NoVonsof soundness andcompleteness .
Provingsoundnessandcompletenessofsearchalgorithms .
43</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>9/20/10
26Yetanotherlemmatowardstheproof
Lemma3 :If&lt;v1,v2,,vk&gt;isapathinthe
queueatanygivenVme,thenitisasimple
path(containsnocycles).
Proof :(byinvariance)
Basecase :IniVally,thereisonly&lt;S&gt;inthequeue.
Hence,the invariantholds.
Induc(onstep :Letscheckthatthe invariant
conVnuestoholdineverystepofthealgorithm.
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
52</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>9/20/10
32ProofofSoundness
2.ReturnedpathdoesnotcontainGathead:
v0=G
Butclearly,thereturnedpathhasthepropertythat
Head(N)=G
Recallthepseudocode:
63
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
64/negationslash</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>9/20/10
28PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 55
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 56</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>9/20/10
3BrianWilliams,Fall105S B G A &lt;S&gt;&lt;B,S&gt;&lt;A,S&gt;&lt;G,B,S&gt;&lt;A,B,S&gt;GraphSearchisaKindofStateSpaceSearch
SBAGBGraphSearchisaKindOfTreeSearch
BrianWilliams,Fall106SoluVon:DepthFirstSearch(DFS)S D B A C G C G D C G S D B A C G C G D C G SoluVon:BreadthFirstSearch(BFS)</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>9/20/1
AutonomousSystems:
PlancomplexsequencesofacVons
Schedule Vghtresources
Monitorand diagnose behavior
Repairorrecongure hardware.
formulateas statespacesearch .
BrianWilliams,Fall10 3
FormalizingGraphSearch 
BrianWilliams,Fall10 4C 
S 
B G 
A 
D Input:A searchproblem SP=&lt;g,S,G&gt;where
graphg =&lt;V,E&gt;,
start vertex SinV,and
goal vertex GinV.
Output:A simplepath P=&lt;S,v2,G&gt;ingfromSto G.
(i.e.,&lt;vi,v &gt;E,andv ifij).i+1 ivj0 
2</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>7/2/11
11SoundnessandCompletenessof
StateSpaceSearch
SertacKaraman
16.41013
Sept20th,2010
2Assignments
Remember:
ProblemSet#2:Uninformedsearch
OutlastWednesday,
DuethisWednesday,September22nd

Reading:
 Today:ProofsandInducNon:Lecture2and3Notesof6.042.
 Wednesday:[AIMA]Ch.6.1;24.35ConstraintSaNsfacNon.
Tolearnmore:ConstraintProcessing,by RinaDechter 
 Chapter2:ConstraintNetworks
 Chapter3:ConsistencyEnforcingandPropagaNon</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>9/20/10
14SoundnessandCompletenessof
SearchAlgorithms
Today :
provestatementsaboutthesearchalgorithmswe
havestudiedintheclass.
studywhetherthealgorithmreturnsacorrect
soluVon.
studywhetherthealgorithmreturnsasoluVonatallwhenoneexists.
SoundnessandCompleteness
Givena problemPR,an algorithm thataYemptstosolvethis
problemmayhavethefollowingproperJes:
Soundness: 
ThesoluVonreturnedbythealgorithmiscorrect.
Completeness:
ThealgorithmalwaysreturnsasoluVon,ifoneexists.
IfthereisnosoluVon,thealgorithmreportsfailure.
Also, OpJmality :
ThealgorithmreturnstheopVmalsoluVon,ifitreturnsone.
28</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>9/20/10
16PseudoCodeForSimpleSearch
Let g be a Graph    G be the Goal vertex of g.   
      S be the start vertex of g    Q be a list of simple partial paths in GR,  
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  
d) Add children of head(N) to Visited; 
e) Go to step 2. 
31
SoundnessandCompleteness
Theorems
Wewouldliketoprovethefollowingtwotheorems:
Theorem1(Soundness) :
Simplesearchalgorithmissound.
Theorem2(Completeness) :
Simplesearchalgorithmiscomplete.
Wewilluseablendofprooftechniquesforprovingthem.
32</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>9/20/10
11ProofbyInducVon formalized
LetP(i)beastatementwithparameter i.
ProofbyinducVonstatesthefollowingimplicaVon:
P(0)isTrue(1)andP(i)impliesP( i+1)(2)
(1)and(2) implies P(i)isTrueforalli.
InducVonisoneofthe coreprinciplesofmathemaVcs.
Itisgenerallytakenasanaxiom,ortheaxiomsare
designedsothatinducVonprinciplecanbeproven.
21
AninducVonexample
Theorem :fn(n+ 1)1 + 2 +   +n= orall n.
Proof :
Basecase :P(0)isTrue.
Because,0=0.
InducVonstep:P(n)impliesP( n+1)
Assumethatthehypothesisholdsforn.
Forn+1:2
n(n+ 1)1 + 2 +   +n+ (n + 1) = +n+ 12
(n+ 1)(n + 2)=2</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>9/20/10
27PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 53
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 54</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>9/20/10
4BrianWilliams,Fall107SoluVon:DepthFirstSearch(DFS)S D B A C G C G D C G S D B A C G C G D C G SoluVon:BreadthFirstSearch(BFS)Depth-first:    Add path extensions to front of Q    Pick first element of Q 
Breadth-first:    Add path extensions to back of Q Pick first element of Q 
BrianWilliams,Fall108TheWorstofTheWorst
Search Method Worst Time Worst Space Shortest Path? Guaranteed to find path? Depth-first ~bm b*m No Yes for finite graph Breadth-first ~bm bm Yes unit lngth Yes Worst case time is proportional to number of nodes visited Worst case space is proportional to maximal length of Q S D B A C G C G D C G Whichisbeler,depthrstorbreadthrst?C S B G A D Assumed=mintheworstcase,andcallbothm.Bestrstcantexpandtolevelm+1,justm.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>9/20/10
33ProofofSoundness
3.SometransiVoninthereturnedpathisnotvalid:
f(vi1, vi)/ E orsome i{1,2, . . . , v k}
ContradictsLemma2!
Lemma2 :If&lt;v1,v2,,vk&gt;isapathinthe
queueatanygivenVme,thenitisvalid.
65
ProofofSoundness
4.Returnedpathisnotsimple:
f vi=vjorsomewith i, j{0,1, . . . , k } i=j
ContradictsLemma3!
Lemma3 :If&lt;v1,v2,,vk&gt;isapathinthe
queueatanygivenVme,thenitisasimple
path(containsnocycles).
66/negationslash</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>9/20/10
22PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
43
PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 44</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>9/20/10
12AfaultyinducVon
Theorem[!]:Allhorsesarethesamecolor.
Proof[!]:
Basecase :P(1)isTrue.
because,thereisonlyonehorse.
Induc(onstep :P(i)impliesP( i+1).
AssumethatP(i)is True.
Bythe induc(onhypothesis rst ihorsesarethesamecolor,andthe
lastihorsesarealsothesamecolor.
h1, h2, . . . , h i,hi+1 h1,h2, . . . , h i, hi+1
Soallthe i+1horsesmustbethesamecolor.
Hence,P( i+1)isalsoTrue.
Whatwentwronghere?
ProofbyInvariance
Acommontechniqueinalgorithmanalysis 
Showthatacertainpropertyholdsthroughout
inanalgorithm.
AssumethatthepropertyholdsiniVally.
Showthatinanystepthatthealgorithmtakes,
thepropertysVllholds.
Then,propertyholdsforever.
ItisasimpleapplicaVonofinducVon.Why?</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>9/20/10
36Acommontechniquein
analysisofalgorithms
Letsslightlymodifythealgorithm
Wewillanalyzethemodiedalgorithm.
Then,projectourresultstotheoriginal
algorithm.
PseudoCodeForSimpleSearch
Let g be a Graph    G be the Goal vertex of g.   
      S be the start vertex of g    Q be a list of simple partial paths in GR,  
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. // If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  
d) Add children of head(N) to Visited; 
e) Go to step 2. 
72</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9/20/10
9ProvingimplicaVons:
Simplestprooftechnique 
ToprovePimpliesQ,
AssumePandshowthatQlogicallyfollows.
Theorem:
If,then0x2 x3+ 4x + 1&gt;0
Proof:
Assume(P) 0x2
Then,,,andar x2x x+ 2 eallnonnegaVve
Then,isnonneg x(2x)(2 + x) aVve
Then,isnonneg x(2x)(2 + x) + 1 aVve
Then,mulVplyingoutthelewsidegives
(Q x3+ 4x + 1&gt;0 )
ProofbyContradicVon
ToprovethatastatementPis True.
Assumethatitisnot.
Showthatsomeabsurd(clearlyfalse)statementfollows.
Formalized :InordertoproveastatementPis True 
AssumethatPis False,
DeducealogicalcontradicVon(negaVonofaprevious
statementoranaxiom).</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>9/20/10
10ProofbyContradicVon
Theorem :isanirraVonalnumber.
Proof :
AssumethatisnotirraVonal.
Then,isaraVonalnumberandcanbewrilenas= a/b
where aand bareintegersand frac(onisinlowestterms
Then,squaringbothsidesandrearranginggives2= a2/b2
Then,amustbeeven
Then,a2mustbeamulVpleof4
Then,2b2mustalsobeamulVpleof4
Then,bisalsoeven
Then,thefracVonis notinthelowestterms
(since aand barebotheven)2

2
2
2
ProofbyInducVon
PickparameterNtodeneproblemsize.
NumberofedgesinthesoluVon.
Numberofnodesingraph.
BaseStep :N=0(orsmallN)
ProvepropertyforN=0
InducJonStep :
AssumepropertyholdsforN
ProvepropertyforN+1
Conclusion :propertyholdsforallproblemsizesN.20</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>9/20/10
25PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 49
PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 50</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>9/20/10
31ProofofSoundness
Assumethatthesearchalgorithmis notsound :
Letthereturnedpathbe &lt; v 0, v1, . . . , v k&gt;
Then,oneofthefollowingmustbe True:
1.ReturnedpathdoesnotstartwithS:
vk=S
2.ReturnedpathdoesnotcontainGathead:
v0=G
3.SometransiVoninthereturnedpathisnotvalid:
(vi1, vi)/ E forsome i{1,2, . . . , v k}
4.Returnedpathisnotsimple:
fvi=vj orsomewith i, j{0,1, . . . , k } i=j
61
ProofofSoundness
1.ReturnedpathdoesnotstartwithS: vk=S
But,thiscontradictsLemma1!
Lemma1 :If&lt;v1,v2,,vk&gt;isapathinthe
queueatanygivenVme,thenvk=S.
62/negationslash/negationslash
/negationslash
/negationslash</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>9/20/10
38ProofofCompleteness
DeniJon :Avertexvis reachablefromS,ifthereexistsa
path&lt;v0,v1,,vk&gt;thatstartsfromSandendsatv,i.e.,vk=
Sandv0=v.
Lemma2 :IfavertexvisreachablefromS,thenvisplaced
intothevisitedlistaweranitenumberofsteps.
ProofofCompleteness
Lemma2 :IfavertexvisreachablefromS,thenvisplacedintothevisitedlist
aweranitenumberofsteps.
Proof :(bycontradic(on)
AssumevisreachablefromS, butitisneverplacedonthevisitedlist.
SincevisreachablefromS,thereexistsapaththatisoftheform&lt;v0,v1,,
vk&gt;,wherev0=vandvk=S.
Letvibetherstnode(starVngfromvk)inthechainthatisneveraddedto
thevisitedlist.
(1)Notethatviwasnotinthevisitedlistbeforethisstep.
(2)Notealsothat(vi+1,vi)isin E.
Sincevi+1wasinthevisitedlist,thequeueincludedapath&lt;vi+1,,vk&gt;(not
necessarilythesameasabove),wherevk=S.
Thispathmusthavebeenpoppedfromthequeue,sincethereareonly
nitelymanydierentparValpathsandnopathisaddedtwice( byLemma
1)andviwasnotinthevisitedlist(seestatement1above).
Sinceitispoppedfromthequeue,then&lt;vi+1,vi,,vk&gt;mustbeplacedinto
queue(seestatement2above)and viplacedintothevisitedlist
Redstatementscontradict!</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>9/20/10
21PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenJme,thenvk=S.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 41
Anotherlemmatowardstheproof
DeniJon: Apath&lt;v0,v1,,vk&gt;isvalidif
f (vi1, vi)E orall i{1,2, . . . , k }
Lemma2 :If&lt;v1,v2,,vk&gt;isapathinthequeue
atanygivenVme,thenitisvalid.
Proof :(byinvariance)
Basecase :IniVallythereisonlyonepath&lt;S&gt;,whichis
valid.Hence,theinvariant holds.
Induc(onstep :Letscheckthatthe invariant conVnues
toholdineverystepofthealgorithm.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>9/20/10
41BacktotheAxiomaVcMethod
Doesitreallywork? 
EssenVallyallofwhatweknowinmathemaVcstodaycan
bederivedfromahandfulofaxiomscalledtheZarmeloFrankelsettheorywiththeaxiomof Choice(ZFC).
TheseaxiomsweremadeupbyZarmelo
(theydidnotexist apriori ,unlikephysicalphenomena).
Wedo notknowwhethertheseaxiomsare logically
consistent !
Soundscrazy!But,happenedbefore
Around1900,B.Russelldiscoveredthattheaxiomsofthat(me
werelogicallyinconsistent,i.e.,onecouldproveacontradic(on.
BacktotheAxiomaVcMethod
Doesitreallywork? 
ZFCaxiomsgivesonewhatshe/hewants:
Theorem:5+5=10.
However,absurdstatementscanalsobedriven:
Theorem(BanachTarski):Aballcanbecutintoanite
numberofpiecesandthenthepiecescanberearranged
tobuildtwoballsofthesamesizeoftheoriginal.
Clearly,thiscontradictsourgeometricintui(on!
Image by Benjamin D. Esham, in the public domain.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>9/20/10
13Provingstatementsaboutalgorithms
Handlewithcare!
Correctnessofsimplestalgorithmsmaybe
veryhardtoprove
Collatzconjecture:
Algorithm(Half OrTriple Plus OneHOTPO):
Givenaninteger n.
1.Ifniseven,then n=n/2
2.Ifnisodd,then n=3n+1
3.Ifn=1,thenterminate,elsegotostep1.
Conjecture:Foranyn,thealgorithmalways
terminates(withn=1).
Provingstatementsaboutalgorithms
Handlewithcare!
Collatzconjecture:
Firstproposedin1937 .
Itisnotknownwhetherthe
conjectureistrueorfalse.
First1000
numbers
PaulErds(19131996)
famousnumbertheorist
Mathema(csisnotyetready
forsuchproblems,1985.
First100
numbers
Images are in the public domain.  Images by Keenan Pepper and Jon McLoone.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>9/20/10
8TheaxiomaVcmethod
Euclidsaxiomproofapproachisnow
fundamentaltomathemaVcs!
Amazingly,essenVallyallmathemaVcscan
bederivedfromjustahandfulofaxioms
Howtoevenstartaproof?
Therearemanytemplates
(outlines,ortechniques)
Thedetailsdier
EuclidofAlexandria
EuclidstatuteinOxford
Provingan implica2on
SeveralmathemaVcalclaimsareoftheform:
IfP,thenQ ,orequivalently PimpliesQ. 
QuadraJcs: 
Ifand,2 b
ax+bx+c= 0 a= 0 then x=
InequaliJes:
If ,then
GoldbachsConjecture:
Ifn&gt;2,thennisasumoftwoprimes.b24ac
2a
0x2 x3+ 4x + 1&gt;0/negationslash</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>9/20/10
42BacktotheAxiomaVcMethod
Doesitreallywork? 

BacktotheAxiomaVcMethod
Doesitreallywork? 
Onthefundamentallimitsof mathema2cs
Godelshowedin1930thattherearesomeproposiVonsthat
aretrue,butdonotlogicallyfollowfromtheaxioms.
Theaxiomsarenotenough!
But,Godelalsoshowedthatsimplyaddingmoreaxiomsdoesnoteliminatethisproblem.Anysetofaxiomsthatis
 notcontradictorywillhavethesameproblem!
GodelsresultsaredirectlyrelatedtocomputaVon.Theseresultswerelaterusedby AlanTuring in1950stoinventa
revoluVonaryidea: computer 

 Images of Godel, Turing, and Einstein removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>9/20/10
5ElementsofAlgorithmDesign
DescripVon:(lastMonday)
Problemstatement.
Stylizedpseudocode,sucienttoanalyzeandimplementthe
algorithm.
ImplementaVon(lastWednesday).
Analysis:(lastWednesday)
Performance:
Timecomplexity:
howlongdoesittaketondasoluVon?
Spacecomplexity:
howmuchmemorydoesitneedtoperformsearch?
Correctness:(today)
Soundness:
whenasoluVonisreturned,isitguaranteedtobecorrect?
Completeness:
isthealgorithmguaranteedtondasoluVonwhenthereisone?
BrianWilliams,Fall10 9
Outline
Review
ProoftechniquesandtheaxiomaVcmethod
Proofsofsoundnessandcompletenessof
searchalgorithms
LimitsofaxiomaVcmethod
BrianWilliams,Fall10 10</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>9/20/10
29PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
WewouldliketoshowthateachnewlyaddedpathissimpleassumingNissimple.
Proof:(bycontradic2on) Assumeonepathisnotsimple.Then,achildrenof
head(N)appearsinN.But,thisiscontradictsLine4.b
 57
PseudoCodeForSimpleSearch
Invariant :If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisasimplepath.
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 58</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>9/20/10
24PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Inthiscasenonewpathisaddedtothequeue.
 47
PseudoCodeForSimpleSearch
Invariant: If&lt;v1,v2,,vk&gt;isapathinthequeueatanygivenVme,thenitisvalid 
1. Initialize Q with partial path (S) as only entry; set Visited = ( ); 
2. If Q is empty, fail.  Else, pick some partial path N from Q; 
3. If head(N) = G, return N;    (goal reached!) 
4. Else  
a) Remove N from Q; 
b) Find all children of head(N) (its neighbors in g) not in Visited 
and create a one-step extension of N to each child; 
c) Add to Q all the extended paths;  d) Add children of head(N) to Visited; 
e) Go to step 2. 
Beforethisline: assumethatinvariantholds.
AIerthisline:showthatinvariantissJlltrue.
 Notethatvalidityholdsforallnewlyaddedpath(fromLine4.b)
 48</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>9/20/10
34ProofofSoundness
Assumethatthesearchalgorithmis notsound :
Letthereturnedpathbe &lt; v 0, v1, . . . , v k&gt;
Then,oneofthefollowingmustbe True:
1.ReturnedpathdoesnotstartwithS:
vk=S
2.ReturnedpathdoesnotcontainGathead:
v0=G
3.SometransiVoninthereturnedpathisnotvalid:
(vi1, vi)/ E forsome i{1,2, . . . , v k}
4.Returnedpathisnotsimple:
fvi=vj orsomewith i, j{0,1, . . . , k } i=j
67
ProofofSoundness
Assumethatthesearchalgorithmis notsound :
WereachacontradicVoninallcases.
Hence,thesimplesearchalgorithmissound ./negationslash/negationslash
/negationslash</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Mathematical programming I [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec16/</lecture_pdf_url>
      <lectureno>16</lectureno>
      <slides>
        <slide>
          <slideno>19</slideno>
          <text>Geometric Interpretation (2)   
Consider the following simple LP: 
max z = x1 +2x2 = (1, 2) (x1, x2),
s.t.: x1  3,
x1 + x2  5, 
x1, x2  0. 
The c vecto r denes the gradient of
the cost.
Constant-cost loci are planes normal to c. 
x1x2c
Most often, the optimal point is located at a vertex (corner) of the 
feasible region. 
If there is a single optimum, it must be a corner of the feasible region. 
If there are more than one, two of them must be adjacent corners. 
If a corner does not have any adjacent corner that provides a better 
solution, then that corner is in fact the optimum. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 17 / 23</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Converting a LP into standard form 
Convert to maximization problem by ipping the sign of c. 
Turn all technological inequalit y constraints into equali ties: 
less than constraints: intro duce slack variables. 
n n
aij xj  bi  aij xj + si = bi , si  0. 
j=1 j=1 
greater than constraints: intro duce excess variables. 
n n
aij xj  bi  aij xj  ei = bi , ei  0. 
j=1 j=1 
Flip the sign of non-p ositive variables: xi  0  xi = xi  0. 
If a variable does not have sign constraints, use the following trick: 
xi  xi  xi, xi, xi  0. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 18 / 23</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Assignments
Readings 
Lecture notes 
[IOR] Chapters 2, 3, 9.1-3. 
[PA] Chapter 6.1-2 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 2 / 23</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Arema rkably practical and theo retical framew ork:LPs eatalargechunk
oftotal scientic computational powerexpended today.Itiscrucial for
economic success ofmost distribution/transp ortindustries and to
manufacturing.
Nowbecom essuitable forreal-time applications, often asthe
fundamental tooltosolve orapproximate much morecomplex
optimization problem .
Historical Notes
Histo rical contributo r: G. Dantzig (1914-2005), in the late 1940s. (He 
was at Stanfo rd Universit y.) Realize many real-w orld design problems 
can be formulated as linea r programs and solve d eciently . Finds 
algorithm, the Simplex metho d, to solve LPs. As of 1997, still best 
algorithm for most applications. 
So important for world economy that any new algorithmic development 
on LPs is likely to make the front page of majo r newspap ers (e.g. NY 
times, Wall Street Journal). Example: 1979 L. Khachy ans adaptation of 
ellipsoid algorithm, N. Karmarkars new interio r-point algorithm. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 15 / 23</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Another look at shortest path problems (3)
Summa rizing, what we want to do is: 
minimize nE 
i=1 wi xi 
subject to:  
ei In(s ) xi   
ej Out(s ) xj = 0, s  V ; 
xi  0, i = 1, . . . , nE ; 
x0 = 1. 
It turns out that the solution of this problem yields the shortest path. 
(Interestingly , we do not have to set that xi  {0, 1}, this will be 
automatically satised by the optimal solution!) 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 7 / 23</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>A re-ghting problem: formulation (2) 
Let tA1, tA2, tA3 the the time vehicle A devotes to re 1, 2, 3,
respectively .
Dente tB1, tB2, tB3 in a simila r way, for vehicle B.
Let T be the total time needed to extinguish all three res.
Optimal value (and optimal strategy) found solving the following
problem:
min T 
s.t.: tA1 +2tB1 = 1000 , 
tA2 +2tB2 = 2000 , 
tA3 +2tB3 = 3000 , 
tA1 + tA2 + tA3  T , 
tB1 + tB2 + tB3  T , 
tA1, tA2, tA3, tB1, tB2, tB3, T  0. 
(if you are curious about the solution, the optimal T is 2000 time 
units) 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 10 / 23</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>A na  ve algorithm (2)
One could possibly generate all basic feasible solutions, and then
check the value of the cost function, nding the optimum by
enumeration.
Problem : how many candidates? 
n n! = . n  m m!(n  m)! 
for a small problem with n = 10, m = 3, we get 120 candidates. 
this numb er grows very quickly , the typical size of realistic LPs is such 
that n,m are often in the range of several hundreds, or even thousands. 
Much more clever algorithms exist: stay tuned. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 23 / 23</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410  / 16.413 Principles of Autonomy and Decision Making 
Fall 2010 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Outline 
1 
2 
3 
Mathematical Programming 
Linea r Programming 
Geometric Interp retation 
Geometric Interp retation 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 19 / 23</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Soimportant forworldeconomy that anynew algorithmic development
onLPs islikelytomakethefront page ofmajo rnewspap ers(e.g. NY
times, WallStreet Journal). Example: 1979 L.Khachy ansadaptation of
ellipsoid algorithm, N.Karmarkarsnew interio r-point algorithm.
Arema rkably practical and theo retical framew ork:LPs eatalargechunk
oftotal scientic computational powerexpended today.Itiscrucial for
economic success ofmost distribution/transp ortindustries and to
manufacturing.
Nowbecom essuitable forreal-time applications, often asthe
fundamental tooltosolve orapproximate much morecomplex
optimization problem .
Historical Notes
Histo rical contributo r: G. Dantzig (1914-2005), in the late 1940s. (He 
was at Stanfo rd Universit y.) Realize many real-w orld design problems 
can be formulated as linea r programs and solve d eciently . Finds 
algorithm, the Simplex metho d, to solve LPs. As of 1997, still best 
algorithm for most applications. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 15 / 23</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Another look at shortest path problems
Cost formula tion 
The cost of a path P is the sum of the cost of the edges on the path. 
Can we express this as a simple mathematical formula? 
Label all the edges in the graph with consecutive integers, e.g., 
E = {e1, e2, . . . , enE }. 
Dene wi = w(ei ), for all i  1, . . . , nE . 
Asso ciate with each edge a variable xi , such that: 
xi =  1 if ei  P, 
0 otherwise. 
Then, the cost of a path can be written as: 
Cost (P) = nE 
i=1 wi xi . 
Notice that the cost is a linear function of the unkno wns {xi } 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 5 / 23</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Outline 
1 
2 
3 Mathematical Programming 
Linea r Programming 
Geometric Interp retation 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 11 / 23</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Outline
1 
2 
3 Mathematical Programming 
Linea r Programming 
Histo rical notes 
Geometric Interp retation 
Reduction to standa rd form 
Geometric Interp retation 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 13 / 23</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413 
Principles of Autonomy and Decision Making 
Lecture 16: Mathematical Programming I 
Emilio Frazzoli 
Aeronautics and Astronautics
Massachusetts Institute of Technology
Novemb er 8, 2010 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 1 / 23</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Shortest Path Problems on Graphs
Input: V , E , w , s, G : 
V : set of vertices (nite, or in some cases countably innite). 
E  V  V : set of edges. 
w : E  R+, e  w(e): a function that associates to each edge a strictly 
positive weight (cost, length, time, fuel, prob. of detection). 
S, G  V : respectively , start and end sets. Either S or G , or both, 
contain only one element. For a point-to-p oint problem, both S and G 
contain only one element. 
Output: T , W  
T is a weighted tree (graph with no cycles) containing one 
minimum-w eight path for each pair of start-goal vertices (s, g)  S  G . 
W : S  G  R+ is a function that returns, for each pair of start-goal 
vertices (s, g)  S  G , the weight W (s, g ) of the minimum-w eight path 
from s to g. The weight of a path is the sum of the weights of its edges. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 3 / 23</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Another look at shortest path problems (2)
Constraints formulation 
Clearly, if we just wanted to minimize the cost, we would choose 
xi = 0, for all i = 1, . . . , nE : this would not be a path connecting the 
start and goal vertices (in fact, it is the empt y path). 
Add these constraints: 
There must be an edge in P that goes out of the start vertex. 
There must be an edge in P that goes into the goal vertex. 
Every (non start/goal) node with an incoming edge must have an 
outgoing edge 
A neater formulation is obtained by adding a virtual edge e0 from 
the goal to the start vertex: 
x0 = 1, i.e., the virtual edge is always chosen. 
Every node with an incoming edge must have an outgoing edge 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 6 / 23</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Example: point-to-point shortest path
Find the minimum-w eight path from s to g in the graph below: 
Solution: a simple path P = s, a, d, g (P = s, b, d, g would be 
acceptable, too), and its weight W (s, g) = 8. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 4 / 23</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Nowbecom essuitable forreal-time applications, often asthe
fundamental tooltosolve orapproximate much morecomplex
optimization problem .
Historical Notes
Histo rical contributo r: G. Dantzig (1914-2005), in the late 1940s. (He 
was at Stanfo rd Universit y.) Realize many real-w orld design problems 
can be formulated as linea r programs and solve d eciently . Finds 
algorithm, the Simplex metho d, to solve LPs. As of 1997, still best 
algorithm for most applications. 
So important for world economy that any new algorithmic development 
on LPs is likely to make the front page of majo r newspap ers (e.g. NY 
times, Wall Street Journal). Example: 1979 L. Khachy ans adaptation of 
ellipsoid algorithm, N. Karmarkars new interio r-point algorithm. 
A rema rkably practical and theo retical framew ork: LPs eat a large chunk 
of total scientic computational power expended today. It is crucial for 
economic success of most distribution/transp ort industries and to 
manufacturing. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 15 / 23</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Linear Programs
The Standa rd Form of a linea r program is an optimization problem 
of the form 
max	 z = c1x1 + c2x2 + ..., cnxn, 
s.t.:	 a11x1 + a12x2 + ... + a1nxn = b1, 
a21x1 + a22x2 + ... + a2nxn = b2, 
... 
am1x1 + am2x2 + ... + amnxn = bm, 
x1, x2,..., xn  0. 
In a more compact form, the above can be rewritten as: 
min z = c T x, 
s.t.: Ax = b, 
x  0. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 14 / 23</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Geometric Interpretation (2)
Consider the following simple LP: 
max z = x1 +2x2 = (1, 2) (x1, x2),
s.t.: x1  3,
x1 + x2  5, 
x1, x2  0. 
The c vecto r denes the gradient of
the cost.
Constant-cost loci are planes normal to c. 
x1x2c
Most often, the optimal point is located at a vertex (corner) of the 
feasible region. 
If there is a single optimum, it must be a corner of the feasible region. 
If there are more than one, two of them must be adjacent corners. 
If a corner does not have any adjacent corner that provides a better 
solution, then that corner is in fact the optimum. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 21 / 23</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Another look at shortest path problems (4)        
Consider again the following shortest path problem: 
min 2x1 +5x2 +4x3 +2x4 + x5 +5x6 +3x7 +2x8 
s.t.: x0  x1  x2 =0, (node s); 
x1  x3  x4 =0, (node a); 
x2  x5  x6 =0, (node b); 
x4  x7 =0, (node c); 
x3 + x5 + x7  x8 =0, (node c); 
x2 + x5  x0 =0, (node g); 
xi  0, i =1,..., 8; 
x0 =1. 
Notice: cost function and const raints are ane (linea r) functions of the 
unkno wns (x1,..., x8). 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 8 / 23</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Mathematical Programming
Many (most, maybe all?) problems in engineering can be dened as: 
A set of constraints dening all candidate (feasible) solutions, e.g., 
g(x)  0. 
A cost function dening the qua lity of a solution, e.g., f (x). 
The formalization of a problem in these terms is called a 
Mathematical Program, or Optimization Problem. 
(Notice this has nothing to do with computer programs!) 
The two problems we just discussed are examples of mathematical 
program. Furthermo re, both of them are such that both f and g are 
ane functions of x. Such problems are called Linea r Programs. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 12 / 23</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Geometric Interpretation
Consider the following simple LP:
max z = x1 + 2x2 = (1, 2)  (x1, x2), 
s.t.: x1  3, 
x1 + x2  5, 
x1, x2  0. 
Each inequalit y constraint denes a 
hyperplane, and a feasible half-space. 
The intersection of all feasible half 
x1x2c
spaces is called the feasible region. 
The feasible region is a (possibly unbounded ) polyhedron. 
The feasible region could be the empt y set: in such case the problem 
is said unfeasible . 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 20 / 23</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Historical Notes
Histo rical contributo r: G. Dantzig (1914-2005), in the late 1940s. (He 
was at Stanfo rd Universit y.) Realize many real-w orld design problems 
can be formulated as linea r programs and solve d eciently . Finds 
algorithm, the Simplex metho d, to solve LPs. As of 1997, still best 
algorithm for most applications. 
So important for world economy that any new algorithmic development 
on LPs is likely to make the front page of majo r newspap ers (e.g. NY 
times, Wall Street Journal). Example: 1979 L. Khachy ans adaptation of 
ellipsoid algorithm, N. Karmarkars new interio r-point algorithm. 
A rema rkably practical and theo retical framew ork: LPs eat a large chunk 
of total scientic computational power expended today. It is crucial for 
economic success of most distribution/transp ort industries and to 
manufacturing. 
Now becom es suitable for real-time applications, often as the
fundamental tool to solve or approximate much more complex
optimization problem .
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 15 / 23</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Geometric Interpretation
Consider the following simple LP:
max z = x1 + 2x2 = (1, 2)  (x1, x2), 
s.t.: x1  3, 
x1 + x2  5, 
x1, x2  0. 
Each inequalit y constraint denes a 
hyperplane, and a feasible half-space. 
The intersection of all feasible half 
x1x2c
spaces is called the feasible region. 
The feasible region is a (possibly unbounded ) polyhedron. 
The feasible region could be the empt y set: in such case the problem 
is said unfeasible . 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 16 / 23</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>or,really:min z=cT
yy+cT
ss
s.t.: Ayy+Is=b,
y,s0.
This amounts to:
picking nyinequalit yconstra ints, (notice that n=ny+ns=ny+m).
making them active (orbinding),
nding the(unique) point where allthese hyperplanes meet.
Ifallthevariables arenon-negative, this point isinfact avertex ofthe
feasible region.
A na  ve algorithm (1) 
Recall the standa rd form: 
Tmin z = cx 
s.t.: Ax = b, 
x  0. 
Corners of the feasible regions (also called basic feasible solutions ) 
are solutions of Ax = b (m equations in n unkno wns, n &gt; m), 
obtained setting n  m variables to zero, and solving for the others 
(basic variables), ensuring that all variables are non-negative. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 22 / 23</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>A na  ve algorithm (1) 
Recall the standa rd form: 
  min z = cT x min z = cyT y + csT s 
s.t.: Ax = b, or, really: s.t.: Ay y + Is = b,  
x  0. y, s  0. 
Corners of the feasible regions (also called basic feasible solutions ) 
are solutions of Ax = b (m equations in n unkno wns, n &gt; m), 
obtained setting n  m variables to zero, and solving for the others 
(basic variables), ensuring that all variables are non-negative. 
This amounts to: 
picking ny inequalit y constra ints, (notice that n = ny + ns = ny + m). 
making them active (or binding), 
nding the (unique) point where all these hyperplanes meet. 
If all the variables are non-negative, this point is in fact a vertex of the 
feasible region. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 22 / 23</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>A re-ghting problem: formulation   
Three res 
Fire 1 needs 1000 units of water; 
Fire 2 needs 2000 units of water; 
Fire 3 needs 3000 units of water. 
Two re-ghting autonomous aircraft 
Aircraft A can deliver 1 unit of water 
per unit time; 
Aircraft B can deliver 2 units of water 
per unit time. 
Objective 
It is desired to extinguish all the res in 
minimum time. Image by MIT OpenCourseW are. 
E. Frazzoli (MIT) L07: Mathematical Programming I Novemb er 8, 2010 9 / 23</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Global path planning I: informed search [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec14/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text>Example of Uniform-Cost Search: Step 1
Q:
path
cost
hsi
0
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 7 / 46</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Example of Uniform-Cost Search: Step 2
Q:
path
cost
ha;si
2
hb;si
5
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 8 / 46</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Example of Uniform-Cost Search: Step 6
Q:
state
cost
hd;c;a;si
7
hg;d;a;si
8
hg;b;si
10
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 12 / 46</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Example of Uniform-Cost Search: Step 7
Q:
state
cost
hg;d;a;si
8
hg;d;c;a;si
9
hg;b;si
10
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 13 / 46</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Example of Greedy (Best-First) Search: step 5
Q:
path
cost
h
hg;b;si
10
0
hd;a;si
6
4
hd;c;a;si
7
4
s
10
start
a
2
b
3
c
1
d
4
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 21 / 46</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Example of Greedy (Best-First) Search: Step 1
Q:
path
cost
h
hsi
0
10
s
10
start
a
2
b
3
c
1
d
4
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 17 / 46</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Example of A Search: step 4
Q:
path
g
h
f
hb;si
5
3
8
hd;a;si
6
5
11
hd;c;a;si
7
5
12
s
10
start
a
2
b
3
c
1
d
5
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 29 / 46</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Example of Uniform-Cost Search: Step 5
Q:
state
cost
hd;a;si
6
hd;c;a;si
7
hg;b;si
10
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 11 / 46</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Example: point-to-point shortest path
Find the minimum-weight path from stogin the graph below:
Solution: a simple path P=hg;d;a;si(P=hg;d;b;siwould be
acceptable, too), with weight w(P) = 8.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 5 / 46</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Example of A Search: step 3
Q:
path
g
h
f
hc;a;si
4
1
5
hb;si
5
3
8
hd;a;si
6
5
11
s
10
start
a
2
b
3
c
1
d
5
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 28 / 46</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Example of Greedy (Best-First) Search: Step 3
Q:
path
cost
h
hc;a;si
4
1
hb;si
5
3
hd;a;si
6
4
s
10
start
a
2
b
3
c
1
d
4
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 19 / 46</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Example of Greedy (Best-First) Search: Step 4
Q:
path
cost
h
hb;si
5
3
hd;a;si
6
4
hd;c;a;si
7
4
s
10
start
a
2
b
3
c
1
d
4
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 20 / 46</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>A Search
Q hstarti; // Initialize the queue with the starting node
while Q is not empty do
Pick the path Pwith minimum estimated cost f(P) =g(P) +h(head (P))
from the queue Q;
ifhead (P) =goal then return P; // We have reached the goal
foreach vertex v such that (head (P);v)2E,do
addhv;Pito the queue Q;
return FAILURE ; // Nothing left to consider.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 25 / 46</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Uniform-Cost Search
Q hstarti; // Initialize the queue with the starting node
while Q is not empty do
Pick (and remove) the path Pwith lowest cost g=w(P) from the queue Q;
ifhead(P) = goal then return P; // Reached the goal
foreach vertex v such that (head (P);v)2E,do //for all neighbors
addhv;Pito the queue Q; // Add expanded paths
return FAILURE ; // Nothing left to consider.
Note: no visited list!
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 6 / 46</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Greedy (Best-First) Search
Q hstarti; // Initialize the queue with the starting node
while Q is not empty do
Pick the path Pwith minimum heuristic cost h(head (P)) from the queue Q;
ifhead (P) =goal then return P; // We have reached the goal
foreach vertex v such that (head (P);v)2E,do
addhv;Pito the queue Q;
return FAILURE ; // Nothing left to consider.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 16 / 46</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Example of A Search: step 5
Q:
path
g
h
f
hg;b;si
10
0
10
hd;a;si
6
5
11
hd;c;a;si
7
5
12
s
10
start
a
2
b
3
c
1
d
5
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 30 / 46</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Example of A Search: step 2
Q:
path
g
h
f
ha;si
2
2
4
hb;si
5
3
8
s
10
start
a
2
b
3
c
1
d
5
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 27 / 46</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Example of Uniform-Cost Search: Step 4
Q:
state
cost
hb;si
5
hd;a;si
6
hd;c;a;si
7
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 10 / 46</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Outline
1Informed search methods: Introduction
Shortest Path Problems on Graphs
Uniform-cost search
Greedy (Best-First) Search
2Optimal search
3Dynamic Programming
E. Frazzoli (MIT) L05: Informed Search November 1, 2010 2 / 46</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Example of Greedy (Best-First) Search: Step 2
Q:
path
cost
h
ha;si
2
2
hb;si
5
3
s
10
start
a
2
b
3
c
1
d
4
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 18 / 46</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Admissible heuristics for the 8-puzzle
Initial state:
1
5
2
6
3
7
4
8
Goal state:
1
2
3
4
5
6
7
8
Which of the following are admissible heuristics?
h= 0 YES , always good
h= 1NO, not valid in goal state
h= number of tiles in the wrong positon YES , \teleport" each tile
to the goal in one move
h= sum of (Manhattan) distance between tiles and their goal
position.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 39 / 46</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Example of Uniform-Cost Search: Step 3
Q:
state
cost
hc;a;si
4
hb;si
5
hd;a;si
6
s
start
a
b
c
d
g
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 9 / 46</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Admissible heuristics for the 8-puzzle
Initial state:
1
5
2
6
3
7
4
8
Goal state:
1
2
3
4
5
6
7
8
Which of the following are admissible heuristics?
h= 0 YES , always good
h= 1NO, not valid in goal state
h= number of tiles in the wrong positon YES , \teleport" each tile
to the goal in one move
h= sum of (Manhattan) distance between tiles and their goal
position. YES , move each tile to the goal ignoring other tiles.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 39 / 46</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Dijkstra's algorithm: example
InfInf
Inf04652162
4046521
52
404652152
4046521
Dynamic programming requires the computation of all optimal
sub-paths, from all possible initial states (curse of dimensionality).
On-line computation is easy via state feedback: convert an open-loop
problem into a feedback problem. This can be useful in real-world
applications, where the state is subject to errors.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 45 / 46</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Admissible heuristics for the 8-puzzle
Initial state:
1
5
2
6
3
7
4
8
Goal state:
1
2
3
4
5
6
7
8
Which of the following are admissible heuristics?
h= 0 YES , always good
h= 1
h= number of tiles in the wrong positon
h= sum of (Manhattan) distance between tiles and their goal
position.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 39 / 46</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 14: Informed Search
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
November 1, 2010
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 1 / 46</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Uniform-Cost Search
Q hstarti; // Initialize the queue with the starting node
while Q is not empty do
Pick (and remove) the path Pwith lowest cost g=w(P) from the queue Q;
ifhead(P) = goal then return P; // Reached the goal
foreach vertex v such that (head (P);v)2E,do //for all neighbors
addhv;Pito the queue Q; // Add expanded paths
return FAILURE ; // Nothing left to consider.
Note: no visited list!
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 6 / 46</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Outline
1Informed search methods: Introduction
2Optimal search
A search
3Dynamic Programming
E. Frazzoli (MIT) L05: Informed Search November 1, 2010 23 / 46</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Outline
1Informed search methods: Introduction
2Optimal search
3Dynamic Programming
E. Frazzoli (MIT) L05: Informed Search November 1, 2010 42 / 46</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Example of A Search: Step 1
Q:
path
g
h
f
hsi
0
10
10
s
10
start
a
2
b
3
c
1
d
5
g
0
2
2
3
4
5
5
2
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 26 / 46</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Admissible heuristics for the 8-puzzle
Initial state:
1
5
2
6
3
7
4
8
Goal state:
1
2
3
4
5
6
7
8
Which of the following are admissible heuristics?
h= 0
h= 1
h= number of tiles in the wrong positon
h= sum of (Manhattan) distance between tiles and their goal
position.
E. Frazzoli (MIT)L05: Informed SearchNovember 1, 2010 39 / 46</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Foundations II: complexity of state space search [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec03/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides>
        <slide>
          <slideno>7</slideno>
          <text>Analysis uses Machine-independent
Time and Space 
Performance depends on computer speed: 
 Relative speed (run on same machine) 
 Absolute speed (on different machines) 
Big idea: 
 Ignore machine-dependent constraints 
 Look at growth of T(n) as n   
Asymptotic Analysis  
Brian Williams, Fall  10 15 
Asymptotic notation 
O-notation (upper bounds): 
 2n2 = O(n3)
 means 2n2  cn3 for sufficiently large c &amp; n 
 f(n) = O( g(n) ) 
if there exists constants c &gt; 0, n0 &gt; 0 
such that 0 f(n)  c g(n ) for all n  n . o 
Brian Williams, Fall  10 16 
8</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
16.410  / 16.413 Principles of Autonomy and Decision Making 
Fall 2010 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Outline
 Analysis 
 Iterative deepening 
Brian Williams, Fall  10 41 
Iterative Deepening (IDS) 
Idea: 
Explore tree in breadth-first order , using depth-first search . 
 Search tree to depth 1,  . 
called depth-limited search 
Level 0 
Level 1 
Level 2 
Level 3 C G S 
D B A 
C G 
C G D 
Brian Williams, Fall  10 42 
21</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Pseudo Code For Simple Search 
Let g be a Graph G be the Goal vertex of g.
 S be the Start vertex of g Q be a list of simple partial paths in GR,
1./.notdef.g0001 Initialize Q with partial path (S) as only entry; set V isited = ( ); 
2./.notdef.g0001 If Q is empty , fail.  Else, pick some partial path N from Q; 
3./.notdef.g0001 If head(N) = G, return N; (goal reached!) 
4./.notdef.g0001 Else 
a)/.notdef.g0001 Remove N from Q; 
b)/.notdef.g0001 Find all children of head(N) (its neighbors in g) not in V isited 
and create a one-step extension of N to each child; 
c)/.notdef.g0001 Add to Q all the extended paths;
d)/.notdef.g0001 Add children of head(N) to V isited; 
Brian Williams, Fall  10 9 
e)/.notdef.g0001 Go to step 2. 
Solution: Depth First Search (DFS) 
S 
D B A 
C G 
C G D 
C G Depth-first: 
Add path extensions to front  of Q 
Pick first element of Q 
Solution: Breadth First Search (BFS) 
S 
D A 
C 
C G D 
C B Breadth-first: 
Add path extensions to back  of Q G 
Pick first element of Q 
G 
Brian Williams, Fall  10 10 
5</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Performance and Resource Usage 
Which is better , depth-first  or breadth-first? 
C 
G 
A 
D S 
D B A 
C G 
C G D 
C G S 
B 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 27 
Performance and Resource Usage 
Which is better , depth-first or breadth-first ? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 28 
14</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Soundness and Completeness 
(next Monday) 
Soundness: 
 All returned solutions are correct. 
 Returns only simple paths from S to G. 
Completeness: 
 Always returns a solution if one exists. 
 Returns a simple path from S to G whenever S is 
connected to G. 
Brian Williams, Fall  10 47 
Summary
 Most problem solving tasks may be encoded as state space 
search. 
 Basic data structures for search are graphs and search trees. 
 Depth-first and breadth-first search may be framed, 
as instances of a generic search strategy. 
 Cycle detection is required to achieve efficiency and 
completeness. 
 Complexity analysis shows that breadth-first is preferred in 
terms of optimality and time, while depth-first is preferred 
in terms of space. 
 Iterative deepening draws the best from depth-first and 
breadth-first search. 
Brian Williams, Fall  10 48 
24</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Analysis of Uninformed  
Search Methods 
Brian Williams, Fall  10 1 
Brian C. 
Williams 
Draws from materials in:&#13; 16.410-13 
6.034 Tomas Lozano Perez,&#13;
Russell and Norvig AIMA&#13; Sep 15th, 2010 
6.046J Charles E. Leiserson&#13;
Assignments 
Assignment:  
Problem Set #1 due today, Wed Sept 15th, 2010. 
Problem Set #2: Uninformed Search out today,  
due Wednesday, September 22nd, 20010. 
Reading:  
Today: Asymptotic Analysis, Lecture 2 Notes of 6.046J 
               Recurrences, Lecture 12 Notes of 6.042J.  
Monday: Proofs &amp; Induction, Lectures 2 and 3 of 6.042J. 
Brian Williams, Fall  10 2</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Worst Case Space for Breadth-first 
Worst case space Sdfs is proportional to maximum length of Q 
Level 1 
Level d Level 0 
Level d+1 b 
bd+1- b . . . 1 
bd 
Sbfs = [bd+1- b + 1]*cbfs
 = O(bd+1) 
Brian Williams, Fall  10 33 
Performance and Resource Usage 
Which is better , depth-first or breadth-first ? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bd+1 bd+1 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 34 
17</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Worst Case Space for Depth-first 
Worst case space Sdfs is proportional to maximum length of Q 
 If a node is queued its parent and siblings have been queued , 
and its parent dequeued . 
Brian Williams, Fall  10 23 Level 1 
Level m Level 0 
Worst Case Space for Depth-first 
Worst case space Sdfs is proportional to maximuml length of Q 
 If a node is queued its parent and siblings have been queued , 
and its parent dequeued . 
Sdfs [(b-1)*m+1] *cdfswhere cdfs is space per node. 
 At most one sibling of a node has its children queued . 
  Sdfs = [(b-1)*m+1] *cdfs 
 Sdfs = O(b*m) + add visited list Level 1 
Level m Level 0 
b-1 
b-1 
b . . . 
Brian Williams, Fall  10 24 
12</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Outline
 Review 
 Analysis 
 Depth-first search 
 Breadth-first search 
 Iterative deepening 
Brian Williams, Fall  10 11 
Elements of Algorithm Design 
Description: (last Monday) 
 Problem statement. 
 Stylized pseudo code, sufficient to analyze and implement the 
algorithm.
 Implementation (last Wednesday). 
Analysis: (today) 
 Performance: 
 Time complexity: 
 how long does it take to find a solution? 
 Space complexity:
 how much memory does it need to perform search? 
 Correctness: (next Monday) 
 Soundness: 
 when a solution is returned, is it guaranteed to be correct? 
 Completeness:
 is the algorithm guaranteed to find a solution when there is one? 
Brian Williams, Fall  10 12 
6</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Formalizing Graph Search 
Input: A search pr oblem  SP =  &lt;g, S, G&gt; wher e 
graph g  = &lt;V , E&gt;,  
start  vertex S in V, and 
goal vertex G in V. 
Output: A simple path  P = &lt;S, v2,  G&gt; in g fr om S to G.
 (i.e., &lt;vi,vi+1&gt;  E, and vi  vjif i  j ). 
C 
S 
B G 
A 
D 
Brian Williams, Fall  10 5 
Brian Williams, Fall  10 6 S 
B G A 
&lt;S&gt; 
&lt;B, S&gt; &lt;A, S&gt; 
&lt;G, B, S&gt; &lt; A, B, S&gt; Graph Search is a Kind 
of State Space Search 
S 
B A 
G B Graph Search is a Kind 
Of Tree Search 
3</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Solution: Depth First Search (DFS) 
S 
D B A 
C G 
C G D 
C G 
Solution: Breadth First Search (BFS) 
S 
D B A 
C G 
C G D 
C G 
Brian Williams, Fall  10 7
Brian Williams, Fall  10 8 S 
B G A &lt;S&gt; Generate (Q) Test 
&lt;A, S&gt;&lt;B, S&gt; 
Visited S 
4</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Iterative Deepening (IDS) 
Idea: 
Explore tree in breadth-first order , using depth-first search . 
 Search tree to depth 1, then 2, . 
called depth-limited search 
S 
D B A 
C G 
C G D 
C G Level 1 
Level 2 Level 0 
Level 3 
Brian Williams, Fall  10 43 
Iterative Deepening (IDS) 
Idea: 
Explore tree in breadth-first order , using depth-first search . 
 Search tree to depth 1, then 2, then 3 . 
called depth-limited search 
S 
D B A 
C G 
C G D 
C G Level 1 
Level 2 Level 0 
Level 3 
Brian Williams, Fall  10 44 
22</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Worst case time is proportional to number of vertices visited 
Worst case space is proportional to maximum length of Q Set definition of O-notation 
O(n3) = { all functions bounded by cn3 } 
2n2  O(n3) 
O(g(n))  = {f(n) | there exists constants 
c &gt; 0, n0 &gt; 0 such that 
0 f(n)  c g(n)  for all n  no} 
Brian Williams, Fall  10 17 
Performance and Resource Usage 
Which is better , depth-first  or breadth-first? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first 
Breadth-first 
Brian Williams, Fall  10 18 
9</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>For best first search, which runs out first  time or memory? 
Growth for Best First Search 
b = 10; 10,000 nodes/sec; 1000 bytes/node 
Depth Nodes Time Memory 
2 1,100 .11 seconds 1 megabyte 
4 111,100 11 seconds 106 megabytes 
6 107 19 minutes 10 gigabytes 
8 109 31 hours 1 terabyte 
10 1011 129 days 101 terabytes 
12 1013 35 years 10 petabytes 
14 1015 3,523 years 1 exabyte 
Brian Williams, Fall  10 39 
How Do We Get The
Best of Both Worlds? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bd+1 bd+1 Yes unit lngth Yes 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 40 
20</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Performance and Resource Usage 
Which is better , depth-first or breadth-first ? 
S C 
A B G 
A 
D C D G D 
C G C G S 
B 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bd+1 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 31 
Worst Case Space for Breadth-first 
Worst case space Sdfs is proportional to maximum length of Q 
Level 1 
Level d Level 0 
Level d+1 
Brian Williams, Fall  10 32 
16</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Outline
 Review 
 Analysis 
 Depth-first search 
 Breadth-first search 
 Iterative deepening 
Brian Williams, Fall  10 3 
Autonomous Systems: 
 Plan complex sequences of actions 
 Schedule  tight resources 
 Monitor  and diagnose  behavior 
 Repair  or reconfigure  hardware. 
formulate as state space search . 
Brian Williams, Fall  10 4 
2</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Worst Case Time for Breadth-first 
Worst case time T is proportional to number of nodes visited 
Level 1 
Level d Level 0 
Level d+1 
Level m . . . 
Consider case where solution is at level d (absolute worst is m): 
Brian Williams, Fall  10 29 
Worst Case Time for Breadth-first 
Worst case time T is proportional to number of nodes visited 
Level 1 
Level d Level 0 
Level d+1 bd+1- b b . . . 1 
bd 
Level m . . . 
Consider case where solution is at level d (absolute worst is m): 
Tbfs = [bd+1 + bd +  b + 1 - b] * cbfs
 = [bd+2  b2 + b - 1] / [b - 1] * cbfs 
= O[bd+2]
 ~ O(bd+1) for lar ge b 
Brian Williams, Fall  10 30 
15</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Speed of Iterative Deepening 
S 
D B A 
C G 
C G D 
C G d*b 
1*bd . . . d+1
 2*bd-1 Level 1 
Level d-1 Level 0 
Level d 
Compare speed of BFS vs IDS: 
 Tbfs = 1 + b +  b2 + . . . bd + (bd+1  b) ~ O(bd+1) 
 Tids = (d + 1)1 + (d)b + (d - 1)b2+. . . 2bd-1+ bd
 = [bd+2 + d(b-1) + 1)] / [b - 1]2
 ~ O(bd) for lrg b 
 Iterative  deepening performs better than  breadth-first! 
Brian Williams, Fall  10 45 
Speed of Iterative Deepening 
Tids  = (d + 1)1 + (d)b + (d - 1)b2+ . . . 2bd-1+ bd 
bTids  = (d + 1)b + (d)b2 + (d - 1)b3+. . . 2bd+ bd+1 
(b-1)Tids = (d + 1) + b +b2 + b3+. . . bd+ bd+1 
(b-1)Tids = d + {[bd+2 + 1)] / [b  1]}
 = [bd+2 + d(b-1) + 1)] / [b - 1]2
 ~ O(bd) for lrg b 
 Iterative  deepening performs better than  breadth-first! 
Brian Williams, Fall  10 46 
23</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Analyzing Time and Space Complexity 
of Search in Terms of Trees 
b = 3 
d = 1 
Level 1 
Level 2 Level 0 
m = 2 
b = maximum branching factor , number of children 
d = depth of the shallowest goal node 
m = maximum length of any path in the state space 
Brian Williams, Fall  10 19 
Worst Case Time for Depth-first 
Worst case time T is proportional to number of nodes visited 
Level 1 
Level 2 Level 0 
b*1 
b*b 
b*bm-1 . . . 
Level m 1 
Brian Williams, Fall  10 Tdfs
        b * Tdfs
[b  1] * Tdfs = [bm+1  1]*cdfs 
Tdfs = [bm+1  1] / [b  1] *cdfs 
20 where cdfs is time per node
Solve recurrence 
10 = [bm +  b + 1]*cdfs 
= [bm+1 + bm +  b + 0]*cdfs</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Breadth-first Finds Shortest Path 
Nodes visited earlier 
Level 0 
Level 1 reached 
Level d 
Level d+1 G 
G First cant include G 
Assuming each edge is length 1, 
other paths to G must be at least as long as first found 
Brian Williams, Fall  10 35 
Performance and Resource Usage 
Which is better , depth-first or breadth-first ? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bd+1 bd+1 Yes unit lngth 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 36 
18</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Cost Using Order Notation 
Worst case time T is proportional to number of nodes visited 
Level 1 
Level 2 Level 0 
b*1 
b*b 
b*bm-1 . . . 1 
Order Notation 
 T(n) = O(e(n)) if T  c * e for suf ficiently lar ge c &amp; n 
Tdfs = [bm+1  1] / [b  1] *cdfs
 = O(bm+1) 
~ O(bm) as b   (used in some texts) 
Brian Williams, Fall  10 21 
Performance and Resource Usage 
Which is better , depth-first  or breadth-first? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~ bm 
Breadth-first 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 22 
11</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>E.g., a search tree with 
a Goal to the left is easier than one to the right. 
Generally gets harder 
with increased size. 
Everyone likes a guarantee. Performance Analysis 
Analysis of run-time and resource usage: 
 Helps to understand scalability . 
 Draws line between feasible  and impossible . 
 A function of program input . 
 Parameterized by input size . 
 Seeks upper bound . 
Brian Williams, Fall  10 13 
Types of Analyses 
Worst-case: 
 T(n) = maximum time  of algorithm on any input 
of size n. 
Average-case: 
 T(n) = expected time  of algorithm over all inputs 
of size n. 
 Requires statistical distribution on inputs. 
Best-case: 
 T(n) = minimum time  of algorithm on any input . 
Brian Williams, Fall  10 14 
7</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Performance and Resource Usage 
Which is better , depth-first or breadth-first ? 
S C 
A B G 
A 
D C D G D 
C G C G S 
B 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bd+1 bd+1 Yes unit lngth Yes 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 37 
The Worst of The Worst 
Which is better , depth-first or breadth-first ? 
C 
G 
A 
D S 
B 
Assume d = m in the worst case, and call both m. 
 Best-first can t expand to level m+1, just m. S 
D B A 
C G 
C G D 
C G 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No Yes for finite graph 
Breadth-first ~bm bm Yes unit lngth Yes 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 38 
19</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Performance and Resource Usage 
Which is better , depth-first  or breadth-first? 
C 
G 
A 
D S 
D B A 
C G 
C G D 
C G S 
B 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m 
Breadth-first 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 25 
Performance and Resource Usage 
Which is better , depth-first  or breadth-first? 
S 
D B A 
C G 
C G D 
C G C 
S 
B G 
A 
D 
Search 
Method Worst 
Time Worst 
Space Shortest 
Path? Guaranteed to 
find path? 
Depth-first ~bm b*m No 
Breadth-first 
Worst case time is proportional to number of nodes visited 
Worst case space is proportional to maximal length of Q 
Brian Williams, Fall  10 26 
13</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Constraints II: constraint satisfaction [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec06/</lecture_pdf_url>
      <lectureno>6</lectureno>
      <slides>
        <slide>
          <slideno>20</slideno>
          <text>Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment .
B 
R V1 assignments 
V2 assignments 
V3 assignments G 
3. We have a conflict  whenever a domain  becomes empty .
 Backtrack 
R GB V1 
 Restore domains V2 V3 
Solution! 
1. Perform initial pruning. 
41 
Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
B 
G V1 assignments 
V2 assignments 
V3 assignments R 
3. We have a conflict  whenever a domain  becomes empty .
 Backtrack BT-FC is generally 
faster  than pure BT Restore domains 
because it avoids G R B V1 
V3 V2 
rediscovering 
inconsistencies .1. Perform initial pruning. 
42 
21</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Constraint Problems are Everywhere 
 Source unknown. All rights reserved. This content is excluded from our Creative Commons 
license. For more information, see http://ocw.mit.edu/fairuse . 
3
Constraint Satisfaction Problems (CSP) 
Input:  A Constraint Satisfaction Problem  is a triple &lt;V,D,C&gt;,  where: 
 V is a set of variables  Vi 
 D is a set of variable domains , 
 The domain of variable Vi is denoted Di 
 C = is a set of constraints  on assignments to V 
 Each constraint Ci = &lt;Si,Ri&gt; specifies allowed variable assignments. 
 Si the constraints scope , is a subset of variables V. 
 Ri the constraints relation , is a set of assignments to Si. 
Output:  A full assignment to V , from elements of Vs domain, 
such that all constraints in C are satisfied . 
Brian Williams, Fall  10 4 
2</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Procedure Select-Value() 
Output : A value in Di consistent with ai-1, or null, if none. 
while  Di is not empty 
select an arbitrary element a  Di and remove a from Di; 
if consistent(ai-1, xi = a ) 
return a;
 end while 
return null no consistent value 
end procedure 
Constraint Processing, 
by R. Dechter 
pgs 123-127 
23 
24 Search Performance on N Queens 
 Standard Search 
 Backtracking 
 BT with Forward Checking  A handful of queens 
 About 15 queens 1 
2 
3 
4 Q 
Q 
Q 
Q 
12</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>15 Incomplete: Arc consistency doesnt 
rule out all infeasible solutions 
R, G 
R, G R, G 
R, G R, G B, G Graph 
Coloring 
arc consistent, but 
no solutions. 
arc consistent, but 
2 solutions, not 8. 
B,R,G 
B,G,R 
Brian Williams, Fall  10
To Solve CSPs We Combine 
1. Arc consistency (via constraint propagation) 
 Eliminates values that are shown locally to not be a 
part of any solution. 
2. Search 
 Explores consequences of committing to particular 
assignments. 
Methods That Incorporate Search: 
 Standard Search 
 Back Track Search (BT) 
 BT with Forward Checking (FC) 
 Dynamic V ariable Ordering (DV) 
 Iterative Repair (IR) 
 Conflict-directed Back Jumping (CBJ) 16 
8</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>45 Search Performance on N Queens 
 Standard Search 
 Backtracking 
 BT with Forward Checking 
 Dynamic Variable Ordering  A handful of queens 
 About 15 queens 
 About 30 queens 1 
2 
3 
4 Q 
Q 
Q 
Q
BT-FC with dynamic ordering 
Traditional backtracking uses a fixed ordering  over variables  &amp; values. 
Typically better to choose ordering dynamically  as search proceeds. 
  Most Constrained V ariable 
When doing forward-checking, pick variable  with fewest  legal 
values  in domain to assign next. 
 minimizes branching  factor . 
  Least Constraining V alue 
Choose value  that rules out  the smallest number  of values  in 
variables connected  to the chosen variable  by constraints. 
 Leaves most options  to finding a satisfying assignment. 
46 
23</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>What is the Complexity of AC-1? 
Assume: 
 There are n variables. 
 Domains are of size at most k. 
 There are e binary constraints. 
Which is the correct complexity? 
1./.notdef.g0001 O(k2) 
2./.notdef.g0001 O(enk2 ) 
3./.notdef.g0001 O(enk3) 
4./.notdef.g0001 O(nek) 
Brian Williams, Fall  10
 9 
Revise: A directed arc consistency procedure 
Revise ( xi, xj) 
Input:  Variables xi and xj with domains Di and Dj and constraint relation Rij. 
Output : pruned Di, such that xi is directed arc-consistent  relative to xj. 
O(k) 
1./.notdef.g0001 for each ai  Di
2. if there is no aj  Dj such that &lt;ai, aj&gt;  Rij * O(k)
3.   then delete ai from Di.
4. endif
5./.notdef.g0001 endfor
Complexity of Revise? 
= O(k2)
where k = max |D| 
ii Brian Williams, Fall  10 
10 
5</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment .
B 
R V1 assignments 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains 
1. Perform initial pruning. 
39 R R, G B V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
B V1 assignments 
V2 assignments R 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains 
R G B V1 
V3 V2 
1. Perform initial pruning. 
40 
20</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
V1 assignments G 
V2 assignments R 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains
1. Perform initial pruning. 
35 R R G V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
V1 assignments G 
V2 assignments R x x 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains 
R G V1 
V3 V2 
1. Perform initial pruning. 
36 
18</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Procedure Backtrack-Forward-Checking(&lt;x,D,C&gt;) 
Input : A constraint network R = &lt;X, D, C&gt; 
Output : A solution, or notification the network is inconsistent. 
Note : Maintains n domain copies D for resetting, one for each search level i. 
Di  Di for 1  i  n; (copy all domains) 
   i  1;  ai = {} (init variable counter, assignments) 
while  1  i  n 
instantiate xi  Select-Value-FC(); (add to assignments, making ai) 
if xi is null (no value was returned) 
reset each Dk for k &gt; i, to its value before xi was last instantiated; 
i  i - 1; (backtrack) 
else
 i  i + 1; (step forward) 
end while 
if i = 0 
return inconsistent Constraint Processing, 
by R. Dechterelse 
return  ai , the instantiated values of {xi, , xn} pgs 131-4, 141 
end procedure 43 
Procedure Select-Value-FC() 
Output : A value in Di consistent with ai-1, or null, if none. O(ek2) 
while  Di is not empty 
select an arbitrary element a  Di and remove a from Di;
for all k, i &lt; k  n 
for all values b in Dk
 if not consistent(ai-1, xi = a, xk = b)
 remove b from Dk;
end for 
if Dk is empty (xi = a leads to a dead-end, dont select a) 
reset each Dk, i &lt; k  n to its value before a was selected;
 else 
return a;
 end while 
Constraint Processing, 
return null by R. Dechter 
end procedure pgs 131-4, 141 
44 
22</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Constraint Modeling (Programming) Languages 
Features Declarative specication of the problem that 
separates the formulation and the search strategy. 
Example : Constraint Model of the Sudoku Puzzle in 
Number Jack ( http://4c110.ucc.ie/numberjack/home ) 
matrix = Matrix(N*N,N*N,1,N*N) 
sudoku = Model( [AllDiff(row) for row in matrix.row], 
[AllDiff(col) for col in matrix.col],
 [AllDiff(matrix[x:x+N, y:y+N].flat) 
for x in range(0,N*N,N) 
for y in range(0,N*N,N)] ) 
5 
Constraint Problems are Everywhere 
6 
3  Source unknown. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/fairuse .</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Colors: R, G, B, Y
A B 
D E C R, Y G, B, Y 
F R, B, Y
Which country should we color next? 
What color should we pick for it? E most-constrained variable 
(smallest domain). 
RED least-constraining value 
(eliminates fewest values from 
neighboring domains). 
47 
for 1  i  n; 
ai = {} Procedure Dynamic-Var-Forward-Checking(&lt;x,D,C&gt;) 
Input : A constraint network R = &lt;X, D, C&gt; 
Output : A solution, or notification the network is inconsistent. 
Di  Di Copy all domains 
i  1;
 Init variable counter and assignments 
s = mini &lt; j  n  |Dj| Find unassigned variable w smallest domain 
xi+1xs Rearrange variables so that xs follows xi 
while  1  i  n 
instantiate xi  Select-Value-FC(); Select value (dynamic) and add to assignments, ai 
if xi is null No value to assign was returned. 
reset each Dk for k &gt; i, to its value before xi was last instantiated; 
i  i - 1; Backtrack
else
if I &lt; n 
i  i + 1; Step forward to xs
 s = mini &lt; j  n  |Dj| Find unassignedvariable w smallest domain 
xi+1xs Rearrange variables so that xs follows xi 
else
 i  i + 1; Step forward to xs 
end while 
if i = 0 
return inconsistent Constraint Processing, 
else 
by R. Dechterreturn  ai , the instantiated values of {xi, , xn} 
end procedure pgs 137-140 
48 
24</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Outline 
 Analysis of constraint propagation 
 Solving CSPs using Search 
Brian Williams, Fall  10
 7 
What is the Complexity of AC-1? 
AC-1 (CSP)
Input:  A network of constraints CSP = &lt;X, D, C&gt;. 
Output : CSP , the largest arc-consistent subset of CSP. 
1./.notdef.g0001 repeat
2./.notdef.g0001 for every cij  C,
3.   Revise( xi, xj)
4.   Revise( xj, xi)
5. endfor
6./.notdef.g0001 until no domain is changed. 
Assume: 
 There are n variables. 
 Domains are of size at most k. 
 There are e binary constraints. 
Brian Williams, Fall  10 8 
4</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Combining Backtracking and 
Limited Constraint Propagation
Initially: Prune domains using constraint propagation (optional) 
Loop: 
 If complete  consistent assignment , then return it , Else 
 Choose  unassigned variable. 
 Choose assignment  from variable s pruned  domain. 
 Prune (some)  domains using  Revise (i.e., arc-consistency ). 
 If a domain has no remaining  elements , then backtrack . 
Question:	 Full propagation is O(ek3), 
How much propagation  should we do? 
Very little (except for big problems) 
Forward Checking (FC) 
 Check arc consistency  ONL Y for arcs that terminate
 25on the new assignment  [O(e k) total].
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
R V1 assignments 
V2 assignments 
V3 assignments 
R, G R, G R, G, B V1 
V3 V2 
1. Perform initial pruning. 
26 
13</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Search Performance on N Queens
1 
2 
3 
4 Q 
Q 
Q 
Q
	Standard Search  A handful of queens 
	Backtracking  About 15 queens 
	BT with Forward Checking  About 30 queens 
	Dynamic Variable Ordering  About 1,000 queens 
	Iterative Repair 
 Conflict-directed Back 
Jumping 
49 
Incremental Repair (Min-Conflict Heuristic) 
1.	Initialize  a candidate solution using a  greedy heuristic. 
 gets the candidate near a solution. 
2.	 Select a variable in a conflict  and assign  it a value  that minimizes
the number of conflicts  (break ties randomly). 
The heuristic is used in a local hill-climber  (without or with backup). 
R R R : 3 BRR GRR  RGR RRG 
R, G R, G R, G, B V1 
V3 V2 
50 
25</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
V1 assignments G 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains
1. Perform initial pruning. 
33 R, G R, G G V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
V1 assignments G 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains 
R R G V1 
V3 V2 
1. Perform initial pruning. 
34 
17</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Full Arc-Consistency via AC-3 
AC-3(CSP)
Input:  A network of constraints CSP = &lt;X, D, C&gt;. 
Output : CSP, the largest arc-consistent subset of CSP. 
1. for every cij C, O(e) + 
2. queue  queue  {&lt;xi,xj&gt;, &lt;xi,xj&gt;}
3. endfor
4./.notdef.g0001 while queue  {}
5.  select and delete arc &lt;xi, xj&gt; from queue
6. Revise(xi, xj) O(k2)
7. if Revise(xI, xJ) caused a change in Di. * O(ek) 
8. then queue  queue  {&lt;xk,xI&gt; | k  i, k  j} 
9. endif 
10. /.notdef.g0001 endwhile 
Complexity of AC-3? 
= O(e+ek*k2) = O(ek3) where k = max |D |, n = |X|, e = |C| 
ii 
Brian Williams, Fall  10  13 
Is arc consistency sound and complete? 
An arc consistent solution  selects a value  for every variable 
from its arc consistent domain . 
Soundness: All solutions  to the CSP  are arc consistent 
solutions ?
Yes 
 No 
Completeness: All arc-consistent solutions  are solutions  to the 
CSP? 
 Yes 
 No R, G 
R, G R, G 
Brian Williams, Fall  10 
14 
7</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment .
R V1 assignments 
V2 assignments G 
V3 assignments 
Note: No need  to 
check new 
assignment  against 
1. Perform initial pruning. previous assignments 
29 G G R V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
R V1 assignments 
V2 assignments G x 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Back track
G R V1 
V3 V2 
1. Perform initial pruning. 
30 
15</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Back Track Search (BT) 
1.  Expand assignments of one variable  at each step. 
2.  Pursue depth first . 
3.  Check consistency  after each expansion , and backup. 
R G 
R G R G 
R G R G B 
R G 
R G R G V1 assignments 
V2 assignments 
V3 assignments 
Preselect order Assign Backup at 
of variables to designated inconsistent 
assign variable assignment
R, G R, G R, G, B V1 
V3 V2 
21 
Procedure Backtracking(&lt;X,D,C&gt;) 
Input : A constraint network  R = &lt;X, D, C&gt; 
Output : A solution , or notification that the network is inconsistent .
   i  1;  ai = {} Initialize  variable counter, assignments, 
Di  Di; Copy domain  of first variable. 
while  1  i  n 
instantiate xi  Select-Value(); Add to assignments ai. 
if xi is null No value  was returned, 
i  i - 1;  then backtrack 
else
 i  i + 1;  else step forward and
 Di  Di; copy domain  of next variable 
end while 
if i = 0 
return inconsistent 
else 
return  ai , the instantiated values of {xi, , xn} 
end procedure 
22 
11</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Solving Constraint Programs using  
Backtrack Search and Forward Checking  
9/29/10 1 
Slides draw upon material from: Brian C. Williams 
6.034 notes, by Tomas Lozano Perez 
AIMA, by Stuart Russell &amp; Peter Norvig 16.410-13  
Constraint Processing, by Rina Dechter September 27th, 2010 
Assignments  
Remember:  
Problem Set #3: Analysis and Constraint Programming, 
due this Wed., Sept. 29th, 2010. 
Reading:  
Today: [AIMA] Ch. 6.2-5 ; Constraint Satisfaction. 
Wednesday: Operator-based Planning [AIMA] Ch. 10 
      Graph Plan, by Blum &amp; Furst, posted on Stellar.  
To Learn More: Constraint Processing , by Rina Dechter 
Ch. 5: General Search Strategies: Look-Ahead 
Ch. 6: General Search Strategies: Look-Back 
Ch. 7: Stochastic Greedy Local Search 2 
Brian Williams, Fall  10</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment .
B V1 assignments 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains
1. Perform initial pruning. 
37 R, G R, G B V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
B V1 assignments 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains 
R, G R, G B V1 
V3 V2 
1. Perform initial pruning. 
38 
19</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment .
R V1 assignments 
V2 assignments 
V3 assignments 
R, G R, G R V1 
V3 V2 
1. Perform initial pruning. 
27 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
R V1 assignments 
V2 assignments 
V3 assignments 
G G R V1 
V3 V2 
1. Perform initial pruning. 
28 
14</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Next Lecture: Back Jumping
Backtracking At dead end, backup to the most recent variable . 
Backjumping At dead end, backup to the most recent variable  that 
eliminated  some value  in the domain  of the dead end variable . 
53 
27</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Solving CSPs with Standard Search 
Standard Search: 
 Children select any value for any variable [O(|v|*|d|)]. 
 Test complete assignments for consistency against CSP . 
Observations: 
1. The order  in which variables are assigned  does not change  the solution. 
 Many  paths denote the  same solution, 
 (|v|!), 
 expand only one path (i.e., use one  variable ordering ). 
2. We can identify  a dead end  before we assign all variables. 
 Extensions  to inconsistent partial assignments  are always 
inconsistent.
 Check consistency  after each assignment. 
19 R, G R, G R, G, B V1 
V3 V2
Back Track Search (BT) 
1.  Expand assignments of one variable  at each step. 
2.  Pursue depth first .
3.  Check consistency  after each expansion , and backup. 
V3 assignments 
Preselect order Assign 
of variables to designated 
assign variable V1 assignments 
V2 assignments R G B 
R, G R, G R, G, B V1 
V3 V2 
20 
10</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Backtracking with Forward Checking (BT-FC)
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
R V1 assignments 
V2 assignments G x x 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
1. Perform initial pruning. 
31 R V1 
V3 V2 
Backtracking with Forward Checking (BT-FC) 
2. After  selecting each assignment , remove  any values  of 
neighboring domains  that are inconsistent  with the new assignment . 
V1 assignments G 
V2 assignments 
V3 assignments 
3. We have a conflict  whenever a domain  becomes empty . 
 Backtrack 
 Restore domains
R, G R, G G, B V1 
V3 V2 
1. Perform initial pruning. 
32 
16</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Min-Conflict Heuristic
Pure hill climber  (w/o backtracking) gets stuck in local minima : 
Add random moves  to attempt to get out of minima. 
Add weights  on violated constraints  and 
increase weight  every cycle the constraint  remains violated . 
Sec
(Sparc 1) 
100 
101 102 103 104 105 106 Performance on n-queens.10 (with good initial guesses) 
1
10-1
10-2
Size (n) 
GSAT: Randomized hill climber  used to solve propositional logic
SATisfiability problems. 
51 
To Solve CSP &lt;X,D,C&gt; We Combine: 
1. Reasoning - Arc consistency via constraint propagation  
 Eliminates values that are shown locally to not be a part 
of any solution. 
2. Search 
 Explores consequences of committing to particular 
assignments. 
Methods That Incorporate Search: 
 Standard Search 
 Back Track Search (BT) 
 BT with Forward Checking (FC) 
 Dynamic V ariable Ordering (DV) 
 Iterative Repair (IR) 
 Conflict-directed Back Jumping (CBJ) 52 
26</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Full Arc-Consistency via AC-1 
AC-1 (CSP)
Input:  A network of constraints CSP = &lt;X, D, C&gt;. 
Output : CSP , the largest arc-consistent subset of CSP. 
1./.notdef.g0001 repeat
2./.notdef.g0001 for every cij  C, O(2e*revise)
3.   Revise( xi, xj)
4.   Revise( xj, xi)
5. endfor
* O(nk)6./.notdef.g0001 until no domain is changed. 
Complexity of AC-1 ? 
= O(nk*e*revise) 
= O(enk3) 
where k = maxi |Di| 
Brian Williams, Fall  10 n = |X|, e = |C| 
11 
What is the Complexity of 
Constraint Propagation using AC-3?
Assume: 
 There are n variables. 
Domains are of size at most k. 
 There are e binary constraints. 
Which is the correct complexity? 
1./.notdef.g0001 O(k2) 
2./.notdef.g0001 O(ek2 ) 
3./.notdef.g0001 O(ek3) 
4./.notdef.g0001 O(ek) 
Brian Williams, Fall  10 
12 
6</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Solving CSPs using Generic Search 
 State  Partial assignment  to variables,
made thus far. 
 Initial State  No assignment. 
 Operator  Creates new assignment  (Xi = vij) 
 Select any unassigned variable Xi 
 Select any one of its domain values vij 
 Child  extends parent  assignments with  new. 
 Goal Test  All variables  are assigned. 
 All constraints  are satisfied. 
 Branching factor? 
 Sum  of domain size of all variables O(|v|*|d|). 
 Performance? 
  Exponential in the  branching factor O([|v|*|d|]|v|). 17 R, G R, G R, G, B V1 
V3 V2
 18 Search Performance on N Queens 
 Standard Search 
 Backtracking  A handful of queens 1 
2 
3 
4 Q 
Q 
Q 
Q 
9</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Game theory I: sequential games [EF]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec24/</lecture_pdf_url>
      <lectureno>24</lectureno>
      <slides>
        <slide>
          <slideno>43</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44
5 (9 ;5)
X(6;5)
XX5(5;1)
3(5;3)
X X
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
5(4;5)
(9;5)
X
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
5(4;5)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Games in extensive form
Extensive Form
Suitable for games played in sequential \turns."
Consider the following version of the prisoner's dilemma: is it the same as the
one we saw before?
Player 1Player 2cooperatedefectdefectdefectcooperatecooperate(-1,-1)(-10,0)(0,-10)(5,5)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 8 / 21</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
(4;1)
5
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44
5 (9 ;5)
X(6;5)
XX5(5;1)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
5(4;5)
(9;5)
X(6;5)
XX
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44
5 (9 ;5)
X(6;5)
XX5(5;1)
(5;1)
3
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44
5 (9 ;5)
X(6;5)
XX5(5;1)
(5;1)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>16.410/413
Principles of Autonomy and Decision Making
Lecture 24: Sequential Games
Emilio Frazzoli
Aeronautics and Astronautics
Massachusetts Institute of Technology
December 6, 2010
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 1 / 21</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
(4;1)
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44
5 (9 ;5)
X(6;5)
XX5
3(5;3)
X X5
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Tic-Tac-Toe Game Tree
!"#$%&amp;'$$(%)*'+
,-(((((((((.%)*'+(.(.(.(.((.((.(1 Move1/2 Move1 Ply&amp;/01&amp;"01&amp;2$345%6%78%9%6%7:;$&lt;&lt;345%6%=&gt;8%9%6%,??(%)*'+.%)*'+(.(..(.((.(..((.(.(.((..(%)*'+,?1,&amp;$'#/+"@%A29$%B)/@/)/$&lt;
The complete tree has no more than 9! = 362880 nodes
(not accounting for symmetries and termination conditions).
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 12 / 21</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Outline
1Game Theory
Overview
Games in normal form: Nash equilibria, pure and mixed strategies
Games in extensive form
2
Sequential Games
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 2 / 21</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Outline
1Game Theory
2
Sequential Games
Zero-Sum Two-Player Sequential Games
Minimax search
Alpha-Beta pruning
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 9 / 21</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Alpha-Beta Pruning Example
8  7  2  9  1  6   2  4  1   1  3  5   3  9  2  6  5  2   1  2  3   9  7  2 16 6  4  
8 (9 ;8)
XX44(4;1)
5 (9 ;5)
X(6;5)
XX5
E. Frazzoli (MIT)L24: Sequential GamesDecember 6, 2010 20 / 21</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Planning III: robust execution of temporal plans [BW]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/16-410-principles-of-autonomy-and-decision-making-fall-2010/resources/mit16_410f10_lec09/</lecture_pdf_url>
      <lectureno>9</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text>4/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001
dinner/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001wrap
/.notdef.g0001
/.notdef.g0001carry /.notdef.g0001
/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 noop-dinner/.notdef.g0001
noop-present/.notdef.g0001Total Order Plans &lt; Actions[i] &gt;
Contain Irrelevant Commitments 
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001
dinner/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 Partial Order Plans &lt; Actions, Orderings, Links &gt;
Remove Irrelevant Commitments</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18  35
/.notdef.g0002Disjunctive Temporal Problem (DTP)/.notdef.g0002
/.notdef.g0002Extends TCSP by allowing non-binary constraints. /.notdef.g0002Temporal Relations Described as a DTP/.notdef.g0002
MS/.notdef.g0002 D-/.notdef.g0002[0, inf]/.notdef.g0002
D+/.notdef.g0002 S-/.notdef.g0002 S+/.notdef.g0002
I-/.notdef.g0002 I+/.notdef.g0002[5, 10]/.notdef.g0002 [0, inf]/.notdef.g0002 [4, 5]/.notdef.g0002
[15, 15]/.notdef.g0002
[1, 1]/.notdef.g0002[0, inf]/.notdef.g0002Activities of Mars Rover: Drill (D) , Image (I), Send Data (S)/.notdef.g0002
Drilling causes vibration./.notdef.g0002
Image cannot occur /.notdef.g0002
/.notdef.g0002 during the last two minutes before drilling, or/.notdef.g0002
/.notdef.g0002 during the rst minute after drilling ends./.notdef.g00022&lt; D+ - I+&lt; inf/.notdef.g0002
OR/.notdef.g0002
1&lt; I - - D+&lt; inf/.notdef.g0002Send data/.notdef.g0002 Drill/.notdef.g0002
Image/.notdef.g0002
36
/.notdef.g0002Disjunctive Temporal Problem (DTP)/.notdef.g0002
/.notdef.g0002extends a TCSP by allowing non-binary constraints. /.notdef.g0002A Temporal Plan Described as a DTP/.notdef.g0002
DTP/.notdef.g0002-/.notdef.g0002non-binary constraints/.notdef.g0002
-/.notdef.g0002multiple intervals in constraints/.notdef.g0002
TCSP/.notdef.g0002-/.notdef.g0002 binary constraints/.notdef.g0002
-/.notdef.g0002multiple intervals/.notdef.g0002
STP/.notdef.g0002
-/.notdef.g0002 binary constraints/.notdef.g0002
-/.notdef.g0002simple intervals/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23  45
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = 0 d(B) = 2 
46
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -1 d(B) = 2</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21  41
STP Consistency 
/.notdef.g0002Example of inconsistent constraint: 
/.notdef.g0002An STP is consistent iff its distance graph has no negative 
cycles.
/.notdef.g0002Detect by computing shortest path from one node to all 
other nodes. 
/.notdef.g0002Single Source Shortest Path (SSSP) AB[2, 1] 
AB1
-2
42
STP Consistency: 
Generic Labeling Algorithm 
Detect negative cycles by computing the shortest-path
from a single node to all other nodes (Single Source Shortest Path).
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002 d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002         d(j) = d(i) + c(i,j) 
d(A) = inf  d(B) = inf</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28  55
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Schedule Off-line
[1,10]/.notdef.g0002
[0,9]/.notdef.g0002[1,1]/.notdef.g0002[2,2]/.notdef.g0002
A/.notdef.g0002B/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002
56
Scheduling
X0 Ls Le
Ss Se[10,20] [30,40]
[10,20]
[40,50]
[60,70]
/.notdef.g0002Idea: Expose Implicit Constraints in STP X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12  23
Expanding Robustness by /.notdef.g0001
Coordinating Underactuated Systems/.notdef.g0002
Chekov; Sulu: Kongming /.notdef.g0002
[Hofmann; Leaute; Blackmore; Ono; Li] /.notdef.g0002
24
Robust Execution of Time-critical Tasks  
/.notdef.g0002Executing Simple Plans 
/.notdef.g0002Robust Execution 
/.notdef.g0002Describing Temporal Plans 
/.notdef.g0002Checking Temporal Plan Consistency 
/.notdef.g0002Scheduling Plans 
/.notdef.g0002Robust, Dynamic Scheduling</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001
dinner/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 Plan Execution w Action Monitoring 
Start/.notdef.g0002
Plan Execution w Action Monitoring 
Initialize queue Ready , with action Start .
Mark all actions as not executed .
Loop
/.notdef.g0002IfReady isempty , Then terminate .
/.notdef.g0002Dequeue action afrom Ready .
/.notdef.g0002Ifas preconditions satisfied, then execute, else fail .
/.notdef.g0002When completed, mark a as executed .
/.notdef.g0002For each succeeding action b such that
a &lt; b or linked( a,b,p),
/.notdef.g0002If every preceding action c is marked  executed ,
such that c &lt; b or linked( c,b,p),
/.notdef.g0002Then queue b on Ready .</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>917
Executing Timed Programs and Plans Robustly 
Start End
Rover1.goto(p4)
Rover2.goto(p1)Rover1.imageTargets Rover1.goto(p5) Rover1.goto(p3)
Rover2.goto(p2) Rover2.imageTargets Rover2.goto(p3)imageScienceTargets(Rover1, Rover2)  
{Parallel
   {Sequence 
[5,10] Rover1.goto(p4);
[5,10] Rover1.goto(p5);
[2,5] Rover1.imageTargets();  
[5,10] Rover1.goto(p3); 
   },    {Sequence 
 [5,10] Rover2.goto(p1);  [5,10]Rover2.imageTargets(); 
        [2,5] Rover2.goto(p2); 
 [5,10] Rover2.goto(p3); 
   } 
}
p1
p2p3p4
p5
1
2
[5,10] [5,10] [2,5] [5,10]
[5,10] [5,10] [2,5] [5,10]
Agents adapt to temporal disturbances in a coordinated manner 
by scheduling the start of activities on the fly. 
In general, categorize durations into controllable and uncontrollable (STNUs)./.notdef.g0002in RMPL  [williams et al] /.notdef.g0002
18
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Scheduling Off-line 
/.notdef.g0002
4. Dynamically Execute Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002
3. Reformulate Plan/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002/.notdef.g00021. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002Part II: Scheduling Online</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>34  67
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002/.notdef.g0002 /.notdef.g0002t=0 [10,20]
68
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002Select value for Le, 
consistent with X0, Ls/.notdef.g0002
/.notdef.g0002/.notdef.g0002 /.notdef.g0002t=0 t=15 [45,50]</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1
Massachusetts Institute of Technology  
Robust Execution of Temporal Plans /.notdef.g0001
/.notdef.g0001
/.notdef.g0002
Prof Brian Williams 
16.410 / 16.413 
October.6th, 2010 Slide Contributions: 
Andreas Hofmann 
Julie Shah 
Brian Williams, Fall  10  2Assignments
/.notdef.g0002Remember:
Problem Set #5 due today, Wed, Oct. 6th, 2010. 
Problem Set #6 out today. 
/.notdef.g0002Reading:
/.notdef.g0002Today: Dechter, R., I. Meiri, J. Pearl, Temporal Constraint 
Networks, Artificial Intelligence, 49, pp. 61-95,1991.
/.notdef.g0002Wednesday: Logic [AIMA] Ch. 7, 8
/.notdef.g0002Exam:
/.notdef.g0002Mid-Term - October 20th.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26  51
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -3 d(B) = -1 
52
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -4 d(B) = -1</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8Plan Execution w Execution Monitoring (cont) 
Loop
/.notdef.g0002(continued from previous slide)
/.notdef.g0002Mark a as executed .
/.notdef.g0002For each action c such that linked( c,a,p).
/.notdef.g0002dequeue &lt; c,a,p&gt; from ActiveLinks .
/.notdef.g0002For each action d such that linked( a,d,p).
/.notdef.g0002queue &lt; a,d,p&gt; on ActiveLinks .
/.notdef.g0002For each action b such that a &lt; b or linked( a,b,p).
/.notdef.g0002If every action c has been executed,
such that c &lt; b or linked( c,b,p)
/.notdef.g0002Then queue b on Ready .
16
Robust Execution of Time-critical Tasks  
/.notdef.g0002Executing Simple Plans 
/.notdef.g0002Robust Execution</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>23
Executing Time Critical Missions/.notdef.g0002
4
An effective Scrub Nurse: 
/.notdef.g0002works hand-to-hand, face-to-face with surgeon, 
/.notdef.g0002assesses and anticipates needs of surgeon, 
/.notdef.g0002provides assistance and tools in order of need, 
/.notdef.g0002responds quickly to changing circumstances, 
/.notdef.g0002responds quickly to surgeons cues and requests. T eam Coordination under Time Pressure/.notdef.g0002Image credit: NASA.
Images of scrub nurses and surgeons
removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19  37
RMPL - Nested Compositions:/.notdef.g0002
/.notdef.g0002Activity/.notdef.g0002
/.notdef.g0002Sequence/.notdef.g0002
/.notdef.g0002Parallel/.notdef.g0002
/.notdef.g0002Choice/.notdef.g0002
/.notdef.g0002With Time/.notdef.g0002Temporal Plan Networks and Conditional STPs/.notdef.g0002
/g0/g0/g0/g0/g0/g0/g0/g0/g0/g0
/g0/g0/g0/g0/g0 /g0 /g0/g0/g0/g0/g0
/g0/g0 /g0 /g0 /g0 /g0 /g0 /g0 /g0/g0 /g0/g0 /g0/g0/g0
/g0/g0 /g0/g0/g0
/g0 /g0/g0/g0 /g0/g0/g0
/g0/g0/g0/g0/g0
/g0/g0/g0/g0/g0/g0 /g0/g0 /g0/g0 /g0 /g0/g0/g0 /g0/g0/g0 /g0 /g0 /g0/g0/g0/g0/g0
/g0/g0 /g0 /g0 /g0 /g0 /g0 /g0 /g0/g0 /g0/g0 /g0/g0/g0
/g0 /g0 /g0 /g0/g0/g0 /g0 /g0 /g0 /g0 /g0 /g0 /g0/g0 /g0/g0 /g0/g0/g0
/g0 /g0/g0/g0/g0/g0/g0
/g0/g0 /g0/g0/g0/g0/g0/g0/g0/g0
/g0/g0/g0/g0/g0/g0
/g0/g0 /g0/g0/g0
p1
p2p4
p5
1
2
TPN:/.notdef.g0002
38
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Schedule Off-line
[1,10]/.notdef.g0002
[0,9]/.notdef.g0002[1,1]/.notdef.g0002[2,2]/.notdef.g0002
A/.notdef.g0002B/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32  63
Scheduling: Earliest Solution 
-10 20
-30 40
-10 
20
-40 50
20
X0 Ls Le
Ss Se50 30 70
-10  40 20 60
-40  -30  -10  30
-20  -10  20 50
-60  -50  -20  40
APSP d-graph 70
-60 reference0
Searliest  = (-d10, /.notdef.g0001 , dn0)Active constraints/.notdef.g0002
64
Scheduling: Window of Feasible Values 
20 50 30 70
-10  40 20 60
-40  -30  -10  30
-20  -10  20 50
-60  -50  -20  40
APSP d-graph 0 Latest Times 
Earliest Times /.notdef.g0002Ls in [10, 20] 
/.notdef.g0002Le in [40, 50] 
/.notdef.g0002Ss in [20, 30] 
/.notdef.g0002Se in [60, 70]</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24  47
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -1 d(B) = 1 
48
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -2 d(B) = 1</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
16.410 / 16.413 Principles of Autonomy and Decision Making
Fall 2010
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>35
Human-Robot Teaming/.notdef.g0002
6
Robust Execution of Time-critical Tasks  
/.notdef.g0002Executing Simple Plans 
/.notdef.g0002Robust Execution 
/.notdef.g0002Describing Temporal Plans 
/.notdef.g0002Checking Temporal Plan Consistency 
/.notdef.g0002Scheduling Plans 
/.notdef.g0002Robust, Dynamic Scheduling Images of human-robot teaming (in surgical, space, and rescue settings)
removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25  49
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -2 d(B) = 0 
50
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -3 d(B) = 0</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16  31
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
Qualitative Temporal Relationships as timepoint inequalities/.notdef.g0002
/.notdef.g0002
Y/.notdef.g0001X/.notdef.g0001 Y/.notdef.g0001
X/.notdef.g0001 Y/.notdef.g0001
X/.notdef.g0001 Y/.notdef.g0001
Y/.notdef.g0001X/.notdef.g0001
Y/.notdef.g0001 X/.notdef.g0001
Y/.notdef.g0001X/.notdef.g0001
X/.notdef.g0001X before Y
X meets YX overlaps Y
X during Y
X starts YX finishes Y
X equals YX
+ &lt; Y-
X+ = Y-
Y- &lt; X+and X- &lt; Y+/.notdef.g0002
Y- &lt; X-and X+ &lt; Y+/.notdef.g0002
X- = Y-and X+ &lt; Y+/.notdef.g0002
X- &lt; Y-and X+ = Y+/.notdef.g0002
X- = Y-and X+ = Y+/.notdef.g0002
X disjoint Y X+ &lt; Y-or Y+ &lt; X-/.notdef.g0002Y-/.notdef.g0002X+/.notdef.g0002[0,inf]/.notdef.g0002
Y-/.notdef.g0002[0,0]/.notdef.g0002
X+/.notdef.g0002
32
Describing Temporal Plans/.notdef.g0002/.notdef.g0002
Encode metric Information by generalizing inequalities 
to interval constraints./.notdef.g0002
/.notdef.g0002 Going to the store takes at least 10 min and at 
most 30 min. 
/.notdef.g0002 Bread should be eaten within one day of baking.Start Going to Store /.notdef.g0002G-/.notdef.g0002G+/.notdef.g0002
End Going to Store /.notdef.g0002[10,30]/.notdef.g0002
10 &lt; [G+ - G-]&lt; 30/.notdef.g0002
End Bake Bread /.notdef.g0002B+/.notdef.g0002E-/.notdef.g0002
Start Eat Bread /.notdef.g0002[0,1]/.notdef.g0002
0&lt; [E- - B+]&lt; 1/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001
dinner/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 Execution Monitoring 
/.notdef.g0002Check if any preconditions of unexecuted actions are violated. 
/.notdef.g0001/.notdef.g0002 Check if a causal link that crosses the current time is violated. 
Plan Execution w Execution Monitoring 
Initialize agenda Ready with action Start
Initialize agenda ActiveLinks to empty 
Mark all actions as  not executed .
Loop
/.notdef.g0002IfReady is empty then terminate. 
/.notdef.g0002For each linkonActiveLinks
/.notdef.g0002If the proposition for linkdoesnt hold,
Then return failure 
/.notdef.g0002Dequeue action a from Ready
/.notdef.g0002If preconditions of action are satisfied
/.notdef.g0002Then execute 
/.notdef.g0002Else return failure 
/.notdef.g0002(continued on next slide)</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38  75
To Execute a Temporal Plan/.notdef.g0002
offline  
online  Part I : Schedule Off-line Part II: Schedule Online 
/.notdef.g0002
4. Dynamically Execute Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002
3. Reformulate Plan/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002/.notdef.g00021. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002[1,10]/.notdef.g0002
[0,9]/.notdef.g0002[1,1]/.notdef.g0002[2,2]/.notdef.g0002
[0,9]/.notdef.g0002[1,1]/.notdef.g0002
[1,1]/.notdef.g0002A/.notdef.g0002B/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002
A/.notdef.g0002B/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002
[0,9]/.notdef.g0002[1,1]/.notdef.g0002
[1,1]/.notdef.g0002 A/.notdef.g0002B/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002t=0/.notdef.g0002
t=2/.notdef.g0002t=3/.notdef.g0002
t=4/.notdef.g0002How do we schedule on line?/.notdef.g0002
76
Dynamic Scheduling by Decomposition?/.notdef.g0002
Consider a Simple Example/.notdef.g0002
CDB[2,11]/.notdef.g0002
A [1,1]/.notdef.g0002[0,10]/.notdef.g0002
[0,10]/.notdef.g0002 [2,2]/.notdef.g0002[1,1]/.notdef.g0002/.notdef.g0002Select executable timepoint and assign/.notdef.g0002
/.notdef.g0002Propagate assignment to neighbors/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11  21
Expanding Robustness 
by Dynamically Assigning Tasks 
/.notdef.g0002Off-nominal
/.notdef.g0002Partner adapts 
in response to 
teammatesfailure.
22
Expanding Robustness by /.notdef.g0001
Coordinating Underactuated Systems
Chekov; Sulu: Kongming /.notdef.g0002
[Hofmann; Leaute; Blackmore; Ono; Li] /.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10  19
Start
EndRover1.goto(p4)
Rover2.goto(p1)Rover1.imageTargets Rover1.goto(p5)
Rover1.goto(p3)
p1
p2p3p4
p5
1
2
Rover1.goto(p5)Rover1.imageTargets 
Rover2.goto(p2)Rover2.imageTargets 
Rover2.goto(p3)Rover2.goto(p2) Rover2.goto(p3)
Rover2.imageTargets 
Ask site1 = obstructed
Ask site1 = obstructed
Rover2.imageTargetssk site1 = obstructed
 Failure
Tell site1 = obstructedobstructed
imageScienceTargets(Rover1, Rover2) 
{
   {
        [5,10] Rover1.goto(p4);
choose {
            { 
                do { [5,10] Rover1.goto(p5); }
maintaining( site1 =  obstructed );
                 [2,5] Rover1.imageTargets();             } 
           { 
              [2,5] Rover1.imageTargets();  
              [5,10] Rover1.goto(p5); 
           } 
          }; 
         [5,10] Rover1.goto(p3); 
    },
    { 
       [5,10] Rover2.goto(p1);
choose {
         { 
             do { [2,5 ]Rover2.imageTargets(); } 
maintaining ( site1 =  obstructed);            
             [5,10] Rover2.goto(p2); 
             [5,10] Rover2.goto(p3); 
         }
          { 
                [5,10] Rover2.goto(p2);
               [5,10] Rover2.goto(p3); 
               [2,5] Rover2.imageTargets();  
}      } 
}Expanding Robustness by
Dynamically Choosing Methods
distributed Kirk /.notdef.g0002
[Kim:Efnger;Block; Wehowsky] ]/.notdef.g0002in RMPL  [williams et al] /.notdef.g0002
20
Expanding Robustness by
Dynamically Assigning Tasks 
20
Remove one ball from red bin /.notdef.g0002
Remove one ball from blue bin /.notdef.g0002
Remove one ball from green bin /.notdef.g0002Remove one ball from pink bin /.notdef.g0002Swap black striped ball /.notdef.g0002
/.notdef.g0002 Right Robot picks up and 
offers ball. /.notdef.g0002
/.notdef.g0002 Robots perform hand-to-hand 
swap./.notdef.g0002
Swap red striped ball /.notdef.g0002
/.notdef.g0002 Left Robot picks up and offers 
ball./.notdef.g0002
/.notdef.g0002 Robots perform hand-to-hand 
swap./.notdef.g0002
  tstart/.notdef.g0002  tnish/.notdef.g0002(Someone) Remove one ball from red bin /.notdef.g0002
Remove one ball from red bin /.notdef.g0002
L[32,39]  V R[42,55] /.notdef.g0002
OR/.notdef.g0002Agents choose and/.notdef.g0002
schedule activities/.notdef.g0002
Chaski, Drake, Kirk /.notdef.g0002
[Kim; Shah; Conrad] /.notdef.g0002in RMPL  [williams et al] /.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>31  61
Scheduling with All Pairs Shortest Path Graph 
20 50 30 70
-10  40 20 60
-40  -30  -10  30
-20  -10  20 50
-60  -50  -20  40
APSP d-graph X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002After Floyd Warshall/.notdef.g0002
62
Scheduling: Latest Solution 
-10 20
-30 40
-10 
20
-40 50
20
X0 Ls Le
Ss Se50 30 70
-10  40 20 60
-40  -30  -10  30
-20  -10  20 50
-60  -50  -20  40
APSP d-graph 70
-60 reference0
Slatest = (d01, /.notdef.g0001 , d0n)Active constraints/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36  71
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002Select value for Le, 
consistent with X0, Ls/.notdef.g0002
/.notdef.g0002Select  value for Ss, 
consistent with X0, Ls, 
Le/.notdef.g0002t=0 t=15 t=45
t=30
72
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002Select value for Le, 
consistent with X0, Ls/.notdef.g0002
/.notdef.g0002Select  value for Ss, 
consistent with X0, Ls, 
Le/.notdef.g0002
/.notdef.g0002Select value for Se/.notdef.g0002t=0 t=15 t=45
t=30 t=70</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35  69
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002Select value for Le, 
consistent with X0, Ls/.notdef.g0002
/.notdef.g0002/.notdef.g0002 /.notdef.g0002t=0 t=15 t=45
70
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002Select value for Ls, 
consistent with X0/.notdef.g0002
/.notdef.g0002Select value for Le, 
consistent with X0, Ls/.notdef.g0002
/.notdef.g0002Select  value for Ss, 
consistent with X0, Ls, 
Le/.notdef.g0002t=0 t=15 t=45
[25,30]</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33  65
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002
66
Scheduling without Search: 
 Solution by Decomposition 
Key ideas 
/.notdef.g0002 Incrementally tighten feasible intervals,
  as commitments are made. 
/.notdef.g0002 Perform on demand. /.notdef.g0002Can assign variables in any order, without backtracking. 
X0/.notdef.g0002 Ls/.notdef.g0002 Le/.notdef.g0002
S s/.notdef.g0002 S e/.notdef.g0002[40,50]/.notdef.g0002
[10,20]/.notdef.g0002 [30,40]/.notdef.g0002
[20,30]/.notdef.g0002[10,20]/.notdef.g0002
[60,70]/.notdef.g0002[40,50]/.notdef.g0002[20,30]/.notdef.g0002[50,60]/.notdef.g0002
[10,20]/.notdef.g0002/.notdef.g0002Select value for X0/.notdef.g0002
/.notdef.g0002/.notdef.g0002 /.notdef.g0002t=0</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37  73
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Schedule Off-lineProblem: delays and uctuations in task 
duration can cause plan failure./.notdef.g0002
/.notdef.g0002
Observation: Least commitment 
temporal plans leave room to 
adapt./.notdef.g0002
/.notdef.g0002
Flexible Execution adapts through 
dynamic scheduling [Muscettola et al] /.notdef.g0002
/.notdef.g0002Assigns time to event when 
executed/.notdef.g0002
74
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Schedule Off-line Part II: Schedule Online 
/.notdef.g0002
4. Dynamically Execute Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002
3. Reformulate Plan/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002/.notdef.g00021. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27  53
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = -4 d(B) = -1 
How do we detect inconsistency? 
1./.notdef.g0002One way: Check for any d-value to drop below nC
54
STP Consistency: 
FIFO  Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating ,
5./.notdef.g0002         d(j) = d(i) + c(i,j) 
d(A) = -4 d(B) = -1 
/.notdef.g0002Maintain queue of updated nodes. 
/.notdef.g0002For each node on queue, check for 
outgoing arcs that may be potentially 
violating.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14  27
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
Qualitative Temporal Relationships (Allen 83)/.notdef.g0002
/.notdef.g0002
Y/.notdef.g0001X/.notdef.g0001 Y/.notdef.g0001
X/.notdef.g0001 Y/.notdef.g0001
X/.notdef.g0001 Y/.notdef.g0001
Y/.notdef.g0001X/.notdef.g0001
Y/.notdef.g0001 X/.notdef.g0001
Y/.notdef.g0001X/.notdef.g0001
X/.notdef.g0001X before Y
X meets YX overlaps Y
X during Y
X starts YX finishes Y
X equals YY after X
Y met-by XY overlapped-by X
Y contains X
Y started-by XY finished-by X
Y equals X
X disjoint Y
28
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
Example: Deep Space One Remote Agent Experiment/.notdef.g0002
Max_Thrust Idle Idle
PokeTimer 
AttitudeAccum thrust 
SEP Action SEP_Segment
Th_Seg
contained_by/.notdef.g0001
equals/.notdef.g0001equals/.notdef.g0001meets/.notdef.g0001
meets/.notdef.g0001contained_by/.notdef.g0001
Start_Up Start_UpShut_Down Shut_DownThr_Boundary
Thrust Thrust Thrust Thrust Standby Standby StandbyTh_Sega Th_Seg Th_Seg Idle_Seg Idle_Seg
Accum_NO_Thr Accum_Thr Accum_Thr Accum_Thr Thr_Boundarycontained_by/.notdef.g0001
CP(Ips_Tvc) CP(Ips_Tvc) CP(Ips_Tvc)contained_by/.notdef.g0001Th_Seg</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22  43
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002         d(j) = d(i) + c(i,j) 
d(A) = 0 d(B) = inf  
44
STP Consistency: 
Generic Labeling Algorithm 
Can detect negative cycles by just computing the shortest-path from a single node to 
all the other nodes (Single Source Shortest Path)
1./.notdef.g0002For all nodes s in graph G 
2./.notdef.g0002   d(s) = inf 
3./.notdef.g0002d(sstart) = 0 
4./.notdef.g0002while some arc(i,j) is violating, 
5./.notdef.g0002 d(j) = d(i) + c(i,j) 
d(A) = 0 d(B) = inf  
arc(i,j) is violating if, 
d(j) &gt; d(i) + c(i,j)</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41  81
Dynamic Scheduling through Dispatchable Execution 
Compiler
DispatcherTemporal 
Plan 
Observations of  
past events  
Generate dynamic 
schedule  offline  
online  Image credit: NASA.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13  25
To Execute a Temporal Plan/.notdef.g0002
offline  
online  /.notdef.g0002
3. Schedule Plan/.notdef.g0002/.notdef.g0002
1. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002
/.notdef.g0002
4. Execute Plan/.notdef.g0002
/.notdef.g0002Part I : Schedule Off-line   Part II: Schedule Online 
/.notdef.g0002
4. Dynamically Execute Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002
3. Reformulate Plan/.notdef.g0002/.notdef.g0002
2. T est Consistency/.notdef.g0002/.notdef.g00021. Describe T emporal Plan/.notdef.g0002
/.notdef.g0002/.notdef.g0002
26
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
/.notdef.g0002
/.notdef.g0002 Activities to perform/.notdef.g0002
/.notdef.g0002Relationships among activities/.notdef.g0002
Egress/ SetupRemove NH3 Shunt Vent NH3 Shunt &amp; Stow Release Loop A Tray
Configure Vent Tools Fluid Caps SFU Reconfig Release Loop B Tray
t = tmaxImage credit: NASA.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30  59
All Pairs Shortest Path  
Floyd-Warshall (alternatively Johnson)  
1. for i := 1 to n do dii     0; 
2. for i, j := 1 to n do dij     w(i,j); 
3. for k := 1 to n do 
4.   for i, j := 1 to n do 5.     d
ij    min{dij, dik + dkj};
Complexity O(n3)i/.notdef.g0001k/.notdef.g0001
j/.notdef.g0001Initialize distances/.notdef.g0002
Take minimum distance/.notdef.g0002
over all triangles/.notdef.g0002
60
APSP
-10 20
-30 40
-10 
20
-40 50
20
X0 Ls Le
Ss Se inf  inf 70
-10  40  inf  inf 
 inf -30  -10   inf 
inf  inf 20 50
-60   inf  inf 40
Initial d-graph 70
-60 0
Slatest = (d01, /.notdef.g0001 , d0n)i = X0, k = Ls, j = L/.notdef.g0002
3. for k := 1 to n do/.notdef.g0002
4.   for i, j := 1 to n do/.notdef.g0002
5.     dij    min{dij, dik + dkj};/.notdef.g0002
/.notdef.g0002
60/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001
dinner/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
present/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001/.notdef.g0001
cook
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
wrap/.notdef.g0001
/.notdef.g0001carry /.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
/.notdef.g0001/.notdef.g0001/.notdef.g0001
/.notdef.g0001
/.notdef.g0001  cleanH /.notdef.g0001/.notdef.g0001/.notdef.g0001
  quiet/.notdef.g0001  noGarb/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  cleanH/.notdef.g0001
/.notdef.g0001
/.notdef.g0001
  dinner/.notdef.g0001
/.notdef.g0001/.notdef.g0001  present/.notdef.g0001/.notdef.g0001
Prop at 0  Action  at 0          Prop at 1       Action  at 1       Prop at 2 Partial Order Plan Execution 
Start/.notdef.g0002
Partial Order Plan Execution 
Initialize queue Ready , with action Start ..
Mark all actions as not executed .
Loop
/.notdef.g0002IfReady isempty, Then terminate .
/.notdef.g0002Dequeue action afrom Ready andexecute .
/.notdef.g0002When completed, mark aasexecuted .
/.notdef.g0002For each succeeding action b such that
a &lt; b or linked( a,b,p),
/.notdef.g0002If every preceding action cis marked  executed ,
such that c &lt; b or linked( c,b,p),
/.notdef.g0002Then queue bonReady.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15  29
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
Adding Metric Information/.notdef.g0002
/.notdef.g0002 Going to the store takes at least 10 min and at 
most 30 min. 
/.notdef.g0002 Bread should be eaten within one day of baking.Activity: Going to the store/.notdef.g0002[10min, 30min]/.notdef.g0002
Activity: Bake Bread/.notdef.g0002[0d, 1d]/.notdef.g0002
Activity: Eat Bread/.notdef.g0002
30
Describing Temporal Plans/.notdef.g0002
/.notdef.g0002
Simplify by reducing interval relations to /.notdef.g0001
 relations on timepoints./.notdef.g0002
Activity A/.notdef.g0002
Start Activity A /.notdef.g0002A+/.notdef.g0002A-/.notdef.g0002
End Activity A /.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17  33
/.notdef.g0002Simple Temporal Problem (STP)/.notdef.g0002
/.notdef.g0002variables X1,Xn, representing /.notdef.g0001
time points with real-valued domains, /.notdef.g0002
/.notdef.g0002binary constraints of the form:/.notdef.g0002Temporal Relations Described as an STP/.notdef.g0002
X1/.notdef.g0002 X3/.notdef.g0002
X2/.notdef.g0002[l1, u1]/.notdef.g0002
[l2, u2]/.notdef.g0002 [l3, u3]/.notdef.g0002
Xk/.notdef.g0001Xi()/.notdef.g0002aik,bik[] .
Sufcient to represent:/.notdef.g0001
/.notdef.g0002 all Allen relations but 1/.notdef.g0001
/.notdef.g0002 simple metric constraints/.notdef.g0001
Cant represent:/.notdef.g0001
/.notdef.g0002 Disjoint activities/.notdef.g0001
34
/.notdef.g0002Temporal Constraint 
Satisfaction Problem (TCSP)/.notdef.g0002
/.notdef.g0002Extends STP by allowing multiple 
intervals for each binary constraints: /.notdef.g0002Temporal Relations Described as a TCSP/.notdef.g0002
X1/.notdef.g0002 X2/.notdef.g0002[l1, u1]V [l2, u2]VV[ln,un]/.notdef.g0002
Supports:/.notdef.g0002
/.notdef.g0002Multiple time windows for accomplishing an 
activity./.notdef.g0002
/.notdef.g0002Different methods of accomplishing an activity./.notdef.g0002
/.notdef.g0002X1/.notdef.g0002X2/.notdef.g0002[5, 7] V [10, 11]/.notdef.g0002Xk/.notdef.g0002Xi()/.notdef.g0003Paik,bik[] |aik/.notdef.g0001bik {}() .</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40  79
Dispatching Execution Controller/.notdef.g0002
/.notdef.g0002How can we x it?/.notdef.g0002
/.notdef.g0002Assignments must monotonically increase in value./.notdef.g0002
/.notdef.g0002Respect induced orderings./.notdef.g0002
/.notdef.g0002Execute an event when enabled  and alive/.notdef.g0002
/.notdef.g0002
/.notdef.g0002Enabled   Predecessors are completed/.notdef.g0002
/.notdef.g0002
/.notdef.g0002Alive  Current time within bound of task/.notdef.g0002
A/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002B/.notdef.g0002[0,10]/.notdef.g0002[2,11]/.notdef.g0002
[0,10]/.notdef.g0002[1,1]/.notdef.g0002
[2,2]/.notdef.g0002[1,1]/.notdef.g0002
80
Dispatching Execution Controller/.notdef.g0002
Initially:/.notdef.g0002
/.notdef.g0002E = Time points w/o predecessors/.notdef.g0002
/.notdef.g0002S = { }/.notdef.g0002
Repeat:/.notdef.g00021./.notdef.g0002Wait until current time has advanced 
such that some TP in E is active/.notdef.g0002
2./.notdef.g0002Set TPs execution time to current time./.notdef.g0002
3./.notdef.g0002Add TP to S./.notdef.g0002
4./.notdef.g0002Propagate time of execution to TPs 
immediate neighbors/.notdef.g0002
5./.notdef.g0002Add to E, all immediate neighbors that become enabled/.notdef.g0002
/.notdef.g0002TP enabled if all +lb edges starting at TP have their 
destination in S./.notdef.g0002
A/.notdef.g0002
C/.notdef.g0002D/.notdef.g0002B/.notdef.g0002[0,10]/.notdef.g0002[2,11]/.notdef.g0002
[0,10]/.notdef.g0002[1,1]/.notdef.g0002
[2,2]/.notdef.g0002[1,1]/.notdef.g0002</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39  77
Dynamic Scheduling by Decomposition?/.notdef.g0002
Consider a Simple Example/.notdef.g0002
CDB[2,11]/.notdef.g0002
A [1,1]/.notdef.g0002[0,10]/.notdef.g0002
[0,10]/.notdef.g0002 [2,2]/.notdef.g0002[1,1]/.notdef.g0002/.notdef.g0002Select executable timepoint and assign/.notdef.g0002
/.notdef.g0002Propagate assignment to neighbors/.notdef.g0002
A t = 0 [0, 10] 
[0, 10] [2, 11] 
78
Dynamic Scheduling by Decomposition?/.notdef.g0002
Consider a Simple Example/.notdef.g0002
CDB[2,11]/.notdef.g0002
A [1,1]/.notdef.g0002[0,10]/.notdef.g0002
[0,10]/.notdef.g0002 [2,2]/.notdef.g0002[1,1]/.notdef.g0002/.notdef.g0002Select executable timepoint and assign/.notdef.g0002
/.notdef.g0002Propagate assignment to neighbors/.notdef.g0002
A t = 0 t = 3 
[2, 2] [4, 4] Uh oh! /.notdef.g0002
C must be 
executed at t =2 /.notdef.g0001
in the past !/.notdef.g0002
How can we x it?/.notdef.g0002</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Model-based programming of robotic space explorers [BW]
Encoding planning problems as propositional logic satisfiability [SK]</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/http://www.ai.sri.com/~gerkey/movies/duc/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides/>
      <videos/>
    </lecture>
  </lectures>
</doc>
