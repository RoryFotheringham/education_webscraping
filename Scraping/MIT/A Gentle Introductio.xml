<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/</course_url>
    <course_title>A Gentle Introduction to Programming Using Python</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Software Design and Engineering </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>          check_for_vowels.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/check_for_vowels/</lecture_pdf_url>
      <lectureno>0</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          height_example.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/height_example/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          inheritance_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/inheritance_examples/</lecture_pdf_url>
      <lectureno>5</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          while_else.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/while_else/</lecture_pdf_url>
      <lectureno>23</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          raw_input_example.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/raw_input_example/</lecture_pdf_url>
      <lectureno>15</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          point.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/point/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          tuple_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/tuple_examples/</lecture_pdf_url>
      <lectureno>21</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          rps_example1.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/rps_example1/</lecture_pdf_url>
      <lectureno>18</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          string_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/string_examples/</lecture_pdf_url>
      <lectureno>20</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_mistakes</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_mistakes/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>to a rubb er duck, or a teddy bear, or your coee cup -the idea is, that by explaining what your written code 
actually does (as opposed to what you want it to do) will help your spot your errors. Be sure to commen t 
your code as you go; if, when youre explain ing your code, you reach a section that is particularly confusing, 
youve found a really great place for a commen t!! 
	Dening functions and reusing them. It is okay -in fact, it is completely neces sary sometimes -to dene 
multiple functions, and call them inside another function. Example: 
VOWELS = [a, e, i, o, u] 
def is_a_vowel(c):
# check if c is a vowel
lowercase_c = c.lower()
if lowercase_c in VOWELS:
# Return (BOOLEAN!) True if c is a vowel
return True
else:
# c must not be a vowel; return (BOOLEAN!) False
return False
def only_vowels(phrase):
# Takes a phrase, and returns a string of all the vowels
# Initalize an empty string to hold all of the vowels
vowel_string = 
for letter in phrase:
#	check if each letter is a vowel 
if is_a_vowel(letter): 
# If its a vowel, we append the letter to the vowel string 
vowel_string = vowel_string + letter 
#	if not a vowel, we dont care about it- so do nothing! 
return vowel_string
# Code after a "return" doesnt print
print "A line of code after the return!"
Note in this example how we 
	Commen t well, explaining what every line does! 
	Return a Boolean type in the function is a vowel so that we can use that function within an if condi
tional in the only vowels code. 
	Return only when we know what the result is 
	Show that any code after a return statemen t wont be shown, because functions exit upon hitting a 
return. 
See our solutions to Hangman if you didnt really get this in the last project. 
3</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011 Common Python Mistak es 
Weve been seeing a bunch of mistak es or misconceptions so this handout should clear some things out for you and 
serve as a reference. 
	Variables. Remem ber that a varible is a placeholder for a value that you (or someone callin g your function) 
can assign, and it can be any type -string, list, int, oat, dictionary , tuple. Variables are exactly like variables 
you learned about in calculus, although they can be more than numbers. So, rock is a variab le, called rock, 
that we can assign any value -ie rock = 8 or rock = paper. However, rock is a string -we cannot 
assign it a value, it is already the string value rock. If this distinction is still confusing to you, please visit 
oce hours for clarication. 
	The in keyword: Chec ks if some single item is in a larger collection. Returns True if the item is in the list, 
and False otherwise. Can be negated with the keyword not. 
&gt;&gt;&gt; some_list = [1, 3, 6, 7]
&gt;&gt;&gt; 3 in some_list
True
&gt;&gt;&gt; 5 in some_list
False
&gt;&gt;&gt; 5 not in some_list
True
&gt;&gt;&gt; [3] in some_list
False
Take special note of this last example. While the single item 3 is in some list, the list [3] is not. 
	Boolean types. Remem ber that True and False are Boolean types, but True, True, False and 
False are all strings. Boolean types are really importan t because they enable us to do special things within 
if statemen ts and while loops -so be sure to return a Boolean, not a string, when writing functions that ask 
you to return a Boolean. 
	Print versus return. When youre calling a function, you can print things wherev er you want; the print 
statemen t functions as a handy debugging tool, even. However, you can only return one thing. This means 
that as soon as your code hits a return statemen t, the function will exit. Keep this in mind -you never want 
to return too early. Also, INDENT ATION IS REALL Y, REALL Y IMPOR TANT! 
For exam ple, can you nd the error in the following code that should return True if a number is prime, and 
return False if it is not? 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) != 0:
return True
return False
In this case, there is a big error. It seems to work at rst: 
&gt;&gt;&gt; is_prime(7)
True
&gt;&gt;&gt; is_prime(10)
False
1</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>But look at the test case 
&gt;&gt;&gt; is_prime(9)
True
Hmmmm..... whats wrong? Ultimately , the problem is that I return True in the wrong place. So, I try again. 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) == 0:
return False
return True
There is another big problem here -I return True too early (when? for what tests cases? why is that?). 
Finally , one last try: 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) == 0:
return False
return True
Ah, this time Ive got it. See how I have returned True and False, but only when I know the number is or is 
not prime. I dont want to return too early, because then I might get false positives or negativ es. 
	is versus ==. == asks if two values are equal -ie, if they are interpreted the same way. However, is asks if 
two values are the exact same object, which often gives unexp ected results. If youre unsure, use == (the same 
applies to not is versus !=). Example: 
&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; b = [1,2]
&gt;&gt;&gt; c = a
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a is c
True
&gt;&gt;&gt; a == b
True
	Integer division. Remember that one of your argumen ts to division should be a oat if you want to make a 
fractional quan tity -do this by including a decimal or casting one of your argumen ts to a oat. 
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; print 1/x
0
&gt;&gt;&gt; print 1./x
0.14285714285714285
&gt;&gt;&gt; print 1/float(x)
0.14285714285714285
	Debugging. Weve seen a lot of code that has too many return statemen ts and studen ts are very, very confused 
at the results theyre seeing. We suggest using Rubber Duck Debugging 
(http://en.wikipedia.org/wiki/Rubber duck debugging -a silly concept that works. Explain your code 
2</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          MIT6_189IAP11_rec_problems.pdf
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_problems/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011: Optional Recursion Exercises 
These exercises are optional, have fun playing around with them. Solution s will be posted to the website on Tuesda y; 
feel free to ask questions about these problems on the sta email list, or at oce hours. 
For all these problems, be sure to carefully consider your base and recursive cases carefu lly! 
1. Write a function that takes in two numbers and recursiv ely multiplies them together. 
2. Write a function that takes in a base and an exp and recursiv ely computes baseexp. You are not allowe d to 
use the ** operator! 
3. Write a function using recursion to print numbers from n to 0. 
4. Write a function using recursion to print numbers from 0 to n (you just need to change one line in the program 
of problem 1). 
5. Write a function using recursion that takes in a string and returns a reversed copy of the string.	 The only 
string operation you are allowed to use is string concatenation. 
6. Write a function using recursion to check if a number n is prime (you have to check whether n is divisible by 
any number below n). 
7. Write a recursive function that takes in one argumen t n and computes Fn, the nth value of the Fibonacci 
sequence. Recall that the Fibonacci sequence is dened by the relation 
Fn = Fn1 + Fn2 
where
F0 = 0 and F1 =1
Visit the Wikip edia page on the Fibonacci Num ber for more information if youre still confused.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          MIT6_189IAP11_start.pdf
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_start/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>6.189: Getting Started with Python and Idle
udo apt-get install idle
o install Idle for Python 2.6. If you have Python and Idle installed with a newer version of Python (eg Python 3.1... 
ython 2.7 won't cause a conflict for 6.189 and you can leave it alone for now), you'll want to instead run these two 
ommands to install the correct version of Idle: 
udo apt-get install idle-python2.6
udo ln -s /usr/bin/idle-python2.6 /usr/bin/idle
ou should then be able to run Idle by simply running  
dle&amp;   
rom the command prompt. If you would rather compile from source, visit the Python 2.6.4 release page for 
ompressed tarballs. If you're having problems, please ask an LA for assistance. 
arning: On the Python homepage, the latest version available for download is actually 3.0. Do not install this! This 
ersion is not backwards compatible with the code that you'll be writing in this course (for example, you have to type 
rint("test") instead of print "test"). Instead, be sure to download the version listed above. 
sing IDLE
DLE is the standard Python development environment Its name is an acronym of "Integrated DeveLopment 
nvironment". It works well on both Unix and Windows platforms. 
t has a Python shell window, which gives you access to the Python interactive mode. It also has a file editor that lets 
ou create and edit existing Python source files. 
uring the following discussion of IDLE's features, instead of passively reading along, you should start IDLE and try to 
eplicate the screenshots. 
nteractive Python shell
hen you start up IDLE, a window with an interactive Python shell will pop up: s
tPc
s
s
Y
i
f
c
W
vp
U
I
E
I
y
D
r
I
W</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189: Getting Started with Python and Idle
Getting Started: Python and IDLE 
Introduction
This handout will cover how to set up Python and introduce you to IDLE, the Python development environment we will 
be using throughout this course. 
Setting up Python
On Athena* / Linux
Python should be set up correctly on the Linux athena* machines. Type 'idle' at the command prompt to ensure that 
everything is working correctly. This should start up the Python development environment IDLE. 
On your own machine
If you are working on your own machine, you will probably need to install Python. We will be using the standard 
Python software, available here. You should download and install version 2.6.x, NOT 2.7.x or 3.x All MIT Course 6 
classes currently use a version of Python 2.6. 
Windows: 
Go to the website and download the windows MSI installer for either x86 or x86-64, depending on which version of 
Windows you are running. 
Mac OS X: 
Download and install the Mac Installer disk image from the site. 
Other Linux: 
Check which version of Python you have by running  
python -V   
at a terminal. If you have a newer version of Python already installed - eg Python 2.7.x or 3.1.x, you can set Python 2.6 as the default by following the instructions listed here. Otherwise, you should be able to do one of the following 
options: 
sudo apt-get install python2.6
if you don't already have Python 2.6 installed; if you do, run 
Athena* is MIT's UNIX-based computing environment. OCW does not provide access to it.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>6.189: Getting Started with Python and Idle
 
You can type Python code directly into this shell, at the '&gt;&gt;&gt;' prompt. Whenever you enter a complete code fragment, 
it will be executed. For instance, typing: 
&gt;&gt;&gt; print "hello 
world"  
and pressing ENTER, will cause the following to be displayed: 
hello world  
Try typing an underscore ( _ ). Can you see it? On some operating systems, the bottoms of hanging letters such as 'g' 
or 'y', as well as underscorces, cannot be seen in IDLE. If this is the case for you, go to Options -&gt; Configure IDLE, and 
change the size of the default font to 9 or 11. This will fix the problem!  
 IDLE can also be used as a calculator: 
&gt;&gt;&gt; 4+4 
8 &gt;&gt;&gt; 8**3 512  
Addition (+), subtraction (-), multiplication (*), division (/), modulo (%) and power (**) operators are built into the 
Python language. This means you can use them right away. If you want to use a square root in your calculation, you</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>6.189: Getting Started with Python and Idle
can either raise something to the power of 0.5 or you can import the math module. Do not worry about what it means 
right now, we will cover this later during the course. Below are two examples of square root calculation: 
&gt;&gt;&gt; 16**0.5 4.0 &gt;&gt;&gt; import math 
&gt;&gt;&gt; math.sqrt(16) 
4.0 
 
The math module allows you to do a number of useful operations: 
&gt;&gt;&gt; math.log(16, 2) 
4.0 &gt;&gt;&gt; math.cos( 0 ) 
1.0 
 
Note that you only need to execute the import command once after you start IDLE; however you will need to execute 
it agin if you restart the shell, as restarting resets everything back to how it was when you opened IDLE. Don't worry 
too much about this right now; we'll cover it more in depth soon! 
Exercise
(this is just for practice, solutions will not be graded or collected in class) 
Use IDLE to calculate: 
1.  
6+4*10
2.  
(6+4)*10 (Compare this to #1, and note that Python uses parentheses just like you would in normal math to 
determine order of operations!)
3.  
23.0 to the 5th power
4.  
Positive root of the following equation: 
34*x^2 + 68*x - 510  Recall: a*x^2 + b*x + c x1 = ( - b + sqrt ( b*b - 4*a*c ) ) / ( 2*a) 
-------- 
The tutorial for IDLE is based on the 
official IDLE tutorial
 by Daryl Harms. 
Asfandyar Qureshi, Feb 2006. 
Edited by Vladimir Bychkovsky, Sept 2006. Edited by Calvin On, Feb 2007. Edited by Yang Zhang, Sep 2008. Edited by Chih-yu Chao, Feb 2009. Edited by Sari Canelake, Dec 2009.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
6.189 A Gentle Introduction to Programming 
January IAP 2011
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          functions.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/functions/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          rec_ex.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/rec_ex/</lecture_pdf_url>
      <lectureno>16</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          MIT6_189IAP11_rec_notes.pdf
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_notes/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011: Recursion Notes 
Recursion: (denition) noun. See recursion. 
Recursion: Formal Denition : An algorithmic technique where a function , in order to accomplish a task, calls 
itself with some part of the task. 
 Recursiv e solutions involve two major parts: 
1. Base case(s), in which the problem is simple enough to be solved directly . 
2. Recursiv e case(s). A recursiv e case has three comp onents: 
(a) Divide the problem into one or more simpler or smaller parts of the problems, 
(b) Invoke the function (recursiv ely) on each part, and 
(c) Combine the solutions of the parts into a solution for the problem. 
 Depending on the problem, any of these may be trivial or complex. 
Example: Sum 
A non-recursiv e example: 
def it_sum(a_list): 
result = 0 
for x in a_list: 
result += x 
return result 
We say that the above function iterates over the values in the variable a list, and return s their sum. 
Recursion is similar to iteration, such that the operation being performed is dened (partly) in terms of itself. Such 
an operation is said to be recursive . 
Here is a recursiv e denition of the sum() function: 
def rec_sum(a_list): 
if a_list == []: 
return 0 
else: 
return a_list[0] + rec_sum(a_list[1:]) 
rec sum computes the same exact thing as it sum, but in a dieren t way. The rst thing to note is that it does 
not use a for-lo op. The second thing to note is that the rec sum function calls itself. That is to say, rec sum() is 
dened in terms of itself; it is recursiv e. 
How does it work? Lets go through the parts of recursion mentioned at the introduction to this handout. 
1. Base Case: What is the base case of rec sum?</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2. Recursiv e case: 
(a) How do we divide the problem ? 
(b) Where do we invoke the function recursively ? 
(c) Finally , where do we combine the solutions ? 
Now, lets pretend to be a Python interpreter and execute the recursiv e calls ourselv es. 
rec_sum([1, 2, 3])
= 1 + rec_sum([2, 3])
= 1 + (2 + rec_sum([3]))
= 1 + (2 + (3 + rec_sum([]))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
=1+5
=6
Note that our base case is when the list is empt y. That is the recursiv e call to rec sum([]), which evaluates to 0. 
A base case is very importan t -it is the stopping point for recursion. 
The recursive case is demonstrated by calls to rec sum where the argumen t is a non-empt y list. During a recursiv e 
case, we make increme ntal progress towards solving the problem, and also make a recursiv e call to the function 
with a smaller input space. 
2</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_problems</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_problems/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011: Optional Recursion Exercises 
These exercises are optional, have fun playing around with them. Solution s will be posted to the website on Tuesda y; 
feel free to ask questions about these problems on the sta email list, or at oce hours. 
For all these problems, be sure to carefully consider your base and recursive cases carefu lly! 
1. Write a function that takes in two numbers and recursiv ely multiplies them together. 
2. Write a function that takes in a base and an exp and recursiv ely computes baseexp. You are not allowe d to 
use the ** operator! 
3. Write a function using recursion to print numbers from n to 0. 
4. Write a function using recursion to print numbers from 0 to n (you just need to change one line in the program 
of problem 1). 
5. Write a function using recursion that takes in a string and returns a reversed copy of the string.	 The only 
string operation you are allowed to use is string concatenation. 
6. Write a function using recursion to check if a number n is prime (you have to check whether n is divisible by 
any number below n). 
7. Write a recursive function that takes in one argumen t n and computes Fn, the nth value of the Fibonacci 
sequence. Recall that the Fibonacci sequence is dened by the relation 
Fn = Fn1 + Fn2 
where
F0 = 0 and F1 =1
Visit the Wikip edia page on the Fibonacci Num ber for more information if youre still confused.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          conditional_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/conditional_examples/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_notes</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_rec_notes/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011: Recursion Notes 
Recursion: (denition) noun. See recursion. 
Recursion: Formal Denition : An algorithmic technique where a function , in order to accomplish a task, calls 
itself with some part of the task. 
 Recursiv e solutions involve two major parts: 
1. Base case(s), in which the problem is simple enough to be solved directly . 
2. Recursiv e case(s). A recursiv e case has three comp onents: 
(a) Divide the problem into one or more simpler or smaller parts of the problems, 
(b) Invoke the function (recursiv ely) on each part, and 
(c) Combine the solutions of the parts into a solution for the problem. 
 Depending on the problem, any of these may be trivial or complex. 
Example: Sum 
A non-recursiv e example: 
def it_sum(a_list): 
result = 0 
for x in a_list: 
result += x 
return result 
We say that the above function iterates over the values in the variable a list, and return s their sum. 
Recursion is similar to iteration, such that the operation being performed is dened (partly) in terms of itself. Such 
an operation is said to be recursive . 
Here is a recursiv e denition of the sum() function: 
def rec_sum(a_list): 
if a_list == []: 
return 0 
else: 
return a_list[0] + rec_sum(a_list[1:]) 
rec sum computes the same exact thing as it sum, but in a dieren t way. The rst thing to note is that it does 
not use a for-lo op. The second thing to note is that the rec sum function calls itself. That is to say, rec sum() is 
dened in terms of itself; it is recursiv e. 
How does it work? Lets go through the parts of recursion mentioned at the introduction to this handout. 
1. Base Case: What is the base case of rec sum?</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2. Recursiv e case: 
(a) How do we divide the problem ? 
(b) Where do we invoke the function recursively ? 
(c) Finally , where do we combine the solutions ? 
Now, lets pretend to be a Python interpreter and execute the recursiv e calls ourselv es. 
rec_sum([1, 2, 3])
= 1 + rec_sum([2, 3])
= 1 + (2 + rec_sum([3]))
= 1 + (2 + (3 + rec_sum([]))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
=1+5
=6
Note that our base case is when the list is empt y. That is the recursiv e call to rec sum([]), which evaluates to 0. 
A base case is very importan t -it is the stopping point for recursion. 
The recursive case is demonstrated by calls to rec sum where the argumen t is a non-empt y list. During a recursiv e 
case, we make increme ntal progress towards solving the problem, and also make a recursiv e call to the function 
with a smaller input space. 
2</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          wheel.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/wheel/</lecture_pdf_url>
      <lectureno>22</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          rps_example2.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/rps_example2/</lecture_pdf_url>
      <lectureno>19</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          loop_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/loop_examples/</lecture_pdf_url>
      <lectureno>8</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_comment</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_comment/</lecture_pdf_url>
      <lectureno>0</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>How To Prop erly Commen t Your Code 
Uncommen ted Code The 6.189 sta receiv ed this code to grade. 
Theres a bunch of problems with it. A quick scan of it reveals no info as to which of our 250 studen ts wrote this 
code. What is the name of the le? What does it do? At a glance, we are lost. This code would receiv e a grade of 
a . 
Commen ted Code The sta next receiv ed this le. 
We can clearly see Alyssas name and the name of her le. Further she has well-commen ted what the lines of her 
program do. This code would receiv e a grade of +. You should be like Alyssa! You should commen t wherev er 
you can -put commen ts that explain what youre doing, and if youre doing something tricky or unique be sure to 
explain that, as well. A good goal is to have 1 commen t for every 1-4 lines of code. Be sure to not only documen t 
what your code is doing, but, as you begin writing more advanced code, you should documen t what was intentionally 
left out, optimized away, tried and discarded, etc -basically , any design decision you make.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          MIT6_189IAP11_mistakes.pdf
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_mistakes/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>to a rubb er duck, or a teddy bear, or your coee cup -the idea is, that by explaining what your written code 
actually does (as opposed to what you want it to do) will help your spot your errors. Be sure to commen t 
your code as you go; if, when youre explain ing your code, you reach a section that is particularly confusing, 
youve found a really great place for a commen t!! 
	Dening functions and reusing them. It is okay -in fact, it is completely neces sary sometimes -to dene 
multiple functions, and call them inside another function. Example: 
VOWELS = [a, e, i, o, u] 
def is_a_vowel(c):
# check if c is a vowel
lowercase_c = c.lower()
if lowercase_c in VOWELS:
# Return (BOOLEAN!) True if c is a vowel
return True
else:
# c must not be a vowel; return (BOOLEAN!) False
return False
def only_vowels(phrase):
# Takes a phrase, and returns a string of all the vowels
# Initalize an empty string to hold all of the vowels
vowel_string = 
for letter in phrase:
#	check if each letter is a vowel 
if is_a_vowel(letter): 
# If its a vowel, we append the letter to the vowel string 
vowel_string = vowel_string + letter 
#	if not a vowel, we dont care about it- so do nothing! 
return vowel_string
# Code after a "return" doesnt print
print "A line of code after the return!"
Note in this example how we 
	Commen t well, explaining what every line does! 
	Return a Boolean type in the function is a vowel so that we can use that function within an if condi
tional in the only vowels code. 
	Return only when we know what the result is 
	Show that any code after a return statemen t wont be shown, because functions exit upon hitting a 
return. 
See our solutions to Hangman if you didnt really get this in the last project. 
3</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189 IAP 2011 Common Python Mistak es 
Weve been seeing a bunch of mistak es or misconceptions so this handout should clear some things out for you and 
serve as a reference. 
	Variables. Remem ber that a varible is a placeholder for a value that you (or someone callin g your function) 
can assign, and it can be any type -string, list, int, oat, dictionary , tuple. Variables are exactly like variables 
you learned about in calculus, although they can be more than numbers. So, rock is a variab le, called rock, 
that we can assign any value -ie rock = 8 or rock = paper. However, rock is a string -we cannot 
assign it a value, it is already the string value rock. If this distinction is still confusing to you, please visit 
oce hours for clarication. 
	The in keyword: Chec ks if some single item is in a larger collection. Returns True if the item is in the list, 
and False otherwise. Can be negated with the keyword not. 
&gt;&gt;&gt; some_list = [1, 3, 6, 7]
&gt;&gt;&gt; 3 in some_list
True
&gt;&gt;&gt; 5 in some_list
False
&gt;&gt;&gt; 5 not in some_list
True
&gt;&gt;&gt; [3] in some_list
False
Take special note of this last example. While the single item 3 is in some list, the list [3] is not. 
	Boolean types. Remem ber that True and False are Boolean types, but True, True, False and 
False are all strings. Boolean types are really importan t because they enable us to do special things within 
if statemen ts and while loops -so be sure to return a Boolean, not a string, when writing functions that ask 
you to return a Boolean. 
	Print versus return. When youre calling a function, you can print things wherev er you want; the print 
statemen t functions as a handy debugging tool, even. However, you can only return one thing. This means 
that as soon as your code hits a return statemen t, the function will exit. Keep this in mind -you never want 
to return too early. Also, INDENT ATION IS REALL Y, REALL Y IMPOR TANT! 
For exam ple, can you nd the error in the following code that should return True if a number is prime, and 
return False if it is not? 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) != 0:
return True
return False
In this case, there is a big error. It seems to work at rst: 
&gt;&gt;&gt; is_prime(7)
True
&gt;&gt;&gt; is_prime(10)
False
1</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>But look at the test case 
&gt;&gt;&gt; is_prime(9)
True
Hmmmm..... whats wrong? Ultimately , the problem is that I return True in the wrong place. So, I try again. 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) == 0:
return False
return True
There is another big problem here -I return True too early (when? for what tests cases? why is that?). 
Finally , one last try: 
def is_prime(number):
for divisor in range(2, number):
if (number % divisor) == 0:
return False
return True
Ah, this time Ive got it. See how I have returned True and False, but only when I know the number is or is 
not prime. I dont want to return too early, because then I might get false positives or negativ es. 
	is versus ==. == asks if two values are equal -ie, if they are interpreted the same way. However, is asks if 
two values are the exact same object, which often gives unexp ected results. If youre unsure, use == (the same 
applies to not is versus !=). Example: 
&gt;&gt;&gt; a = [1,2]
&gt;&gt;&gt; b = [1,2]
&gt;&gt;&gt; c = a
&gt;&gt;&gt; a is b
False
&gt;&gt;&gt; a is c
True
&gt;&gt;&gt; a == b
True
	Integer division. Remember that one of your argumen ts to division should be a oat if you want to make a 
fractional quan tity -do this by including a decimal or casting one of your argumen ts to a oat. 
&gt;&gt;&gt; x = 7
&gt;&gt;&gt; print 1/x
0
&gt;&gt;&gt; print 1./x
0.14285714285714285
&gt;&gt;&gt; print 1/float(x)
0.14285714285714285
	Debugging. Weve seen a lot of code that has too many return statemen ts and studen ts are very, very confused 
at the results theyre seeing. We suggest using Rubber Duck Debugging 
(http://en.wikipedia.org/wiki/Rubber duck debugging -a silly concept that works. Explain your code 
2</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          recursion.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/recursion/</lecture_pdf_url>
      <lectureno>17</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_start</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_start/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>6.189: Getting Started with Python and Idle
udo apt-get install idle
o install Idle for Python 2.6. If you have Python and Idle installed with a newer version of Python (eg Python 3.1... 
ython 2.7 won't cause a conflict for 6.189 and you can leave it alone for now), you'll want to instead run these two 
ommands to install the correct version of Idle: 
udo apt-get install idle-python2.6
udo ln -s /usr/bin/idle-python2.6 /usr/bin/idle
ou should then be able to run Idle by simply running  
dle&amp;   
rom the command prompt. If you would rather compile from source, visit the Python 2.6.4 release page for 
ompressed tarballs. If you're having problems, please ask an LA for assistance. 
arning: On the Python homepage, the latest version available for download is actually 3.0. Do not install this! This 
ersion is not backwards compatible with the code that you'll be writing in this course (for example, you have to type 
rint("test") instead of print "test"). Instead, be sure to download the version listed above. 
sing IDLE
DLE is the standard Python development environment Its name is an acronym of "Integrated DeveLopment 
nvironment". It works well on both Unix and Windows platforms. 
t has a Python shell window, which gives you access to the Python interactive mode. It also has a file editor that lets 
ou create and edit existing Python source files. 
uring the following discussion of IDLE's features, instead of passively reading along, you should start IDLE and try to 
eplicate the screenshots. 
nteractive Python shell
hen you start up IDLE, a window with an interactive Python shell will pop up: s
tPc
s
s
Y
i
f
c
W
vp
U
I
E
I
y
D
r
I
W</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.189: Getting Started with Python and Idle
Getting Started: Python and IDLE 
Introduction
This handout will cover how to set up Python and introduce you to IDLE, the Python development environment we will 
be using throughout this course. 
Setting up Python
On Athena* / Linux
Python should be set up correctly on the Linux athena* machines. Type 'idle' at the command prompt to ensure that 
everything is working correctly. This should start up the Python development environment IDLE. 
On your own machine
If you are working on your own machine, you will probably need to install Python. We will be using the standard 
Python software, available here. You should download and install version 2.6.x, NOT 2.7.x or 3.x All MIT Course 6 
classes currently use a version of Python 2.6. 
Windows: 
Go to the website and download the windows MSI installer for either x86 or x86-64, depending on which version of 
Windows you are running. 
Mac OS X: 
Download and install the Mac Installer disk image from the site. 
Other Linux: 
Check which version of Python you have by running  
python -V   
at a terminal. If you have a newer version of Python already installed - eg Python 2.7.x or 3.1.x, you can set Python 2.6 as the default by following the instructions listed here. Otherwise, you should be able to do one of the following 
options: 
sudo apt-get install python2.6
if you don't already have Python 2.6 installed; if you do, run 
Athena* is MIT's UNIX-based computing environment. OCW does not provide access to it.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>6.189: Getting Started with Python and Idle
 
You can type Python code directly into this shell, at the '&gt;&gt;&gt;' prompt. Whenever you enter a complete code fragment, 
it will be executed. For instance, typing: 
&gt;&gt;&gt; print "hello 
world"  
and pressing ENTER, will cause the following to be displayed: 
hello world  
Try typing an underscore ( _ ). Can you see it? On some operating systems, the bottoms of hanging letters such as 'g' 
or 'y', as well as underscorces, cannot be seen in IDLE. If this is the case for you, go to Options -&gt; Configure IDLE, and 
change the size of the default font to 9 or 11. This will fix the problem!  
 IDLE can also be used as a calculator: 
&gt;&gt;&gt; 4+4 
8 &gt;&gt;&gt; 8**3 512  
Addition (+), subtraction (-), multiplication (*), division (/), modulo (%) and power (**) operators are built into the 
Python language. This means you can use them right away. If you want to use a square root in your calculation, you</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>6.189: Getting Started with Python and Idle
can either raise something to the power of 0.5 or you can import the math module. Do not worry about what it means 
right now, we will cover this later during the course. Below are two examples of square root calculation: 
&gt;&gt;&gt; 16**0.5 4.0 &gt;&gt;&gt; import math 
&gt;&gt;&gt; math.sqrt(16) 
4.0 
 
The math module allows you to do a number of useful operations: 
&gt;&gt;&gt; math.log(16, 2) 
4.0 &gt;&gt;&gt; math.cos( 0 ) 
1.0 
 
Note that you only need to execute the import command once after you start IDLE; however you will need to execute 
it agin if you restart the shell, as restarting resets everything back to how it was when you opened IDLE. Don't worry 
too much about this right now; we'll cover it more in depth soon! 
Exercise
(this is just for practice, solutions will not be graded or collected in class) 
Use IDLE to calculate: 
1.  
6+4*10
2.  
(6+4)*10 (Compare this to #1, and note that Python uses parentheses just like you would in normal math to 
determine order of operations!)
3.  
23.0 to the 5th power
4.  
Positive root of the following equation: 
34*x^2 + 68*x - 510  Recall: a*x^2 + b*x + c x1 = ( - b + sqrt ( b*b - 4*a*c ) ) / ( 2*a) 
-------- 
The tutorial for IDLE is based on the 
official IDLE tutorial
 by Daryl Harms. 
Asfandyar Qureshi, Feb 2006. 
Edited by Vladimir Bychkovsky, Sept 2006. Edited by Calvin On, Feb 2007. Edited by Yang Zhang, Sep 2008. Edited by Chih-yu Chao, Feb 2009. Edited by Sari Canelake, Dec 2009.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu 
6.189 A Gentle Introduction to Programming 
January IAP 2011
 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          MIT6_189IAP11_comment.pdf
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/mit6_189iap11_comment/</lecture_pdf_url>
      <lectureno>9</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>How To Prop erly Commen t Your Code 
Uncommen ted Code The 6.189 sta receiv ed this code to grade. 
Theres a bunch of problems with it. A quick scan of it reveals no info as to which of our 250 studen ts wrote this 
code. What is the name of the le? What does it do? At a glance, we are lost. This code would receiv e a grade of 
a . 
Commen ted Code The sta next receiv ed this le. 
We can clearly see Alyssas name and the name of her le. Further she has well-commen ted what the lines of her 
program do. This code would receiv e a grade of +. You should be like Alyssa! You should commen t wherev er 
you can -put commen ts that explain what youre doing, and if youre doing something tricky or unique be sure to 
explain that, as well. A good goal is to have 1 commen t for every 1-4 lines of code. Be sure to not only documen t 
what your code is doing, but, as you begin writing more advanced code, you should documen t what was intentionally 
left out, optimized away, tried and discarded, etc -basically , any design decision you make.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>MIT OpenCourseWare 
http://ocw.mit.edu 
6.189  A Gentle Introduction to Programming 
January IAP 2011 
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          lecture3.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/lecture3/</lecture_pdf_url>
      <lectureno>6</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          comprehension_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/comprehension_examples/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides/>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>          list_examples.py
        </lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/resources/list_examples/</lecture_pdf_url>
      <lectureno>7</lectureno>
      <slides/>
      <videos/>
    </lecture>
  </lectures>
</doc>
