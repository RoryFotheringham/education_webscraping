<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/</course_url>
    <course_title>Computer Graphics</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Programming Languages </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>Ray Casting and Rendering (PDF - 3.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec11/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>39</slideno>
          <text>40 
Camera Description?</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Origin  Point 
 Direction  Vector  
 normal
ized is bette
r 
 Parametric line 
 P(t) = origin + t * direction 
29 Ray Representation 
origin direction P(t) How would you 
represent a ray?</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Questions? 
Even Funkier 
Multiperspective 
Imaging 
Courtesy of Paul Rademacher. Used with permission.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Questions?</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Ray Casting Basics 
 
 Camera and Ray Generation 
 
 Ray-Plane Intersection 
 
 Ray-Sphere Intersection 
33 Ray Casting</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Also need surface normal for shading 
 (Diffuse: dot product between light 
direction and normal, clamp to zero) 
 Normal is constant over the plane 
65 Normal  
normal</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>(Infinite) plane defined by  
 Po = (x0, y0, z0) 
 n = (A,B,C)  
 Implicit plane equation 
 H(P) = Ax+By+Cz+D = 0 
         = nP + D = 0 
58 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Ray Generation? 
 Origin = e + x*size* u + y*size* v 
 Direction is constant: w 
51 
Orthographic Camera</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Surface/Scene Properties 
 surface normal 
 direction to light 
 viewpoint 
 Material Properties 
 Diffuse (matte) 
 Specular (shiny) 
  
 Light properties 
 Position 
 Intensity, ... 
 Much more! 
20 
Shading = What Surfaces Look Like 
Diffuse sphere Specular spheres N 
L 
V</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26 Ray Tracing 
Reflections, refractions 
Caustics Reflections 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Henrik Wann Jensen. Used with permission.
 Turner Whitted, Bell Laboratories. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Rendering refers to the entire 
process that produces color values for pixels,  
given a 3D representation of the scene 
 Pixels correspond to rays; need to figure out the 
visible scene point along each ray 
 Called hidden surface problem in older texts 
 Visibility is a more modern term 
 Also, we assume (for now) a single ray per pixel 
14 Rendering</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 Perspective vs. Orthographic 
 Parallel projection 
 No foreshortening 
 No vanishing point 
perspective orthographic</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Intersection means both are satisfied 
 So, insert explicit equation of ray into  
implicit equation of plane &amp; solve for t 
      P(t) = Ro + t * Rd 
      H(P) = n P + D = 0 
      n(Ro + t * Rd) + D = 0 
      t = -(D + nRo) / nRd  
62 Ray-Plane Intersection 
P(t) 
Done!</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>3 cases, depending on the sign of  b2  4ac 
 What do these cases correspond to? 
 Which root (t+ or t-) should you choose? 
 Closest positive! 
71 Ray-Sphere Intersection</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 
Scene Camera 
Image 
plane Image 
Pixels Rendering = Scene to Image 
 source unknown. All rights reserved. This
content is excluded from our Creative
Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia- P
astor, Daniel Rypl . All rights  reserved.
This content i
s excluded from our Creative Commons
license. For  more information, see
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 
Scene Image 
Pixels Rendering 
Pixel Color 
Determined by 
Lighting/Shading  source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content is excluded from our Creative Commons
license. For more information, see 
http://ocw.mit .
edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 
Camera Image 
plane Image Coordinates 
-1  x  1  -1  y  1  
Convenient to define 
normalized image 
coordinates such 
that the x, y 
coordinates run 
from -1 to 1 
regardless of the 
dimensions and 
aspect ratio of the 
image rectangle. 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Questions?</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Eye-image pyramid (view frustum) 
 Note that the distance/size of image are arbitrary 
39 Simplified Pinhole Camera 
same image 
will result on 
this image plane</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>E.g. fish eye, omnimax, parabolic 
52 Other Weird Cameras 
CAVE Columbia University  
 source unknown. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /. CAVE Lab, Columbia University. All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Implicit sphere equation  
 Assume centered at origin (easy to translate) 
 H(P) = ||P||2 - r2 = PP - r2  = 0 
68 Sphere Representation? 
Rd Ro</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>For every pixel  
Construct a ray from the eye  
For every object in the scene  
Find intersection with the ray  
Keep if closest  
First we will study ray-plane intersection 
55 
Ray Casting</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Ray-Sphere Intersection 
 It's so easy  
that all  
ray-tracing  
images  
have  
spheres! 
:-) 
Turner Whitted  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>(Infinite) plane defined by  
 Po = (x0, y0, z0) 
 n = (A,B,C)  
57 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Origin  Point 
 Direction  Vector  
 normal
ized is bette
r 
 Parametric line 
 P(t) = origin + t * direction 
30 Ray Representation 
origin direction P(t) Another way to put 
the ray casting 
problem statement: 
Find smallest t &gt; 0 
such that P(t) lies 
on a surface in the 
scene</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Modeling 
 splines, hierarchies, transformations, meshes, etc. 
 
 Animation 
 skinning, ODEs, masses and springs 
 
Now well to see how to generate  
an image given a scene description! 
4 The Story So Far</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Intersection means both are satisfied 
 So, insert explicit equation of ray into  
implicit equation of plane &amp; solve for t 
      P(t) = Ro + t * Rd 
      H(P) = n P + D = 0 
      n(Ro + t * Rd) + D = 0 
      t = -(D + nRo) / nRd  
63 Ray-Plane Intersection 
P(t) 
Done! 
Whats the deal 
when nR d = 0?</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Ray Casting Basics 
 
 Camera and Ray Generation 
 
 Ray-Plane Intersection 
 
 Ray-Sphere Intersection 
17 Ray Casting</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>For every pixel  
  Construct a ray from the eye  
  For every object in the scene  
    Find intersection with ray  
      Keep if closest  
34 Cameras 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Ray Casting and Ray Tracing 
 Intro to Global Illumination 
 Monte Carlo techniques, photon mapping, etc. 
 Shading, texture mapping 
 What makes materials look like they do? 
 Image-based Rendering 
 Sampling and antialiasing 
 Rasterization, z-buffering 
 Shadow t
echniques 
 Graphics Hardware 
5 The Remainder of the Term 
[Lehtinen et al. 2008]  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Albrecht Drer , 16th century 
31 Drers Ray Casting Machine 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Image by Henrik Wann Jensen 
66 Questions? 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 
Scene Image 
Pixels Rendering 
Whats the 
color you put 
in each pixel?  source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content is excluded from our Creative Commons
license. For more  
information, see 
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 
Ray Generation in 2D 
field of view  
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
D 
eye point e r p then we just 
normalize r to get 
the ray r = p-e = (x* u, D*w) 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Cool Artifacts from Assignment 1 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Simply Q/||Q||  
 Q = P(t), intersection point 
 (for spheres centered at origin) 
73 Sphere Normal 
Q 
normal Ro O 
Rd</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Cool Artifacts from Assignment 1 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Camera Obscura Today 
Abelardo Morell    
www.abelardomorell.net Images removed due to copyright restrictions -- please see
http://www.abelardomorell.net/photography/cameraobsc_01/cameraobsc_17.html
http://www.abelardomorell.net/posts/camera-obscura/
http://www.abelardomorell.net/photography/cameraobsc_49/cameraobsc_63.html 
for further details.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Lets think about shadows... 
21 Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44 
field of view  
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
eye point e p p is point on image 
plane at coordinate x, 
we want to know the 
direction of the ray r 
r? Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>(Infinite) plane defined by  
 Po = (x0, y0, z0) 
 n = (A,B,C)  
 Implicit plane equation 
 H(P) = Ax+By+Cz+D = 0 
         = nP + D = 0 
 Point-Plane distance? 
 If n is normalized,  
distance to plane is
 H(P) 
 it is a signed  distance! 
60 3D Plane Representation? 
H Po normal P 
P' 
H(p) &lt; 0 H(p) &gt; 0</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Insert explicit equation of ray into  
implicit equation of sphere &amp; solve for t  
    P(t) = Ro + t*Rd ;     H(P) = PP - r2  =  0 
         ( Ro + tRd)  (Ro + tRd) - r2  =  0 
                  RdRdt2 + 2RdRot + RoRo - r2  = 0 
69 
Ray-Sphere Intersection 
Rd Ro</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Quadratic: at2 + bt + c = 0 
 a = 1  (remember, ||Rd|| = 1) 
 b = 2RdRo 
 c = RoRo  r2 
 
 with discriminant 
 
 and solutions 
70 Ray-Sphere Intersection</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Ray equation is explicit       P(t) = Ro + t * Rd 
 Parametric 
 Generates points 
 Hard to verify that a point is on the ray  
 Plane equation is implicit    H(P) = nP + D = 0 
 Solution of an equation 
 Does not generate points 
 Verifies that a point is on the plane 
 
 Exercise: Explicit plane and implicit ray? 
61 Explicit vs. Implicit?</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>y coordinate is treated just like x, 
except accounting for aspect ratio 
r = (x* u, aspect*y* v, D*w) 
 Again, u, v, w are the basis vectors 
of the view coordinate system 
 Aspect ratio handles non-square viewports 
 Think of your 16:9 widescreen TV 
 
 The point of the exercise with computing D was to 
allow us to use the [-1,1] image coordinate system 
regardless of field of view. 
49 That was 2D, 3D is just as simple</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Ray casting = eye rays only, tracing = also secondary 
 
24 
X Secondary rays are used for 
testing shadows, doing 
reflections, refractions, etc. 
Well do all this a little 
later! Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Parametric line  
 P(t) = Ro + t * Rd 
 Explicit representation 
56 Recall: Ray Representation 
Rd Ro 
origin direction P(t)</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 
field of view  image plane 
-1 &lt; x &lt; 1 1 
right u view direction w Ray Generation in 2D 
What is the distance 
D to the screen so 
that the normalized 
coordinates go to 1? 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Pinhole Camera 
 Box with a tiny hole 
 Inverted image 
 Similar triangles  Perfect image if hole 
infinitely small 
 Pure geometric optics 
 No depth of field issue 
(everything in focus)</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Also Called Camera Obscura 
Image courtesy of Wellcome Library, London. License: CC- BY-NC. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Albrecht Drer, 16th century 
32 Drers Ray Casting Machine 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Scene 
7  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more  information, see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade  
19 
Shading</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 
camera rays 
are rays from the 
camera to the 
scene ? Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>(Infinite) plane defined by  
 Po = (x0, y0, z0) 
 n = (A,B,C)  
 Implicit plane equation 
 H(P) = Ax+By+Cz+D = 0 
         = nP + D = 0 
 What is D? 
59 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0 
(Point P 0 must lie on plane)</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>47 
field of view  
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
D r = p-e = (x* u, D*w) 
eye point e r p Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 
field of view  image plane 
-1 &lt; x &lt; 1 
D 1 
right u view direction w Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>MIT EECS 6.837  Durand  Thats All for Today 
NVIDIA  
 But before we talk about the quiz, lets watch a  cool 
video! 
 Next time: Ray-triangle intersection, ray tracing 
75  NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Verify that intersection is closer than previous 
 
 Verify that it is not out of range (behind eye) 
64 Additional Bookkeeping 
t &gt; tmin t &lt; tcurrent 
P(t)</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 Questions? 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 
Scene Camera 
Image 
plane Pixels  source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights  reserved.
This content is excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/hel p
/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 
Scene Image 
Each pixel corresponds to 
one ray. We need to figure 
out which scene point each 
one hits. Pixels Rendering  Pinhole Camera 
 source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content  
is excluded from our Creative Commons
license. For more information, see 
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>What does rendering  mean? 
 
 Basics of ray casting 
6 Today</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>For every pixel  
Construct a ray from the eye  
For every object in the scene  
Find intersection  with the ray   
Keep if closest  
Shade depending on light and normal vector 
28 
Ray Casting 
N Finding the 
intersection point  
and normal  is the 
central part of ray 
casting</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Ray Casting Basics 
 
 Camera and Ray Generation 
 
 Ray-Plane Intersection 
 
 Ray-Sphere Intersection 
54 Ray Casting</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 
Scene Camera This image is in the public domain.
Source: openclipart source unknown. All rights reserved. This content is  excluded from our Creative
Commons license. For more  information, see http://ocw.mit.edu/help/faq-fair-use /.
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This  content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
 MIT EECS 6.837  Matusik MIT EECS 6.837 Computer Graphics 
Part 2  Rendering 
NVIDIA Today: Intro to Rendering, Ray Casting 
 NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Eye point e (center) 
 Orthobasis u, v, w (horizontal, up, direction) 
41 
Camera Description? 
Object 
coordinates 
World 
coordinates 
View 
coordinates 
Image 
coordinates u w v</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 
X ray from light to hit 
point is blocked, i.e., 
point is in shadow Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Rendering refers to the entire 
process that produces color values for pixels 
 Pixels correspond to rays; need to figure out the 
visible scene point along each ray 
 Called hidden surface problem in older texts 
 Visibility is a more modern term 
 Also, we assume (for now) a single ray per pixel 
 Major algorithms: Ray casting and rasterization 
 
 Note: We are assuming a pinhole camera (for now) 
15 Rendering</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Secondary Rays 
Indirect illumination 
Shadows Reflections Refractions 
Caustics Henrik Wann Jensen 25 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Ray Casting Basics 
 
 Camera and Ray Generation 
 
 Ray-Plane Intersection 
 
 Ray-Sphere Intersection 
67 Ray Casting</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>From Gemma Frisius, 1545 
36 Oldest Illustration  
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 
Camera Description? 
Object 
coordinates 
World 
coordinates 
View 
coordinates 
Image 
coordinates u w v  Eye point e (center) 
 Orthobasis u, v, w (horizontal, up, direction) 
 Field of view angle 
 Image rectangle aspect ratio</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
18 
Ray Casting</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Shading and Material Appearance (PDF - 1.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec15/</lecture_pdf_url>
      <lectureno>15</lectureno>
      <slides>
        <slide>
          <slideno>71</slideno>
          <text>72 Thats All for Today! 
Images from  the movie, The Matrix, removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Reflection angle = light angle 
 Both R &amp; L have to lie on one plane  
R =  L + 2 (L  N) N 
34 Recap: How to Get Mirror Direction 
R L 
 L  R N 
L N N L N N 
-L light source</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>The specular reflection distribution 
is usually called a lobe 
 For Phong, its shape is  
41 Terminology: Specular Lobe 
Surface 
light source</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Phong Illumination Model 
 
 
 
Is it physically based? 
No, does not even conserve energy, 
may well reflect more energy than what goes in 
Furthermore, it does not even conform to the BRDF model 
directly (we are taking the proper cosine for diffuse, but 
not for specular) 
And ambient was a total hack 
45 Putting It All Together</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>The ideal diffuse BRDF is a constant fr(l, v) = const. 
 What constant /, where  is the albedo  
 Coefficient between 0 and 1 that says what fraction is reflected 
 Usually just called diffuse color kd 
 You have already implemented this by taking dot products 
with the normal and multiplying by the color!   
28 Ideal Diffuse Reflectance</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Spotlight Geometry 
Adapted from 
POVRAY documentation hotspot angle (direction d)</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Light only reflects to the mirror direction 
 A Dirac delta multiplied by a specular coefficient ks 
 
 Not very useful for point lights, only for reflections 
of other surfaces 
 Why? You cannot really see a mirror reflection of an 
infinitely small light! 
35 Ideal Specular BRDF</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Ideal diffuse reflectors reflect light according to 
Lamberts cosine law 
 The reflected light varies with cosine even if distance to 
light source is kept constant 
26 Ideal Diffuse Reflectance</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Increasing specularity near grazing angles. 
 Most BRDF models account for this. 
47 Fresnel Reflection 
Source: Lafortune et al. 97 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>A Data-Driven Reflectance Model, SIGGRAPH 
2003 
 The data is available 
http://people.csail.mit.edu/wojciech/BRDFDatabase/ 
69 Image-Based Acquisition 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837  Matusik  
Shading &amp; Material Appearance   
 
 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Another possibility: Take pictures of spheres coated 
with material, rotate light around a 1D arc 
 This gives 3DOF =&gt; isotropic materials only 
22 How Do We Obtain BRDFs? 
Matusik et al.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Dark Blue Paint 
Acquired data Cook-Torrance 
Material  Dark blue paint Finding the BRDF model parameters that best reproduce the real material Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Ideal diffuse reflectors reflect light according to 
Lamberts cosine law 
 The reflected light varies with cosine even if distance to 
light source is kept constant 
27 Ideal Diffuse Reflectance 
Remembering that incident irradiance depends on cosine, 
what is the BRDF of an ideally diffuse surface?</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Questions?</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions?</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59 Microfacet Theory 
 Value of BRDF at (L,V) is a product of 
 number of mirrors oriented halfway between L and V 
 ratio of the un(shadowed/masked) mirrors 
 Fresnel coefficient</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Dark Blue Paint 
Blinn-Phong 
Material  Dark blue paint Acquired data 
Finding the BRDF model parameters that best reproduce the real material Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Sum of three components: 
      ideal diffuse reflection + 
      specular reflection + 
      ambient. 
42 The Complete Phong Model 
Surface light source</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 Adding a Second Lobe 
Material  Red Christmas Ball 
 Some materials impossible to represent with a 
single lobe 
Cook-Torrance 2 lobes Acquired data 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Questions? T. Weyrich  et al., Fabricating 
Microgeometry  for Custom Surface 
Reflectance, SIGGRAPH 2009  
Images of Fig. 1 and Fig. 6 in Weyrich T. et al, "Fabricating Microgeometry for Custom Surface Reflectance."
SIGGRAPH '09 ACM SIGGRAPH 2009 papers; Article No. 32 --removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 Questions?</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Assume surface reflects equally in all directions. 
 An ideal diffuse surface is, at the microscopic level, a 
very rough surface. 
 Example: chalk, clay, some paints 
25 Ideal Diffuse Reflectance 
Surface</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Lets combine this with the 1/r2 fall-off: 
 
 
Iin is the irradiance (intensity) at 
surface point x 
Ilight is the intensity of the light 
  is the angle between light direction l  
and surface normal n 
 r is the distance between light and x. 
7 Incoming Irradiance for Pointlights 
Surface  n 
x l</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Questions?</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>BRDFs can be measured from real data 
 But tabulated 4D data is too cumbersome for most uses 
 Therefore, parametric BRDF models represent the 
relationship between incident and outgoing light by 
some mathematical formula 
 The appearance can then be tuned by setting parameters 
 Shininess, anisotropy, etc. 
 Physically-based or Phenomenological 
 They can model with measured data (examples later) 
 Popular models: Diffuse, Blinn- Phong, Cook-
Torrance, Lafortune, Ward, Oren-Nayar, etc. 
23 Parametric BRDFs</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Value of BRDF at (L,V) is a product of 
 number of mirrors oriented halfway between L and V 
57 Microfacet Theory</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>We will not be too formal in this class 
 Issues we will not really care about 
 Directional quantities vs. integrated over all directions 
 Differential terms: per solid angle, per area 
 Power? Intensity? Flux? 
 
 Color 
 All math here is for a single wavelength only; we will 
perform computations for R, G, B separately 
 Do not panic, that just means 
we will perform every operation three times, that is all 
3 Unit Issues - Radiometry</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Phong Illumination Model 
44 Putting It All Together 
 Leonard McMillan. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Observations 
Material  Red Christmas Ball Acquired data Cook-Torrance  Some materials impossible to represent with a 
single lobe 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>When keeping l and v fixed, if rotation of surface 
around the normal does not change the reflection, the 
material is called isotropic 
 Surfaces with strongly oriented microgeometry 
elements are anisotropic 
 Examples:  
 brushed metals, 
 hair, fur, cloth, velvet 
19 Isotropic vs. Anisotropic 
Westin et.al 92</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>The amount of light energy received by a surface 
depends on incoming angle 
 Bigger at normal incidence, even if distance is const. 
 Similar to winter/summer difference 
 How exactly? 
 Cos  law 
 Dot product with normal 
6 Incoming Irradiance 
Surface  n</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Parameters 
ks: specular reflection coefficient 
q : specular reflection exponent 
39 The Phong Specular Model 
Surface   Camera  r n 
l 
v 
light source</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 BRDF fr</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Single Point Light Source 
kd: diffuse coefficient (color) 
n: Surface normal. 
l: Light direction. 
 Li: Light intensity  
 r: Distance to source 
 Lo: Shaded color 
30 Ideal Diffuse Reflectance Math 
Surface  
l n r 
light source</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Demo</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Pointlights with non-uniform directional emission 
 Usually symmetric about a central 
direction d, with angular falloff 
 Often two angles 
 Hotspot angle: 
No attenuation within the central cone  
 Falloff angle: Light attenuates 
from full intensity to zero intensity 
between the hotspot and falloff 
angles 
 
 Plus your favorite distance 
falloff curve 9 Spotlights 
d</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 BRDF fr</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15 BRDF fr 
 Relates incident irradiance from 
every direction to outgoing light. 
How? 
l = light direction 
(incoming) 
v = view direction 
(outgoing)</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 BRDF fr 
 Relates incident irradiance from 
every direction to outgoing light. 
How? 
 
 
 Lets combine with what 
we know already of pointlights: 
l = light direction 
(incoming) 
v = view direction 
(outgoing)</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 Demo</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>This is the simplest possible parametric BRDF 
 One parameter: kd 
 (One for each RGB channel) 
29 Ideal Diffuse Reflectance</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Effect of q  the specular reflection exponent 
40 The Phong Model</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Example 
 Think of water surface as lots of tiny mirrors (microfacets) 
 Bright pixels are 
 Microfacets aligned with the vector between sun and eye 
 But not the ones in shadow 
 And not the ones that are occluded 
53 Microfacet Theory 
Image of sunset removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 2D Slice at Constant Incidence 
Example: Plot of PVC BRDF at 55  incidence 
highlight incoming 
incoming  For a fixed incoming direction, 
view dependence is a 2D 
spherical function 
 Here a moderate specular 
component 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission. ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Designer BRDFs by Ashikhmin et al.  
63 Questions? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Interpolate the average vertex normals across the 
face and use this in shading computations 
 Again, use barycentric interpolation! 
71 Phong Normal Interpolation (Not Phong  
Shading )</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>How much light is reflected? 
 Depends on the angle   between the ideal reflection 
direction r and the viewer direction v. 
38 The Phong Specular Model 
Surface   Camera  r n 
l 
v light source</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Represents the reflection of all indirect illumination. 
 This is a total hack! 
 Avoids the complexity of 
indirect (global) illumination 
43 Ambient Illumination</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>One possibility: Gonioreflectometer 
 4 degrees of freedom 
21 How do we obtain BRDFs? 
Source: Greg Ward 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Quantifying Reflection  BRDF 
 Bidirectional Reflectance 
Distribution Function 
 Ratio of light coming from one 
direction that gets reflected in 
another direction 
 Pure reflection, assumes no 
light scatters into the 
material 
 
 Focuses on angular aspects, not 
spatial variation of the material 
How many dimensions? 
Incoming  
direction 
Outgoing  
direction  ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>s is the specular coefficient (3 numbers RGB) 
 D is the microfacet distribution  
  is the angle between the half vector H and the normal N 
 m defines the roughness (width of lobe) 
 G is the shadowing and masking term 
 Need to add a diffuse term 
62 Full Cook-Torrance Lobe</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Value of BRDF at (L,V) is a product of 
 number of mirrors oriented halfway between L and V 
 ratio of the un(shadowed/masked) mirrors 
58 Microfacet Theory</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Reflection is only at mirror angle 
 View dependent 
 Microscopic surface elements are usually oriented in the 
same direction as the surface itself. 
 Examples: mirrors, highly polished metals. 
33 Ideal Specular Reflectance 
Surface  l n 
r  
light source</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>All materials seen so far are the same everywhere 
 In other words, we are assuming the BRDF is independent 
of the surface point x 
 No real reason to make that assumption 
 More next time 
73 Spatial Variation 
 ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission. source unknown. All rights reserved. This
content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Uses the halfway vector h between l and v. 
49 Blinn-Torrance Variation of Phong 
Surface l n 
Camera 
v h 
 
Light source</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Single Point Light Source 
kd: diffuse coefficient (color) 
n: Surface normal. 
l: Light direction. 
 Li: Light intensity  
 r: Distance to source 
 Lo: Shaded color 
31 Ideal Diffuse Reflectance Math 
Surface  
l n r 
 We do not want light from below the 
surface! From now on we always 
assume (on this lecture) that dot 
products are clamped to zero and 
skip writing out the max(). Do not forget 
to normalize 
your n  and l! light source</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Input for realistic rendering 
 Geometry, Lighting and Materials 
 Material appearance 
 Intensity and shape of highlights 
 Glossiness 
 Color 
 Spatial variation, i.e., texture (next Tuesday) 
2 Lighting and Material Appearance 
Slide Addy Ngan  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Today, we only consider point light sources 
 Thus we do not need to care about solid angles 
 For multiple light sources, use linearity 
 We can add the solutions for two light sources 
 I(a+b) = I(a) + I(b) 
 We simply multiply the solution when we scale the light 
intensity 
 I(s a) = s I(a) 
4 Light Sources 
a b 
Yet again, linearity 
is our friend!</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Simple Empirical Reasoning for Glossy Materials 
 We expect most of the reflected light to travel in the 
direction of the ideal mirror ray. 
 However, because of microscopic surface variations we 
might expect some of the light to be reflected just slightly 
offset from the ideal reflected ray.  
 As we move farther and farther, in the angular sense, from 
the reflected ray, we expect to see less light reflected.  
37 Non-ideal Reflectors</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 Phong Examples 
 The spheres illustrate 
specular reflections as 
the direction of the 
light source and the 
exponent q (amount of 
shininess) is varied.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 
Half Vector Lobe is Better 
 More consistent with what is observed in 
measurements ( Ngan, Matusik, Durand 
2005) 
Example: Plot of PVC BRDF at 55  incidence Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Real glossy materials usually deviate significantly 
from ideal mirror reflectors 
 Highlight is blurry 
 They are not ideal diffuse surfaces either  
36 Non-ideal Reflectors</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>1/r2 fall-off for isotropic point lights 
 Why? An isotropic point light 
outputs constant power per solid 
angle (into all directions) 
 Must have same power in all 
concentric spheres 
 Spheres surface area grows with r2 =&gt; energy obeys 1/r2 
  but in graphics we often cheat with or ignore this.  
 Why? Ideal point lights are kind of harsh 
 Intensity goes to infinity when you get close  not great! 
 In particular, 1/(ar2+br+c) is popular 
5 Intensity as Function of Distance 
r1 r2</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Develop BRDF models by imposing simplifications 
[Torrance-Sparrow 67 ], [Blinn 77], [Cook-Torrance 
81], [Ashikhmin et al. 2000 ] 
 
 Model the distribution p(H) of 
microfacet normals 
 Also, statistical models 
for shadows and masking 
61 
Microfacet Theory-based Models 
spherical plot of a 
Gaussian-like p(H)</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Lobe Comparison 
Half vector lobe Mirror lobe  Half vector lobe 
 Gradually narrower when approaching grazing 
 Mirror lobe 
 Always circular</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Model surface by tiny mirrors 
[Torrance &amp; Sparrow 1967]  
54 Microfacet Theory</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64 BRDF Examples from Ngan et al.  
Acquired data 
Material  Dark blue paint 
Lighting 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Value of BRDF at (L,V) is a product of 
 number of mirrors oriented halfway between L and V 
55 Microfacet Theory</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Pointlights that are infinitely far 
 No falloff, just one direction and one intensity 
 
 
Iin is the irradiance at surface point x 
from the directional light 
Ilight is the intensity of the light 
  is the angle between light direction l  
and surface normal n 
 Only depends on n, not x! 
8 Directional Lights 
Surface  n 
x l</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Value of BRDF at (L,V) is a product of 
 number of mirrors oriented halfway between L and V 
56 Microfacet Theory</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Questions?</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Some facets are hidden from viewpoint 
 Some are hidden from the light 
60 Shadowing and Masking 
hidden from viewpoint hidden from viewpoint</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Curves Properties and Conversion, Surface Representation (PDF - 1.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec02/</lecture_pdf_url>
      <lectureno>02</lectureno>
      <slides>
        <slide>
          <slideno>18</slideno>
          <text>Questions? 
19</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>Specialized Procedural Definitions 
 Surfaces of 
revolution 
 Rotate given 2D 
profile curve 
 Generalized 
cylinders 
 Given 2D profile and 
3D curve, sweep the 
profile along the 3D 
curve 
Assignment 1! 
93</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>P(u,v) is a 3D point specified by u, v 
The partial derivatives                  and                are 
3D vectors 
Both are tangent to surface at P 
Normal is perpendicular to both, i.e., 
 
 
n is usually not 
unit, so must 
normalize! Tangents and Normals for Patches 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
63</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>Frame defined by 1st 
(tangent), 2nd and 3rd  
derivatives of a 3D curve 
 Looks like a good idea 
for swept surfaces... Frames on Curves: Frenet Frame 
Image courtesy of Kristian Molhave  on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative C
ommons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.
97</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + 
B3(u) * P3(v) 
  + B4(u) * P4(v) 
 Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 Bicubics, Tensor Product 
P1,1 P1,2 P1,3 P1,4 P2,1 P2,2 P2,3 
P2,4 P3,1 P3,2 
P3,3 P3,4 P4,1 P4,2 
P4,3 P4,4 
57</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Corner Cutting 
85</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Connecting Cubic Bzier Curves 
 Where is this curve 
 C0 continuous? 
 G1 continuous? 
 C1 continuous? 
 Whats the relationship 
between:  
 the # of control points, and 
the # of cubic Bzier 
subcurves? 
23</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Questions? 
5</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>6.837  Durand  Subdivision Surfaces 
 Start with polygonal mesh 
 Subdivide into larger number of polygons, 
smooth result after each subdivision 
 Lots of ways to do this. 
 The limit surface is smooth! 
 IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
76</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Triangle meshes 
 Surface analogue of polylines, this is what GPUs 
draw 
Tensor Product Splines 
 Surface analogue of spline curves 
Subdivision surfaces 
  Implicit surfaces, e.g. f(x,y,z)=0 
Procedural 
 e.g. surfaces of revolution, generalized cylinder 
 From volume data (medical images, etc.) Representing Surfaces 
40</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>You can stack the Gx, Gy, Gz matrices into a 
geometry tensor  of control points 
 I.e., Gki,j = the kth coordinate of control point Pi,j 
 A cube of numbers! 
 
 
 Definitely not required, but nice! 
 See http://en.wikipedia.org/wiki/Multilinear_algebra Super Hardcore: Tensor Notation 
68</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Differentiation is a linear operation 
 (f+g)=f+g 
 (af)=a f 
 This means that the derivative of the basis is 
enough to know the derivative of any spline.  
 Can be done with matrices 
 Trivial in monomial basis 
 But get lower-order polynomials Linearity? 
14</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Cubic B-Splines 
 Local control (windowing) 
 Automatically C2, and no need to match tangents! 
Courtesy of Seth Teller.  Used with permission. 
33</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Not all surfaces are smooth... Cool: Displacement Mapping 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
72</text>
        </slide>
        <slide>
          <slideno>109</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>The tangent to the curve P(t) can be defined as  
T(t)=P(t)/||P(t)|| 
 normalized velocity, ||T(t)|| = 1 
 This provides us with one orientation for swept 
surfaces later Tangent Vector 
15
Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Questions? 
39</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>6.837  Durand  
Cubic B-Splines 
  4 control points 
 Locally cubic 
 Cubics chained together, again. 
 Curve is not constrained to pass through any 
control points 
29Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Curves: 
 
 
 Surfaces: 
 
 
 
T = power basis 
B = spline matrix 
G = geometry matrix Hardcore: Matrix Notation for Patches 
A separate 4x4 geometry 
matrix for x, y, z 
67</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>For Bzier curves, the  
    basis polynomials/vectors 
    are Bernstein polynomials 
 
 For cubic Bezier curve: 
    B 1(t)=(1- t)          B 2(t)=3t(1- t) 
    B 3(t)=3t (1-t) B 4(t)=t 
    (careful with indices, many authors start at 0) 
 Defined for any degree Bernstein Polynomials 
3</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 v=1/3 v=2/3 A 2D surface patch! 
52</text>
        </slide>
        <slide>
          <slideno>105</slideno>
          <text>Point Set Surfaces 
Alexa et al. 2001 From Point Set Surfaces, used 
with permission from ACM, Inc 
 IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
106</text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>Build triplet of vectors 
 include tangent (it is reliable) 
 orthonormal 
 coherent over the curve 
 Idea:  
 use cross product to create orthogonal vectors 
 exploit discretization of curve  
 use previous frame to bootstrap orientation 
See Assignment 1 instructions! Smooth Frames on Curves 
99</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Displacement Mapping Example 
Smooth base surface Displaced Surface 
This image is in the public domain. Source: Wikimedia Commons.
74</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>P(t) =  (1-t)  P1 
  + 3t(1-t)  P2  
  + 3t(1-t)  P3 
  + t  P4  Smooth Surfaces? 
Whats the 
dimensionality of a 
curve? 1D! 
 
What about a 
surface? 
42</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Rational cubics 
 Use homogeneous coordinates, just add w ! 
 Provides an extra weight parameter to control points 
 
 NURBS:  Non-Uniform Rational B-Spline 
non-uniform = different spacing between the 
blending functions, a.k.a. knots 
rational  = ratio of cubic polynomials 
(instead of just cubic) 
 implemented by adding the homogeneous coordinate w into 
the control points. NURBS (Generalized B-Splines) 
38</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>How do we get M? 
 Translation is easy, given by c(v) 
 What about orientation? 
 Orientation options: 
 Align profile curve with an axis. 
Better : Align profile curve with 
frame that follows the curve General Swept Surfaces 
where M is a matrix that depends on the trajectory c s(u,v)= M(c(v)) q(u) 
q c 
s 
96</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Questions? 
61</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + B3(u) * P3(v) 
  + B4(u) * P4(v) 
 Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 
Bicubics, Tensor Product 
58</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>C0 = continuous 
 The seam can be a sharp kink 
 G1 = geometric continuity 
 Tangents point to the same 
direction  at the seam 
 C1 = parametric continuity 
 Tangents are the same at the 
seam, implies G1 
 C2 = curvature continuity 
 Tangents and their derivatives 
are the same Orders of Continuity 
C0 
G1 
C1 
20</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>B-Spline Curve Control Points 
Default B-Spline 
 B-Spline with 
derivative 
discontinuity B-Spline which passes 
through  
end points 
Repeat interior control 
point Repeat end points 
34</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Velocity 
Sanity check: t=0; t=1 
 First derivative w.r.t. t 
 Can you compute this for Bezier curves? 
P(t) =  (1-t)  P1 
  + 3t(1-t)  P2  
  + 3t(1-t)  P3 
  + t  P4  
P(t) =  -3(1-t)2  P1  
 + [3(1-t) 2 -6t(1-t)] P2 
 + [6t(1-t) -3t 2]        P3 
 + 3t 2    P4 
13</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>K is zero for a line, constant for circle 
 What constant? 1/r 
 1/||K(t)|| is the radius of the circle that touches 
P(t) at t and has the same curvature as the curve Geometric Interpretation 
17</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Geometry: control points coordinates assembled 
into a matrix (P1, P2, , Pn+1) 
 Power basis:  the monomials 1, t, t2, ... 
 Cubic Bzier: General Spline Formulation 
4</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Idea: cut corners to smooth 
 Add points and compute  
weighted average of neighbors 
 Same for surfaces 
 Special case for irregular vertices  
 vertex with more or less than 6 neighbors in a triangle mesh Subdivision Curves and Surfaces 
Warren et al.  
 IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
88</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 
48</text>
        </slide>
        <slide>
          <slideno>104</slideno>
          <text>Point Set Surfaces 
 Given only a noisy 3D point cloud (no 
connectivity), can you define a reasonable surface 
using only the points? 
 Laser range scans only give you points, 
so this is potentially useful 
From Point Set Surfaces, (Alexa et al. 2001). IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use/.
105</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>In the previous, P is were just some curves 
What if we make them Bzier curves? 
Each u=const. and v=const.                             
curve is a Bzier curve! 
Note that the boundary                                  
control points (except                                   
corners) are NOT                                     
interpolated! Tensor Product Bzier Patches 
v=0 v=1 v=2/3 
54</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Questions? 
75</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>Trace out surface by moving a  
profile curve along a trajectory. 
 profile curve q(u) provides one dim 
 trajectory c(u) provides the other 
 Surface of revolution can be seen  
as a special case where trajectory  
is a circle General Swept Surfaces 
where M is a matrix that depends on the trajectory c 
q c 
s 
s(u,v)= M(c(v)) q(u) 
95</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Corner Cutting 
 
84</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Parametric surface P( u,v) is a bicubic polynomial 
of two variables u &amp; v 
 Defined by 4x4=16 control points P1,1, P1,2.... 
P4,4 
 Interpolates 4 corners, approximates others 
 Basis are product of two Bernstein polynomials: 
B1(u)B1(v); B1( u)B2(v);... B4( u)B4(v) 
 Recap: Tensor Bzier Patches 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
60</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Cubic B-Splines 
  4 control points 
 Locally cubic 
 Cubics chained together, again. 
28
Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Cubic Bzier in matrix notation Recap: Matrix Notation for Curves 
point on curve 
(2x1 vector) 
Geometry matrix 
of control points P1..P4 
(2 x 4) Spline matrix 
(Bernstein) Canonical 
power basis 
65</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Corner Cutting 
80</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Tensor Product Bzier Patches 
The Control Mesh 
16 control points 
56</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Normalized curvature: T(t)/||T(t)|| Curve Normal 
18</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>G1 = geometric continuity 
 Tangents point to the same 
direction  at the seam 
 good enough for modeling 
 C1 = parametric continuity 
 Tangents are the same at the 
seam, implies G1 
 often necessary for animation Orders of Continuity 
G1 
C1 
21</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Corner Cutting 
(Well, not totally unexpected, 
remember de Casteljau) 
87</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Corner Cutting 
83</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837  Matusik  6.837 Computer Graphics 
 
Curve Properties &amp; Conversion, 
Surface Representations 
 
vectorportal.com 
1</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Questions? 
24</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>P(t) =  (1-t)  P1 
  + 3t(1-t)  P2  
  + 3t(1-t)  P3 
  + t  P4  Cubic Bezier Splines 
2</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>P(u) = (1-u)  P1 
  + 3u(1- u) P2  
  + 3u(1-u) P3 
 
 + u  P4  
 How to Build Them? Heres an Idea 
(Note! We relabeled 
t to u) 
43</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Tensor Product Bzier Patches 
A bicubic Bzier 
surface 
 
 
55</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Corner Cutting 
77</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>First derivative w.r.t. t 
 Can you compute this for Bezier curves? 
P(t) =  (1-t)  P1 
  + 3t(1-t)  P2  
  + 3t(1-t)  P3 
  + t  P4  
 You know how to 
differentiate polynomials... Velocity 
12</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>Normal flips! 
 Bad to define a smooth swept surface Frenet: Problem at Inflection! 
An inflection is a point 
where curvature changes 
sign 
98</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Cubic B-Splines: Basis 
B1 B4 B2 B3 These sum to 1, too! 
A B-Spline curve is also 
bounded by the convex  
hull of its control points.  
30</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Corner Cutting 
82</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Questions? 
92</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 v=1/3 v=2/3 
51</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Hardcore: Matrix Notation for Patches 
x coordinate of 
surface at ( u,v) 
Row vector of 
basis functions ( u) Column vector of 
basis functions ( v) 
4x4 matrix of x coordinates 
of the control points 
 Not required, 
but convenient! 
66</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Differential Properties of Curves 
 Motivation 
 Compute normal for surfaces 
 Compute velocity for animation  
 Analyze smoothness 
Image courtesy of Kristian Molhave on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.
11</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Derivative of unit tangent 
 K(t)=T(t) 
 Magnitude ||K(t)|| is constant for a circle 
 Zero for a straight line 
 Always orthogonal to tangent, ie. Curvature Vector 
16</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>B1 B4 B2 B3 
3
2 Cubic B-Splines: Basis 
32</text>
        </slide>
        <slide>
          <slideno>106</slideno>
          <text>Modern take on implicit surfaces 
 Cool math: Moving Least Squares (MLS), 
partitions of unity, etc. 
 
 
 
 
 
 Not required in this class, but nice to know. Point Set Surfaces 
Ohtake et al. 2003From Multi-Level Partition 
of Unity Implicits
 ACM, Inc.  All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
107</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>P(u) = (1-u)  P1 
  + 3u(1- u) P2  
  + 3u(1-u) P3 
 
 + u  P4   
 How to Build Them? Heres an Idea 
(Note! We relabeled 
t to u) 
45</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 v=1/3 v=2/3 
50</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>What youve used so far in Assignment 0 
 Triangle represented by 3 vertices 
Pro: simple, can be rendered directly 
Cons : not smooth, needs many triangles to 
approximate smooth surfaces (tessellation) 
 Triangle Meshes 
This image is in the public domain. Source: Wikimedia Commons.
41</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>P(u,v) is a 3D point specified by u, v 
The partial derivatives                  and                are 
3D vectors 
Both are tangent to surface at P 
 
Tangents and Normals for Patches 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
62</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Converting between Bzier &amp; BSpline 
 
 Simple with the basis matrices! 
 Note that this only works for 
a single segment of 4 
control points 
 P(t) = G B1 T(t) = 
G B1 (B2-1B2) T(t)= 
(G B 1 B2-1) B2 T(t) 
G B1 B2-1 are the control points 
for the segment in new basis. 
36</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>P(u) = (1-u)  P1 
  + 3u(1- u) P2  
  + 3u(1-u) P3 
 
 + u  P4  
 How to Build Them? Heres an Idea 
(Note! We relabeled 
t to u) 
44</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>Questions? 
101</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>B1 B4 B2 B3 
3
1 Cubic B-Splines: Basis 
31</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>P(u) = (1-u)  P1 
  + 3u(1- u) P2  
  + 3u(1-u) P3 
 
 + u  P4   
 How to Build Them? Heres an Idea 
(Note! We relabeled 
t to u) 
46</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Connecting Cubic Bzier Curves 
 How can we guarantee C0 continuity? 
 How can we guarantee G1 continuity?  
 How can we guarantee C1 continuity? 
 C2 and above gets difficult 
22</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>Surface of Revolution 
v 
s(u,v)= R(v)q(u) 
where R is a matrix, 
q a vector, 
and s is a point on 
the surface s(u,v)  2D curve q( u) provides one dimension 
 Note: works also with 3D curve 
 Rotation R(v ) provides 2nd dimension 
 
94</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>6.837  Durand  Utah Teapot: Tensor Bzier Splines 
 Designed by Martin Newell 
Image courtesy of Dhatfield  on Wikimedia Commons. License: CC-BY -SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
71</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Questions? 
9</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>MIT EECS 6.837, Popovi Converting between Bzier &amp; B-Spline 
original 
control 
points as 
Bzier 
original 
control 
points as 
B-Spline new Bzier 
control 
points to 
match     
B-Spline new 
BSpline 
control 
points to 
match  
Bzier 
37</text>
        </slide>
        <slide>
          <slideno>103</slideno>
          <text>Questions? 
104</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 v=1/3 
49</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Corner Cutting 
81</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Corner Cutting 
78</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Corner Cutting 
79</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Cubic B-Splines 
  4 control points 
 Locally cubic 
 Cubics chained together, again. 
Courtesy of Seth Teller.  
25</text>
        </slide>
        <slide>
          <slideno>108</slideno>
          <text>0
9 6.837  Durand  Thats All for Today 
Further reading 
Buss, Chapters 7 &amp; 8 
 
Subvision curves and surfaces 
http://www.cs.nyu.edu/~dzorin/sig00course/ 
109</text>
        </slide>
        <slide>
          <slideno>107</slideno>
          <text>Questions? 
108</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + B3(u) * P3(v) 
  + B4(u) * P4(v) 
 Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 
Bicubics, Tensor Product 
16 control points Pi,j 
16 2D basis functions Bi,j 
59</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Questions? 
64</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Tensor Product B-Spline Patches 
 Bzier and B-Spline curves are both cubics 
 Can change between representations using matrices 
 
 Consequently, you can build tensor product 
surface patches out of B-Splines just as well 
 Still 4x4 control points for each patch 
 2D basis functions are pairwise 
products of B-Spline basis functions 
 Yes, simple! 
 Addison-Wesley. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
69</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Advantages 
 Arbitrary topology 
 Smooth at boundaries 
 Level of detail, scalable 
 Simple representation 
 Numerical stability, well-behaved meshes 
 Code simplicity 
 Little disadvantage: 
 Procedural definition 
 Not parametric 
 Tricky at special vertices 
Warren et al.  Subdivision Curves and Surfaces 
 IEEE. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
89</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>What if we want to transform each point on the 
curve with a linear transformation M? 
 Because everything is linear, it is the same as 
transforming only the control points Linear Transformations &amp; Cubics 
P(t)=  
M 
= 
M 
7</text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>Need partial derivatives w.r.t. 
both u and v 
 
Remember to normalize! 
 One given by tangent of profile 
curve, the other by tangent of                             
trajectory Normals for Swept Surfaces 
where M is a matrix that depends on the trajectory c s(u,v)=M(c (v))q(u) 
q c 
s s s 
100</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Not all surfaces are smooth... 
 Paint displacements on a smooth surface 
 For example, in the direction of normal 
 Tessellate smooth patch into fine grid, 
then add displacement D(u,v) to vertices 
 Heavily used in movies, more and more in games Cool: Displacement Mapping 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
73</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Subdivision + Displacement 
Original rough mesh Original mesh with  
subdivision Original mesh with 
subdivision and 
displacement 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
91</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Homogeneous coordinates also work 
 Means you can translate, rotate, shear, etc. 
 Note though that you need to normalize P by 1/ w Affine Transformations 
P(t)=  
M 
= 
M 
1 1 1 1 
1 1 1 1 
8</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Differential Properties of Curves &amp; Continuity 
 B-Splines 
 Surfaces 
 Tensor Product Splines 
 Subdivision Surfaces 
 Procedural Surfaces 
 Other  The Plan for Today 
10</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Catmull-Clark 
 Quads and triangles 
 Generalizes bicubics to 
arbitrary topology! 
 Loop, Butterfly 
 Triangles 
 Doo-Sabin, sqrt(3), biquartic... 
 and a whole host of others 
 Used everywhere  in movie and game modeling! 
 See http://www.cs.nyu.edu/~dzorin/sig00course/ Flavors of Subdivision Surfaces 
Image courtesy of Romainbehar on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
90</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>What if we want to transform each point on the 
curve with a linear transformation M?  Linear Transformations &amp; Cubics 
P(t)=  
M 
6</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Cubic B-Splines 
  4 control points 
 Locally cubic 
 Cubics chained together, again. 
27
Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>102</slideno>
          <text>Pros:  
 Efficient check whether  point is inside 
 Efficient Boolean operations 
 Can handle weird topology for animation 
 Easy to do sketchy modeling 
 Cons: 
 Does not allow us to easily generate a  
point on the surface Implicit Surfaces 
Image courtesy of Anders Sandberg on Wikimedia Commons. License: CC-BY -
SA. This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
103</text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>Implicit Surfaces 
 Surface defined implicitly by a function 
This image is in the public domain. Source: Wikimedia Commons.
102</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Cubic B-Splines 
  4 control points 
 Locally cubic 
 Cubics chained together, again. 
26
Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>In the previous, P is were just some curves 
What if we make them Bzier curves? Tensor Product Bzier Patches 
53</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Bzier  B-Spline 
Bzier B-Spline 
But both are cubics, so one can be converted into the other! 
35</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Corner Cutting 
It turns out corner cutting 
(Chaikins Algorithm) 
produces a quadratic B-
Spline curve! (Magic!) 
86</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Pros 
 Smooth  
 Defined by reasonably small set of points 
 Cons 
 Harder to render (usually converted to triangles) 
 Tricky to ensure continuity at patch boundaries 
 Extensions 
 Rational splines: Splines in homogeneous coordinates 
 NURBS: Non-Uniform Rational B-Splines 
 Like curves: ratio of polynomials, non-uniform location of 
control points, etc. Tensor Product Spline Patches 
70</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>P(u, v) =  (1-u)   P1(v) 
  + 3u(1- u)       P2(v)  
  + 3u(1-u)  P3(v) 
 
 + u  P4(v)  
 Lets make 
the Pis move along 
curves!
 Heres an Idea 
v=0 v=1 
47</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Basics of Computer Animation&#8212;Skinning/Enveloping (PDF - 2.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec06/</lecture_pdf_url>
      <lectureno>06</lectureno>
      <slides>
        <slide>
          <slideno>10</slideno>
          <text>Physically-Based Character Animation 
 Specify keyframes, solve for physically valid motion 
that interpolates them by spacetime optimization 
 
 Anthony C. Fang and Nancy S. Pollard, 2003. Efficient 
Synthesis of Physically Valid Human Motion , ACM 
Transactions on Graphics 22(3) 417-426, Proc. SIGGRAPH 
2003. http://graphics.cs.cmu.edu/nsp/projects/spacetime/space
time.html Another Example 
11</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Super Cool: Automatic Rigging 
 When you just have some reference skeleton 
animation (perhaps from motion capture) and a 
skin mesh, figure out the bone transformations 
and vertex weights! 
 Ilya Baran, Jovan Popovic: Automatic Rigging 
and Animation of 3D Characters, 
SIGGRAPH 2007 

 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
71</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>This is what we do to get deformed positions 
 
 
 
 But wait... 
 
 
 
Rotations are not handled correctly (!!!) Hmmh... 
67</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Each bone has a deformation of 
the space around it (rotation, translation) 
 What if we attach each 
vertex of the skin to a single bone? 
 Skin will be rigid, except at joints where it will 
stretch badly 
 Lets attach a vertex to many bones at once! 
 In the middle of a limb, 
the skin points follow the bone rotation (near-
rigidly) 
 At a joint, skin is deformed according to a 
weighted combination of the bones SSD / Skinning 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA. 
29</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. Because we are Lazy... 
Can you think of examples? 
13</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>From: Pose Space Deformation: A Unified Approach to Shape Interpolation and Skeleton-Driven 
Deformation, J. P. Lewis, Matt Cordner, Nickson Fong 
Indeed... Limitations 
 Rotations really need to be combined differently 
(quaternions!) 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
68</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Types of Animation: Keyframing 
 Specify scene only at 
some instants of time 
 Generate in-betweens automatically 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
8</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Building 3D models and their animation controls is 
a major component of every animation pipeline. 
 
Building the controls is called rigging. 
17</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Describes the motion algorithmically 
 Express animation as a function of 
small number of parameters 
 Example 
 a clock/watch with second, minute and hour hands 
 express the clock motions in terms of 
a seconds variable 
 the clock is animated by 
changing this variable 
 Another example: Grass in the wind, 
tree canopies, etc. Types of Animation: Procedural 
9</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Many slides courtesy of Jovan 
Popovic, Ronen Barzel, and 
Jaakko Lehtinen Basics of Computer Animation 
Skinning/Enveloping 
 
 MIT EECS 6.837 Computer Graphics 
6.837 Matusik Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
1</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>How to compute 
vertex positions? 
38</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Ken Perlins facial expression 
applet  
 
 Lower-level controls are 
mapped to semantically 
meaningful higher-level ones 
 Frown/smile etc. Example of Higher-Level Controls 
http://mrl.nyu.edu/~perlin/experiments/facedemo/ 
 Ken Perlin. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
16</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
 Transform by 
T1 and T2 
yields p01, p02 
 the new position  
is p0= 
0.5*p1 +  
0.5*p2 Rest (bind) pose  
After rotations p0 
p0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
p01 p02 Skin  
Skin  
45</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>SSD is Not Perfect 
After rotations p0 q0 Questions? 
47</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Do the usual forward kinematics  
 get a matrix Tj(t) per bone  
(full transformation from local to world) 
 For each skin vertex pi Skinning Pseudocode 
61</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Example 
James &amp; Twigg, Skinning Mesh Animations.Colored 
triangles are 
attached to 1 
bone 
Black triangles 
are attached to 
more than 1 
 
Note how they 
are near joints 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
31</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. Linear Blend Skinning 
39</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>We then figure out the vertex 
weights wij. 
 How? Usually paint by hand! 
 Well look at much cooler 
methods in a while. Bind Pose &amp; Weights 
From Automatic Rigging and Animation of 3D Characters.
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
60</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>This is what we do to get deformed positions Hmmh... 
65</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Forward kinematics 
describes the positions of the 
body parts as a function of 
joint angles 
 Body parts are 
usually called bones 
 Angles are the low-
dimensional control. 
 Inverse kinematics specifies 
constraint locations for bones 
and solves for joint angles. Articulated Character Models 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA.
18</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>The in-betweening, was once a job for apprentice animators. 
Splines accomplish these tasks automatically. However, the 
animator still has to draw the keyframes.  This is an art form and 
precisely why the experienced animators were spared the in-
betweening work even before automatic techniques. 
 The classical paper on animation by John Lasseter from Pixar 
surveys some the standard animation techniques:   
 "Principles of Traditional Animation Applied to 3D Computer  
Graphics , SIGGRAPH'87 , pp. 35 -44. 
 See also The Illusion of Life:  Disney Animation, by Frank 
Thomas and Ollie Johnston.  Traditional Animation Principles 
3</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Types of Animation (overview) 
 Keyframing 
 Procedural 
 Physically-based 
 
 Animation Controls 
 
Character Animation 
using skinning/enveloping Plan 
CERN 
24</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Bind Pose contd 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
57</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
 Weight properties 
 Usually want weights to be non-negative 
 Also, want the sum over all bones 
to be 1 for each vertex Vertex Weights 
35</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. 
 Example: The joint angles (bone transformations) in a 
hierarchical character determine the pose 
 Example: A rigid motion is represented by 
changing the object- to-world transformation 
(rotation and translation). 
Because we are Lazy... 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA.
14</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>The Other Direction 
From Skinning Mesh Animations.
73 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Skinning Characters 
 Embed a skeleton into a 
detailed character mesh 
 
Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
19</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>When we animate the model, 
the bone transformations 
Tj change. Bind Pose contd 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
52</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Questions? 
23</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Undeformed vertices pi are given 
in the object space of the skin 
Tj is in local bone coordinate system 
 according to skeleton  
hierarchy Coordinate Systems 
GNU Free Documentation License. Some rights reserved. This content is
excluded from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
50</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Do the usual forward kinematics  
 For each skin vertex pi 
 
 
 Note that the weights &amp; bind pose vertices are 
constant over time 
 Only matrices change  
(small number of them, one per bone) 
 This enables implementation on GPU vertex 
shaders 
(little information to update for each frame) Skinning Pseudocode 
64</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT EECS 6.837 - Duand  Thats All for Today! 
 Further reading 
http://www.okino.com/
conv/skinning.htm 
 
 Take a look at any 
video game  
basically all the 
characters are 
animated using 
SSD/skinning. 
74</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Vertex Weights 
 Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
From Automatic Rigging and Animation of 3D Characters.   ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
33</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Vertex Weights 
 Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
32</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. 
Basic Idea 2 : Then blend the results using the 
weights. 
        Computing Vertex Positions 
pij is the vertex i 
transformed using 
bone j. 
Tj is the current 
transformation of bone 
j. 
pi is the new skinned 
position of vertex i. 
41</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>This is what we do to get deformed positions 
 
 
 
 But wait... Hmmh... 
66</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Do the usual forward kinematics  
 get a matrix Tj(t) per bone  
(full transformation from local to world) 
 For each skin vertex pi 
 
 
 
 Inverse transpose for normals! Skinning Pseudocode 
63</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>When we animate the model, 
the bone transformations 
Tj change. 
 What is Tj? It maps from the 
local coordinate system of 
bone j to world space. 
 To be able to deform pi according 
to Tj, we must first express pi in the local 
coordinate system of bone j. 
 This is where the bind pose 
bone transformations B j come in. Bind Pose contd 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
54</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Bind Pose contd 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. 
56</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Super Cool: Automatic Rigging 
From Automatic Rigging and Animation 
of 3D Characters by Baran and Popovic, 
used with permission from ACM, Inc.  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
72</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75
MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
 Weight properties 
 Usually want weights to be non-negative Vertex Weights 
34</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>How do we describe and generate motion of 
objects in the scene? 
 
 
 
 Two very different contexts:  
 Production (offline)  
 Can be hardcoded, entire sequence know beforehand 
 Interactive (e.g. games, simulators)  
 Needs to react to user interaction, sequence not known Computer Animation 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
6</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Example 
James &amp; Twigg, Skinning Mesh Animations, 2005, used with permission from ACM, Inc . Colored 
triangles are 
attached to 1 
bone 
Black triangles 
are attached to 
more than 1 
 
Note how they 
are near joints 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
30</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Squash : flatten an object or character by pressure or by 
its own power 
 
Stretch: used to increase the sense of speed and 
emphasize the squash by contrast Example: Squash and Stretch 
Image adapted from: Lasseter, John. "Principles of Traditional Animation applied to 3D Computer Animation."  ACM SIGGRAPH Com puter Graphics 21, no. 4 (July 1987): 35- 44.  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For mo
re information, see http://ocw.mit.edu/help/faq-fair-use/.
4</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Traditional Animation 
 From ACM  1997 Multiperspective panoramas for cel animation . Draw each frame by hand
 
 great control, but tedious 
 Reduce burden with cel animation 
 Layer, keyframe, inbetween,  
 Example: Cel panoramas (Disneys 
Pinocchio) 
Image courtesy of Garrett Albright on Wikimedia
Commons. License: CC-BY -SA. This content is
excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
2</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Motion Capture 
 Usually uses optical markers and multiple 
high-speed cameras 
 Triangulate to get marker 3D position 
 (Again, structure from motion and projective 
geometry, i.e., homogeneous coordinates) 
 Captures style, subtle nuances and realism 
 But need ability to record someone 
Courtesy Robert C. Duvall, Duke University. License CC BY-NC-SA.
21</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Skinning 
 We know how to animate a 
bone hierarchy 
 Change the joint angles, i.e., 
bone transformations, over 
time (keyframing) 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA.Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
26</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Embed a skeleton into a 
detailed character mesh 
 Animate bones 
 Change the joint 
angles over time 
 Keyframing, procedural, etc. 
 Bind skin vertices to bones 
 Animate skeleton, skin will 
move with it Skinning Characters 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA. Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
20</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>We are given a skeleton and a 
skin mesh in a default pose 
 Called bind pose 
 Undeformed vertices pi are  
given in the object space of  
the skin 
 a global coordinate system, 
no hierarchy Bind Pose 
GNU Free Documentation License. Some rights reserved. This content i s
excluded from our Creative Commons license. For more i
nformation, see
http://ocw.mit.edu/help/faq-fair-use/.
48</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>We are given a skeleton and a 
skin mesh in a default pose 
 Called bind pose 
 Undeformed vertices pi are  
given in the object space of  
the skin 
 Previously we conveniently 
forgot that in order for 
pij = Tj pi to make sense, 
coordinate systems must 
match up. Bind Pose 
GNU Free Documentation License. Some rights reserved. This content is
excluded from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
49</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>In the rigging phase, we 
line the skeleton up with the 
undeformed skin. 
 This gives some rest pose 
bone transformations Bj 
from local bone coordinates to global  
Bj concatenates all hierarchy matrices  
from node j up to the root Bind Pose contd 
51</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Assign physical properties to objects 
 Masses, forces, etc. 
 Also procedural forces (like wind) 
 Simulate physics by solving equations of motion 
 Rigid bodies, fluids, plastic deformation, etc. 
 Realistic but difficult to control Types of Animation: Physically-Based 
v0 
m g 
10</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Do the usual forward kinematics  
 get a matrix Tj(t) per bone  
(full transformation from local to world) 
 For each skin vertex pi Skinning Pseudocode 
Do you remember how to treat normals? 
62</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Types of Animation (overview) 
 Keyframing 
 Procedural 
 Physically-based 
 
 Animation Controls 
 
 Character Animation 
using skinning/enveloping Plan 
CERN 
7</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Bind Pose contd 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
The 
identity! 
Questions? 
59</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Bind Pose contd 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
The 
identity! 
58</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Need to infer how skin deforms 
from bone transformations. 
 Most popular technique: 
Skeletal Subspace Deformation 
(SSD), or simply Skinning 
 Other aliases 
 vertex blending 
 matrix palette skinning 
 linear blend skinning Skinning/Enveloping 
 This image is in the public domain. Source: Wikimedia Commons.
28</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Types of Animation (overview) 
 Keyframing 
 Procedural 
 Physically-based 
 
Animation Controls 
 
 Character Animation 
using skinning/enveloping Plan 
CERN 
12</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. 
Basic Idea 2 : Then blend the results using the 
weights. Linear Blend Skinning 
40</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Bind Pose contd 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj.  To be able to deform pi 
according to Tj, we must first 
express pi in the local 
coordinate system of bone j. 
 This is where the bind pose 
bone transformations Bj come 
in. 
55</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
 Well limit the number of bones N that can 
influence a single vertex 
N=4 bones/vertex is a usual choice 
 Why? You most often dont need very many. 
 Also, storage space is an issue. 
 In practice, well store N   (bone index j, weight wij) 
pairs per vertex. Vertex Weights contd 
37</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
 Transform by 
T1 and T2 
yields p01, p02 
 the new position  
is p0= 
0.5*p1 +  
0.5*p2 Rest (bind) pose  
After rotations p0 
p0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
p01 p02 Skin  
44</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Usual approach: Paint them on the skin. 
 Can also find them by optimization from example 
poses and deformed skins. 
Wang &amp; Phillips, SCA 2002 Figuring out the Weights 
From Automatic Rigging and Animation of 3D Characters. ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
70</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Example: Timing 
 Timing affects weight: 
 Light object move quickly 
 Heavier objects move slower 
 
 
 Timing completely changes the interpretation of the 
motion. 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
5</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. 
 Example: The joint angles (bone transformations) in a 
hierarchical character determine the pose 
 Example: A rigid motion is represented by 
changing the object- to-world transformation 
(rotation and translation). 
Blendshapes are 
keyframes that are just 
snapshots of the 
entire geometry. Because we are Lazy... 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA.
15</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>We know how to animate a 
bone hierarchy 
 Change the joint angles, i.e., 
bone transformations, over 
time (keyframing) 
 Embed a skeleton into a 
detailed character mesh 
 Bind skin vertices to bones 
 Animate skeleton, skin will 
move with it 
 But how? Skinning 
Courtesy of Blender Foundation. License CC-BY. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
27</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>SSD is Not Perfect 
After rotations p0 q0 
46</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>When we animate the model, 
the bone transformations 
Tj change. 
 What is Tj? It maps from the 
local coordinate system of 
bone j to world space. 
 again, concatenates hierarchy matrices Bind Pose contd 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
53</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Real-time enveloping with rotational regression 
Wang, Pulli, Popovic 
We learn a fast model from exported examples. 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
69</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>5 Skinning/Enveloping 
25 Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use.
25</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 Rest (bind) pose  
p0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
Skin  
42</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
 Transform by 
T1 and T2 
yields p01, 
p02 Rest (bind) pose  
After rotations p0 
p01 p02 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
Skin  
43</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Motion Capture 
 Motion capture records 
3D marker positions 
 But character is  
controlled using 
animation controls  
that affect bone 
transformations! 
 Marker positions must be 
translated into character 
controls (retargeting) 
 
This image is in the public domain. Source: Wikimedia Commons .
22</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Well assign a weight wij 
for each vertex pi for each bone Bj. 
 How much vertex i should move with bone j 
wij = 1 means pi is rigidly attached to bone j. 
 Well limit the number of bones N that can 
influence a single vertex 
N=4 bones/vertex is a usual choice 
Why? Vertex Weights contd 
36</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Sampling, Aliasing, and Mipmaps (PDF - 1.6MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec17/</lecture_pdf_url>
      <lectureno>17</lectureno>
      <slides>
        <slide>
          <slideno>21</slideno>
          <text>22 
  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Questions? 
61</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Sampling,  
Aliasing,  
&amp; Mipmaps 
1 
MIT EECS 6.837 Computer Graphics 
Wojciech Matusik, MIT EECS</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Solution? 
 How do we avoid that high-frequency patterns 
mess up our image? 
 We blur! 
 In the case of audio, people first include an analog low-
pass filter before sampling 
 For ray tracing/rasterization: compute at higher 
resolution, blur, resample at lower resolution 
 For textures, we can also blur the texture image before 
doing the lookup 
 To understand what really happens, we need 
serious math 
16</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>1 sample / pixel 
 
 
 
 
 
 
   2 sample / pixel 
 
 
 
 
 
 
         0 jittering                               jittering by 0.5                        jittering by 1        Jittered supersampling 
39</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Examples of Aliasing 
3  Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Examples of Aliasing 
2  Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Choosing the parameters 
 Empirical tests determined usable parameters 
 Mitchell, Don and Arun Netravali, "Reconstruction Filters in 
Computer Gra
phics", SIGGRAPH 88.  
         http ://www.mentallandscape.com/Papers_siggraph88.pdf  
         http://dl.acm.org/citation.cfm?id=378514  
 
25 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Mitchell-Netravali cubic (1/3. 1/3) 
30 http://rise.sourceforge.net/cgi-bin/makepage.cgi?Filtering 
 Aravind Krishnaswamy. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>MIP Mapping Example 
MIP Mapped (Bi-Linear) Nearest Neighbor 
50</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>MIP Indices 
 
Actually, you have a choice of ways to translate this derivative value into a MIP 
level. 
 
Because we have two derivatives, for u and for v (anisotropy) 
         
This also brings up one of the shortcomings of MIP mapping. MIP mapping assumes 
that both the u and v components of the texture index are undergoing a uniform 
scaling, while in fact the terms du/dt and dv/dt are relatively independent. Thus, we 
must make some sort of compromise. Two of the most common approaches are 
given below: 
55</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>In signal processing, the process of mapping a continuous 
function to a discrete one is called sampling 
 The process of mapping a continuous variable to a discrete one 
is called quantization 
 Gamma helps quantization 
 To represent or render an image using a computer,  
we must both sample and quantize  
 Today we focus on the effects of sampling and how to fight them More on Samples 
discrete position discrete 
value 
9</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Jittering 
 Displaced by a vector a fraction of the size of the 
subpixel distance 
 Low-frequency Moire (aliasing) pattern replaced 
by noise 
 Extremely effective 
 Patented by Pixar! 
 When jittering amount is 1, equivalent to 
stratified sampling (cf. later) 
40</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Your intuitive solution is to 
compute multiple color values per 
pixel and average them In practice: Supersampling 
jaggies w/ antialiasing 
18</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Gauss 
27 
 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html   Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Sampling Density 
 If we insufficiently sample the signal, it may be 
mistaken for something simpler during reconstruction 
(that's aliasing!) 
 This is why its called aliasing: the new low-frequency 
sine wave is an alias/ghost of the high-frequency one 
13</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>What is a Pixel? 
 A pixel is not: 
 a box 
 a disk 
 a teeny tiny little light 
 A pixel looks different on 
different display devices 
 A pixel is a sample 
 it has no dimension 
 it occupies no area 
 it cannot be seen 
 it has a coordinate 
 it has a value 
8  source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Solution? 
 How do we avoid that high-frequency patterns 
mess up our image? 
 We blur! 
 In the case of audio, people first include an analog low-
pass filter before sampling 
 For ray tracing/rasterization: compute at higher 
resolution, blur, resample at lower resolution 
 For textures, we can also blur the texture image before 
doing the lookup 
 To understand what really happens, we need 
serious math 
17 Questions?</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Mitchell-Netravali cubic 
33  
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>How to map the texture area seen through the pixel 
window to a single pixel value? Sampling Texture Maps 
image plane textured surface 
(texture map) 
circular pixel window 
43</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Spatial Filtering 
 Remove the high frequencies 
which cause artifacts in texture 
minification. 
 Compute a spatial integration 
over the extent of the pixel 
 This is equivalent to 
convolving the texture with a 
filter kernel centered at the 
sample (i.e., pixel center)! 
 Expensive to do during 
rasterization, but an 
approximation it can be 
precomputed 
projected texture in image plane 
pixels projected in texture plane 
48</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Jittering 
 Uniform sample + random perturbation 
 Sampling is now non-uniform 
 Signal processing gets more complex 
 In practice, adds noise to image 
 But noise is better than aliasing Moir patterns 
37</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Isotropic filter wrt screen space 
 Becomes anisotropic in texture 
space 
 e.g. use anisotropic Gaussian 
 Called Elliptical Weighted 
Average (EWA) 
Elliptical weighted average 
57  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Sampling Texture Maps 
 When texture mapping it is rare that the screen-space 
sampling density matches the sampling density of the 
texture.  
Original Texture Minification for Display Magnification for Display 
64x64 pixels 
44</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Box 
26 
 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html   Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Anisotropy &amp; MIP-Mapping 
 What happens when the surface is tilted? 
MIP Mapped (Bi-Linear) Nearest Neighbor 
56</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>MIP Mapping 
 Construct a pyramid  
of images that are  
pre-filtered and  
re-sampled at  
1/2, 1/4, 1/8, etc.,  
of the original  
image's sampling 
 During rasterization  
we compute the index of the decimated image that is sampled at 
a rate closest to the density of our desired sampling rate 
 MIP stands for multum in parvo  which means  
many in a small place   
49</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Image Quality Comparison 
 Trilinear mipmapping 
EWA trilinear mipmapping 
58</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Recommended filter 
 Bicubic 
http://www.mentallandscape.com/Papers_siggraph88.
pdf 
 Good tradeoff between sharpness and aliasing 
23 
http://de.wikipedia.org/wiki/Datei:Mitchell_Filter.svg</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Box 
31 
  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>1 sample / pixel 
 
 
 
 
 
 
 
 
 
 
 
 
 
         0 jittering                               jittering by 0.5                        jittering by 1        
Jittered supersampling 
38</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>How does a screen-space change dt relates to a texture-space change du,dv.  
=&gt; derivatives, ( du/dt, dv/dt ).  
e.g. computed by hardware during rasterization 
often: finite difference (pixels are handled by quads) Finding the MIP level 
dt du, dv 
54</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Linear Interpolation 
 Tell OpenGL to use a tent filter instead of a box filter. 
 Magnification looks better, but blurry 
 (texture is under-sampled for this resolution) 
 Oh well.  
46 Questions?</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Uniform supersampling 
 Advantage:  
 The first (super)sampling captures more high 
frequencies that are not aliased 
 Downsampling can use a good filter 
 Issues 
 Frequencies above the (super)sampling limit are still 
aliased 
 Works well for edges, since  
spectrum replication is less an issue 
 Not as well for repetitive textures 
 But solution soon 
35 Questions?</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Sampling &amp; reconstruction 
The visual array of light is a continuous function 
1/ we sample it  
 with a digital camera, or with our ray tracer 
 This gives us a finite set of numbers,  
not really something we can see 
 We are now inside the discrete computer world 
2/ we need to get this back to the physical world:  
we reconstruct a continuous function 
 for example, the point spread of a pixel on a CRT or LCD 
 Both steps can create problems 
 pre-aliasing caused by sampling 
 post-aliasing caused by reconstruction 
 We focus on the former 
10</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Uniform supersampling 
 Advantage:  
 The first (super)sampling captures more high 
frequencies that are not aliased 
 Downsampling can use a good filter 
 Issues 
 Frequencies above the (super)sampling limit are still 
aliased 
 Works well for edges, since  
spectrum replication is less an issue 
 Not as well for repetitive textures 
 But solution soon 
34</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Mitchell bicubic 
28 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html  
 Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Low pass / convolution 
 Each output (low-res) pixel is a weighted average 
of input subsamples 
 Weight depends on relative spatial position 
 For example: 
 Gaussian as a function of distance 
 1 inside a square, zero outside (box) 
 
20 
 http://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm   2003 R. Fisher, S. Perkins, A. Walker and E. Wolfart . All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Box 
29 
http://rise.sourceforge.net/cgi-bin/makepage.cgi?Filtering Aravind Krishnaswamy. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Philosophical perspective 
 The physical world is continuous, inside the 
computer things need to be discrete 
 Lots of computer graphics is about translating 
continuous problems into discrete solutions  
 e.g. ODEs for physically-based animation, global 
illumination, meshes to represent smooth surfaces, 
rasterization, antialiasing 
 Careful mathematical understanding helps do the 
right thing 
7</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Examples of Aliasing 
4  Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Gaussian 
32  
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Sampling &amp; reconstruction 
The visual array of light is a continuous function 
1/ we sample it  
 with a digital camera, or with our ray tracer 
 This gives us a finite set of numbers,  
not really something we can see 
 We are now inside the discrete computer world 
2/ we need to get this back to the physical world:  
we reconstruct a continuous function 
 for example, the point spread of a pixel on a CRT or LCD 
 Both steps can create problems 
 pre-aliasing caused by sampling 
 post-aliasing caused by reconstruction 
 We focus on the former 
11 Questions?</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Linear Interpolation 
 Tell OpenGL to use a tent filter instead of a box filter. 
 Magnification looks better, but blurry 
 (texture is under-sampled for this resolution) 
 Oh well.  
45</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Recap: image antialiasing 
 Render multiple samples per pixel 
 Jitter the sample locations 
 Use appropriate filter to reconstruct final image 
 Bicubic for example 
41</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Examples of Aliasing 
Texture Errors 
nearest neighbor/ point 
sampling 
mipmaps &amp; linear interpolation 
52</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Finding the mip level 
 Square MIP-map area is a bad approximation 
image plane textured surface 
(texture map) 
circular pixel window area pre- 
filtered in MIP-
map 
53</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Approximation of anisotropic 
 Feline: Fast Elliptical Lines for Anisotropic Texture Mapping Joel 
McCormack, Ronald Perry, Keith I. Farkas, and Norman P. Jouppi 
SIGGRAPH 1999 
 Andreas Schilling, Gunter Knittel &amp; Wolfgang Strasser . Texram: A Smart 
Memory for Texturing. IEEE Computer Graphics and Applications, 16(3): 32-
41, May 1996.  
 Approximate Anisotropic Gaussian by a set of 
isotropic probes 
59  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Piecewise-cubic 
 General formula 
 
 
   where P, Q, R, S, T, U, V, W are parameters 
 But we want the derivatives to be zero at the 
boundary and constant signals to be well 
reconstructed. Reduces to 2 parameters 
24</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Sampling Density 
 If were lucky, sampling density is enough 
Input Reconstructed 
12</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Recap: image antialiasing 
 Render multiple samples per pixel 
 Jitter the sample locations 
 Use appropriate filter to reconstruct final image 
 Bicubic for example 
42 Questions?</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>In photos too 
See also http://vimeo.com/26299355  
 
6  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Minification: Examples of Aliasing 
point sampling 
47</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Uniform supersampling 
 Problem: supersampling only pushes the problem 
further: The signal is still not bandlimited 
 Aliasing happens 
 Especially if the signal and the sampling are 
regular 
36</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Uniform supersampling 
 Compute image at resolution k*width, k*height 
 Downsample using low-pass filter  
(e.g. Gaussian, sinc, bicubic) 
19</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>MIP Mapping Example 
 Small details may "pop" in and out of view 
MIP Mapped (Bi-Linear) Nearest Neighbor 
51</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>FELINE results 
60  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>In practice: Supersampling 
 Your intuitive solution is to 
compute multiple color values per 
pixel and average them 
 A better interpretation of the 
same idea is that 
 You first create a higher resolution 
image 
 You blur it (low pass, prefilter) 
 You resample it at a lower resolution 
21 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Solution? 
 How do we avoid that high-frequency patterns 
mess up our image? 
15</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Discussion 
 Types of aliasing 
 Edges 
 mostly directional 
aliasing 
(vertical and horizontal 
edges rather than actual 
slope)  
 Repetitive textures 
 Paradigm of aliasing 
 Harder to solve right 
 Motivates fun  
mathematics 
14  Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights
reserved. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Examples of Aliasing 
Texture Errors 
point sampling 
5</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Graphics Pipeline and Rasterization II (PDF - 2.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec22/</lecture_pdf_url>
      <lectureno>22</lectureno>
      <slides>
        <slide>
          <slideno>78</slideno>
          <text>Back to ray-triangle 
79</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Texture Filtering 
 We should pre-filter image function before sampling 
 That means blurring the image function with a low-pass 
filter (convolution of image function and filter) 
Low-pass filter 
44</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Back to the basics: Barycentrics 
 Barycentric coordinates for a triangle ( a, b, c) 
 
 
 Remember,  
 
 Barycentrics are very general: 
 Work for x, y, z, u, v, r, g, b 
 Anything that varies linearly in object space 
 including z 
12</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Graphics Hardware 
 High performance through  
 Parallelism  
 Specialization 
 No data dependency 
 Efficient pre-fetching 
 
 More next week G 
R 
T 
F 
D G 
R 
T 
F 
D G 
R 
T 
F 
D G 
R 
T 
F 
D task  
parallelism data parallelism 
89</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>CAD-CAM &amp; Design rasterization  for GUI, 
anything  for final image 
94 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Ray-triangle 
 
 
 
 
 Cramers rule (where | | is the determinant) 
77</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>From barycentric to screen-space 
 Barycentric coordinates for a triangle ( a, b, c) 
 
 
 Remember,  
 
 Lets project point P by projection matrix C 
a, b, c are the 
projected 
homogeneous 
vertices before 
division by w 
15</text>
        </slide>
        <slide>
          <slideno>107</slideno>
          <text>Reyes - ignoring transparency 
 For each tile of pixels 
 For each geometry 
 Dice into micropolygons adaptively 
 For each micropolygon 
 compute shaded value 
 For each sample in tile at coordinates x, y, u, v, t 
 reproject micropolygon to its position at time t, and lens position uv 
 determine if micropolygon overlaps samples 
 if yes, test visibility (z-buffer) 
 if z buffer passes, update framebuffer 
108</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Rasterization 
 
 
 
 Cache redundant computation independent of D: 
 
 
 
 And for each pixel 
82 
Equivalent to the setup of edge equations and 
interpolants in rasterization 
Per-pixel calculation of 
edge equations and z (=t)</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Basic strategy 
 How to make it work 
 start by computing x, y given barycentrics 
 invert 
 Later: shortcut barycentrics, directly build interpolants 
14</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Paul Heckbert published seminal work on texture 
mapping and filtering in his masters thesis (!) 
 Including EWA 
 Highly recommended reading! 
 See http://www.cs.cmu.edu/~ph/texfund/texfund.pdf  
 More reading 
Feline: Fast Elliptical Lines for  
Anisotropic Texture Mapping,  
McCormack, Perry, Farkas, Jouppi 
SIGGRAPH 1 999 
Texram: A Smart Memory for Texturing  
Schilling, Knittel, Strasser,. IEEE CG&amp;A, 16(3): 32-4 1 Further Reading 
Arf! 
70  Marc Levoy. All rights reserved. This
content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>Transparency 
 Difficult, pretty much unsolved! 
 Alternative  
 Reyes (Pixars Renderman) 
 deferred shading  
 pre-Z pass 
tile-based rendering 
 
 Shadows 
 Next time 
 Reflections, global illumination More issues 
100</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>How do we get that Z value for each pixel? 
 We only know z at the vertices... 
 (Remember, screen-space z is actually z/w) 
 Must interpolate from vertices into triangle interior Interpolation in Screen Space 
For each triangle  
   for each pixel (x,y) 
      if passes all edge equations  
         compute z 
         if z&lt;zbuffer [x,y] 
            zbuffer [x,y]=z 
            framebuffer [x,y]=shade()  
7</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>From Screen to Barycentrics 
 
 
 
 
 Notes:  
 matrix is inverted once per triangle 
 can be used to interpolate z, color, texture coordinates, etc.  
22</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Multisampling, Visually 
= sub-pixel visibility sample 
The color is only 
computed once 
per pixel per 
triangle  and 
reused for all the 
visibility samples 
that are covered 
by the triangle. 
One pixel 
36</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Interpolation in Screen Space 
8  Also need to interpolate color, normals, texture coordinates, 
etc. between vertices 
 We did this with barycentrics in ray casting 
Linear interpolation in object space 
 Is this the same as linear interpolation on the screen?</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Recipe 
 Compute projected homogeneous coordinates a, b, c 
 Put them in the columns of a matrix, invert it 
 Multiply screen coordinates (x, y, 1) by inverse matrix 
Then divide by the sum of the resulting coordinates 
 This ensures the result is sums to one like barycentrics should 
 Then interpolate value (e.g. Z) from vertices using them! From Screen to Barycentrics 
projective 
equivalence 
21</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Ray-triangle intersection 
 Triangle ABC 
 Ray O+t*D 
 Barycentric coordinates , ,  
 Ray-triangle intersection 
 
 
 or in matrix form 
76</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Multisampling Pseudocode 
For each triangle 
  For each pixel  
    if pixel overlaps triangle 
      color=shade() // only once per pixel!  
      for each sub-pixel sample 
        compute edge equations &amp; z 
        if subsample passes edge equations  
           &amp;&amp; z &lt; zbuffer[subsample] 
          zbuffer[subsample]=z 
          framebuffer[subsample]=color 
 
38</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Determinant 
 Cross product and dot product 
 i.e., for a matrix with 3 columns vectors: M=UVW 
 
78</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>Virtual Reality rasterization 
96 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Ray casting (Python) 
84</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Questions? 
27</text>
        </slide>
        <slide>
          <slideno>104</slideno>
          <text>Reyes - Pixars Renderman 
 Cook et al. http://graphics.pixar.com/library/Reyes/  
 Based on micropolygons 
 each primitive gets diced into polygons as small as a pixel 
 Enables antialiasing motion blur, depth of field 
 Shading is computed at the micropolygon level,  
not pixel 
 related to multisampling: shaded value will be used for 
multiple visibility sample 
 
105</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Main loops 
 
87</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Pseudocode  Rasterization 
   For every triangle 
ComputeProjection 
Compute interpolation matrix 
Compute bbox, clip bbox to screen limits 
For all pixels x,y in bbox 
Test edge functions 
If all Ei&gt;0 
   compute barycentrics 
   interpolate z from vertices 
   if z &lt; zbuffer[x,y ] 
      interpolate UV coordinates from vertices 
      look up texture color k d 
      Framebuffer[x,y ] = kd 
 //or more complex shader 
24 Questions? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Solution: Precomputation 
 Well precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
 Because its low-passed, we can also subsample 
52</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>MIP-Mapping 
 Simplest method: Pick the scale closest, 
then do usual reconstruction on that level 
(e.g. bilinear between 4 closest texture pixels) 
Projected pre-filter 
closest-available  
filter in pyramid Corresponding  
pyramid level 
55</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Rasterization 
 Viewpoint is known and fixed 
 Lets extract what varies per pixel 
 
 
 
 
 Only D! 
81</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Ray Casting 
For each pixel  
For each object  
- Whole scene must be in memory 
- Needs spatial acceleration to be 
efficient 
+ Depth complexity: no computation 
for hidden parts 
+ Atomic computation 
+ More general, more flexible 
 Primitives, lighting effects, 
adaptive antialiasing Rendering Pipeline 
For each triangle  
   For each pixel 
- Harder to get global illumination 
- Needs smarter techniques to address 
depth complexity (overdraw) 
+ Primitives processed one at a time 
+ Coherence: geometric transforms for 
vertices only 
+ Good bandwidth/computation ratio 
+ Minimal state required, good memory 
behavior Ray Casting vs. Rendering Pipeline 
73</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Finding the MIP Level 
 Often we think of the 
pre-filter as a box 
 What is the projection 
of the square 
pixel window 
in texture space? 
Projected pre-filter 
64</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Good References 
http://www.tomshardware.com/reviews/ray-tracing-
rasterization,2351.html  
http://c0de517e.blogspot.com/2011/09/raytracing-
myths.html  
htt
p://people.csail.mit.edu/fredo/tmp/rendering.pdf  
 
88</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Multisampling, Visually 
= sub-pixel visibility sample 
One pixel 
34</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>http://xkcd.com/386/ 
74 Image removed due to copyright restrictions  please see the link above for further details.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Texture Filtering 
 We can combine low-pass and sampling 
 The value of a sample is the integral of the product of the 
image f and the filter h centered at the sample location 
 A local average of the image f weighted by the filter h 
Low-pass filter 
45</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 For each pixel, 
test 3 edge equations 
 if all pass, draw pixel 
 
 Compute per-pixel color 
 Test visibility (Z-buffer), 
update frame buffer color 
3  Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>Simulation rasterization  
(painter for a long time) 
93 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Projection 
 Lets use simple formulation of projection going 
from 3D homogeneous coordinates to 2D 
homogeneous coordinates 
 
 
 
 
 No crazy near-far or storage of 1/z 
 We use  for screen space coordinates 
16</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>From screen-space to barycentric 
 
 
 
 
 Its a projective mapping from 
the barycentrics onto screen coordinates! 
 Represented by a 3x3 matrix 
 Well take the inverse mapping to get from (x, y, 1) 
to the barycentrics! 
20</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>MIP-Mapping 
 Simplest method: Pick the scale closest, 
then do usual reconstruction on that level 
(e.g. bilinear between 4 closest texture pixels) 
 Problem: discontinuity when switching scale 
Projected pre-filter 
closest-available  
filter in pyramid Corresponding  
pyramid level 
56</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Image Quality Comparison 
anisotropic filtering trilinear mipmapping 
(excessive blurring) 
69</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Ray Casting 
For each pixel 
For each object 
Ray-centric 
 Needs to store scene in 
memory 
 (Mostly) Random access 
to scene Rendering Pipeline 
For each triangle 
For each pixel 
 Triangle centric 
 Needs to store image   
(and depth) into memory 
 (Mostly) random access to 
frame buffer Ray Casting vs. Rendering Pipeline 
Which is smaller? Scene or Frame? 
    Frame 
Which is easiest to access randomly? 
    Frame because regular sampling 
72</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Supersampling, Visually 
= sub-pixel visibility sample 
When 
supersampling, 
we compute 
colors 
independently for 
all the visibility 
samples. 
One pixel 
37</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Solution: Precomputation 
 Well precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
 Because its low-passed, we can also subsample 
51</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Questions? 
71 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>4 Samples / Pixel 
30</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Solution: Precomputation 
 Well precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
49</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>For isotropic trilinear mipmapping 
 No right answer,  
circular approximation 
 Two most common 
approaches are 
 Pick level according to 
the length (in texels) of 
the longer partial 
 
 Pick level according to 
the length of their sum 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
w x h 
66</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>100 Samples / Pixel 
Even this 
sampling rate 
cannot get rid 
of all aliasing 
artifacts! 
 
We are really 
only pushing 
the problem 
farther. 
32</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>From barycentric to screen-space 
 From previous slides: 
 
 
 Seems to suggest its linear in screen 
space.  
But its homogenous coordinates a, b, c are the 
projected 
homogeneous 
vertices 
17</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Bad example 
75 Image removed due to copyright restrictions -- please see
https://blogs.intel.com/intellabs/2007/10/10/real_time_raytracing_the_end_o/ for further details.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Finding the MIP Level 
 Often we think of the 
pre-filter as a box 
 What is the projection 
of the square 
pixel window 
in texture space? 
 Answer is in the partial 
derivatives p x and py 
of (u,v) w.r.t. screen (x,y) 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
65</text>
        </slide>
        <slide>
          <slideno>105</slideno>
          <text>Dicing and rasterization 
106 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>106</slideno>
          <text>Reyes - Pixars Renderman 
 Tile-based to save memory and maximize texture 
coherence 
 Order-independent transparency 
 stores list of fragments and depth per pixel 
 Micropolygons get rasterized in space, lens and time 
 frame buffer has multiple samples per pixel 
 each sample has lens coordinates and time value 
107</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Interpolation in Screen Space 
The farther region 
shrinks to a smaller 
area of the screen 
Two regions of same 
size in world space  
10</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Texture Filtering 
 Well, we can just as well change variables and 
compute this integral on the textured plane instead 
 In effect, we are projecting the pre-filter onto the plane 
 Its still a weighted average of the texture under filter 
Low-pass filter 
47</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Anisotropic filtering 
 Pick levels according  
to smallest partial 
 well, actually max of the  
smallest and the largest/5 
 Distribute circular  
probes along  
longest one 
 Weight them  
by a Gaussian 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
67</text>
        </slide>
        <slide>
          <slideno>109</slideno>
          <text>Questions? 
110</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>From barycentric to screen-space 
 From previous slides: 
 
 
 Seems to suggest its linear in screen 
space.  
But its homogenous coordinates 
 After division by w, the (x,y) screen coordinates are  a, b, c are the 
projected 
homogeneous 
vertices 
18</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Modern Graphics Pipeline 
For each triangle  
   transform into eye space  
   (perform projection)  
   setup 3 edge equations  
   for each pixel x,y  
      if passes all edge equations  
         compute z 
         if z&lt;zbuffer [x,y] 
            zbuffer[x,y]=z 
            framebuffer [x,y]=shade()  
5  Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Pseudocode  Rasterization 
   For every triangle 
ComputeProjection 
Compute interpolation matrix 
Compute bbox, clip bbox to screen limits 
For all pixels x,y in bbox 
Test edge functions 
If all Ei&gt;0 
   compute barycentrics 
   interpolate z from vertices 
   if z &lt; zbuffer[x,y ] 
      interpolate UV coordinates from vertices 
      look up texture color k d 
      Framebuffer[x,y ] = kd 
 //or more complex shader 
23  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Interpolation in Screen Space 
Two regions of same 
size in world space  
9</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Games rasterization 
92 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>How Are Partials Computed? 
 You can derive closed form formulas based on the uv 
and xyw coordinates of the vertices... 
 This is what used to be done 
 ..but shaders may compute texture coordinates 
programmatically, not necessarily interpolated 
 No way of getting analytic derivatives! 
 
In practice, use finite differences 
 GPUs process pixels in blocks of (at least) 4 anyway 
 These 2x2 blocks are called quads  
68</text>
        </slide>
        <slide>
          <slideno>108</slideno>
          <text>REYES results 
109 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Projected pre-filter Anisotropic filtering 
 Approximate Elliptical filter with multiple circular 
ones (usually 5) 
 Perform trilinear lookup at each one 
 i.e. consider five times eight values 
 fair amount of computation 
 this is why graphics hardware  
has dedicated units to compute  
trilinear mipmap reconstruction 
59</text>
        </slide>
        <slide>
          <slideno>102</slideno>
          <text>Pre z pass 
 Again, avoid shading hidden fragment 
 First pass: rasterize triangles, update only z buffer, 
not color buffer 
 Second pass: rasterize triangles again, but this time, 
do full shading 
 
 Advantage over deferred shading: less storage, less 
code modification, more general shading is possible, 
multisampling possible 
 Disadvantage: needs to rasterize twice 
103</text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>Deferred shading 
 Avoid shading fragments that are eventually hidden 
 shading becomes more and more costly  
 First pass: rasterize triangles, store information such 
as normals, BRDF per pixel 
 Second pass: use stored information to compute 
shading 
 

Advantage: no useless shading 
 Disadvantage: storage, antialiasing is difficult 
102</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Questions 
62</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>MIP Mapping Example 
MIP Mapped (Tri-Linear) Nearest Neighbor 
60</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>85</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Problem  
 Shading is very expensive today (complicated shaders) 
 Full supersampling has linear cost in #samples (k*k) 
 Goal: High-quality edge antialiasing at lower cost 
 Solution 
 Compute shading only once per pixel for each primitive, 
but resolve visibility at sub-pixel level 
 Store (k*width, k*height) frame and z buffers, but share shading 
results between sub-pixels within a real pixel 
 When visibility samples within a pixel hit different 
primitives, we get an average of their colors 
 Edges get antialiased without large shading cost  Related Idea: Multisampling 
33</text>
        </slide>
        <slide>
          <slideno>103</slideno>
          <text>Tile-based rendering 
 Problem: framebuffer is a lot of memory, especially 
with antialiasing 
 Solution: render subsets of the screen at once 
 For each tile of pixels 
 For each triangle 
 for each pixel 
 
 Might need to handle a triangle in multiple tiles 
 redundant computation for projection and setup 
 Used in mobile graphics cards 
104</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Ray-triangle recap 
 
 
 
 
 
 And 
 
 
 Intersection if 
 
80</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Basic strategy 
 Given screen-space x, y 
 Compute barycentric coordinates 

Interpolate anything specified at the three vertices 
13</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>2 closest-available  
filters in pyramid 
Tri-Linear MIP-Mapping 
 Use two closest scales,  
compute reconstruction results from both,  
and linearly interpolate between them 
Projected pre-filter 
Blurrier  
pyramid level 
Sharper  
pyramid level 
57</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Questions? 
90</text>
        </slide>
        <slide>
          <slideno>110</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Must still integrate product of projected filter and 
texture  That doesnt sound any easier... Texture Pre-Filtering, Visuall
y 
image 
plane textured surface 
(texture map) 
image-space filter image-space filter 
projected onto plane 
Image adapted from 
McCormack et al. 
48</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>MIP Mapping Example 
nearest neighbor/ 
point sampling 
mipmaps &amp; linear interpolation 
(tri-linear) 
61</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Multisampling vs. Supersampling 
 Supersampling 
 Compute an entire image at a higher resolution, then 
downsample (blur + resample at lower res) 
 Multisampling 
 Supersample visibility, compute expensive shading only 
once per pixel, reuse shading across visibility samples 
 But Why? 
 Visibility edges are where supersampling really works 
 Shading can be prefiltered more easily than visibility 
 This is how GPUs perform antialiasing these days 
40</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Supersampling 
 
  
28  Trivial to do with rasterization as well 
 Often rates of 2x to 8x 
 Requires to compute per-pixel average at the end 
 Most effective against edge jaggies 
 Usually with jittered sampling 
 pre-computed pattern for a big block of pixels</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>Medical Imaging same as  
visualization 
98 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Graphics Pipeline &amp; Rasterization II 
1 MIT EECS 6.837 
Computer Graphics 
Wojciech Matusik Image remov
ed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Questions? 
41</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>This is Called MIP-Mapping 
 Construct a pyramid  
of images that are  
pre-filtered and  
re-sampled at  
1/2, 1/4, 1/8, etc.,  
of the original  
image's sampling 
 During rasterization  
we compute the index of the decimated image that is sampled at 
a rate closest to the density of our desired sampling rate 
 MIP stands for multum in parvo  which means  
many in a small place 
53</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>The infamous half pixel 
 I refuse to teach it, but its an annoying issue you 
should know about 
 Do a line drawing of a rectangle  
from [top, right] to [bottom,left] 
 Do we actually draw the columns/rows of pixels? 
25 Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>16 Samples / Pixel 
31</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Texture Filtering 
 Problem: Prefiltering is impossible when you can 
only take point samples 
 This is why visibility (edges) need supersampling 
 Texture mapping is simpler 
 Imagine again we are looking at an infinite textured plane 
43</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Nope, Not the Same 
 Linear variation in world space does not yield linear 
variation in screen space due to projection 
 Think of looking at a checkerboard at a steep angle; all 
squares are the same size on the plane, but not on screen 
 linear screen-space 
(Gouraud ) interpolation 
BAD Perspective-correct 
Interpolation Head -on view 
11 This image is in the public domain. Source: Wikipedia.</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>Visualization mostly rasterization, 
interactive ray-tracing is starting 
97 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Modern Graphics Pipeline 
For each triangle  
   transform into eye space  
   (perform projection)  
   setup 3 edge equations  
   for each pixel x,y 
      if passes all edge equations  
         compute z  
         if z&lt;zbuffer [x,y] 
            zbuffer [x,y]=z 
            framebuffer [x,y]=shade()  
6 Questions?  source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>For each triangle 
  For each pixel  
    if pixel overlaps triangle 
      color=shade() // only once per pixel!  
      for each sub-pixel sample 
        compute edge equations &amp; z 
        if subsample passes edge equations  
           &amp;&amp; z &lt; zbuffer[subsample] 
          zbuffer[subsample]=z 
          framebuffer[subsample]=color 
At display time: //this is called resolving  
  For each pixel 
    color = average of subsamples Multisampling Pseudocode 
39</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Movies both rasterization and ray tracing 
91 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Conclusions 
 Rasterization and ray casting do the same thing 
 Just swap the two loops 
 And cache what is independent of pixel location 
83</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>1 Sample / Pixel 
29</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Storing MIP Maps 
 Can be stored compactly: Only 1/3 more space! 
63  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility (Z-buffer), 
update frame buffer color 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>MIP-Mapping 
 When a pixel wants an integral of the pre-filtered 
texture, we must find the closest results from the 
precomputed MIP-map pyramid 
 Must compute the size of 
the projected pre-filter in 
the texture UV domain 
Projected pre-filter 
54</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>Transparency  
 Triangles and pixels can have transparency (alpha) 
 But the result depends on the order in which triangles 
are sent 
 
 Big problem: visibility 
 There is only one depth stored per pixel/sample 
 transparent objects involve multiple depth 
 full solutions store a (variable-length) list of visible objects 
and depth at each pixel 
 see e.g. the A-buffer by Carpenter  
http://portal.acm.org/citation.cfm?id=808585  
101</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Modern Graphics Pipeline 
 Perform projection of vertices 
 Rasterize triangle: find which 
pixels should be lit 
 Compute per-pixel color 
 Test visibility, 
update frame buffer color 
 Store minimum distance to camera 
for each pixel in Z-buffer 
 ~same as t min in ray casting! 
if new_z &lt; zbuffer [x,y] 
    zbuffer[ x,y]=new_z 
    framebuffer [x,y]=new_color  
Z buffer frame buffer 
4 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Examples of Texture Aliasing 
point sampling 
Magnification 
Minification 
42</text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>Questions? 
99</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>One pixel Multisampling, Visually 
= sub-pixel visibility sample 
35</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>The infamous half pixel 
 Displace by half a pixel so that top, right, bottom, left 
are in the middle of pixels 
 Just change the viewport transform 
26 Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Recap: barycentric to screen-space 
19</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>Architecture ray-tracing, rasterization with   
preprocessing  for complex lighting 
95 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Texture Filtering 
 Well, we can just as well change variables and 
compute this integral on the textured plane instead 
 In effect, we are projecting the pre-filter onto the plane 
Low-pass filter 
46</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Projected pre-filter Tri-Linear MIP-Mapping 
 Use two closest scales,  
compute reconstruction results from both,  
and linearly interpolate between them 
 Problem: our filter might not be circular, because of 
foreshortening 
58</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Solution: Precomputation 
 Well precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
50</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Acceleration Structures for Ray Casting (PDF)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec14/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides>
        <slide>
          <slideno>40</slideno>
          <text>Bounding Box of a Plane 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
= (-, -, -)* = (+, +, +)*  
n = (a, b, c) 
ax + by + cz = d 
* unless n is exactly perpendicular to an axis 
41</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>BVH Discussion 
 Advantages 
 easy to construct 
 easy to traverse 
 binary tree (=simple structure) 
 
 Disadvantages 
 may be difficult to choose a good split for a node 
 poor split may result in minimal spatial pruning 
 
 Still one of the best methods 
Recommended for your first hierarchy! 
62 Questions?</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Bounding Volume Hierarchies 
 If ray hits bounding volume, 
must we test all primitives inside it? 
 Lots of work, think of a 1M-triangle mesh 
 You guessed it already, well split the primitives in 
groups and build recursive bounding volumes 
 Like collision detection, 
remember? 
bounding 
sphere 
hierarchy 
46</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Ray-BVH Intersection 
54</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Where to Split Objects? 
 At midpoint of current volume    OR 
 Sort, and put half of the objects on each side    OR 
 Use modeling hierarchy 
52</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Kd-tree traversal - three cases 
 If t&gt;t end =&gt; intersect only front 
 If t&lt;t start =&gt; intersect only back Note: Back and 
Front depend on 
ray direction! 
73</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Conservative Bounding Regions 
14  Desiderata 
 Tight  
avoid false positives 
 Fast to intersect</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
End= 
min of maxs 
25</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Recursion For Reflection: 2 
0 recursion 
5</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Test if Parallel 
 If Rdx = 0  (ray is parallel)   AND 
    Rox &lt; X1 or Rox &gt; X2    no intersection  
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
 (The same 
for Y and Z, 
of course) 
18</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Hard-core efficiency considerations 
 See e.g. Ingo Walds PhD thesis  
   
 Calculation 
 Optimized barycentric ray-triangle intersection 
 Memory 
 Make kd-tree node as small as possible 
(dirty bit packing, make it 8 bytes) 
 Parallelism 
 SIMD extensions, trace 4 rays at a time, mask results 
where they disagree 
89 http://www.sci.utah.edu/~wald/PhD/</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Ray-Box Intersection 
 Axis-aligned box 
 Box:   (X1, Y1, Z1)  (X2, Y2, Z2) 
 Ray:    P(t) = Ro + tRd 
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
15</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Split in the Median 
84  Tries to balance tree, but does not conform to empty 
vs. dense areas 
 Inefficient traversal  Not good</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Then Intersect Intervals 
 Update t start &amp; tend for each subsequent dimension 
If t1 &gt; tstart,  tstart = t1 
If t2 &lt; tend,    tend    = t2 
tend y=Y2 
y=Y1 
x=X1 x=X2 tstart 
t1 t2 
32</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Then Intersect Intervals 
 Update t start &amp; tend for each subsequent dimension 
If t1 &gt; tstart,  tstart = t1 
If t2 &lt; tend,    tend    = t2 
y=Y2 
y=Y1 
x=X1 x=X2 t1 t2 
 tend tstart 
31</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Conservative Bounding Volume 
12  First check for an 
intersection with a 
conservative  
bounding volume 
 Early reject: If ray 
doesnt hit volume, 
it doesnt hit the 
triangles!</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Recursion For Reflection: 1 
0 recursion 
4</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Ray Tracing Algorithm Analysis 
 Lots of primitives 
 Recursive 
 Distributed Ray 
Tracing 
 Means using many 
rays for non-
ideal/non-pointlike 
phenomena  
 Soft shadows 
 Anti-aliasing 
 Glossy reflection 
 Motion blur 
 Depth of field cost     height * width *  
              num primitives *  
              intersection cost *  
              size of recursive ray tree *  
         num shadow rays * 
         num supersamples * 
              num glossy rays *               
              num temporal samples * 
              num aperture samples * 
              . . . 
Can we reduce this? 
9</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Then Intersect Intervals 
 Compute t 1 and t2 for Y... 
t1 t2 
y=Y2 
y=Y1 
x=X1 x=X2 
30</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Important! 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Walds thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
75</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Conservative Bounding Volume 
 What does 
conservative mean? 
 Volume must be big 
enough to contain all 
geometry within 
13</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Kd-tree Construction 
 Start with scene axis-aligned bounding box 
 Decide which dimension to split (e.g. longest) 
 Decide at which distance to split (not so easy) 
65</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Early termination is powerful! 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Walds thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
76</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Return the Correct Intersection 
 If tstart  &gt;  tmin   closest intersection at tstart 
 Else                       closest intersection at tend 
 Eye is inside box 
y=Y2 
y=Y1 
x=X1 x=X2 tend 
tstart 
36</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Find Intersections Per Dimension 
 Basic idea 
 Determine an interval along the ray for each dimension 
 The intersect these 1D intervals (remember CSG!) 
 Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
20</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Stack Studios, Rendered using Maxwell  
Questions? 
92  Next Limit S.L. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Ray-Box Intersection Summary 
 For each dimension,  
 If Rdx = 0  (ray is parallel)  AND   
    Rox &lt; X1 or Rox &gt; X2    no intersection  
 For each dimension, calculate intersection distances t1 and t2 
 t1 = (X1 - Rox) / Rdx                         t2 = (X2 - Rox) / Rdx 
 If t1 &gt; t2,   swap 
 Maintain an interval [tstart, tend], intersect with current 
dimension 
 If t1 &gt; tstart,  tstart = t1               If t2 &lt; tend,    tend    = t2 
 If tstart &gt; tend     box is missed  
 If tend &lt; tmin     box is behind  
 If tstart  &gt;  tmin   closest intersection at tstart 
 Else                       closest intersection at tend 
37</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Is there an Intersection? 
 If tstart &gt; tend  box is missed  
y=Y2 
y=Y1 
x=X1 x=X2 tend tstart 
34</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Intersection with BVH 
58</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Efficient Implementation 
 Not so easy, need ability to sort primitives along the 
three axes very efficiently and split them into two 
groups 
 Plus primitives have an extent (bbox) 
 Extra tricks include smarter tests to check if a 
triangle is inside a box 
Node  bbox of triangle 
88</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Ray tree 
 Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray This gets pretty complicated 
pretty fast! 
7</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Bounding Box of a Triangle 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
(x0, y0, z0) 
(x1, y1, z1) 
(x2, y2, z2) 
= (min( x0,x1,x2),  
     min( y0,y1,y2),  
     min( z0,z1,z2)) = (max( x0,x1,x2), 
     max( y0,y1,y2), 
     max( z0,z1,z2)) 
39</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Early termination is powerful 
 If there is an intersection in the first node, dont visit 
the second one 
 Allows ray casting to be reasonably independent of 
scene depth complexity 
77</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Kd-tree Traversal - High Level 
 If leaf, intersect with list of primitives 
 If intersects back child, recurse 
 If intersects front child, recurse 
69</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Find bounding box of objects/primitives 
 Split objects/primitives into two, compute child BVs 
 Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
51</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Kd-trees 
 Probably most popular acceleration structure  
 Binary tree, axis-aligned splits 
 Each node splits space 
in half along an axis-aligned plane 
 A space partition: The nodes do not overlap! 
 This is in contrast to BVHs 
63</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Kd-tree Traversal Pseudocode 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Walds thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
74</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Questions? 
 Further reading on efficient Kd-tree construction 
Hunt, Mark &amp; Stoll, IRT 2006  
Zhou et al., SIGGRAPH Asia 2008  
 Zhou et al. 
68  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Intersecting 1D Intervals 
23</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Ray-BVH Intersection 
55</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Bounding Box of a Group 
(xmin_b, ymin_b, zmin_b) 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
= (min(xmin_a,xmin_b),  
     min(ymin_a,ymin_b),  
     min(zmin_a,zmin_b)) = (max(xmax_a,xmax_b),  
     max(ymax_a,ymax_b),  
     max(zmax_a,zmax_b)) 
(xmin_a, ymin_a, zmin_a) (xmax_b, ymax_b, zmax_b) (xmax_a, ymax_a, zmax_a) 
42</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Bounding Volume Hierarchy (BVH) 
 Find bounding box of objects/primitives 
 Split objects/primitives into two, compute child BVs 
 Recurse, build a binary tree 
47</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Accelerating Ray Casting 
 Goal: Reduce the number 
of ray/primitive 
intersections 
11</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Bounding Box of a Transform 
(x'min, y'min, z'min) (x'max, y'max, z'max) 
= (min(x0,x1,x2,x3,x4,x5,x6,x7),  
     min( y0,y1,y2,y3,y4,x5,x6,x7),  
     min( z0,z1,z2,z3,z4,x5,x6,x7)) M 
(xmin, ymin, zmin) (x0,y0,z0) =  
M (xmin,ymin,zmin) = (max( x0,x1,x2,x3,x4,x5,x6,x7),  
     max(y0,y1,y2,y3,y4,x5,x6,x7),  
     max(z0,z1,z2,z3,z4,x5,x6,x7)) 
(x1,y1,z1) =  
M (xmax,ymin,zmin) (x2,y2,z2) =  
M (xmin,ymax,zmin) (x3,y3,z3) =   
M (xmax,ymax,zmin) (xmax, ymax, zmax) Bounding box of transformed object IS NOT 
the transformation of the bounding box! 
43</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Intersection with BVH 
59</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Find bounding box of objects/primitives 
 Split objects/primitives into two, compute child BVs 
 Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
49</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Optimizing Splitting Planes 
 Most people use the Surface Area Heuristic (SAH) 
MacDonald and Booth 1990, Heuristic for ray tracing 
using space subdivision, Visual Computer  
 Idea: simple probabilistic prediction of traversal cost 
based on split distance 
 Then try different possible splits and keep the one 
with lowest cost 
 Further reading on efficient Kd-tree construction 
Hunt, Mark &amp; Stoll, IRT 2006  
Zhou et al., SIGGRAPH Asia 2008  
85</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Pros and Cons of Kd trees 
 Pros 
 Simple code 
 Efficient traversal 
 Can conform to data 
 
 Cons  
 costly construction, not great if you work with moving 
objects 
90</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Ray tree 
 Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray 
6</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Nave Ray-Box Intersection 
 6 plane equations: Compute all intersections 
 Return closest intersection inside the box  
 Verify intersections are on the correct side  
of each plane: Ax+By+Cz+D &lt; 0  
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
16</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
24</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Find bounding box of objects/primitives 
 Split objects/primitives into two, compute child BVs 
 Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
50</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Kd-tree Construction - Recurse 
 Stop when minimum number of primitives reached 
 Other stopping criteria possible 
67</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Kd-tree Traversal - Three Cases 
 Intersects only back, only front, or both 
 Can be tested by examining t, t start and tend 
72</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Bounding Box of a Sphere 
r 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
(x, y, z ) 
= (x-r,  y-r,  z-r ) = (x+r,  y+r,  z+r ) 
40</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Ray-BVH Intersection 
56</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Surface Area Heuristic 
 Probability that we need to intersect a child 
 Area of the bbox of that child  
(exact for uniformly distributed rays) 
 Cost of the traversal of that child 
 number of primitives (simplistic heuristic) 
 This heuristic likes to put big densities of primitives 
in small-area nodes 
86</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Kd-tree Construction - Split 
 Distribute primitives to each side 
 If a primitive overlaps split plane, assign to both 
sides 
66</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Find Intersections Per Dimension 
 Basic idea 
 Determine an interval along the ray for each dimension 
 The intersect these 1D intervals (remember CSG!) 
 Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 
19</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Kd-tree Traversal, Nave Version 
 Could use bounding box test for each child 
 But redundant calculation: bbox similar to that of 
parent node, plus axis aligned, one single split 
70</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Questions? 
8</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>BVH Discussion 
 Advantages 
 easy to construct 
 easy to traverse 
 binary tree (=simple structure) 
 
 Disadvantages 
 may be difficult to choose a good split for a node 
 poor split may result in minimal spatial pruning 
60</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics 
Wojciech Matusik, MIT EECS 
Acceleration 
Structures for Ray Casting 
Haan  et al. 2007  1  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Find Intersections Per Dimension 
 Basic idea 
 Determine an interval along the ray for each dimension 
 The intersect these 1D intervals (remember CSG!) 
 Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
Interval 
between Y 1 
and Y 2 
Intersection 
22</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Reducing Total Computation 
 Pairs of planes have the same normal 
 Normals have only one non-zero component 
 Do computations one dimension at a time 
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
17</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Data Structure 
KdTreeNode: 
KdTreeNode* backNode, frontNode //children 
int dimSplit // either x, y or z 
float splitDistance  
// from origin along split axis 
boolean isLeaf 
List of triangles //only for leaves 
 
here dimSplit = 0 (x axis) backNode frontNode 
X=splitDistance  
64</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Find Intersections Per Dimension 
 Calculate intersection distance t1 and t2 
t1 t2 
Ro Rd y=Y2 
y=Y1 
x=X1 x=X2 
27</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Is it Important to Optimize Splits? 
 Given the same traversal code, the quality of Kd-tree 
construction can have a big impact on performance, 
e.g. a factor of 2 compared to naive middle split 
 But then, you should consider carefully if you need that 
extra performance 
 Could you optimize something else for bigger gain? 
87</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Find bounding box of objects/primitives 
 Split objects/primitives into two, compute child BVs 
 Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
48</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Bounding Box of a Transform 
(x'min, y'min, z'min) (x'max, y'max, z'max) 
= (min(x0,x1,x2,x3,x4,x5,x6,x7),  
     min( y0,y1,y2,y3,y4,x5,x6,x7),  
     min( z0,z1,z2,z3,z4,x5,x6,x7)) M 
(xmin, ymin, zmin) (x0,y0,z0) =  
M (xmin,ymin,zmin) = (max( x0,x1,x2,x3,x4,x5,x6,x7),  
     max(y0,y1,y2,y3,y4,x5,x6,x7),  
     max(z0,z1,z2,z3,z4,x5,x6,x7)) 
(x1,y1,z1) =  
M (xmax,ymin,zmin) (x2,y2,z2) =  
M (xmin,ymax,zmin) (x3,y3,z3) =   
M (xmax,ymax,zmin) (xmax, ymax, zmax) Bounding box of transformed object IS NOT 
the transformation of the bounding box! 
44 Questions?</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Important Details 
 For leaves, do NOT report 
intersection if t is not in [t near, tfar].  
 Important for primitives that overlap multiple nodes! 
 
 Need to take direction of ray into account 
 Reverse back and front if the direction has negative 
coordinate along the split dimension 
 Degeneracies when ray direction 
is parallel to one axis 
80</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Motivation 
 You need LOTS of rays to generate nice pictures 
 Intersecting every ray with every primitive becomes the 
bottleneck 
 Bounding volumes 
 Bounding Volume Hierarchies, Kd-trees 
For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade Today 
10</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Questions? 
 For extensions to moving scenes, see Real-Time KD-
Tree Construction on Graphics Hardware, Zhou et  
al., SIGGRAPH 2008  
91  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Two main gains 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Walds thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
Only near line 
stop at first intersection 
79</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Find Intersections Per Dimension 
 Basic idea 
 Determine an interval along the ray for each dimension 
 The intersect these 1D intervals (remember CSG!) 
 Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
Interval 
between Y 1 
and Y 2 
21</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Recursion For Reflection: None 
0 recursion</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Efficiency Issues 
 1/Rdx, 1/Rdy and 1/Rdz can be pre-computed  
and shared for many boxes 
38</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Intersection with BVH 
57</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>BVH Discussion 
 Advantages 
 easy to construct 
 easy to traverse 
 binary tree (=simple structure) 
 
 Disadvantages 
 may be difficult to choose a good split for a node 
 poor split may result in minimal spatial pruning 
 
 Still one of the best methods 
Recommended for your first hierarchy! 
61</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Is the Box Behind the Eyepoint? 
 If tend &lt;  tmin    box is behind  
y=Y2 
y=Y1 
x=X1 x=X2 tend 
tstart 
35</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Stopping criteria: 
 Recursion depth 
 Stop after a 
number  
of bounces 
 Ray contribution 
 Stop if reflected /  
transmitted 
contribution  
becomes too small trace ray  
   Intersect all objects  
   color = ambient term  
   For every light  
      cast shadow ray  
      color += local shading term  
   If mirror 
      color += colorrefl *  
                trace reflected ray  
   If transparent  
      color += colortrans *  
               trace transmitted ray  
 
   Does it ever end? 
Recap: Ray Tracing 
2</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Find Intersections Per Dimension 
 Calculate intersection distance t1 and t2 
 t1 = (X1 - Rox) / Rdx 
 t2 = (X2 - Rox) / Rdx 
[t1, t2] is the X interval 
t1 t2 
Ro Rd y=Y2 
y=Y1 
x=X1 x=X2 
28</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Then Intersect Intervals 
 Init t start &amp; tend with X interval 
 Update t start &amp; tend for each subsequent dimension 
y=Y2 
y=Y1 
x=X1 x=X2 
tend tstart 
29</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Where to Split Objects? 
 At midpoint of current volume    OR 
 Sort, and put half of the objects on each side    OR 
 Use modeling hierarchy 
53 Questions?</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Then Intersect Intervals 
 Update t start &amp; tend for each subsequent dimension 
If t1 &gt; tstart,  tstart = t1 
If t2 &lt; tend,    tend    = t2 
y=Y2 
y=Y1 
x=X1 x=X2 
tend tstart :-) 
33</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
End= 
min of maxs If Start &gt; End, the intersection is empty! 
26</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Recap: Two main gains 
 Only intersect with triangles near the line 
 Stop at the first intersection 
78</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Split in the Middle 
83  Does not conform to empty vs. dense areas 
 Inefficient traversal  Not so good!</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Are Bounding Volumes Enough? 
 If ray hits bounding volume, 
must we test all primitives inside it? 
 Lots of work, think of a 1M-triangle mesh 
bounding 
sphere 
45</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Kd-tree Traversal, Smarter Version 
 Get main bbox intersection from parent  
 tnear, tfar 
 Intersect with splitting plane  
 easy because axis aligned 
tnear tfar 
t 
71</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Important Details 
 For leaves, do NOT report 
intersection if t is not in [t near, tfar].  
 Important for primitives that overlap multiple nodes! 
 
 Need to take direction of ray into account 
 Reverse back and front if the direction has negative 
coordinate along the split dimension 
 Degeneracies when ray direction 
is parallel to one axis 
81 Questions?</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Where to split for construction? 
 Example for baseline 
 Note how this ray traverses easily: one leaf only 
82</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Implicit Integration, Collision Detection (PDF - 1.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec09/</lecture_pdf_url>
      <lectureno>09</lectureno>
      <slides>
        <slide>
          <slideno>53</slideno>
          <text>54 Implicit Euler with Newton, Visually 
What is the location 
Xi+1=X(t+h) such that the 
derivative there, multiplied 
by -h, points back to 
Xi=X(t) where we are 
starting from? 
Xi=Y0 -hf(X,t) 
Y=Xi+1 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39 Newton, Visually 
We are here Lets approximate f 
by its tangent at 
point (x n, f(x n)) 
f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Midpoint : 
  Euler step 
 evaluate fm 
 full step using fm 
 Trapezoid: 
 Euler step (a) 
 evaluate f1 
 full step using f1 (b)  
 average (a) and (b) 
 Better than Euler but still a speed limit 
18 Integrator Comparison f1 a 
 
fm f1 a 
b 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>76 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>62 Efficient Simulation of Inextensible Cloth  
Rony  Goldenthal, David Harmon, Raanan Fattal, Michel Bercovier, Eitan Grinspun 
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Iterative method for solving non-linear equations 
 
 
 Start from initial guess x0, then iterate 
35 Newtons Method (1D)</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>A cloth has many points of contact 
 Stays in contact 
 Requires 
 Efficient collision detection 
 Efficient numerical treatment (stability) 
98 The Cloth Collision Problem 
Image from Bridson et al.   
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>Using axis-aligned bounding box 
center=  
((xmin+xmax)/2, (y min+ymax)/2, (z min, zmax)/2) 
 Better than the average of the vertices because does not 
suffer from non-uniform tessellation  
93 Bounding Sphere of a Set of Points 
Questions? 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Remember our model problem:  x = -kx 
 Exact solution was a decaying exponential x0 e-kt 
 
 Explicit Euler: x(t+h) = (1- hk) x(t) 
 
 Implicit Euler: x(t+h ) = x(t) + h x(t+h )  
                        x(t+h) = x(t) - h k x(t+h) 
                               = x(t) / (1+ hk) 
It is a hyperbola! 
29 Implicit Euler is 
unconditionally stable! 
1/(1+hk ) &lt; 1, 
when h,k &gt; 0 Simple Closed Form Case</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Implicit Euler, Visually 
Xi+1 = Xi + h f( Xi+1, t+h ) 
Xi+1 - h f( Xi+1, t+h ) = Xi 
 
 What is the location 
Xi+1=X(t+h)  such that the 
derivative there, multiplied 
by -h, points back to 
Xi=X(t) where we are 
starting from? 
Xi+1 -hf(X,t) 
i X
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>To simplify, consider only time-invariant systems 
 This means X = f( X,t) = f(X) is independent of t 
 Our spring equations satisfy this already 
 
 Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1) 
 
 Non-linear equation, 
unknown Xi+1 on both the LHS and the RHS 
44 Implicit Euler and Large Systems</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Tuesday, October 16th  2:30pm  4:00pm 
 In class 
 Two-pages of notes (double sided) allowed 
2 Midterm</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
node 1  
node 2 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>83 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>Take longest scene dimension 
 Cut in two in the middle 
 assign each object or triangle to one side 
 build sphere around it 
94 Top-Down Construction 
 Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.This image is in the public domain.
Source: Wikimedia Commons. Sara McMains . All rights reserved. This content is excluded
from our Creative Commons license. Fo
r more information,
see http://ocw.mit.edu/help/faq-fair-use /. Gareth Bradshaw. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Mid-Point Implementation 
  class MidPoint : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   midPositions = positions + 0.5*h*velocities 
   midVelocities = velocities  + 0.5*h*accelerations 
   midForces = ps-&gt;getForces(midPositions, midVelocities) 
   midAccelerations = midForces / masses 
   newPositions = positions + 0.5*h* midVelocities 
   newVelocities = velocities  + 0.5*h* midAccelerations      
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  }</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1 ) 
 
 Lets rewrite this as                          with 
48 Implicit Euler  N Dimensions</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Easy with implicit equations of surfaces: 
 
H(x,y,z) = 0     on the surface 
H(x,y,z) &lt; 0      inside surface 
 
 So just compute H and you know that 
you are inside if it is negative 
 
 More complex with other surface 
definitions like meshes 
 A mesh is not necessarily even closed, what is inside? 
65 Detecting Collisions</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Using axis-aligned bounding box 
center=  
((xmin+xmax)/2, (y min+ymax)/2, (z min, zmax)/2) 
 Better than the average of the vertices because does not 
suffer from non-uniform tessellation  
92 Bounding Sphere of a Set of Points 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
 
   // if there is nowhere to go, test everythin
g 
   if (node1-&gt;isLeaf() &amp;&amp; node2-&gt;isLeaf()) 
      perform full test between all primitives within nodes 
 
   // otherwise go down the tree in the non-leaf path 
   if ( !node2-&gt;isLeaf() &amp;&amp; !node1-&gt;isLeaf() ) 
      // pick the larger node to subdivide, then recurse 
   else 
      // recurse down the node that is not a leaf 
 
   return false 
87 Pseudocode (with leaf case)</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Axis Aligned Bounding Boxes 
R-Trees 
 
 Oriented bounding boxes 
  S. Gottschalk, M. Lin, and D. Manocha . OBBTree: A hierarchical Structure 
for rapid interference detection, Proc. Siggraph 96. ACM Press, 1996 
 
 Binary space partitioning trees; kd-trees  
88 Other Options</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Two spheres, centers C1 and C2, radii r1 and r2 
 Intersect only if | |C1C2||&lt;r1+r2 
77 Sphere-Sphere Collision Test 
C1 C2 r1 r2 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>1D:  
 
 Now locations Xi, Xi+1 and F are N-D 
 N-D Newton step is just like 1D: 
45 Newtons Method  N Dimensions 
NxN Jacobian 
matrix replaces 
f 
unknown N- D 
step from 
current to next 
guess</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Detection 
 Response 
 Overshooting problem  
(when we enter the solid) 
64 Collisions</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Simple partial differentiation... 
 
 
 
 
 Where 
51 What is the Jacobian? 
The Jacobian of 
the Force function 
f</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Implementing Particle Systems 
 Implicit Integration 
 Collision detection and response 
 Point-object and object-object detection 
 Only point-object response 
3 Plan</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>So far, we have seen explicit Euler 
X(t+h) = X(t) + h X(t) 
 
 We also saw midpoint and trapezoid methods 
 They took small Euler steps, re-evaluated X there, and 
used some combination of these to step away from the 
original X(t). 
 Yields higher accuracy, but not impervious to stiffness 
(twice the speed limit of Euler) 
22 Explicit Integration</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>h &gt; 1/k: oscillate. h &gt; 2/k: explode! 
17 Euler Has a Speed Limit! 
From the SIGGRAPH PBM notes  
Image removed due to copyright restrictions -- please see slide 5 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse/.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>When computing the forces, initialize the force 
vector to zero, then sum over all forces for each 
particle 
 Gravity is a constant acceleration 
 Springs connect two particles, affects both 
dvi/dt = Fi(X, t) is the vector sum of all forces on particle i 
 For 2nd order Fi=miai system, 
dxi/dt is just the current vi 
15 Computing Forces</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new MidPoint() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 Newton, Visually 
We are here Lets approximate f 
by its tangent at 
point ( xn, f(xn)) 
Then well see 
where the tangent 
line crosses zero 
and take that as 
next guess 
f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>82 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Newton, Visually 
We are here f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Remember our model problem:  x = -kx 
 Exact solution was a decaying exponential x0e-kt 
 
 Explicit Euler: x(t+h) = (1- hk) x(t) 
 
 Implicit Euler: x(t+h ) = x(t) + h x(t+h )  
                        x(t+h) = x(t) - hk x(t+h) 
       x(t+h) +hkx(t+h) = x(t) 
                   x(t+h)  = x(t) / (1+hk) 
It is a hyperbola! 
28 Simple Closed Form Case</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Then iterate 
 Initial guess                            (or result of explicit method) 
 
 For each step, solve 
 
 Then set 
50 
Y is variable Xi is fixed 
Implicit Euler  N Dimensions</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 ODE: Path Through a Vector Field 
When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ? 
X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction.   Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Forward Euler Implementation 
  class ForwardEuler : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   newPositions = positions + h*velocities 
   newVelocities = velocities  + h*accelerations 
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  }</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>To simplify, consider only 1D time-invariant systems 
 This means x = f( x,t) = f(x) is independent of t 
 Our spring equations satisfy this already 
 
x(t+h)=x(t)+dx = x(t)+h f(x(t+h )) 
f can be approximated it by 1st order Taylor: 
f(x+dx)=f(x)+dxf(x)+O(dx2) 
x(t+h)=x(t)+h [f(x) + dx f(x)] 
dx=h [f(x) +dx f(x)] 
dx=hf(x)/[1-
hf(x)] 
 Pretty much Newton solution 34 Implicit Euler in 1D</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Iterative method for solving non-linear equations 
 
 
 Start from initial guess x0, then iterate 
 
 
 
 
 Also called Newton-Raphson iteration 
36 Newtons Method (1D)</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>The Jacobian matrix Jf  is usually sparse 
 Only few non-zero entries per row 
 E.g. the derivative of a spring force only depends on the 
adjacent masses positions 
 Makes the system cheaper to solve 
 Dont invert the Jacobian! 
 Use iterative matrix solvers like 
conjugate gradient, perhaps with 
preconditioning, etc.  
57 Good News 
 David Baraff and Andrew Witkin . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>We have N point masses  
 Lets just stack all xs and vs in a big vector of length 6N 
Fi denotes the force on particle i 
 When particles do not interact , Fi only depends on xi and vi. 
6 Many Particles 
f gives d/dt X, 
remember!</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>58 Implicit Euler Pros &amp; Cons 
 Pro: Stability! 
 
 Cons:  
 Need to solve a linear system at each step  
 Stability comes at the cost of numerical viscosity, but 
then again, you do not have to worry about explosions. 
 Recall exp vs. hyperbola 
 
 Note that accuracy is not improved 
 error still O(h) 
 There are lots and lots of implicit methods out there!</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
 Solution: Back up 
 Compute intersection poin
t 
 Ray-object 
intersection! 
 Compute response there 
 Advance for remaining  
fractional time step 
70 Collisions  Overshooting 
backtracking xi 
xi+1</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Collision Response for Particles 
N v</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>In more complex systems, 
step size is limited by the largest k. 
 One stiff spring can ruin things for everyone else! 
 
 Systems that have some big k values 
are called stiff systems . 
 
 In the general case, k values are eigenvalues of the 
local Jacobian! 
21 Stiffness 
From the siggraph PBM notes Questions? 
 David Baraff and Andrew Witkin . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Top down 
 Divide and conquer  
 
 Bottom up 
 Cluster nearby objects 
 
 Incremental 
 Add objects one by one, binary-tree style.  
90 Hierarchy Construction</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Iterate until convergence 
 
 Initial guess                            (or result of explicit method) 
 
 For each step, solve 
 
 
 
 Then set 
52 Putting It All Together</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>boolean intersect(node1, node2) 
   // no overlap? ==&gt; no intersection!  
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
 
   // recurse down the larger 
of the two nodes  
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
      for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
 
   // no intersection in the subtrees? ==&gt; no intersection!  
   return false 
80 Pseudocode (simplistic version)</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Implicit Euler uses the derivative at the destination! 
X(t+h) = X(t) + h X(t+h) 
 It is implicit because we do not have X(t+h), 
it depends on where we go (HUH?) 
 Two situations 
X is known analytically and everything 
is closed form ( doesnt happen in practice ) 
We need some form of iterative non-linear solver. 
25 Implicit Integration</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Trapezoid 
 take fake Euler step 
 read derivative at fake destination 
 Implicit Euler 
 take derivative at the real destination 
 harder because the derivative depends on the destination 
and the destination depends on the derivative 
24 Difference with Trapezoid</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>http://isg.cs.tcd.ie/spheretree/  
79 Examples of Hierarchy 
 Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>http://www.youtube.com/watch?v=b_cGXtc-nMg  
http://www.youtube.com/watch?v=nFd9BIcpHX4&amp;f
eature=related  
http://www.youtube.com/watch?v=2SXixK7yCGU  
89 Questions? 
http://www.youtube.com/watch?v=b_cGXtc-nMg</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Now locations Xi, Xi+1 and F are N-D 
 Newton solution of F(Xi+1) = 0 is just like 1D: 
 
 
 
 
 
 Must solve a linear system at each 
step of Newton iteration 
 Note that also Jacobian changes for each step 
47 Newtons Method  N Dimensions 
NxN Jacobian 
matrix 
unknown N- D 
step from 
current to next 
guess 
Questions?</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 Questions?</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>In more complex systems, 
step size is limited by the largest k. 
 One stiff spring can ruin things for everyone else! 
 
 Systems that have some big k values 
are called stiff systems . 
 
 In the general case, k values are eigenvalues of the 
local Jacobian! 
20 Stiffness 
From the siggraph PBM notes 
 David Baraff and Andrew Witkin . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Implicit vs. Explicit 
From the Siggraph PBM notes Image removed due to copyright restrictions -- please see slide 12 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse /.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 A Mass Spring Model for Hair Simulation  
Selle, A., Lentine, M., G., and Fedkiw 
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Time Stepper Class 
  class TimeStepper 
  { 
        virtual takeStep(ParticleSystem* ps, float h) 
  }</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Particle System Class 
  class ParticleSystem 
  { 
        virtual int getDimension() 
        virtual setDimension(int n) 
        virtual float* getStatePositions() 
        virtual setStatePositions(float* positions) 
        virtual float* getStateVelocities() 
        virtual setStateVelocities(float* velocities) 
        virtual float* getForces(float* positions, float* velocities) 
                        virtual setMasses(float* masses) 
                        virtual float* getMasses() 
 
        float* m_currentState  
  }</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Tangential velocity vt  
often unchanged  
 Normal velocity vn reflects: 
 
 
 
 Coefficient of restitution  
 
 When  = 1 , mirror reflection 
68 Collision Response for Particles 
N v 
vn vt 
N v vnew 
N v vnew =1 
&lt;1</text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>Keyframing mostly 
 Articulated figures, inverse kinematics 
 Skinning  
 Complex deformable skin, muscle, skin motion 
 Hierarchical controls 
 Smile control, eye blinking, etc.  
 Keyframes for these higher-level controls 
 A huge time is spent building the 3D models,  
its skeleton and its controls (rigging) 
 Physical simulation for secondary motion 
 Hair, cloths, water 
 Particle systems for fuzzy objects 
How Do They Animate Movies? 
Images from the Maya tutorial 100  Maya tutorial. All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>97 Reference 
An image of the book, Real Time Collision Detection by Christer Ericson, 
has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Trivial given center C 
 radius = max i ||C-Pi|| 
91 Bounding Sphere of a Set of Points 
C 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
96Top-Down Construction - Recurse 
Questions? 
 Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
 Gareth Bradshaw. All rights reserved.
This content is excluded from our Creative
Commons license. For more information, 
see http://ocw.mit.edu/help/faq-fair-use/. 
This image is in the public domain.Source: Wikimedia Commons .
 Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Basic idea 
 Particle System tells Time Stepper how many 
dimensions (N) the phase space has 
 Particle System has a function to write its state to an N-
vector of floating point numbers (and read state from it) 
 Particle System has a function that evaluates f( X,t), 
given a state vector X and time t 
 
 Time Stepper takes a Particle System as input and 
advances its state 
8 Implementation Notes</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>31 Implicit vs. Explicit 
From the Siggraph PBM notes Questions? 
Image removed due to copyright restrictions -- please see slide 12 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse /.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Place spheres around objects  
 If spheres do not intersect, neither do the objects! 
 Sphere-sphere collision test is easy. 
75 Bounding Spheres 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Now locations Xi, Xi+1 and F are N-D 
 Newton solution of F(Xi+1) = 0 is just like 1D: 
 
 
 
 
 
 Must solve a linear system at each 
step of Newton iteration 
 Note that also Jacobian changes for each step 
46 Newtons Method  N Dimensions 
NxN Jacobian 
matrix 
unknown N- D 
step from 
current to next 
guess</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Pong:  =? 
http://www.youtube.com/watch?v=sWY0Q_lMFfw  
http://www.xnet.se/javaTest/jPong/jPong.html  
72 Questions? 
http://en.wikipedia.org/wiki/Pong  
Animation removed due to 
copyright restrictions. 
This image is in the public domain.
Source: Wikimedia Commons.Image courtesy of Chris Rand on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Use simpler conservative proxies  
(e.g. bounding spheres) 
 
 Recursive (hierarchical) test 
 Spend time only for parts of the scene that are close 
 
 Many different versions, we will cover only one 
 
 
74 Hierarchical Collision Detection</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>101 
Thats All for Today! 
Bungie / ign.com 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Remember our model problem:  x = -kx 
 Exact solution was a decaying exponential x0 e-kt 
 
 Explicit Euler: x(t+h) = (1- hk) x(t) 
 Here we got the bounds on h  to avoid oscillation/explosion 
26 Simple Closed Form Case</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
85  Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>84 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
      
for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1 ) 
 
 Lets rewrite this as                          with 
 
 
 
 Then the Y that solves F(Y)=0 is Xi+1 
49 Implicit Euler  N Dimensions</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Often, the 1st Newton step may suffice 
 People often implement Implicit Euler using only one 
step. 
 This amounts to solving the system 
 
 
 
 
where the Jacobian and f are evaluated at Xi, and we are 
using Xi as an initial guess. 
55 One-Step Cheat</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Newton, Visually 
 Questions? 
Image courtesy of Ralf Pfeifer on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 
Xi Xi+1  Implicit Euler, Visually 
Xi+1 = Xi + h f( Xi+1, t+h ) 
Xi+1 - h f( Xi+1, t+h ) = Xi 
 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Often, the 1st Newton step may suffice 
 People often implement Implicit Euler using only one 
step. 
 This amounts to solving the system 
 
 
 
 
where the Jacobian and f are evaluated at Xi, and we are 
using Xi as an initial guess. 
56 One-Step Cheat 
 Questions?</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
69 Collisions  Overshooting 
xi 
xi+1</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
 Solution: Back up 
 Compute intersection point 
 Ray-object 
intersection! 
 Compute response there 
 Advance for remaining  
fractional time step 
 Other solution: 
Quick and dirty hack  
 Just project back to object closest point 
71 Collisions  Overshooting 
fixing backtracking xi 
xi+1</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>To simplify, consider only time-invariant systems 
 This means X = f( X,t) = f(X) is independent of t 
 Our spring equations satisfy this already 
 
 Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1) 
43 Implicit Euler and Large Systems</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Given a function f(X,t) compute X(t) 
 Typically, initial value problems : 
 Given values X(t0)=X0 
 Find values X(t) for t &gt; t0 
 
 We can use lots of standard tools 
4 ODEs and Numerical Integration</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>It pays off to abstract (as usual) 
 Its easy to design your Particle System and Time 
Stepper to be unaware of each other 
 
 Basic idea 
 Particle system and Time Stepper communicate via 
floating-point vectors X and a function that computes 
f(X,t) 
 Time Stepper does not need to know anything else! 
7 Implementation Notes</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Implicit Euler with Newton, Visually 
Xi=Y0 Y1 Y2 
Y3 Y=Xi+1 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Implicit Integration 
Collision Detection 
Philippe Halsman : Dali Atomicus MIT EECS 6.837  Matusik 
This image is in the public domain. Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>x=-kx 
 First half Euler step: xm=x-0.5 hkx = x(1-0.5 hk) 
 Read derivative at xm: fm=-kxm=-k(1-0.5 hk)x 
 Apply derivative at origin:  
x(t+h)=x+hfm = x-hk(1-0.5hk)x =x(1-hk+0.5 h2k2) 
 Looks a lot like Taylor... 
 We want 0&lt;x(t+h )/x(t)&lt;1 
-hk+0.5 h2k2 &lt; 0 
hk(-1+0.5 hk)&lt;0 
For positive values of h &amp; k =&gt;  h &lt;2/k 
 Twice the speed limit of Euler
 
19 Midpoint Speed Limit</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Imagine we have n objects. Can we test all pairwise 
intersections? 
 Quadratic cost O(n2)! 
 
 Simple optimization: separate static objects 
 But still O(static  dynamic+ dynamic2) 
73 Collision Detection in Big Scenes</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Simulating Knitted Cloth at the Yarn Level  
Jonathan Kaldor, Doug L. James, and Steve Marschner 
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>99 Robust Treatment of Simultaneous Collisions  
David Harmon, Etienne Vouga, Rasmus Tamstorf, Eitan Grinspun 
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>So far, we have seen explicit Euler 
X(t+h) = X(t) + h X(t) 
 
 Implicit Euler uses the derivative at the destination! 
X(t+h) = X(t) + h X(t+h) 
It is implicit because we do not have X(t+h ), 
it depends on where we go (HUH?) 
 
 aka backward Euler 
23 Implicit Integration</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Collision Response for Particles 
N v 
vn vt 
v=vn+vt 
normal component  
tangential component</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59 Reference 
Large steps in cloth simulation   
David Baraff    Andrew Witkin    
http://portal.acm.org/citation.cfm?id=280821  
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new ForwardEuler() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Hierarchy of bounding spheres 
 Organized in a tree 
 Recursive test with early pruning Hierarchical Collision Test 
Root encloses 
whole object 
 Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
78</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41 Newton, Visually 
Image courtesy of Ralf Pfeifer on  Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Remember our model problem:  x = -kx 
 Exact solution was a decaying exponential x0 e-kt 
 
 Explicit Euler: x(t+h) = (1- hk) x(t) 
 
 Implicit Euler : x(t+h ) = x(t) + h x(t+h ) 
27 Simple Closed Form Case</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
95Top-Down Construction - Recurse 
 Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, seehttp://ocw.mit.edu/help/faq-fair-use/.
 Gareth Bradshaw. All rights reserved.This content is excluded from our CreativeCommons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.
This image is in the public domain.Source: Wikimedia Commons .
 Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Iterative method for solving non-linear equations 
 
 
 Start from initial guess x0, then iterate 
37 Newtons Method (1D) 
one step</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Global Illumination and Monte Carlo (PDF - 2.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec18/</lecture_pdf_url>
      <lectureno>18</lectureno>
      <slides>
        <slide>
          <slideno>40</slideno>
          <text>Irradiance Caching 
 Yellow dots:  
indirect diffuse sample points 
The irradiance cache tries to 
adapt sampling density to 
expected frequency content of 
the indirect illumination (denser 
sampling near geometry) 
41 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Global Illumination (with Indirect) 
6 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>More Subsurface Scattering 
Photograph Rendering Weyrich et al. 2006  
50  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>References 
82 Images of the following book covers have been removed due to copyright restrictions:
-Advanced Global Illumination  by Philip Dutre, Philippe Bekaert, and Kavita Bala
-Realistic Ray Tracing  by Peter Shirley and R.  K. Morley
-Realistic Image Synthesis Using Photon Mapping  by Henrik Wann Jensen
Please check the books for further details.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Today 
 Lots of randomness! 
Dunbar &amp; Humphreys 2</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>That Was Just the Beginning 
 Tons and tons of other Monte Carlo techniques 
 Bidirectional Path Tracing 
 Shoot random paths not just from camera but also light, connect 
the path vertices by shadow rays 
 Metropolis Light Transport 
 And Finite Element Methods 
 Use basis functions instead of random sampling 
 Radiosity (with hierarchies &amp; wavelets) 
Precomputed Radiance Transfer  
 
 This would warrant a class of its own! 
51</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>The Reflectance Equation 
 
 
 
 Where does L in come from? 
x 
9</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Thats All for today 
Image: Fournier and 
Reeves, SIGGRAPH 86 83 Image removed due to copyright restrictions -- please Fig. 13 in  Fournier A. and W.T. Reeves. "A Simple Model of Ocean Waves."
SI
GGRAPH '86 Proceedings of the 13th Annual Conference on Computer Graphics and Interactive Techniques; Pages 75-84.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Direct Illumination 
5 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Photon Mapping 
 Preprocess: cast rays from light sources, let them 
bounce around randomly in the scene 
 Store photons 
44</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Global Illumination (with Indirect) 
35 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Importance of Sampling the Light 
Without explicit  
light sampling With explicit  
light sampling 
1 path 
per pixel 
4 paths 
per pixel  
 
29</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Stratified Sampling Analysis 
 Cheap and effective 
 But mostly for low-dimensional domains 
 Again, subdivision of N-D needs Nd domains like 
trapezoid, Simpsons, etc.! 
 
 With very high dimensions, Monte Carlo is pretty 
much the only choice 
79</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Monte Carlo Integration 
 S is the integration domain 
 Vol(S) is the volume (measure) of S 
{xi} are independent uniform random points in S 
 The integral is the average of f times the volume of S 
 Variance is proportional to 1/N 
 Avg. error is proportional 1/sqrt(N) 
 To halve error, need 4x samples 
61</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Note : More noise. This is not a coincidence; the integrand 
has higher variance (the BRDFs are spikier).  10 paths/pixel Path Tracing Results: Glossy Scene 
Henrik Wann Jensen 
27 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Results 
Henrik Wann Jensen 
22 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Monte Carlo Path Tracing 
 Trace only one secondary ray per recursion 
 Otherwise number of rays explodes! 
 But send many primary rays per pixel (antialiasing) 
Again, trace 
shadow rays 
from each 
intersection 
24</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Monte Carlo Computation of  
 The probability is  /4  
 Count the inside ratio n = # inside / total # trials 
    n * 4 
 The error depends on the number or trials 
Demo 
def piMC(n):     
   success = 0     
   for i in range(n):                       x=random.random()        
 y=random.random()         
 if x*x+y*y&lt;1: success = success+1         return 
4.0*float(success )/float(n) 
63</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Why Not Use Simpson Integration? 
 Youre right, Monte Carlo is not very efficient for 
computing  
 When is it useful? 
 High dimensions: Convergence is independent of 
dimension! 
 For d dimensions, Simpson requires Nd domains (!!!) 
 Similar explosion for other quadratures (Gaussian, etc.) 
64</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
73 Image removed due to copyright restrictions  please see Jason Lawrences slide 9 -12 in  the talk slides on Efficient BRDF
Importance Sampling Using a Factored Representation, available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Example: Glossy Reflection 
 Integral over hemisphere 
 BRDF times cosine times incoming light Slide courtesy of Jason Lawrence 
70 Image removed due to copyright restrictions  please see Jason Lawrences slide 9 -12 in  the talk slides on Efficient BRDF
Importance Sampling Using a Factored Representation, available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Global Illumination 
 So far, we only used the BRDF for point lights 
 We just summed over all the point light sources 
 BRDF also describes how indirect illumination 
reflects off surfaces 
 Turns summation into integral over hemisphere 
 As if every direction had a light source 
7</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Questions? 
 Images by Veach and Guibas, SIGGRAPH 95  
Nave sampling strategy Optimal sampling strategy 
67  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>10 paths/pixel 
Path Tracing Results 
Henrik Wann Jensen 
26 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Reflectance Equation, Visually 
outgoing light to 
direction v incident light 
from direction 
omega the BRDF cosine term 
v 
Sum (integrate) 
over every 
direction on the 
hemisphere, 
modulate incident 
illumination by 
BRDF Lin Lin 
Lin 
Lin 
8</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>The rendering equation describes the appearance of 
the scene, including direct and indirect illumination 
 An integral equation, the unknown solution function L 
is both on the LHS and on the RHS inside the integral 
 Must either discretize or use Monte Carlo integration 
 Originally described by Kajiya and Immel et al. in 1986 
 More on 6.839 
 Also, see book references towards the end The Rendering Equation 
12</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Irradiance Caching 
 Indirect illumination is smooth 
38</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Importance Sampling Math 
 
 
 
 
 Like before, but now {x i} are not uniform but drawn 
according to a probability distribution p 
 Uniform case reduces to this with p(x) = const. 
 The problem is designing ps that are easy to sample 
from and mimic the behavior of f 
74</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Monte Carlo Path Tracing 
http://www.youtube.com/watch?v=mYMkAnm -PWw 75 Video removed due to copyright restrictions  please see the link below for further details.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>The Rendering Equation 
 Analytic solution is usually impossible 
 Lots of ways to solve it approximately 
 Monte Carlo techniques use random samples for 
evaluating the integrals 
 Well look at some simple method in a bit... 
 Finite element methods discretize the solution using 
basis functions (again!) 
 Radiosity, wavelets, precomputed radiance transfer, etc. 
13</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Questions? 
14</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Integration 
 Compute integral of arbitrary function 
 e.g. integral over area light source, over hemisphere, etc. 
 Continuous problem  we need to discretize 
 Analytic integration never works because of visibility and other 
nasty details 
57</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Monte Carlo Integration 
 Monte Carlo integration: use random samples and 
compute average 
 We dont keep track of spacing between samples 
 But we kind of hope it will be 1/N on average 
59</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Error/noise Results in Variance 
 We use random rays 
 Run the algorithm again  get different image 
 What is the noise/variance/standard deviation? 
 And whats really going on anyway? 
56  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Questions? 
Image: Pure 
43 Image of Y chair designed by H.J. Wegner has been removed due to copyright restrictions.  
Please see http://tora_2097.cgsociety.org/portfolio/project-detail/786738/  for further details.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>What Else Can We Integrate? 
 Pixel: antialiasing 
 Light sources: Soft shadows 
 Lens: Depth of field 
 Time: Motion blur 
 BRDF: glossy reflection 
 (Hemisphere: indirect lighting) 
52  source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Henrik Wann Jensen.
Used with permission.
 ACM. All rights reserved. This content is
excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Hmmh... 
 Are uniform samples the best we can do? 
68</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Smarter Sampling 
Sample a non-uniform probability 
Called importance sampling 
Intuitive justification: Sample more in places where there are 
likely to be larger contributions to the integral 
69</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>How To Render Global 
Illumination? 
Lehtinen  et al. 2008  
15  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Monte-Carlo Ray Tracing 
 Cast a ray from the eye through each pixel 
 Cast random rays from the visible point  
 Recurse 
20</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>The Reflectance Equation 
 
 
 
 Where does L in come from? 
 It is the light reflected towards x from the surface point in 
direction l ==&gt; must compute similar integral there! 
 Recursive! 
 
x 
10</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Path Tracing is costly 
 Needs tons of rays per pixel! 
34</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Global Illumination 
 So far, we've seen only direct lighting (red here) 
 We also want indirect lighting 
 Full integral of all directions (multiplied by BRDF) 
 In practice, send tons of random rays 
4</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>100 paths/pixel 
Path Tracing Results: Glossy Scene 
Henrik Wann Jensen 
28 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Irradiance Caching 
 Indirect illumination is smooth 
37</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Stratified Sampling Example 
 When supersampling, instead of taking KxK regular 
sub-pixel samples, do random jittering within each 
KxK sub-pixel 
78</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Questions? 
 Vintage path tracing by Kajiya 
33  Jim Kajiya. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Irradiance Caching 
 Store the indirect illumination 
 Interpolate existing cached values 
 But do full calculation for direct lighting 
40</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Monte Carlo Computation of  
 Take a square 
 Take a random point (x,y) in the square 
 Test if it is inside the  disc (x2+y2 &lt; 1) 
 The probability is  /4  
x y Integral of the function that 
is one inside the circle, zero 
outside 
62</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Global Illumination and Monte Carlo 
MIT EECS 6.837 Computer Graphics 
Wojciech Matusik 
with many slides from Fredo Durand and Jaakko Lehtinen 
1  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Indirect Lighting is Mostly Smooth 
36 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Monte Carlo Integration 
 S is the integration domain 
 Vol(S) is the volume (measure) of S 
{xi} are independent uniform random points in S 
60</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Monte-Carlo Ray Tracing 
 Systematically sample light sources at each hit 
 Dont just wait the rays will hit it by chance 
21</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Irradiance Caching 
 Indirect illumination is smooth 
==&gt; Sample sparsely, interpolate nearby values 
39</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Stratified Sampling 
 With uniform sampling, we can get unlucky 
 E.g. all samples clump in a corner 
 If we dont know anything of the integrand, 
we want a relatively uniform sampling 
 Not regular, though, because of aliasing! 
 
 To prevent clumping, subdivide domain   
into non-overlapping regions i 
 Each region is called a stratum 
 Take one random sample per i 
77</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>The Photon Map 
 Efficiently store photons for fast access 
 Use hierarchical spatial structure (kd-tree) 
46</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Ray Casting 
 Cast a ray from the eye through each pixel  
16</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Monte-Carlo Ray Tracing 
 Cast a ray from the eye through each pixel 
 Cast random rays from the hit point to evaluate 
hemispherical integral using random sampling 
18</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Advantages of MC Integration 
 Few restrictions on the integrand 
 Doesnt need to be continuous, smooth, ... 
 Only need to be able to evaluate at a point 
 Extends to high-dimensional problems 
 Same convergence  
 Conceptually straightforward 
 Efficient for solving at just a few points 
65</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Domains of Integration 
 Pixel, lens (Euclidean 2D domain) 
 Antialiasing filters, depth of field 
 Time (1D) 
 Motion blur 
 Hemisphere 
 Indirect lighting 
 Light source 
 Soft shadows 
Famous motion blur image 
from Cook et al. 1984  
53  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Photon Map Results 
48 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Ray Tracing 
 Cast a ray from the eye through each pixel  
 Trace secondary rays (shadow, reflection, refraction) 
17</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Rendering glossy reflections 
 Random reflection rays around mirror direction 
 256 samples per pixel 
Motivational Eye Candy 
55  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>For more demo/experimentation 
http://www.mitsuba-renderer.org/ 
http://www.pbrt.org/  
http://www.luxrender.net/en_GB/index  
32</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Monte-Carlo Ray Tracing 
 Cast a ray from the eye through each pixel 
 Cast random rays from the visible point  
 Recurse 
19</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Questions? 
Traditional importance function 
 Better importance by Lawrence et al.  1200 Samples/Pixel 
76  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Monte Carlo Path Tracing 
 We shoot one path from the eye at a time 
 Connect every surface point on the way to the light by a 
shadow ray 
 We are randomly sampling the space of all possible light 
paths between the source and the camera 
25</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Rendering glossy reflections 
 Random reflection rays around mirror direction 
 1 sample per pixel Motivational Eye Candy 
54  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Questions? 
 Image from the ARNOLD Renderer by Marcos Fajardo 
80 Images removed due to copyright restrictions -- Please see
http://www.3dluvr.com/marcosss/morearni/ for further details.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Photon Mapping - Rendering 
 Cast primary rays 
 For secondary rays 
 reconstruct irradiance using adjacent stored photon 
 Take the k closest photons 
 Combine with irradiance caching and a number of other techniques 
Shooting one bounce of 
secondary rays and 
using the density 
approximation at those 
hit points is called final 
gathering . 
47</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
71 Image removed due to copyright restrictions  please see Jason Lawrences slide 9 -12 in  the talk slides on Efficient BRDF
Importance Sampling Using a Factored Representation, available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Today 
 Global Illumination 
 Rendering Equation 
 Path tracing 
 Monte Carlo integration 
 Better sampling 
 importance 
 stratification 
3  ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>6.839! 
 Eric Veachs PhD dissertation 
http://graphics.stanford.edu/papers/veach_thesis/  
 
 
 
 
Physically Based Rendering   
by Matt Pharr, Greg Humphreys For Further Information... 
81</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Monte Carlo Path Tracing 
 Trace only one secondary ray per recursion 
 Otherwise number of rays explodes! 
 But send many primary rays per pixel (antialiasing) 
23</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Integration 
 You know trapezoid, Simpsons rule, etc. 
58</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Photon Mapping 
 Preprocess: cast rays from light sources 
 Store photons (position + light power + incoming direction) 
45</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Why Use Random Numbers? 
 Fixed random sequence 
 We see the structure in the error 
Henrik Wann Jensen 
30 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Many materials exhibit subsurface scattering  
 Light doesnt just reflect off the surface 
 Light enters, scatters around, and exits at another point 
 Examples: Skin, marble, milk 
More Global Illumination Coolness 
Images: Jensen et al.  
49 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Disadvantages of MC 
 Noisy 
 Slow convergence 
 Good implementation is hard 
 Debugging code 
 Debugging math 
 Choosing appropriate techniques 
66</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Radiance  by Greg Ward 
 The inventor of irradiance caching 
http://radsite.lbl.gov/radiance/  
42 Image removed due to copyright restrictions.  Please see above link for further details.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Demo  
http://madebyevan.com/webgl-path-tracing/  
31 Image removed due to copyright restrictions.  Please see the above link for further details.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
72 Image removed due to copyright restrictions  please see Jason Lawrences slide 9 -12 in  the talk slides on Efficient BRDF
Importance Sampling Using a Factored Representation, available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Where does L in come from? 
 It is the light reflected towards x from the surface point in 
direction l ==&gt; must compute similar integral there! 
 Recursive! 
 AND if x happens 
to be a light source, 
we add its contribution 
directly 
 The Rendering Equation 
x 
11</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Real-time Shadows (PDF - 2.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec23/</lecture_pdf_url>
      <lectureno>23</lectureno>
      <slides>
        <slide>
          <slideno>13</slideno>
          <text>2. The Bias (Epsilon) Nightmare 
 For a point visible 
from the light source 
 ShadowMap(x,y )  z 
 But due to rounding 
errors the depths 
never agree exactly 
 How can we  
avoid erroneous  
self-shadowing? 
 Add bias (epsilon)  
14  Addison-Wesley
. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>It is possible to implement shadow volumes rather 
efficiently using the stencil buffer 
 John Carmacks Doom 3 engine did this very well 
 Shadow volumes had their 15 minutes of popularity around that 
ti
me 
 NVIDIA even came up with 
hardware acceleration 
(UltraShadow ) 
 Further info 
Wikipedia  
Aila &amp; Akenine-Mller: 
Hierarchical Shadow Volumes,  
Proc. Graphics Hardware 20 04 Shadow Volumes Are Sort of Pass 
Id Software 
40 Screenshot from video game Doom 4 removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
0 
+1 0  
 
 Introduces problems  
with far clipping plane 
 Solved by clamping the  
depth during clipping 
37</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Shadow Mapping 
 Texture mapping with 
depth information 
 2 passes 
 Compute shadow  
map == depth from  
light source 
 You can think of 
it as a z-buffer as 
seen from the light 
 Render final image, 
check shadow map  
to see if points are  
in shadow 
Foley et al. Computer Graphics Principles and 
Practice 
9  Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Compression algorithm 
 Approximation:  
Piecewise linear  
 Set an error bound 
 Decide which vertices  
to keep 
 Greedy from zero do far 
48 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>1. Test Eye with Respect to Volumes 
 Adjust initial  
counter value 
 
 Expensive 
0 
+1 0 
+1 
34</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
0 
+1 0  
 
 Introduces problems  
with far clipping plane 
 Solved by clamping the  
depth during clipping 
38 Questions?</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Today 
 Shadow Maps 
 Shadow Volumes 
 (The Stencil Buffer) 
 Deep Shadow Maps 
 Alias-free Shadow Maps 
54</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>1. Field of View Problem 
 What if point to 
shadow is outside 
field of view of 
shadow map? 
 Use 6 shadow maps 
on the faces of a cube 
 ... or use only  
spot lights  
13  Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Instead we need to filter the result of the shadow test 
(weighted average of comparison results) 3. Percentage Closer Filtering 
18 50.2 50.0 50.0
50.1 1.2 1.1
1.3 1.4 1.2XSurface at z = 49.8
Sample transform step&lt;49.8?
0.550 0 0
0 1 1
1 1 1Compare Filter
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Deep shadow map results 
 Advantage of deep shadow map over higher-
resolution normal shadow map:  
Pre-filtering for shadow antialiasing 
51 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Enables motion blur in shadows 
52 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Shadow Volumes Are Sort of Pass 
 The need to extract 
silhouette edges and 
rasterize the resulting 
shadow polygons is just 
too much work when 
scene complexities and 
image resolutions grow 
 Still, such use of the 
stencil buffer can be 
useful for other tricks ??? 
41  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>3. Percentage Closer Filtering 
 5x5 samples 
 Nice antialiased 
shadow 
 Using a bigger 
filter produces 
fake soft shadows 
 Setting bias  
is tricky 
20 Questions?</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Better Shadow Volumes 
 Shoot a ray from the eye to 
the visible point 
 Increment/decrement a 
counter each time we 
intersect a shadow  
volume polygon  
  
 If the counter  0, 
the point is  
in shadow +1 -1 
+1 
28</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Shadow Map Look Up 
 We have a 3D point (x,y,z)WS 
 How do we look up  
the depth from the  
shadow map? 
 
 Use the 4x4  
perspective projection  
matrix from the light  
source to get (x',y',z')LS 
 ShadowMap(x',y') &lt; z'? 
Foley et al. Computer Graphics Principles and 
Practice (x,y,z)WS (x',y',z')LS 
10  Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Visibility function along depth 
 Fraction of a pixel occluded, as a function of depth 
 Due to  
 small occluders, semi-transparent objects, smoke &amp; 
volumetric effects 
46 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837  Durand  Real-Time 
Shadows MIT EECS 6.837 
Computer Graphics 
 
Wojciech Matusik 
1 A cartoon has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Shadows in Production 
 Often use 
shadow maps 
 Ray casting as 
fallback in case 
of robustness 
issues 
21  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Content removed due to copyright restrictions -- please see slide 4,6-14 from Timo Aila and Samuli Laine's talk slides on "Alias-
Free Shadow Maps." available at https://research.nvidia.com/publication/alias-free-shadow-maps for further details.
56</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Why are Shadows Important? 
 Depth cue 
 Scene 
Lighting 
 Realism 
 Contact  
points Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Today 
 Shadow Maps 
 Shadow/View Duality  
 Texture Mapping 
 Shadow Volumes 
 Deep Shadow Maps 
 Alias-free Shadow Maps 
 
6</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Tag pixels in one rendering pass to 
control their update in subsequent 
rendering passes 
 "For all pixels in the frame buffer"  
"For all tagged pixels in the frame buffer" 
 Can specify different rendering 
operations for each case: 
 stencil test fails 
 stencil test passes &amp; depth test fails 
 stencil test passes &amp; depth test passes 
stencil buffer Stencil Buffer 
frame buffer 
depth buffer 
29</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Shadow in Ray Tracing 
5  Trace secondary (shadow) rays towards each 
light source 
 If the closest hit point is smaller than the 
distance to the light then the point is in shadow</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>If the Eye is in Shadow... 
 ... then a counter of 0 does 
not necessarily mean lit 
 3 Possible Solutions: 
1.  Explicitly test eye  
point with respect  
to all shadow volumes 
2.  Clip the shadow  
volumes to the  
view frustum 
3.  "Z-Fail" shadow  
volumes -1 
0 -1 
33</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>2. Clip the Shadow Volumes 
 Clip the shadow volumes to the view frustum 
and include these new polygons   
Messy CSG 
35</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Shadows as the Origin of Painting 
4  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.This image is in the public domain. Author: David Allan (!744- 1796).</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Deep shadow maps 
 Lokovic &amp; Veach, Pixar  
 Shadows in participating media like smoke, inside 
hair, etc. 
 They represent not 
just depth of the 
first occluding 
surface, but the 
attenuation 
along the light rays 
 Note: shadowing  
only, no scattering 
45  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Shadow Volumes 
 Explicitly represent the volume  
of space in shadow 
 For each polygon 
 Pyramid with point  
light as apex 
 Include polygon to cap 
 
25</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Alias-free shadow maps 
 Aila and Laine,  
http://www.tml.tkk.fi/~timo/  
 aka Irregular z-buffer by Johnson et al. 
http://pl887.pairlitesite.com/papers/tog05-izb/ 
 
 Following slides by Aila and Laine 
55</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>3. Shadow Map Aliasing 
 Under-sampling of the shadow map 
 Jagged shadow edges 
16</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>2. Bias (Epsilon) for Shadow Maps 
ShadowMap(x,y) + bias &lt; z 
Choosing a good bias value can be very tricky 
Correct image Not enough bias 
(surface acne) Way too much bias 
15</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Shadow Maps Are Important 
 Both in high-end production software... 
 Pixars RenderMan 
 ... and in real-time rendering (e.g. games) 
7  Pixar. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. source unknown. All rights reserved. This content is
excluded from our Creative Comm
ons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Clear frame, depth &amp; stencil buffers 
 Draw all non-mirror geometry to 
frame &amp; depth buffers 
 Draw mirror to stencil buffer, where 
depth buffer passes 
 Set depth to infinity, where stencil 
buffer passes 
 Draw reflected geometry to  
frame &amp; depth buffer, where  
stencil buffer passes 
See NVIDIA's stencil buffer tutorial 
http://developer.nvidia.com 
also discusses blending, multiple  
mirrors, objects behind mirror, etc Stencil Buffer  Real-time Mirror 
without  
stencil  
buffer: reflected 
geometry 
30  NVIDIA. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Today 
 Shadow Maps 
 Shadow Volumes 
 (The Stencil Buffer) 
 Deep Shadow Maps 
 Alias-free Shadow Maps 
 
24</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Further Reading on Shadows 
 Some recent techniques allow filtering the shadow 
map instead of just the tests (percentage closer) 
 Works pretty well in some situations, although not general 
Variance Shadow Maps (Donnelly, Lauritzen I3D 2006)  
 Convolution Shadow Maps 
Annen et al., SIGGRAPH 2008  
Annen et al., EGSR 2007  
 An interesting hybrid between 
shadow maps and ray tracing 
Aila and Laine, Alias-Free  
Shadow Maps, EGSR 200 4 
Annen et al. 2008 
43  ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Deep shadow map results 
49 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Deep shadow map results 
50 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>3. Percentage Closer Filtering 
 5x5 samples 
 Nice antialiased 
shadow 
 Using a bigger 
filter produces 
fake soft shadows 
 Setting bias  
is tricky 
19</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Initialize stencil buffer to 0 
Draw scene with ambient light only 
Turn off frame buffer &amp; z-buffer updates 
Draw front-facing shadow polygons 
If z-pass  increment counter 
Draw back-facing shadow polygons 
If z-pass  decrement counter 
Turn on frame buffer updates 
Turn on lighting and  
redraw pixels with  
counter = 0 Shadow Volumes w/ the Stencil Buffer  
0 
+2 +1 
31</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Today 
 Shadow Maps 
 Shadow Volumes 
 (The Stencil Buffer) 
 Deep Shadow Maps 
 Alias-free Shadow Maps 
44</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Deep shadow maps 
 Preprocess: 
Compute dense visibility function for each pixel of 
shadow map 
 send lots of rays or rasterize at a high resolution 
 compress visibility function at each pixel 
 to reduce memory cost 
 At render time, shadow query 
 Transform visible point into light coordinates 
 just like shadow maps 
 Read visibility value from compressed function 
47</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Shadow Map Look Up 
 We have a 3D point (x,y,z)WS 
 How do we look up  
the depth from the  
shadow map? 
 
 Use the 4x4  
perspective projection  
matrix from the light  
source to get (x',y',z')LS 
 ShadowMap(x',y') &lt; z'? 
Foley et al. Computer Graphics Principles and 
Practice (x,y,z)WS (x',y',z')LS 
11 Questions? 
 Addison-Wesley. All rights reserved. This content is excluded from our Creative 
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Shadows as a Depth Cue 
3  source unknown. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
Start at infinity 
 
... 
 
Draw front-facing shadow polygons 
If z-fail, decrement counter 
Draw back-facing shadow polygons 
If z-fail, increment counter 
 
...   
0 
+1 0 
36</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Irregular z buffer results 
57 A video clip demonstrating the irregular z buffer results has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Initialize stencil buffer to 0 
Draw scene with ambient light only 
Turn off frame buffer &amp; z-buffer updates 
Draw front-facing shadow polygons 
If z-pass  increment counter 
Draw back-facing shadow polygons 
If z-pass  decrement counter 
Turn on frame buffer updates 
Turn on lighting and  
redraw pixels with  
counter = 0 Shadow Volumes w/ the Stencil Buffer  
0 
+2 +1 
32 Questions?</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Optimizing Shadow Volumes 
 Use silhouette edges only  (edge where  
a back-facing &amp; front-facing polygon meet) 
39</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Shadow Volumes Are Sort of Pass 
 The need to extract 
silhouette edges and 
rasterize the resulting 
shadow polygons is just 
too much work when 
scene complexities and 
image resolutions grow 
 Shadow maps are bad, 
but theyre the best 
weve got! ??? 
42  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Enables motion blur in shadows 
53 
Questions?  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Shadow Volumes 
 If a point is inside a shadow  
volume cast by a particular light,  
the point does not receive any  
illumination from that light 
 
 Cost of naive  
implementation: 
 #polygons * #lights 
26</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Shadow/View Duality 
 A point is lit if it 
is visible from the 
light source 
 
 
 Shadow 
computation 
similar to view 
computation 
8</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Limitations of Shadow Maps 
1.Field of View 
2.Bias (Epsilon) 
3.Aliasing 
12  Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Thats All For Today! 
58 
Image: Laine  and Aila, EG 2005  Image removed due to cop
yright restrictions --  please see Fig. 4 in S. Laine and T. Aila, Hierarchical
Penumbra Casting. Computer Graphics Forum 24(3) ( Eurographics  2005) for further details.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Can be done with hardware texture mapping 
 Texture coordinates u,v,w generated using 4x4 matrix 
 Modern hardware permits tests on texture values 
Hardware Shadow Maps 
23 Questions?</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Can be done with hardware texture mapping 
 Texture coordinates u,v,w generated using 4x4 matrix 
 Modern hardware permits tests on texture values 
Hardware Shadow Maps 
22</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Shadow Volumes 
 If a point is inside a shadow  
volume cast by a particular light,  
the point does not receive any  
illumination from that light 
 
 Cost of naive  
implementation: 
 #polygons * #lights 
27 Questions?</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Should we filter the depth?   
(weighted average of neighboring depth values) 
 No...  filtering depth is not meaningful 3. Shadow Map Filtering 
17 50.2 50.0 50.0
50.1 1.2 1.122.9
1.3 1.4 1.2XSurface at z = 49.8
Ordinary texture map filtering. Does not work for depth maps.&lt;49.8?
1 Filter Compare
Image by MIT OpenCourseWare.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Bezier Curves and Splines (PDF)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec01/</lecture_pdf_url>
      <lectureno>01</lectureno>
      <slides>
        <slide>
          <slideno>27</slideno>
          <text>28 Questions?</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Tessellation 
t0 t1 t2 tn 
 
To display P(t),  
discretize it at discrete ts</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 Tessellation 
t0 t1 t2 tn 
Its clear that adding 
more points will get 
us closer to the 
curve.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Cubic Bernstein: 
 B1(t)=(1- t) 
 B2(t)=3t(1- t) 
 B3(t)=3t(1 -t) 
 B4(t)=t 
51 How You Get the Matrix 
Expand these out 
and collect powers of t. 
The coefficients are the entries 
in the matrix B!</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Cubic polynomials form a 4D vector space. 
 Bernstein basis is canonical for Bzier. 
 Can be seen as influence function of data points 
 Or data points are coordinates of the curve in the 
Bernstein basis 
 We can change between basis with matrices. 
54 Recap</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>4 control points 
 Curve passes through first &amp; last control point 
 Curve is tangent at P1 to (P1-P2) and at P4 to (P4-P3) 
27 Cubic Bzier Curve 
A Bzier curve is 
bounded by the 
convex hull  of its 
control points.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>A type of smooth curve 
in 2D/3D 
 Many different uses 
 2D illustration (e.g., Adobe Illustrator) 
 Fonts (e.g., PostScript, TrueType) 
 3D modeling 
 Animation: trajectories 
 In general: interpolation 
and approximation 
5 Splines 
ACM  1987 Principles of 
traditional animation applied to 3D 
computer animation 
 ACM. All rights reserved. This content is excluded from our
Creativ e
 Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 
Cubic Bzier Curve 
That is, 
 P(t) =  (1-t)  P1 
  + 3t(1- t)     P2  
  + 3t (1-t)      P3 
  + t          P4</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Interpolation 
 Goes through all specified points 
 Sounds more logical 
 
 Approximation 
 Does not go through all points 
20 Interpolation vs. Approximation 
Interpolation 
Approximation</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>For example: 
1,  1+t,  1+t+t2, 1+t-t2+t3 
t3,  t3+t2,  t3+t,  t3+1 
44 Matrix-Vector Notation 
Change-of-basis 
matrix Canonical 
monomial 
basis 
Not any matrix will do! 
If its singular, the basis 
set will be linearly 
dependent, i.e., 
redundant and 
incomplete.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Anything on your mind 
concerning Assignment 0? 
 Any questions about the course? 
 
 Assignment 1 (Curves &amp; Surfaces)  
 Linear algebra review session 
2 Before We Begin</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12Physical Splines 
See http://en.wikipedia.org/wiki/Flat_spline  Courtesy of The Antique Boat Museum.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Explanation 1: 
 Magic! 
 Explanation 2:  
 These are smart weights that describe the influence of 
each control point 
 Explanation 3: 
 It is a linear combination of  basis polynomials. 
The opposite perspective:  
control points are the weights of polynomials!!! 
 
33 Why Does the Formula Work?</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>For Bzier curves, the  
    basis polynomials/vectors 
    are Bernstein polynomials 
 
 For cubic Bezier curve: 
    B1(t)=(1- t) B2(t)=3t(1- t) 
    B3(t)=3t(1- t) B4(t)=t 
    (careful with indices, many authors start at 0) 
 Defined for any degree 
45 Bernstein Polynomials</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>P(t) = P1B1( t) + P2B2( t) + P3B3( t) + P4B4( t) 
 Pi are 2D points ( xi, yi) 
P(t) is a linear combination of the control points 
with weights equal to Bernstein polynomials at t 
 But at the same time, the control points  
(P1, P2, P3, P4) are the coordinates of the 
curve in the Bernstein basis 
 In this sense, specifying a Bzier curve with control 
points is exactly like specifying a 2D point with its x 
and y coordinates. 
47 Bzier Curves in Bernstein Basis</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>The two new curves are defined by 
P1, P1, P1, and P 
P, P2, P3, and P4 
 Together they exactly replicate the original 
curve! 
 Originally 4 control points, now 7 (more control) 
66 Result of Split in Middle 
P1 P2 
P1 
P P3 P2 
P4 
P1</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Specified by a few control points 
 Good for UI 
 Good for storage 
 
 Results in a smooth parametric curve P( t) 
 Just means that we specify x(t) and y(t) 
 In practice: low-order polynomials, chained together 
 Convenient for animation, where t is time 
 Convenient for tessellation because we can discretize 
t and approximate the curve with a polyline 
15 Splines</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Questions?</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 
Properties of Bernstein Polynomials 
          for all  0    t     1 
 Sum to 1 for every t 
 called partition of unity 
 These two together are the 
reason why Bzier curves  
lie within convex hull 
 B1(0) =1 
 Bezier curve interpolates P1 
 B4(1) =1 
 Bezier curve interpolates P4</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 How Many Dimensions? 
This curve lies on the 2D plane, 
but is itself 1D.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>User specifies control points 
 We will interpolate the control points 
by a smooth curve 
 The curve is completely 
determined by the control points. 
11 General Principle of Splines</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions?</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837  Matusik 6.837 Computer Graphics 
 
Bzier Curves and Splines 
Wojciech Matusik 
MIT CSAIL 
vectorportal.com</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Understand relationships between types of splines 
 Conversion 
 Express what happens when a spline curve is 
transformed by an affine transform  
(rotation, translation, etc.)  
 Cool simple example of non-trivial vector space 
 Important to understand for advanced methods 
such as finite elements 
34 Why Study Splines as Vector Space?</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>More precisely: 
Whats a basis? 
 
 A set of atomic vectors 
 Called basis vectors 
 Linear combinations of basis vectors span the space 
 i.e. any cubic polynomial is a sum of those basis cubics 
 Linearly independent 
 Means that no basis vector can be obtained from the 
others by linear combination 
 Example: i, j, i+j is not a basis (missing k direction!) 
40 Basis for Cubic Polynomials 
i j 
k In 3D</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Questions?</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>In 3D, each vector has three components x, y, z 
 But geometrically, each vector is actually the sum 
 
 
i, j, k  are basis vectors 
 
 Vector addition: just add components 
 Scalar multiplication: just multiply components 
35 Usual Vector Spaces 
i j 
k</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Actually works to construct a point at any t, not just 
0.5 
 Just subdivide the segments with ratio (1- t), t 
(not in the middle) 
68 De Casteljau Construction 
t 
t t t t 
t</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Two Definitions of a Curve 
 A continuous 1D set of points in 2D (or 3D) 
 A mapping from an interval S onto the plane  
 That is, P(t) is the point of the curve at parameter t 
 
 
 
 Big differences 
 It is easy to generate points on the curve from the 2nd 
 The second definition can describe trajectories, the 
speed at which we move on the curve</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Given B1...B4, how to get back 
to canonical 1, t, t, t ? 
53 
Change of Basis, Other Direction 
Thats right, with the inverse matrix!</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Questions?</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Demo</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Tessellation 
t0 t1 t2 tn 
Its clear that adding 
more points will get 
us closer to the 
curve.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Take the middle point of each of the 3 segments 
 Construct the two segments joining them 
 Take the middle of those two new segments 
 Join them  
 Take the middle point P 
65 De Casteljau Construction 
P1 P2 
P1 
P P3 P2</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56 More Matrix-Vector Notation 
matrix of 
control points (2 x 4) Bernstein polynomials 
(4x1 vector) 
point on curve 
(2x1 vector)</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Bezier curves: piecewise polynomials 
 Bernstein polynomials 
 Linear combination of basis functions 
 Basis: control points  weights: polynomials 
 Basis: polynomials  weights: control points  
 Subdivision by de Casteljau algorithm 
 All linear, matrix algebra 
 
69 Recap</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Interpolation 
 Goes through all specified points 
 Sounds more logical 
 But can be more unstable 
 Approximation 
 Does not go through all points 
 Turns out to be convenient 
 
 We will do something  
in between. 
21 Interpolation vs. Approximation 
Interpolation 
Approximation</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Cubic Bzier Curve 
Verify what happens  
for t=0 and t=1  P(t) =  (1-t)  P1 
  + 3t(1- t)     P2  
  + 3t (1-t)      P3 
  + t          P4</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>4 control points 
 Curve passes through first &amp; last control point 
26 Cubic Bzier Curve 
Courtesy of Seth Teller. 
Used with permission.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>For example: 
 {1,  1+t,  1+t+t2 , 1+t-t2+t3 } 
 {t3,  t3+t2 ,  t3+t,  t3+1} 
 
 
 These can all be obtained from 
by linear combination 
 Infinite number of possibilities, just like you have 
an infinite number of bases to span R2 
42 Different Basis  
2D examples</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Can we split a Bezier curve in the middle into 
two Bzier curves? 
 The resulting curves are again a cubic 
(Why? A cubic in t is also a cubic in 2 t) 
 Hence it must be representable using the Bernstein 
basis. So yes, we can! 
64 Subdivision of a Bezier Curve 
? 
t=1 t=0.5 t=0 t2=2t-0.5 t1=2t 
cubic</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>The plane where the curve lies, a 2D vector space  
 The space of cubic polynomials, a 4D space 
 Dont be confused! 
 The 2D control points can be replaced by 3D 
points  this yields space curves. 
 The math stays the same, just add z(t). 
 The cubic basis can be extended to higher-order 
polynomials 
 Higher-dimensional vector space 
 More control points 
48 Two Different Vector Spaces!!!</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>55 Questions?</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Questions?</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>How do we go from Bernstein basis  
to the canonical monomial basis  
1, t, t, t and back? 
 With a matrix! 
50 Change of Basis 
New basis vectors 
 B1(t)=(1-t)  
 B2(t)=3t(1- t) 
 B3(t)=3t (1-t) 
 B4(t)=t</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Geometry: control points coordinates assembled 
into a matrix (P1, P2, , Pn+1) 
 Spline matrix: defines the type of spline 
 Bernstein for Bzier  
 Power basis:  the monomials (1, t, ..., tn) 
 Advantage of general formulation 
 Compact expression 
 Easy to convert between types of splines 
 Dimensionality (plane or space) does not really matter 
59 General Spline Formulation</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 How Many Dimensions? 
This curve lies on 
the 2D plane, 
but is itself 1D. You can just as well 
define 1D curves in 
3D space.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Can we split a Bezier curve in the middle into 
two Bzier curves? 
 This is useful for adding detail  
 It avoids using nasty higher-order curves 
63 Subdivision of a Bezier Curve 
?</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Bezier curves: piecewise polynomials 
 Bernstein polynomials 
 Linear combination of basis functions 
 Basis: control points  weights: polynomials 
 Basis: polynomials  weights: control points  
 Subdivision by de Casteljau algorithm 
 All linear, matrix algebra 
 
70 Recap</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Smooth curves in 2D 
 Useful in their own right 
 Provides basis for surface 
editing 
3 Today 
This image is in the public domain
Source: Wikimedia Commons</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>57 Flashback</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 6.837  Durand Tessellation 
 It is easy to rasterize mathematical line segments 
into pixels 
 OpenGL and the graphics hardware can do it for you 
 But polynomials and other parametric functions 
are harder  
Image courtesy of Phrood on Wikimedia Commons. License: CC- BY-SA.This content is excluded from our
Creative Commons license. For moreinformation, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>P(t) is a weighted 
combination of the 4 
control points with 
weights: 
 B1(t)=(1- t) 
 B2(t)=3t(1- t) 
 B3(t)=3t(1- t) 
 B4(t)=t 
 First, P1 is the most 
influential point, 
then P2, P3, and P4 
 30 Weights  
P(t) =  (1-t)  P1 
 + 3t(1- t)   P2  
 + 3t(1 -t)  P3 
 + t  P4</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>For example: 
1,  1+t,  1+t+t, 1+t-t+t  
t,  t+t,  t+t,  t+1 
43Matrix-Vector Notation 
Change-of-basis 
matrix Canonical 
monomial 
basis 
These 
relationships 
hold for each 
value of t</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>58 Cubic Bzier in Matrix Notation 
point on curve 
(2x1 vector) 
Geometry matrix 
of control points P1..P4 
(2 x 4) Spline matrix 
(Bernstein) Canonical 
monomial basis</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Questions?</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 How Many Dimensions?</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>What if you want more control? 
61 A Cubic Only Gets You So Far</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Polynomials 
  
 
 
 In the polynomial vector space, {1, t, ..., tn} are 
the basis vectors, a0, a1, ..., an are the 
components 
37 Polynomials as a Vector Space</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Any cubic polynomial is a 
linear combination of these: 
a0+a1t+a2t2+a3t3 = a0*1+ a1*t+a2*t2+a3*t3 
 
 They are linearly independent 
 Means you cannot write any of the four monomials as 
a linear combination of the others. (You can try.) 
41 Canonical Basis for Cubics 
1 
t 
t2 
t3</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Explanation 1: 
 Magic! 
 Explanation 2:  
 These are smart weights that describe the influence of 
each control point 
 Explanation 3: 
 It is a linear combination of  basis polynomials. 
29 Why Does the Formula Work?</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Do we actually get the middle point? 
 B1(t)=(1-t)  
 B2(t)=3t(1- t) 
 B3(t)=3t(1 -t) 
 B4(t)=t 
67 Sanity Check 
 P1 P2 
P1 
P P3 P2</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&gt; 4 control points 
 Bernstein Polynomials as the basis functions 
 For polynomial of order n, the ith basis function is  
 
 
 
 Every control point affects the entire curve  
 Not simply a local effect  
 More difficult to control for modeling 
You will not need this in this class 
62 Higher-Order Bzier Curves 
Courtesy of Seth Teller.  Used with 
permission.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Closed under addition &amp; scalar multiplication 
 Means the result is still a cubic polynomial (verify!) 
 Cubic polynomials also compose a vector space 
 A 4D subspace  of the full space of polynomials 
 The x and y coordinates of cubic Bzier curves 
belong to this subspace as functions of t. 
39 Subset of Polynomials: Cubic</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>P2 and P3 never have full 
influence 
 Not interpolated! 
31 Weights 
P(t) =  (1-t)  P1 
 + 3t(1- t)   P2  
 + 3t(1 -t)  P3 
 + t  P4</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Polylines 
 Sequence of vertices connected 
by straight line segments 
 Useful, but not for smooth curves 
 This is the representation 
that usually gets drawn in the end 
(a curve is converted into a polyline) 
Smooth curves 
 How do we specify them? 
 A little harder (but not too much) 
4 Modeling 1D Curves in 2D</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Given B1...B4, how to get back 
to canonical 1, t, t, t ? 
52 Change of Basis, Other Direction</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Polynomials 
 Can be added: just add the coefficients 
 
 
 
 Can be multiplied by a scalar: multiply the 
coefficients 
36 Polynomials as a Vector Space</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>User specifies 4 control points P1 ... P4 
 Curve goes through (interpolates) the ends P1, P4 
 Approximates the two other ones 
 Cubic polynomial 
23 Cubic Bzier Curve</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Hierarchical Modeling (PDF - 2.1MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec04/</lecture_pdf_url>
      <lectureno>04</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>Normal  
Surface Normal:  unit vector that is locally 
perpendicular to the surface  
6</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Adding Transformations  
36</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Frames &amp; transformations  
Transformation S wrt car frame f  
 
how is the world frame a affected by this?  
we have  
which gives  
 
i.e. the transformation in a is A -1SA 
i.e., from right to left, A takes us from a to f, then 
we apply S, then we go back to a with A -1 
3</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
58</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Further Reading  
Buss, Chapter 2 
 
Other Cool Stuff  
Algebraic Groups  
http://phototour.cs.washington.edu / 
http://phototour.cs.washington.edu/findingpaths/  
Free-form deformation of solid objects  
Harmonic coordinates for character articulation  
19</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Articulated Models  
Articulated models  are rigid parts connected by joints  
each joint has some angular degrees of freedom  
 
Articulated models can be animated by specifying the joint 
angles as functions of time.  
74</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Traversal State  
The state is updated during traversal  
Transformations  
But also other properties (color, etc.)  
Apply when entering node, undo when leaving  
 
How to implement?  
Bad idea to undo transformation by inverse matrix (Why?)  
61</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = I 
56</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Text format is fictitious, better to use XML in real applications  
33 Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Why is the Normal important?  
It's used for shading  makes things look 3D! 
object color only  Diffuse Shading  
7</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
53</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Recap  
Vectors can be expressed in a basis  
Keep track of basis with left notation  
Change basis  
Points can be expressed in a frame  
(origin+basis)  
Keep track of frame with left notation  
adds a dummy 4th coordinate always 1 
2</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Scene Graph Traversal  
How to handle transformations?  
Traversal algorithm keeps a transformation state S (a 4x4 matrix)  
from world coordinates  
Initialized to identity in the beginning  
Geometry nodes always drawn using current S  
When visiting a transformation node T: 
multiply current state S with T, 
then visit child nodes  
Has the effect that nodes below  
will have new transformation  
When all children have been  
visited, undo the effect of T!  
39</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Inverse Kinematics  
vs 
w 
85 Forward Kinematics  
Given the skeleton parameters p (position of the root and the joint 
angles) and the position of the point in local coordinates vs, what is 
the position of the point in the world coordinates vw? 
Not too hard, just apply transform accumulated from the root.  
 
 
Inverse Kinematics  
Given the current position of the point                                             
and the desired new position      in                                                     
world coordinates, what are the skeleton                                          
parameters p that take the point to the                                        
desired position?</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
50</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
49</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>6.837 -  Durand  Forward Kinematics  
vs vs 
parameter vector p This product is S Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
Note that the angles have a non -linear effect.  
81</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
46</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
51</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Digression  
 
 
The previous proof is not quite rigorous; first 
youd need to prove that tangents indeed 
transform with M. 
-Turns out they do, but well take it on faith here.  
-If you believe that, then the above formula follows .  nWS = (M) nOS 
16</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
57</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
47</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Draw by Traversing a Tree  
 
 
 
 
 
 
 
 
Assumes drawing procedures 
for thigh, calf, and foot use 
joint positions as the origin for 
a drawing coordinate frame  hips 
r-thigh 
r-calf 
r-foot left-leg ... glLoadIdentity();  
glPushMatrix();  
  glTranslatef();  
  glRotate();  
  drawHips();  
  glPushMatrix();  
    glTranslate();  
 glRotate();  
 drawThigh();  
 glTranslate();  
 glRotate();  
 drawCalf();  
 glTranslate();  
 glRotate();  
 drawFoot();  
  glPopMatrix();  
      left-leg 
77</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = I 
44</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
45</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Scene Graph Traversal  
Depth first recursion  
Visit node, then visit subtrees (top to bottom, left to right)  
When visiting a geometry node: Draw it!  
 
How to handle transformations?  
Remember, transformations are always specified  
in coordinate system of the parent  
38</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Hierarchical models  
22 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Example: Style -Based IK  
Video  
 
Prior on good pose  
 
Link to paper: Grochow, Martin, Hertzmann, Popovic: Style -Based 
Inverse Kinematics, ACM SIGGRAPH 2004 
89</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Inverse Kinematics  
Context: an animator wants to pose a character  
Specifying every single angle is tedious and not intuitive  
Simpler interface:  
directly manipulate position of e.g. hands and feet  
That is, specify vw, infer joint transformations  
vs 
83</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Comment  
So the correct way to transform normals is:  
 
But why did  nWS = M nOS work for similitudes?  
Because for similitude / similarity transforms,  
(M) = M 
e.g. for orthonormal basis:  
 
                   M = M      i.e.  ( M) = M 
  nWS = (M) nOS Sometimes denoted M  
17</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Some slides from BarbCutler &amp; 
Jaakko Lehtinen  Wojciech Matusik, MIT EECS  
1 6.837 Computer Graphics  
Hierarchical Modeling  
Image courtesy of BrokenSphere  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>More Normal Visualizations  
Incorrect Normal Transformation  Correct Normal Transformation  
13</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Hierarchical models  
23 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
48</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Plan 
Hierarchical Modeling, Scene Graph  
OpenGL matrix stack  
Hierarchical modeling and animation of characters  
Forward and inverse kinematics  
72</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Scene Graph Representation  
30 Basic idea: Tree  
Comprised of several node types  
Shape: 3D geometric objects  
Transform: Affect current transformation  
Property: Color, texture  
Group: Collection of subgraphs  
 
 
C++ implementation  
base class Object  
children, parent  
derived classes for each                                
node type (group, transform)</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>More Specifically...  
An OpenGL transformation call corresponds to a matrix T 
The call multiplies current modelview matrix C by T from the 
right, i.e. C = C * T. 
This also works for projection, but you often set it up only once.  
 
This means that the transformation for the subsequent 
vertices will be p = C * T * p 
Vertices are column vectors on the right in OpenGL  
This implements hierarchical transformation directly!  
69</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Connections  
Not part of class, but cool  
Covariant: transformed by the matrix  
e.g., tangent  
Contravariant: transformed by the inverse transpose  
e.g., the normal  
a normal is a co -vector  
 
Google differential geometry to find out more  
18</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
55</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Traversal State  
The state is updated during traversal  
Transformations  
But also other properties (color, etc.)  
Apply when entering node, undo when leaving  
 
How to implement?  
Bad idea to undo transformation by inverse matrix  
Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix  you accumulate error  
Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane  no way to undo, inverse doesnt exist!  
Can you think of a data structure suited for this?  
63</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Hierarchical Grouping of Objects  
The scene graph represents  
the logical organization of scene  
6.837 -  Durand  
chair table 
table fruits ground  scene  
28</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Text format is fictitious, better to use XML in real applications  
32 Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }  
Here we have only simple shapes, but easy to add a Mesh 
node whose parameters specify an .OBJ to load (say)  
34</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Recap: Scene Graph Traversal  
How to handle transformations?  
Traversal algorithm keeps a transformation state S (a 4x4 matrix)  
from world coordinates  
Initialized to identity in the beginning  
Geometry nodes always drawn using current S  
When visiting a transformation node T: 
multiply current state S with T, 
then visit child nodes  
Has the effect that nodes below  
will have new transformation  
When all children have been  
visited, undo the effect of T!  
42</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Hierarchical Modeling  
Triangles, parametric curves and surfaces 
are the building blocks from which more 
complex real -world objects are modeled.  
 
Hierarchical modeling creates complex real -
world objects by combining simple primitive 
shapes into more complex aggregate 
objects.  
21 
Image courtesy of Nostalgic dave on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
54</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Hierarchical models  
25 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>How to tackle these problems?  
Deal with non -linearity:  
Iterative solution (steepest descent)  
Compute Jacobian matrix of world position w.r.t. angles  
Jacobian: If the parameters p change by tiny amounts, what is the resulting 
change in the world position vWS? 
Then invert Jacobian.  
This says if vWS changes by a tiny amount, what is the change in the 
parameters p? 
But wait! The Jacobian is non -invertible ( 3xN) 
Deal with ill -posedness: Pseudo -inverse  
Solution that displaces things the least  
See http://en.wikipedia.org/wiki/Moore -Penrose_pseudoinverse  
Deal with ill -posedness: Prior on good pose (more advanced)  
Additional potential issues: bounds on joint angles, etc.  
Do not want elbows to bend past 90 degrees, etc.  
 
88</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Question?  
20</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Questions?  
Further reading on OpenGL  
Matrix Stack and hierarchical model/view transforms  
http://www.glprogramming.com/red/chapter 03.html 
 
It can be a little confusing if you dont think the previous 
through, but its really quite simple in the end.  
I know very capable people who after 15 years of experience still 
resort to brute force (trying all the combinations) for getting their 
transformations right, but its such a waste :)  
71</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Frames and hierarchy  
Matrix M1 to go from world to torso  
Matrix M2 to go from torso to arm  
 
How do you go from arm coordinates to world?  
 
 
 
 
We can concatenate the matrices  
Matrices for the lower hierarchy nodes go to the right  
41</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Adding Attributes (Material, etc.)  
Group {   
    numObjects 3 
    Material { &lt;BLUE&gt; }  
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Material { &lt;BROWN&gt; }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Material { &lt;GREEN&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Material { &lt;RED&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Material { &lt;ORANGE&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
            Material { &lt;BLACK&gt; }  
    Plane { &lt;PLANE PARAMS&gt; } }  
35</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
 
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Hierarchical models  
26 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Transform Normal like Object?  
translation?  
rotation?  
isotropic scale?  
scale?  
reflection?  
shear?  
perspective?  
11</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Animation  
Hierarchical structure is essential for 
animation  
Eyes move with head  
Hands move with arms  
Feet move with legs  
 
 
Without such structure the model falls apart.  
73</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Forward Kinematics  
vs vs 
How to determine the world -space 
position for point vs? 
78</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Forward Kinematics  
vs vs Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
79</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>More Specifically...  
An OpenGL transformation call corresponds to a matrix T 
The call multiplies current modelview matrix C by T from the 
right, i.e. C = C * T. 
This also works for projection, but you often set it up only once.  
 
This means that the transformation for the subsequent 
vertices will be p = C * T * p 
Vertices are column vectors on the right in OpenGL  
This implements hierarchical transformation directly!  
 
At the beginning of the frame, initialize the current matrix by 
the viewing transform that maps from world space to view 
space.  
For instance, glLoadIdentity() followed by gluLookAt()  
70</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Transformation for shear and scale  
Incorrect 
Normal 
Transformation  
Correct 
Normal 
Transformation  
12</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Traversal State  
The state is updated during traversal  
Transformations  
But also other properties (color, etc.)  
Apply when entering node, undo when leaving  
 
How to implement?  
Bad idea to undo transformation by inverse matrix  
Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix  you accumulate error  
Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane  no way to undo, inverse doesnt exist!  
62</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Hierarchical models  
27 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Forward Kinematics  
vs vs 
This product is S Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
Note that the angles have a non -linear effect.  
80</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>When You Encounter a Transform Node  
Push the current transform using glPushMatrix()  
Multiply current transform by nodes transformation  
Use glMultMatrix(), glTranslate(), glRotate(), glScale(), etc.  
Traverse the subtree  
Issue draw calls for geometry nodes  
Use glPopMatrix() when done.  
 
 
Simple as that!  
 
68</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Transform Normal like Object?  
translation?  
rotation?  
isotropic scale?  
scale?  
reflection?  
shear?  
perspective?  
10</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Recall frames  
An object frame has coordinates O in the world  
(of course O is also our 4x4 matrix)  
 
 
Then we are given coordinates c in the object frame  
 
 
 
Indeed we need to apply matrix O to all objects  
40</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
60 At each node, the current object -to-world transformation is the 
matrix product of all transformations found on the way from the 
node to the root.  
S = T1R1</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Joints and bones  
Describes the positions of the  
body parts as a function of joint angles.  
Body parts are usually called bones  
 
Each joint is characterized by its degrees of freedom (dof)  
Usually rotation for articulated bodies  
1 DOF: knee  2 DOF: wrist  3 DOF: arm  
75</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Mesh-Based Inverse Kinematics 
Video 
 
Doesnt even need a hierarchy or skeleton: Figure proper 
transformations out based on a few example deformations! 
 
Link to paper: 
Sumner, Zwicker, Gotsman, Popovic: Mesh-Based Inverse Kinematics, 
ACM SIGGRAPH 2005 
90</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Inverse Kinematics  
Forward Kinematics  
Given the skeleton parameters p (position of the root and the joint 
angles) and the position of the point in local coordinates vs, what is 
the position of the point in the world coordinates vw? 
Not too hard, just apply transform accumulated from the root.  
vs 
84</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Traversal State  Stack  
The state is updated during traversal  
Transformations  
But also other properties (color, etc.)  
Apply when entering node, undo when leaving  
 
How to implement?  
Bad idea to undo transformation by inverse matrix  
Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix  you accumulate error  
Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane  no way to undo, inverse doesnt exist!  
 
Solution: Keep state variables in a stack  
Push current state when entering node, update current state 
Pop stack when leaving state -changing node  
See what the stack looks like in the previous example!  64</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Think about transforming the tangent plane   
to the normal, not the normal vector  So how do we do it right?  
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane,  
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS 
14</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
52</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Questions?  
82</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
59 .....</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Hierarchical Modeling in OpenGL  
The OpenGL Matrix Stack implements what we just did!  
 
Commands to change current transformation  
glTranslate, glScale, etc.  
Current transformation is part of the OpenGL state, i.e., all 
following draw calls will undergo the new transformation  
Remember, a transform affects the whole subtree  
Functions to maintain a matrix stack  
glPushMatrix, glPopMatrix  
Separate stacks for modelview (object -to-view)  
and projection matrices  
67</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Homogeneous Visualization  
Divide by w to normalize (project)  
w = 0?   
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) =  
(7, 1, 1) = (14, 2, 2) =  
(4, 5, 1) = (8, 10, 2) =  (0,0,0) 
4</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Scene Graph Representation  
Group  Trsfrm  Trsfrm  Trsfrm  Trsfrm  Group  
31 In fact, generalization of a tree: Directed Acyclic Graph (DAG)  
Means a node can have multiple parents, but cycles are not allowed  
Why? Allows multiple instantiations  
Reuse complex hierarchies many times in the scene using different 
transformations (example: a tree)  
Of course, if you only want to reuse meshes, just load the mesh once and make 
several geometry nodes point to the same data</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Plan 
Hierarchical Modeling, Scene Graph  
OpenGL matrix stack  
Hierarchical modeling and animation of characters  
Forward and inverse kinematics  
66</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Inverse Kinematics  
skeleton parameter vector p w 
86 Given the position of the point in local coordinates vs and 
the desired position      in world coordinates, what are the 
skeleton parameters p? 
 
 
 
 
 
Requires solving for p, given vs and  
Non-linear and</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>How do we transform normals?  
Object Space  World Space  nOS nWS 
9</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Visualization of Surface Normal  
    x = Red  
 y = Green  
 z = Blue  
8</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Different objects  
Points  
represent locations  
Vectors  
represent movement, force, displacement from A to B  
Normals  
represent orientation, unit length  
Coordinates  
numerical representation of the above objects  
in a given coordinate system  
5</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Its Underconstrained  
Count degrees of freedom:  
We specify one 3D point ( 3 equations)  
We usually need more than 3 angles  
p usually has tens of dimensions  
 
Simple geometric example (in 3D): 
specify hand position, need elbow &amp; shoulder  
The set of possible elbow location is a circle in 3D  vs vs 
87</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
43</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Hierarchical models  
24 
Image courtesy of David Baina, Kamil Dudka, Jakub Filk, Luk Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Questions?  
37</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Questions?  
65</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Skeleton Hierarchy  
Each bone position/orientation described 
relative to the parent in the hierarchy:  
hips 
r-thigh 
r-calf 
r-foot left-leg ... 
vs y 
x 
z For the root, the 
parameters 
include a position 
as well  
Joints are 
specified by 
angles.  
76</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Thats All for Today!  
Further reading 
OpenGL Matrix Stack and 
hierarchical model/view transforms 
http://www.glprogramming.com/red/c
hapter 03.html 
Image courtesy of BrokenSphere  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.91</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Transform tangent vector v 
v is perpendicular to normal n: 
nOS vOS  =  0 
 nOS  (M    M)  vOS  =  0 
 nWS =  nOS (M  )  (nOS  M  )  (M    vOS)  =  0 
 (nOS  M  )  vWS  =  0 
 nWS vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M  ) nOS nOS 
vWS nWS vOS Dot product  
15</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Introduction and Course Overview (PDF - 2.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec00/</lecture_pdf_url>
      <lectureno>00</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>Pixar Animation Studios, 1986 
 Director: John Lasseter 
2 Luxo Jr. 
Image of Pixar's Luxo Jr. removed due to copyright restrictions -- please see
http://www.computerhistory.org/atchm/pixars-luxo-jr/ for further details.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Animation: Keyframing 
ACM  1987 Principles of traditional animation 
applied to 3D computer animation  
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Vertices are 3-vectors 
 Normals are 3-vectors 
 Orthogonal to surface tangent plane 
 Cross product 
 Colors are 3-vectors 
 Diffuse shading is a dot product 
 A non-bending object moving in a scene 
undergoes a rigid transformation 
 Changing the viewpoint is a linear transformation 
of the scene coordinate 
 Brush up in the review session! 
80 Linear Algebra is Everywhere</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Questions?</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>47
Ray Casting 
 For every pixel  
construct a ray from the eye  
 For every object in the scene 
 Find intersection with the ray  
 Keep if closest</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Initialize  
(get graphics context, etc.) 
For each frame 
Manage UI 
Set appropriate viewpoint 
Set light source directions 
For each triangle  
 For i=0 to 2 
 Send vertex data  
71 OpenGL high-level pseudocode</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Many of the mathematical and algorithmic tools 
are useful in other engineering and scientific 
context 
 Linear algebra 
 Splines 
 Differential equations 
 Monte-Carlo integration 
  
22 Beyond computer graphics</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 The deadline is absolute 
 I mean it.  
 I do regularly give 0 for, 
  an assignment turned in half an hour late 
 turning in the wrong file 
  Submit early, even before you might be fully 
done</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41Modeling 
 Curves and surfaces 
 Subdivision surfaces</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>62Assignment 4: ray casting 
 Cast rays from the viewpoint 
 Intersect with scene primitives</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56The Graphics Pipeline 
 Transformations 
 
 Clipping 
 
 Rasterization 
 
 Visibility</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60Assignment 2: hierarchical modeling 
 Animate character skeleton  
as tree of transformations 
 
 
 
 Skinning: smooth surface deformation</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Video Games 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 How do you make this picture? 
 Modeling 
 Geometry 
 Materials 
 Lights 
 Animation 
 Make it move 
 Rendering 
 I.e., draw the picture! 
 Lighting, shadows, textures... Semester 
 Remedy Enterainment . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Medical Imaging 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>57Questions?</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>76 OpenGL high-level pseudocode 
Initialize  
(get graphics context, etc.) 
For each frame 
Manage UI 
Set appropriate viewpoint 
Set light source directions 
For each triangle  
 For i=0 to 2 
 Send vertex data</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Video removed due to copyright restrictions --  please see "The Light of Mies van der Rohe "
for further details, available at http://graphics.ucsd.edu/~henrik/animations/.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>And why? 
18 What do you expect to learn?</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38Questions?</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 OpenGL Code 
glBegin(GL_TRIANGLES); //what follows describes triangles 
glColor3d (1,1,0); //red, green and blue components=&gt;(yellow)   
glNormal3d (0, 0, 1); //normal pointing up 
glVertex3d (2,3,3); //3D position x, y, z 
glColor3d (1,0,0); 
glNormal3d (0, 0, 1);  
glVertex3d (5,3,3);  
glColor3d (1,0,1); 
glNormal3d (0, 0, 1);  
glVertex3d (3,6,3);  
glEnd();</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Fundamentals of computer graphics algorithms 
 Will give a pretty good idea of how to implement lots 
of the things just shown 
 We will concentrate on 3D, 
not 2D illustration or image processing 
 Basics of real-time rendering 
and graphics hardware 
 Basic OpenGL 
 Not the focus, though: Means, not the end. 
 You will get C++ programming experience 
19 What you will learn in 6.837</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>To compute color as a function of light direction 
 Simplest: Diffuse or Lambert model 
 Intensity = dot product (normal, light direction) 
74 Why normals? 
Surface 
Normal 
Light direction Light 
source</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39Overview of the Semester 
 Modeling, Transformations 
 Animation, Color 
 Ray Casting / Ray Tracing 
 The Graphics Pipeline 
 Textures, Shadows 
 Sampling, Global Illumination</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>54 Global Illumination 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 OpenGL Example: Viewing 
// Current matrix affects objects positions  
glMatrixMode( GL_MODELVIEW ); 
// Initialize to the identity 
glLoadIdentity();               
// Position the camera at [0,0,5], looking at 
// [0,0,0], with [0,1,0] as the up direction. 
gluLookAt(0.0, 0.0, 5.0, 
          0.0, 0.0, 0.0, 
          0.0, 1.0, 0.0); 
// Rotate by -20 degrees about [0,1,0] 
glRotated(-20.0, 0.0, 1.0, 0.0); 
     
// Draw a teapot. 
glutSolidTeapot(1.0);</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Overview of computer graphics 
Administrivia 
 Overview of the semester 
 Overview of assignments 
 Intro to OpenGL &amp; assignment 0 
 
24 Plan</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45Physics (ODEs) 
 Fire, smoke 
 Cloth 
 
 Quotes because 
we do visual 
simulation 
 David E. Breen. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64Questions?</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>55The Graphics Pipeline 
Ray Casting 
 
For each pixel 
For each object 
 Send pixels to scene Rendering Pipeline 
 
For each triangle 
   For each projected pixel 
     Project scene to pixels</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Course website 
 Announcements 
 Slides (posted soon after each lecture) 
 Assignments, both instructions and turn- in 
 Message Board 
 Staff Email 
 Reaches all of us, preferred method of communication 
26 Administrivia: Website, Staff Email</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Character Animation: Skinning 
 Animate simple skeleton 
 Attach skin to skeleton 
 Skin deforms smoothly with skeleton  
 Used everywhere (games, movies) 
43Image removed due to 
copyright restrictions. 
Ilya Baran 
 Ilya Baran . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46Color 
saturation 
hue 
Courtesy of Victor Ostromoukhov.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Overview of computer graphics 
 Administrivia 
Overview of the semester 
 Overview of assignments 
 Intro to OpenGL &amp; assignment 0 
 
36 Plan</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 CAD-CAM &amp; Design 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67Assignment 0 
 Read a file with triangle mesh data 
 Including mesh normals 
 Display it using OpenGL 
 Colors, simple movement 
 
 Due next Wednesday!</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Geographic Info Systems &amp; GPS 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Virtual Reality 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Lots of simple linear algebra 
 Get it right, it will help you a lot! 
 Some more advanced concepts 
 Homogeneous coordinates 
 Ordinary differential equations (ODEs) 
and their numerical solution 
 Sampling, antialiasing (some gentle Fourier analysis) 
 Monte-Carlo integration 
 Always in a concrete and visual context 
21 How much Math?</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>OpenGL is an API that allows you to send 
commands to the graphics card to draw 2D or 3D 
scenes 
 At the beginning of the semester, we will use 
OpenGL as a black box to display 3D content 
 Later, we will see what is under the hood 
66Simple 3D with OpenGL</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Ray Tracing 
 Original Ray-traced 
image by Whitted 
 
 
 
 
 Image computed using 
the Dali ray tracer by 
Henrik Wann Jensen 
 Environment map by 
Paul Debevec 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Simulation 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4 What are the applications of graphics?</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40Transformations 
 Yep, good old linear algebra 
 Homogeneous coordinates 
 (Adding dimensions to make life harder) 
 Perspective</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Overview of computer graphics 
 Administrivia 
 Overview of the semester 
 Overview of assignments 
 Intro to OpenGL &amp; assignment 0 
 
3 Plan</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61Assignment 3: physics 
 Simulate cloth as a mass-spring network 
 ODE integration</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 More than you would expect 
 
 
Video clip removed due to copyright restrictions -- please
see http://vimeo.com/9553622 for further details.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15 Education 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Simple 3D with OpenGL 
68 Scene represented as 
triangles 
 A triangle is a set of 3 vertices 
 A vertex is a set of 3 floating 
point numbers (x, y, z) 
 We will use OpenGL to send 
this to the graphics card 
(GPU) 
 The GPU will do its magic to 
display the scene from the 
current viewpoint (Later, we 
will get to see how this 
happens)</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Overview of computer graphics 
 Administrivia 
 Overview of the semester 
 Overview of assignments 
Intro to OpenGL &amp; assignment 0 
 
65Plan</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Shadows 
 Shininess 
 Texture 
 Etc.  
 
 Be patient, you will have plenty enough 
79 What is missing?</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Movies/special effects 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Administrivia: Grading Policy 
 Assignments: 75% 
 Two-week programming assignments 
 Must be completed individually 
No final project 
 Quiz: 10% 
 in class  
 Final Exam: 10% 
 TBA during finals week 
 Participation: 5%</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Traditional Ray Tracing 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Shadows, reflection, refraction 
 
 + flexible extension 
63Assignment 5: ray tracing</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Overview of computer graphics 
 Administrivia 
 Overview of the semester 
Overview of assignments 
 Intro to OpenGL &amp; assignment 0 
 
58Plan</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44Particle system (PDE) 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52Shadows 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837  Durand  
Welcome to 
6.837 Computer Graphics 
 
Wojciech Matusik 
MIT CSAIL 
Picture: Alexis Rufatt 
Image courtesy of Nicolas Desprez on Wikipedia. License: CC-BY -SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Assignments 
0: Warm up (mesh display with OpenGL) 
1: Curves &amp; surfaces 
2: Hierarchical modeling, skinning 
3: Physically-based simulation 
4: Ray casting 
5: Ray tracing 
 
(more in later slides)</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Questions?</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Assignment 0 
 Read a file with triangle mesh data 
 Including mesh normals 
 Display it using OpenGL 
 Colors, simple movement 
 
 Due next Wednesday!</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>You need to tell OpenGL 
 The geometry of the object 
 Vertex positions 
 Vertex normals 
 3 x vertex makes a triangle! 
 Camera parameters 
 Field of view, aspect ratio, (depth range) 
 The projection matrix How to Draw? 
69Object coordinates 
World coordinates 
View coordinates 
Image coordinates Modelview 
Projection</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59Assignment 1: curves &amp; surfaces 
Bezier curves Surfaces of revolution 
Sweep surfaces</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Very interdisciplinary 
 Within CS: systems, compilers, 
languages, computer architecture, 
algorithms, numerical techniques 
 Math, physics, art, perception, 
architecture, manufacturing 
 Helps you understand why the 
world looks the way it does 
 You can see the result 
81
What Makes Graphics Fun? 
visualparadox.com Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>What information do we need at each vertex? 
 Coordinates (3 floats) 
 Color (optional, 3 floats) 
 Normal information (optional, 3 floats) 
 Transparency (optional, 1 float) 
 More to come (texture information, shininess) 
73 Vertex data</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>The assignments are a lot of work. Really. 
 Start early! 
 
32 Administrivia: Assignments</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Administrivia: Assignments 
 Turn in code and executable (Linux) 
 Always turn in a README file 
 Describe problems, explain partially-working code 
Say how long the assignment took 
 Coding style important 
 Some assignments are cumulative 
 Collaboration policy: 
 You can chat, but code on your own 
 Acknowledge your collaboration! (in readme file) 
 Late policy: 
The deadline is absolute: 0 if not on time 
 Due Wednesday @ 8pm 
 Extensions only considered if requested 1 week before due date 
 Medical problems must be documented</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48
Ray Tracing 
 Shade (interaction of light and material) 
 Secondary rays (shadows, reflection, refraction)</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51Sampling &amp; Antialiasing 
 
 
 source unknown . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>No textbook is required 
 Recommendations 
3D Computer Graphics  (Watt) 
3D Computer Graphics: A Mathematical 
Introduction with OpenGL  (Buss) 
There is a free online version  available 
from Books24x7 
Real-Time Rendering, 3rd ed.  (Akenine-
Mller, Haines, Hoffman) 
Fundamentals of Computer Graphics, 3rd 
ed. (Shirley, Marschner) 
34 Textbooks</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>OpenGL and DirectX hacks 
 Most become obsolete every 18 months anyway! 
 Does not really matter either: Graphics is becoming all 
software again (OpenCL , Larrabee, etc.) 
 Software packages 
 CAD-CAM, 3D Studio MAX, Maya 
 Photoshop and other painting tools 
 Artistic skills 
 Game design 
20 What you will NOT learn in 6.837</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Instructor 
 Wojciech Matusik 
25 Team</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Administrivia: Prerequisites 
 Not strictly enforced 
 All assignments are in C++ 
Optional review/introductory session 
 
 Calculus, Linear Algebra 
 Solving equations, derivatives, integral 
 vectors, matrices, basis, solving systems of equations 
Optional review/introductory session</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>You can chat, but code on your own 
(we use automated plagiarism detection 
software!) 
 Use Piazza message board 
 Help others on Piazza message board (will help 
your grade!) 
 Acknowledge your collaboration (in README) 
 Talk to each other, get a community going 
 Graphics is fun! 
31 Collaboration policy</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Questions?</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Any display 
 Computers go through OpenGL and DirectX to 
display anything 
 2D graphics, Illustrator, Flash, Fonts 
 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>77 OpenGL is a state machine 
 Each command changes the state 
 But glVertex  also pushes data 
 For example, glColor3f changes the current color.  
 The color remains valid until we call glColor xx again 
 Use it before each vertex to get per-vertex color.  
 Other state to manage lighting and other 
rendering aspects 
 Can make it hard to debug 
(Note: This is conceptually simple, but not quite how you write 
efficient code these days.)</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Architecture 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50Textures and Shading 
Courtesy of Jeremy Birn.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Visualization 
Images removed due to copyright restrictions.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Particle Systems and ODEs (PDF - 1.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec07/</lecture_pdf_url>
      <lectureno>07</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>Point 
 
 Rigid body 
 
 Deformable body  
(include clothes, fluids, smoke, etc.) 
6 Types of Dynamics 
Mark Carlson  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Collection of many small simple pointlike things 
 Described by their current state: position, velocity, age, color, 
etc. 
 Particle motion influenced by external force fields and 
internal forces between particles 
 Particles created by generators  or emitters  
 With some randomness 
 Particles often have lifetimes  
 Particles are often independent 
 Treat as points for dynamics, but 
rendered as anything you want 
24 What is a Particle System? 
Image courtesy of Halixi72  on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
    For each particle p in PL  
        p-&gt;position+=p-&gt;velocity*dt; //dt: time step   
        p-&gt;velocity-=g*dt; //g: gravitation constant   
        glColor(p.color);  
        glVertex(p.position); 
30 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Questions? 
http://www.cs.columbia.edu/cg/ESIC/esic.html  
  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 Euler, Visually 
 X(t) 
f(X,t) h f(X,t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Effect of Step Size 
 Step size controls accuracy  
 Smaller steps more closely follow curve 
 May need to take many small steps per frame 
 Properties of f(X, t) determine this (more later) 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 MIT EECS 6.837  Durand  Particle Systems Overview 
Emitters generate tons of particles 
 Describe the external forces with a force field 
Integrate  the laws of mechanics (ODEs) 
 In the simplest case, each particle is independent  
 If there is enough randomness  (in particular at the 
emitter) you get nice effects 
 sand, dust, smoke, sparks, flame, water,  
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Gravity depends on all other particles 
 Opposite for pairs of particles 
 Force in the direction of pi-pj with magnitude 
inversely proportional to square distance 
 
 
 
 Testing all pairs is O(n2)! 
59 Forces: Gravity (N-body problem) 
Pi 
Pj where G=6.67 10-11 Nm2/kg2 
Particles are not 
independent! 
Pk</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Numerical solution is called integration of the 
ODE 
 Many techniques 
 Today, the simplest one 
 Thursday and next week well look at some more 
advanced techniques 
45 Numerics of ODEs</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 Reduction to 1st Order 
2 unknowns ( x, v) 
instead of just x 
or 
 Point mass: 2nd order ODE 
 
 
 
 Corresponds to system of 
    first order ODEs 
This image is in the public domain.
Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Often not shaded (just emission, think sparks) 
 But realistic non-emissive particles needs shadows, etc. 
 Most often, particles dont contribute to the z-buffer, 
i.e., they do not fully occlude stuff thats behind 
 Rendered with z testing on 
(particles get occluded by solid stuff) 
 Draw a line for 
motion blur  
( x, x+v dt ) 
 Or an elongated 
quad with texture 
88 
Rendering and Motion Blur 
Metal Gear Solid by Konami  Konami Digital Entertainment, Inc..  All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>In production tools, all these variables are time-
varying and controllable by the user (artist) 
 Emission rate, color, velocity distribution, 
direction spread, textures, etc. etc. 
 All as a function of time! 
 Example: ParticleFX 
(Max Payne Particle Editor) 
 Custom editor software 
 You can download it  (for Windows) 
and easily create your own particle 
systems. Comes with examples! 
 This is what we used for all the 
particles in the game! 
83 Particle Controls</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 MIT EECS 6.837  Durand  Particle Systems Overview 
Emitters generate tons of particles 
 Sprinkler, waterfall, chimney, 
gun muzzle, exhaust pipe, etc. 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Today We Focus on Point Dynamics 
 Lots of points! 
 Particles systems 
 Borderline between 
procedural and physically-
based 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>94 Questions? 
Early particle fun by Karl Sims Courtesy of Karl Sims . Used with permission.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Simplest and most intuitive 
 Pick a step size h 
 Given X0=X(t0), take step: 
 
 
 
 
 Piecewise-linear approximation to the path 
Basically, just replace d t by a 
small but finite number 
47 Eulers Method</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Why reduce? 
 Numerical solvers grow more complicated with increasing 
order, can just write one 1st order solver and use it 
 Note that this doesnt mean it would always be easy :-) 
38 Reduction to 1st Order 
2 variables ( x, v) 
instead of just one</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>The grass is made of particles 
 The entire lifetime of the particle is drawn at once. 
 This can be done procedurally on the GPU these days! 
93 Particle Modeling [Reeves 1983] 
William Reeves  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Moves along tangent; can leave solution curve, e.g.: 
 
 
 Exact solution is circle: 
 
 
 Euler spirals outward 
no matter how small h is 
 will just diverge more slowly 
55 Eulers method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>E.g., approximate fluid using Lennard-Jones force: 
 
 
 Repulsive + attractive force 
 Again, O(N2) to test all pairs 
 usually only local 
 Use buckets to optimize. Cf. 6.839 
67 Forces: Other Spatial Interaction 
distance force 
Particles are not 
independent!</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Again, reuse splines! 
85 Emitter Controls 
 Controls from ParticleFX by Remedy Entertainment 
 Remedy Entertainment Ltd. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21 EA Fight Night 4 Physics Trailer</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 MIT EECS 6.837  Durand  Particle Systems Overview 
Emitters generate tons of particles 
 Describe the external forces with a force field 
 E.g., gravity, wind 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Newtonian Mechanics 
or 
 Point mass: 2nd order ODE 
 
 
 
 
 Position x and force F are vector quantities 
 We know F and m, want to solve for x 
 
 You have all seen this a million times before 
This image is in the public domain.
Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Externally specified force (or velocity) fields in 
space 
 Force on particle i depends only on its position 
 Arbitrary functions 
 wind 
 attractors, repulsors 
 vortices 
 Can depend on time 
 Note: these add energy, may need damping 
63 Forces: Spatial Fields 
Bridson et al.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Questions? 
http://www.youtube.com/watch?v=dHWCT7RPjPo  
 
70</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Given a function f(X,t) compute X(t) 
 Typically, initial value problems : 
 Given values X(t0)=X0 
 Find values X(t) for t &gt; t0 
 
 We can use lots of standard tools 
34 Ordinary Differential Equations</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Moves along tangent; can leave solution curve, e.g.: 
 
 
 Exact solution is circle: 
54 Eulers method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>80 Battle of the Helms deep, LOTR 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Detection 
 Response 
 
 Covered later Collisions 
71</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 Flocks (Boids) 
 From Craig Reynolds 
 Each bird modeled as a complex particle (boid) 
 A set of forces control its behavior 
 Based on location of other birds and control forces 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/. Courtesy of Craig W. Reynolds. Used with permission.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>PL: linked list of particle = empty; 
 
25 Simple Particle System: Sprinkler 
Image Jeff Lander Image by  Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Point 
 
 Rigid body 
5 Types of Dynamics 
Animation by Mark Carlson</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Its not all hacks: 
Smoothed Particle Hydrodynamics 
(SPH) 
 A family of real particle-based 
fluid simulation techniques. 
 
 Fluid flow is described by the 
Navier-Stokes Equations , a nonlinear 
partial differential equation (PDE) 
 SPH discretizes the fluid as small packets 
(particles!), and evaluates pressures and 
forces based on them. 
18 Generalizations 
Jos Stam Mller et al. 2005  
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Keyframing 
 Procedural 
 Physically-based 
 Particle Systems: TODAY 
 Smoke, water, fire, sparks, etc. 
 Usually heuristic as opposed to simulation, but not always 
 Mass-Spring Models (Cloth) NEXT CLASS 
 Continuum Mechanics (fluids, etc.), finite elements 
 Not in this class 
 Rigid body simulation 
 Not in this class Types of Animation 
2 CERN</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Assign physical properties to objects 
 Masses, forces, etc. 
 Also procedural forces (like wind) 
 Simulate physics by solving equations of motion 
 Rigid bodies, fluids, plastic deformation, etc. 
 Realistic but difficult to control 
3 Types of Animation: Physically-Based 
v0 
m g 
3 3</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Often use texture maps (fire, clouds, smoke puffs) 
 Called billboards or sprites 
 Always parallel to image plane 
90 Rendering and Motion Blur 
90 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Why reduce? 
37 Reduction to 1st Order 
2 variables ( x, v) 
instead of just one</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>We have N point masses 
 Lets just stack all xs and vs in a big vector of length 6N 
40 Now, Many Particles</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Point 
4 Types of Dynamics</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 MIT EECS 6.837  Durand  Particle Systems Overview 
Emitters generate tons of particles 
 Describe the external forces with a force field 
Integrate  the laws of mechanics (ODEs) 
 Makes the particles move 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1;  //how random the colors are  
 
26 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 Euler, Visually 
X(t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>http://processing.org/learning/topics/simpleparticlesy
stem.html  
 
31 Demo with Processing</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>More advanced versions of behavior  
 flocks, crowds 
 Forces between particles 
 Not independent any more  
15 Generalizations 
http://www.blendernation.com/2008/01/05/simulat
ing-flocks-herds- and-swarms-using-
experimental-blender-boids-particles/  
See http://www.red3d.com/cwr/boids/  
for discussion on how to do flocking.  
 
Well come back to this a little later.  Animate Projects Limited 2013. All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Depends only on particle mass 
f(X,t) = constant 
 Hack for smoke, etc: make gravity point up! 
 Well, you can call this buoyancy, too. 
58 Forces: Gravity on Earth 
v0 
mi g 
Image courtesy of MichaelMaggs on Wikimedia Commons. License: CC- BY-
SA. This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>79 Processing demo 
http://processing.org/learning/topics/flocking.html</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 MIT EECS 6.837  Durand  Particle Systems Overview 
Emitters generate tons of particles 
 Describe the external forces with a force field 
Integrate  the laws of mechanics (ODEs) 
 In the simplest case, each particle is independent 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Curl noise for procedural fluid flow , R. Bridson, J. 
Hourihan, and M. Nordenstam, Proc. ACM 
SIGGRAPH 2007. 
65 Example: Procedural Spatial Field 
Plausible, 
conrollable force 
fields  just 
advecting particles 
along the flow gives 
cool results! 
 
And its simple, too!  
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>89 
Rendering and Motion Blur 
Metal Gear Solid by Konami  Konami Digital Entertainment, Inc..  All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Cloth Video 
Selle. A, Su, J., Irving, G. and Fedkiw, R., "Robust High-
Resolution Cloth Using Parallelism, History-Based Collisions, 
and Accurate Friction," IEEE TVCG 15, 339-350 (2009).</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>91 Image from Sameboat
 Image courtesy of Sameboat on Wikimedia Commons. License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Lennard-Jones forces 
http://www.youtube.com/watch?v=XfjYlKxKIWQ&amp;feature=autoplay&amp;list=PL0
605C44C6E8D5EDB&amp;lf=autoplay&amp;playnext=2  
69</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>We have N point masses 
 Lets just stack all xs and vs in a big vector of length 6N 
Fi denotes the force on particle i 
 When particles dont interact, Fi only depends on xi and vi. 
41 Now, Many Particles 
f gives d/dt X, 
remember!</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Current state X 
 Examine f(X ,t) at (or near) current state 
 Take a step to new value of X 
46 Intuitive Solution: Take Steps 
f = d/d t X is a vector 
that sits at each 
point in phase 
space, pointing the 
direction. 
             
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more i n
formation, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Fire 
 
 
 
 
 http://www.youtube.com/watch?v=6hG00etwRBU 
 
14</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>http://www.youtube.com/watch?v=uhTuJZiAG64  
 
60 Real-Time Gravity Demo 
NVIDIA</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Sprinkler 
 
 
 
http://www.youtube.com/watch?v=rhvH12nC6_Q 
 
13</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Flocks (Boids) 
Craig Reynolds 
76</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Mass-spring and deformable surface dynamics 
 surface represented as a set of points 
 forces between neighbors keep the surface coherent 
16 Generalizations  Next Class 
Image Michael Kass 
Image Witkin &amp; Baraff  ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>One of the earliest 
particle systems (from 1982) 
 Also, fractal landscapes  
 
 
 
 
 
 Described in [ Reeves, 1983 ] 
92 Star Trek 2  The Wrath of Khan 
Paramount Pictures 92  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Losasso, F., Talton, J., Kwatra, N. and Fedkiw, R., 
"Two-way Coupled SPH and Particle Level Set Fluid 
Simulation", IEEE TVCG 14, 797-804 (2008).  These Stanford folks use SPH for resolving the 
small-scale spray and mist that would otherwise 
be too much for the grid solver to handle. 
 IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837  Matusik 
MIT EECS 6.837 Computer Graphics 
 
Particle Systems and ODEs 
 
 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Euler, Visually 
X(t) 
f(X,t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>(Boid" was an 
abbreviation of 
"birdoid". His rules 
applied equally to 
simulated flocking 
birds, and shoaling 
fish.) 
75 Flocks (Boids) 
Courtesy of Craig W. Reynolds. Used with permission.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>That was Brute Force 
 Meaning all O( n2) pairs of particles 
were considered when computing forces 
 Yes, computers are fast these days, but this gets 
prohibitively expensive soon. (The square in n2 wins.) 
 
Hierarchical techniques  approximate forces caused 
by many distant attractors by one force, yields O( n)! 
Fast Multipole Method, Greengard and Rokhlin, J 
Comput Phys 73, p. 325 (1987)  
 This inspired very cool hierarchical illumination rendering 
algorithms in graphics (hierarchical radiosity, etc.) 
61 An Aside on Gravity</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 Euler, Visually 
X(t) 
f(X,t) h f(X,t) 
X(t+h) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 Path through a Vector Field 
When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ? 
X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction. 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
     
27 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 MIT EECS 6.837  Durand  More Eyecandy from NVIDIA 
 Fluid flow solved using a regular grid solver 
 This gives a velocity field 
 0.5M smoke particles advected using the field 
 That means particle velocity is given by field 
 Particles are 
for rendering, 
motion solved 
using other 
methods 
Link to 
video NVIDIA 
72 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>87 Unreal Engine 
 Epic Games, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 http://www.youtube.com/watch?v=nl7maklgYnI&amp;feature=related</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
 
28 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Damping force on particle i determined its velocity 
 Opposes motion 
 E.g. wind resistance 
 Removes energy, so system can settle 
 Small amount of damping can stabilize solver 
 Too much damping makes motion like in glue 
62 Forces: Viscous Damping</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Path through a Vector Field 
When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ? 
X(t): path in multidimensional phase space 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Real-time particles in games 
http://www.youtube.com/watch?v=6DicVajK2xQ</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44 Questions? 
http://vimeo.com/14597952</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>Further reading 
Witkin, Baraff, Kass: Physically-based Modeling Course 
Notes, SIGGRAPH 2001  
Extremely good, easy-to -read resource. Highly 
recommended! 
 
William Reeves: Particle systemsa technique for 
modeling a class of fuzzy objects, Proc. SIGGRAPH 1983  
 The original paper on particle systems 
 
particlesystems.org  
95 Thats All for Today!</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Particle-based methods can range from pure 
heuristics (hacks that happen to look good) to 
real simulation 
 
 Basics are the same: 
Things always boil 
down to integrating ODEs!  
 Also in the case of 
grids/computational meshes Take-Home Message 
22 
Andrew Selle et al . 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Often created by generators  or emitters 
 Can be attached to objects in the model 
 Given rate of creation: particles/second 
 record tlast of last particle created 
 
 
 create n particles.  
update tlast if n &gt; 0 
 Create with (random) distribution  
of initial x and v 
if creating n &gt; 1 particles at once, spread out on path 
82 Where do particles come from? 
http://www.particlesystems.org / Image removed due to 
copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Flocking birds, fish shoals 
 http://www.red3d.com/cwr/boids/ 
 Crowds (www.massivesoftware.com ) 
 
73 More Advanced Forces</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Massive software 
http://www.massivesoftware.com/  
 Used for battle scenes in the Lord of The Rings</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Again, reuse splines! 
84 Emitter Controls 
 Controls from ParticleFX by Remedy Entertainment  Remedy Entertainment Ltd. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Basic particle systems are simple hacks 
 Extend to physical simulations, e.g., clothes 
 For this, we need to understand numerical integration 
 This lecture: point particles 
 Next lecture: mass-spring and clothes  
 
33 Path forward</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Midpoint, Trapezoid, Runge-Kutta 
 Also, implicit methods (next week) 
 
 
 
 
 
 
 Extremely valuable resource: SIGGRAPH 2001 
course notes on physically based modeling  
56 More Accurate Alternatives 
More on this during next 
class</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86 Unreal Engine 
 Epic Games, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Lets stack the pair ( x, v) into a bigger state vector X 
39 Notation 
For a particle in 
3D, state vector X 
has 6 numbers</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>http://processing.org/learning/topics/smokeparticlesy
stem.html  
 
64 Processing demo</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>A force changes the motion of the system 
 Newton says: When there are no forces, motion continues 
uniformly in a straight line (good enough for us) 
 
 Forces can depend on location, time, velocity 
 Gravity, spring, viscosity, wind, etc. 
 
 For point masses, forces are vectors 
Ie., to get total force, take vector 
sum of everything 
57 What is a Force?  
Wikipedia 
Image courtesy of BillC on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from ou
r Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>77 Predator-Prey 
 http://www.youtube.com/watch?v=rN8DzlgMt3M</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
    For each particle p in PL  
        p-&gt;position+=p-&gt;velocity*dt;  //dt: time step   
        p-&gt;velocity-=g*dt;  //g: gravitation constant   
        glColor(p.color);  
        glVertex(p.position); 
29 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions .</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Coordinates and Transformations (PDF - 1.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec03/</lecture_pdf_url>
      <lectureno>03</lectureno>
      <slides>
        <slide>
          <slideno>63</slideno>
          <text>Perspective in 2D  
Projectively 
equivalent  
64 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Perspective in 2D  
63 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .
The projected point in 
homogeneous 
coordinates  
(we just added w=1):</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Questions?  
29</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Transform Normal like Object?  
translation?  
rotation?  
isotropic scale?  
scale?  
reflection?  
shear?  
perspective?  
80</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Why bother with extra coord?  
w = 1 
w = 2 This picture gives away almost  
the whole story.  
61</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Reference  
This lecture follows the new book by 
Steven (Shlomo) Gortler from Harvard:  
Foundations of 3D Computer Graphics  
10</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Transform tangent vector v 
v is perpendicular to normal n: 
nOS vOS  =  0 
 nOS   (M  M)  vOS  =  0 
 nWS =  nOS (M)  (nOS  M)  (M    vOS)  =  0 
 (nOS  M)  vWS  =  0 
 nWS vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M) nOS nOS 
vWS nWS vOS Dot product  
84</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Recap, matrix notation  
 
Given the coordinates c in basis  
the transformed vector has coordinates Mc in  
22</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Affine space  
Points are elements of an affine space  
We denote them with a tilde  
 
Affine spaces are an extension of vector spaces  
33</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Point-vector operations  
Subtracting points gives a vector  
 
Adding a vector to a point gives a point  
34</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Frames 
A frame is an origin      plus a basis  
We can obtain any point in the space by adding 
a vector to the origin  
 
 
using the coordinates c of the vector in  
35</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Thats All for Today  
Further Reading  
Buss, Chapter 2  
 
Other Cool Stuff  
Algebraic Groups  
http://phototour.cs.washington.edu/ 
http://phototour.cs.washington.edu/findingpaths/ 
Free-form deformation of solid objects 
Harmonic coordinates for character articulation 
89</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Linear transformation  
Transformation       of the vector space  
16 
Courtesy of Prof. Fredo Durand. Used with permission.</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Questions?  
88</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>How do we transform normals?  
Object Space  World Space  nOS nWS 
78</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Questions?  
48</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>More Normal Visualizations  
Incorrect Normal Transformation  Correct Normal Transformation  
82</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Projective Equivalence  Why? 
For affine transformations,  
adding w=1 in the end proved to be convenient.  
The real showpiece is perspective.  
68 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus . source unknown. All rights reserved. This content is excluded from our Creative  
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-us  e/.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Matrix notation  
Linearity implies  
 
 
 
i.e. we only need to know the basis 
transformation  
or in algebra notation  
19</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Full affine expression  
Which tells us both how to get a new frame ftM  
or how to get the coordinates Mc after transformation  
43</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>More notation properties  
Adding a point  
 
 
                                to a vector  
 
Gives us  
 
 
 
a point (4th coordinate=1)  
46</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Visualization of Surface Normal  
 x = Red  
 y = Green  
 z = Blue  
77</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Step 1: point correspondences  
Extract salient points (corners) from images  
Find the same scene point in other images  
To learn how its done, take 6.815  
71</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Points &amp; vectors are different  
Moving car  
points describe location of car elements  
vectors describe velocity, distance between pairs of 
points  
If I translate  the moving car to a different road  
The points (location) change  
The vectors (speed, distance between points) dont  
6 
Image courtesy of Gunnar A. Sjgren  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Camera at origin, looking along z, 90 degree 
f.o.v., image plane at z=1 Perspective in 2D  
62 
This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>More notation properties  
If the fourth coordinate is zero, we get a vector  
Subtracting two points:  
 
 
 
 
Gives us  
 
a vector (last coordinate = 0)  
45</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Transformation for shear and scale  
Incorrect 
Normal 
Transformation  
Correct 
Normal 
Transformation  
81</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Think about transforming the tangent plane   
to the normal, not the normal vector  So how do we do it right?  
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane,  
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS 
83</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Comment  
So the correct way to transform normals is:  
 
But why did  nWS = M nOS work for similitudes?  
Because for similitude / similarity transforms,  
                              (M) = M 
e.g. for orthonormal basis:  
 
                   M = M      i.e.  (M) = M 
  nWS = (M) nOS Sometimes denoted M  
86</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Non-commutative Composition  
Scale then Translate:   p'  =  T ( S p )  =  TS p  
Translate then Scale:   p'  =  S ( T p )  =  ST p  
(0,0) (1,1) (4,2) 
(3,1) (8,4) 
(6,2) (0,0) (1,1) (2,2) 
(0,0) (5,3) 
(3,1) Scale(2,2)  Translate(3,1)  
Translate(3,1)  Scale(2,2)  
54</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Homogeneous Coordinates  
Add an extra dimension (same as frames)  
in 2D, we use 3 -vectors and 3 x 3 matrices  
In 3D, we use 4 -vectors and 4 x 4 matrices  
The extra coordinate is now an arbitrary  value, w 
You can think of it as scale, or weight  
For all transformations  
except perspective, you can  
just set w=1 and not worry  
about it  x' 
y 
1 a    b  
d    e  
0  0 c 
f 
1 = x 
y 
1 
59</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>And thats it for today  
The rest on Thursday  
74</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Vectors (linear space)  
Formally, a set of elements equipped with 
addition and scalar multiplication  
plus other nice properties  
There is a special element, the zero vector  
no displacement, no force  
12</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Hierarchical modeling  
Many coordinate systems:  
Camera  
Static scene  
car 
driver  
arm 
hand  
... 
Makes it important to understand coordinate 
systems  2 
  
Image courtesy of Gunnar A. Sjgren on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Perspective in 2D  
Well just copy z to w, 
and get the projected 
point after 
homogenization!  
65 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
 
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Eye candy: photo tourism  
QuickTime and a
MPEG-4 Video decompressor
are needed to see this picture.
73</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Change of basis  
We have                               &amp;  
Given the coordinate of    in   :  
 
Replace    by its expression in  
 
 
   has coordinates               in  
Note how we keep track of the coordinate 
system by having the basis on the left  
28</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Plan 
Vectors  
 
Points  
 
Homogeneous coordinates  
 
Normals (in the next lecture)  
11</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Goals for today  
Make it very explicit what coordinate system is 
used  
Understand how to change coordinate systems  
Understand how to transform objects  
Understand difference between points, vectors, 
normals and their coordinates  
8</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Matrix notation  
We know how to transform the vector basis  
 
 
 
We will soon add translation by a vector  
39</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Translation component  
Express translation vector t in the basis  
41</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Points &amp; vectors are different  
The 0 vector has a fundamental meaning:  
no movement, no force  
Why would there be a special 0 point?  
 
Its meaningful to add vectors, not points  
Boston location + NYC location =?  
+ =? 
5</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Forward reference and eye  
The fourth coordinate is useful for perspective 
projection  
Called homogenous coordinates  
58</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Change of basis  
Critical in computer graphics  
From world to car to arm to hand coordinate system  
From Bezier splines to B splines and back  
 
problem with basis change:  
you never remember which is M or M  
its hard to keep track of where you are  
25</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Questions?  
15</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Matrix notation  
Linearity implies  
 
? 
18</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Frames &amp; hierarchical modeling  
Many coordinate systems (frames):  
Camera  
Static scene  
car 
driver  
arm 
hand  
... 
 
Need to understand nested transformations  
49 
Image courtesy of Gunnar A. Sjgren on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>All non-zero scalar multiples of a point are considered 
identical 
to get the equivalent Euclidean point, divide by w 
 Projective Equivalence  
x 
y 
z 
w ax 
ay 
az 
aw 
a  != 0  = x/w 
y/w 
z/w 
1 = w !=0  
60</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Homogeneous Visualization  
Divide by w to normalize (project)  
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) =   
(7, 1, 1) = (14, 2, 2) =   
(4, 5, 1) = (8, 10, 2) =   (0,0,0)  
66</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Structure from motion  
Given point correspondences  
Unknowns: 3D point  location, camera poses  
For each point in each image, write perspective 
equations  
72 Camera 1 R1,t1  Camera 2 R2,t2  Camera 3  
R3,t3  p1 Minimize f(R,T,P)</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Coordinates and 
Transformations  
MIT ECCS 6.837  
Wojciech Matusik  
 
many slides follow Steven Gortlers book  
1</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Change of basis  
We have                               &amp;  
Given the coordinate of    in   :  
 
What are the coordinates in    ?  
27</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Change of basis  
Assume we have two bases        and  
And we have the coordinates of       in  
e.g.  
 
i.e. 
 
which implies  
26</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Eye candy: photo tourism  
Application of homogenous coordinates  
Goal: given N photos of a scene  
find where they were taken  
get 3D geometry for points in the scene  
70 
From Photo Tourism::  Exploring Photo Collections in 3D , used with permission from ACM, Inc.  ACM. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Digression  
 
 
The previous proof is not quite rigorous; first 
youd need to prove that tangents indeed 
transform with M. 
Turns out they do, but well take it on faith here.  
If you believe that, then the above formula follows.   nWS = (M) nOS 
85</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Connections  
Not part of class, but cool  
Covariant: transformed by the matrix  
e.g., tangent  
Contravariant: transformed by the inverse transpose  
e.g., the normal  
a normal is a co -vector  
 
Google differential geometry to find out more  
87</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>More notation properties  
vectors are not affected by the translation part  
 
 
 
 
because their 4th coordinate is 0  
If I rotate my moving car in the world, I want its 
motion to rotate  
If I translate it, motion should be unaffected  
47</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Coordinates  
We are used to represent points with tuples of 
coordinates such as  
But the tuples are meaningless without a clear 
coordinate system  
could be this point                
in the blue 
coordinate system  could be this point 
in the red 
coordinate system  
3</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Different objects  
Points 
represent locations  
Vectors 
represent movement, force, displacement from A to B  
Normals  
represent orientation, unit length  
Coordinates  
numerical representation of the above objects  
in a given coordinate system  
4</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Frames &amp; transformations  
Transformation S wrt car frame f  
 
how is the world frame a affected by this?  
we have  
which gives  
 
i.e. the transformation in a is A -1SA 
i.e., from right to left, A takes us from a to f, then 
we apply S, then we go back to a with A -1 
51</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>L(p + q) = L(p) + L(q)  
L(ap) = a L(p)  Linear Transformations  
Translation  
Rotation Rigid / Euclidean  Linear  Similitudes  
Isotropic Scaling  Scaling 
Shear Reflection  Identity 
Translation  is not linear : 
f(p) = p+t  
f(ap) = ap+t  a(p+t) = a f(p)  
f(p+q) = p+q+t  (p+t)+(q+t) = f(p) + f(q)  
30</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Why is the Normal important?  
It's used for shading  makes things look 3D!  
object color only  Diffuse Shading  
76</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 How are transforms combined?  
(0,0) (1,1) (2,2) 
(0,0) (5,3) 
(3,1) Scale(2,2)  Translate(3,1)  
TS  =  2 
0 0 
2 0 
0 1 
0 0 
1 3 
1 2 
0 0 
2 3 
1 = Scale then Translate  
Use matrix multiplication:   p'  =  T ( S p )  =  TS p  
Caution: matrix multiplication is NOT commutative!   
 
0  
 
0  
 
1  
 
0  
 
0  
 
1  
 
0  
 
0  
 
1 
53</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>TS  =  2 
0 
0 0 
2 
0 0 
0 
1 1 
0 
0 0 
1 
0 3 
1 
1 
ST  =  2 
0 0 
2 0 
0 1 
0 0 
1 3 
1 Non-commutative Composition  
Scale then Translate:   p'  =  T ( S p )  =  TS p  
2 
0 
0 0 
2 
0 3 
1 
1 
2 
0 0 
2 6 
2 = 
= Translate then Scale:   p'  =  S ( T p )  =  ST p  
 
 
0  
 
0  
 
1  
 
0  
 
0  
 
1  
 
0  
 
0  
 
1 
55</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Why do we care  
We like linear algebra  
Its always good to get back to an abstraction 
that we know and for which smarter people have 
developed a lot of tools  
But we also need to keep track of what 
basis/coordinate system we use  
23</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Homogeneous Visualization  
Divide by w to normalize (project)  
w = 0?   
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) =   
(7, 1, 1) = (14, 2, 2) =   
(4, 5, 1) = (8, 10, 2) =   Points at infinity (directions)  
(0,0,0)  
67</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Matrices have two purposes  
(At least for geometry)  
Transform things  
e.g. rotate the car from facing 
North to facing East  
Express coordinate system 
changes  
e.g. given the driver's location 
in the coordinate system of the 
car, express it in the coordinate 
system of the world  
7</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Linear transformation  
Transformation       of the vector space so that  
 
 
Note that it implies  
Notation                for transformations  
17 
Courtesy of Prof. Fredo Durand. Used with permission.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Questions?  
69</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Questions?  
9</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Translation  
42</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Points vs. Vectors  
A point is a location  
A vector is a motion between two points  
Adding vectors is meaningful  
going 3km North + 4km East = going 5km North -East 
Adding points is not meaningful  
Boston location + New York location = ?  
Multiplying a point by a scalar?  
The zero vector is meaningful (no movement)  
Zero point ?  
32</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Algebra notation  
The          are also vectors of the space  
They can be expressed in the basis  
for example:  
 
 
 
which gives us  
21</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Algebra notation  
The          are also vectors of the space  
They can be expressed in the basis  
for example:  
 
 
 
which gives us  
... 
20</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Algebra notation  
We like matrix -vector expressions  
We want to keep track of the frame  
Were going to cheat a little for elegance  
and decide that 1 times a point is the point  
 
 
 
   is represented in   by 4 coordinate, where the 
extra dummy coordinate is always 1 (for now)  
36</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Linear algebra notation  
can be written as  
 
 
Nice because it makes the basis  
(coordinate system) explicit  
Shorthand:  
 
where bold means triplet, t is transpose  
14</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Questions?  
44</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Questions?  
52</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Vectors (linear space)  
We can use a basis  to produce all the vectors in 
the space:  
Given n basis vectors  
any vector       can be written as  
here:  
13</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Affine transformations  
Include all linear transformations  
Applied to the vector basis  
Plus translation  
38 Courtesy of Prof. Fredo Durand . Used with permission.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Plan 
Vectors  
 
Points  
 
Homogenous coordinates  
 
Normals  
57</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Linear component  
Note how we leave the fourth component alone  
40</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Plan 
Vectors  
 
Points 
 
Homogenous coordinates  
 
Normals  
31</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Questions?  
56</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Questions?  
24</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Normal 
Surface Normal:  unit vector that is locally 
perpendicular to the surface  
75</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Frames &amp; hierarchical modeling  
Example: what if I rotate the wheel of the moving 
car:  
frame 1: world  
frame 2: car  
transformation: rotation  
50 
Image courtesy of Gunnar A. Sjgren  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Transform Normal like Object?  
translation?  
rotation?  
isotropic scale?  
scale?  
reflection?  
shear?  
perspective?  
79</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Recap 
Vectors can be expressed in a basis  
Keep track of basis with left notation  
Change basis  
Points can be expressed in a frame  
(origin+basis)  
Keep track of frame with left notation  
adds a dummy 4th coordinate always 1  
37</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Particle Systems and ODE Solvers II, Mass Spring Modeling (PDF - 1.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec08/</lecture_pdf_url>
      <lectureno>08</lectureno>
      <slides>
        <slide>
          <slideno>60</slideno>
          <text>Robert Bridson, Ronald Fedkiw &amp; John Anderson: 
Robust Treatment of Collisions, Contact  
and Friction for Cloth Animation
 
SIGGRAPH 2002 
Selle. A, Su, J., Irving, G. and Fedkiw, R., "Robust 
High-Resolution Cloth Using Parallelism, History-
Based Collisions, and Accurate Friction," IEEE 
TVCG 15, 339-350 (2009).  
Selle, A., Lentine, M. and Fedkiw, R., "A Mass 
Spring Model for Hair Simulation", SIGGRAPH 
2008, ACM TOG 27, 64.1-64.11 (2008).  
61 Cool Cloth/Hair Demos</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Springs for Cloth 
 Network of masses and 
springs 
Structural  springs:  
 link (i j) and (i+1, j);  
and (i, j) and (i, j +1) 
Deformation:  
 Shear springs 
 (i j) and (i+1, j+1)  
 Flexion springs 
  (i,j) and (i+2,j); 
(i,j) and (i,j+2) 
 See Provots Graphics 
Interface 95 paper  for 
details Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Reduction to 1st Order 
2 unknowns ( x, v) 
instead of just x 
or 
 Point mass: 2nd order ODE 
 
 
 
 
 Corresponds to system of first 
order ODEs This image is in the public domain.
Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>This translates to... 
 
 
 
 and we get 
 
 This is the trapezoid method 
 Analysis omitted (see 6.839) 
 Note: What we mean by 2nd order is that the error 
goes down with h2 , not h  the equation is still 1st 
order! 16 2nd Order Methods</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Linear set of particles 
 Length-preserving structural  springs like before 
Deformation  forces proportional to the angle 
between segments 
External forces 
30 Hair</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Forces: Structural vs. Deformation 
 Structural forces are here 
just to enforce a constraint 
 Ideally, the constraint 
would be enforced strictly 
 at least a lot more than we 
can afford 
 Well see that this is the 
root of a lot of problems 
 In contrast, deformation 
forces actually correspond 
to physical forces Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Structural  forces 
 Try to enforce invariant 
properties of the system 
 E.g. force the distance 
between two particles 
to be constant 
 Ideally, these should be constraints , not forces 
Internal deformation  forces 
 E.g. a string deforms, a spring board tries to remain flat 
External forces 
 Gravity, etc.  
34 Cloth  Three Types of Forces 
 ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4 ODE: Path Through a Vector Field 
When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ? 
X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction.   Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Further reading 
Stiff systems 
Explicit vs. implicit solvers 
 Again, consult the 2001 course notes ! 
54 Questions?</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>71 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new MidPoint() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Cloth Simulation 
 Then, the all trick is to set 
the stiffness of all springs 
to get realistic motion! 
 
 Remember that forces 
depend on other particles 
(coupled system) 
 But it is sparse  
(only near neighbors) 
 This is in contrast to e.g. 
the N-body problem. Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Eulers Method: Not Always Stable 
 Test equation</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Problem: f has varied along our Euler step 
 Idea 2: look at f after a smaller step, use that value 
for a full step from initial position 
17 Can We Do Better? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Problem: f varies along our Euler step 
 Idea 1: look at f at the arrival of the step and 
compensate for variation 
15 Can We Do Better? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Gravity G 
 Friction 
 Wind, etc. 
36 External Forces 
Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Time Stepper Class 
  class TimeStepper 
  { 
        virtual takeStep(ParticleSystem* ps, float h) 
  }</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Moves along tangent; can leave solution curve, e.g.: 
 
 
 Exact solution is circle: 
 
 
 Euler spirals outward 
no matter how small h is 
 will just diverge more slowly 
6 Eulers Method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Expand exact solution X(t) 
 
 
 Eulers method approximates: 
 
 
 
 
 First-order method: Accuracy varies with h 
 To get 100x better accuracy need 100x more steps 
13 Analysis: Taylor Series</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Springs between mass n &amp; n+2 with rest length 2L 0 
 Wants to keep particles aligned 
32 Hair - Alternative Structural Forces 
Questions?</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Midpoint : 
  Euler step 
 evaluate fm 
 full step using fm 
 Trapezoid: 
 Euler step (a) 
 evaluate f1 
 full step using f1 (b)  
 average (a) and (b) 
 Not exactly same result, 
but same order of accuracy 
19 Comparison 
fm f1 a 
b 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Springs link the particles 
 Springs try to keep their rest lengths 
and preserve the length of the string 
 Not exactly preserved though, and we get oscillation 
 Rubber band approximation 
28 How Would You Simulate a String?</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Given a function f(X,t) compute X(t) 
 Typically, initial value problems : 
 Given values X(t0)=X0 
 Find values X(t) for t &gt; t0 
 
 We can use lots of standard tools 
2 ODEs and Numerical Integration</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Particle System Class 
  class ParticleSystem 
  { 
        virtual int getDimension() 
        virtual setDimension(int n) 
        virtual float* getStatePositions() 
        virtual setStatePositions(float* positions) 
        virtual float* getStateVelocities() 
        virtual setStateVelocities(float* velocities) 
        virtual float* getForces(float* positions, float* velocities) 
                        virtual setMasses(float* masses) 
                        virtual float* getMasses() 
 
        float* m_currentState  
  }</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 
Thats All for Today! 
Bungie / ign.com 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Eulers Method: Not Always Stable 
Wikipedia user Berland 
 Limited step size! 
 When 
     things are fine, the solution decays 
 When  
 we get oscillation 
 When                                                         things explode 
 
This image is in the public domain. Source: Wikimedia
If k is big, 
h must be small!</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Force in the direction of the spring and proportional 
to difference with rest length L0. 
 
 
 K is the stiffness of the spring 
 When K gets bigger, the spring really 
wants to keep its rest length 
26 
Pi Pj L0 F Spring Force  Hookes Law</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 
Why Stiff Springs Are Difficult 
x1 x2 height=magnitude 
of spring force K=1 
x2 
x1</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 
Why Stiff Springs Are Difficult 
x1 x2 K=11 
x2 
x1 x2 
x1 Forces grow 
really big! The admissible region 
shrinks towards the line 
x1-x2=1 as K grows</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Springs link the particles 
 Springs try to keep their rest lengths 
and preserve the length of the string 
 Not exactly preserved though, and we get oscillation 
 Rubber band approximation 
29 How Would You Simulate a String? 
Questions?</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>You bet! 
 You will implement Runge-Kutta  for assignment 3 
 
 Again, see Witkin, Baraff, Kass: Physically-based 
Modeling Course Notes, SIGGRAPH 2001  
 
 
 
 See eg 
http://www.youtube.com/watch?v=HbE3L5CIdQg   
21 Can We Do Even Better? Questions?</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Euler, Visually 
X(t) 
f(X,t) h f(X,t) 
X(t+h) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Basic idea 
 Particle System tells Time Stepper how many 
dimensions (N) the phase space has 
 Particle System has a function to write its state to an N-
vector of floating point numbers (and read state from it) 
 Particle System has a function that evaluates f( X,t), 
given a state vector X and time t 
 
 Time Stepper takes a Particle System as input and 
advances its state 
65 Implementation Notes</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>69 Mid-Point Implementation 
  class MidPoint : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   midPositions = positions + 0.5*h*velocities 
   midVelocities = velocities  + 0.5*h*accelerations 
   midForces = ps-&gt;getForces(midPositions, midVelocities) 
   midAccelerations = midForces / masses 
   newPositions = positions + 0.5*h* midVelocities 
   newVelocities = velocities  + 0.5*h* midAccelerations      
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  }</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Expand exact solution X(t) 
 
 
 Eulers method approximates: 
 
 
 
 
 First-order method: Accuracy varies with h 
 To get 100x better accuracy need 100x more steps 
14 Analysis: Taylor Series 
 Questions?</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Force in the direction of the spring and proportional 
to difference with rest length L0. 
 
 
 K is the stiffness of the spring 
 When K gets bigger, the spring really 
wants to keep its rest length 
27 Spring Force  Hookes Law  
Pi Pj L0 F This is the force on P j. 
Remember Newton:   
Pi experiences force of 
equal magnitude but 
opposite direction.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Springs between mass n &amp; n+2 with rest length 2L 0 
 Wants to keep particles aligned 
31 Hair - Alternative Structural Forces</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Moves along tangent; can leave solution curve, e.g.: 
 
 
 Exact solution is circle: 
 
 
 Euler spirals outward 
no matter how small h is 
 will just diverge more slowly 
7 Eulers Method: Inaccurate 
Questions? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>How can we compute the external 
contact force? 
 Inverse dynamics! 
 Sum all other forces applied to point 
 Take negative 
 Do we really need to 
compute this force? 
 Not really, just ignore the other forces 
applied to this point! 
41 Contact Forces 
Questions?</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 
Why Stiff Springs Are Difficult 
x1 x2 K=11 
x2 
x1 x2 
x1 Forces grow 
really big! The admissible region 
shrinks towards the line 
x1-x2=1 as K grows</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>What happens if we discretize our cloth more finely?  
 Do we get the same behavior?  
 Usually not! It takes a lot of effort to design a 
scheme that is mostly oblivious to the discretization. 
45 The Discretization Problem 
Questions?</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 Forward Euler Implementation 
  class ForwardEuler : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   newPositions = positions + h*velocities 
   newVelocities = velocities  + h*accelerations 
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  }</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Mass-Spring Cloth 
Michael Kass 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>x=-kx is a true 1st order ODE 
 Energy gets dissipated 
 
 In contrast, a spring is a second order system 
 Energy does not get dissipated 
 It is just transferred between potential and kinetic energy 
 Unless you add damping 
 This is why people always add damping forces and 
results look too viscous 
58 Difference with x=-kx Questions?</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>We use springs while we really mean constraint 
 Spring should be super stiff, which requires tiny  t 
 Remember x=-kx system and Euler speed limit! 
 The story extends to N particles and springs (unfortunately) 
 
 Many numerical solutions 
 Reduce t (well, not a great solution) 
 Actually use constraints (see 6.839) 
 Implicit integration scheme (more next Thursday) 
46 The Stiffness Issue</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>A cloth has many points of contact 
 Requires 
 Efficient collision detection 
 Efficient numerical 
treatment (stability) 
59 The Collision Problem 
Image from Bridson et al.   
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Why Stiff Springs Are Difficult 
x1 x2 K=6 
x2 
x1 
height=magnitude 
of spring force 
Forces grow 
really big!</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Particle Systems 
and ODE Solvers II, 
Mass-Spring Modeling 
With slides from Jaakko Lehtinen 
and others 
Picture: A. Selle et al. 
MIT EECS 6.837  Matusik  Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>How can we compute the external 
contact force? 
 Inverse dynamics! 
 Sum all other forces applied to point 
 Take negative 
 Do we really need to 
compute this force? 
 Not really, just ignore the other forces 
applied to this point! 
40 Contact Forces</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>h &gt; 1/k: oscillate. h &gt; 2/k: explode! 
47 Euler Has a Speed Limit! 
From the SIGGRAPH PBM notes  
Image removed due to copyright restrictions -- please see slide 5 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse/.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Collisions Robert Bridson, Ronald Fedkiw &amp; John Anderson  
Robust Treatment of Collisions, Contact  
and Friction for Cloth Animation  
SIGGRAPH 2002 
 Cloth has many points  
of contact 
 Need efficient collision 
detection and 
stable treatment 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>It pays off to abstract (as usual) 
 Its easy to design your Particle System and Time 
Stepper to be unaware of each other 
 
 Basic idea 
 Particle system and Time Stepper communicate via 
floating-point vectors X and a function that computes 
f(X,t) 
 Time Stepper does not need to know anything else! 
64 Implementation Notes</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Eulers Method: Not Always Stable 
 Test equation 
 
 Exact solution is a decaying exponential:</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Constrain length to increase by less than 10% 
 A little hacky 
43 One Solution  
Simple mass-spring system 
 Improved solution  
(see Provot Graphics Interface 1995) 
http://citeseer.ist.psu.edu/provot96deformation.html  Xavier Provot . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>In our mass-spring cloth, we have encouraged 
length preservation using springs that want to have a 
given length (unfortunately, they can refuse offer ;-) ) 
 Constrained dynamic simulation: 
force it to be constant!
 
 How it works  more in 6.839  
 Start with constraint equation 
 E.g., ( x2-x1)-1 
= 0 in the previous 1D example 
 Derive extra forces that will exactly enforce constraint 
 This means projecting  the external forces (like gravity) onto 
the subspace of phase space where constraints are satisfied 
 Fancy name for this: Lagrange multipliers 
 Again, see the SIGGRAPH 2001 Course Notes 
53 Constrained Dynamics 
 David Baraff and Andrew Witkin. All
rights reserved. This content is excluded
from our Creative Commons license. For
more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>What happens if we discretize our cloth more finely?  
 Do we get the same behavior?  
 Usually not! It takes a lot of effort to design a 
scheme that is mostly oblivious to the discretization. 
44 The Discretization Problem</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>x=-kx is a true 1st order ODE 
 Energy gets dissipated 
 
 In contrast, a spring is a second order system 
 Energy does not get dissipated 
 It is just transferred between potential and kinetic energy 
 Unless you add damping 
 This is why people always add damping forces and 
results look too viscous 
57 Difference with x=-kx</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Guess how well Euler will do... 
always diverge 
56 Mass on a Spring, Phase Space 
Wikipedia user Mazemaster 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Beyond pointlike objects: 
strings, cloth, hair, etc. 
 Interaction between particles 
 Create a network of spring 
forces that link pairs of particles 
 
 First, slightly hacky version of cloth simulation 
 Then, some motivation/intuition for implicit 
integration (NEXT LECTURE) 
22 Mass-Spring Modeling 
Michael Kass 
 ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>State of system (phase) : velocity &amp; position 
 similar to our X=(x v) to get 1st order 
55 Mass on a Spring, Phase Space 
Wikipedia user Mazemaster 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Eulers Method: Not Always Stable 
 Test equation 
 
 Exact solution is a decaying exponential: 
 
 
 Lets apply Eulers method:</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Hanging curtain: 
 2 contact points stay fixed 
 What does it mean? 
 Sum of the forces is zero 
 How so? 
 Because those point undergo an  
external force that balances the system 
 What is the force at the contact? 
 Depends on all other forces in the system 
 Gravity, wind, etc.  
39 Contact Forces 
Reaction force 
Forces from  
other particles,  
gravity</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new ForwardEuler() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Pi Pj  Rest length L0 F 
L0 - ||Pj-Pi|| Spring Force  Hookes Law</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>1D example, with two particles constrained to move 
along the x axis only, rest length L 0 = 1 
 Phase space is 4D: ( x1, v1, x2, v2) 
 But spring force only depends on x1, x2 and L 0. 
48 Why Stiff Springs Are Difficult 
x1 x2 
v1 v2 
L0 = 1</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>You bet! 
 You will implement Runge-Kutta  for assignment 3 
 
 Again, see Witkin, Baraff, Kass: Physically-based 
Modeling Course Notes, SIGGRAPH 2001  
 
 
 
 See eg 
http://www.youtube.com/watch?v=HbE3L5CIdQg   
20 Can We Do Even Better?</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Springs 
Image courtesy of Jean-Jacques MILAN on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Limited step size! 
 When 
     things are fine, the solution decays 
 When  
 we get oscillation 
 When                                                         things explode 
 11 Eulers Method: Not Always Stable 
Wikipedia user Berland 
This image is in the public domain. Source: Wikimedia</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Each particle is linked to two particles (except ends) 
 Come up with forces that try to keep the distance 
between particles constant 
23 How Would You Simulate a String?</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Excessive rubbery deformation:  
the strings are not stiff enough 
42 Example 
Initial position After 200 iterations 
 Xavier Provot . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>This translates to... 
 
 
 
 and we get 
 
 This is the midpoint method 
 Analysis omitted again, 
but its not very complicated, see here. 
18 2nd Order Methods Contd</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Texture Mapping and Shaders (PDF - 2.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec16/</lecture_pdf_url>
      <lectureno>16</lectureno>
      <slides>
        <slide>
          <slideno>27</slideno>
          <text>28 Questions?</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics  
 1 
MIT EECS 6.837  Matusik  Texture Mapping &amp; Shaders 
 Remedy Enterainment. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Information we need: 
 Per vertex 
 3D coordinates 
 Normal 
 2D UV coordinates 
 Other information 
 BRDF (often same for the whole object, but could vary) 
 2D Image for the texture map 
18 3D Model</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Initially for production (slow) rendering 
 Renderman in particular 
 Now used for real-time (Games) 
 Evaluated by graphics hardware 
 More later in the course 
 
 Often makes heavy use of texture mapping 
41 Shader</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Ray cast pixel (x, y), get visible point and , ,  
 Get texture coordinates (u, v) at that point 
 Interpolate from vertices using barycentrics 
 Look up texture color 
using UV coordinates 
13 Pseudocode  Ray Casting 
Scene 
Texture map 
Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64 Other Cool Usage: Displacement, Fur 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26 Questions?</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 
Normal Map Example 
Simplified mesh, 
500 triangles Simplified mesh + 
normal mapping Paolo Cignoni 
Image courtesy of Maksim on Wikimedia Commons. License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>For this course, assume UV given per vertex 
Mesh Parameterization: Theory and Practice 
Kai Hormann, Bruno Lvy and Alla Sheffer
 ACM SIGGRAPH Course Notes, 2007 
http://alice.loria.fr/index.php/publications.html?redir
ect=0&amp;Paper=SigCourseParam@2007&amp;Author=Lev
y 
 
 
16 To Learn More</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Texture Mapping 
3D model 
 Texture mapped model 
Image: Praun et al.  ? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.  Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>You can store an object-space normal 
 Convenient if you have a 
unique parameterization 
 ....but if you want to use a tiling 
 normal map, this will not work 
 Must account for the curvature 
of the object! 
 Think of mapping this diffuse+normal 
map combination on a cylindrical tower 
 Solution: Tangent space normal map 
 Encode a difference from the 
geometric normal in a local coord. system 38 Normal Map Details</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>0 at integer locations 
 Pseudo-random derivative (1D gradient)  
at integer locations 
 define local linear functions 
 Interpolate at location P 1D Noise 
49 noise 
value 
x P</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Precompute (1D) table of n gradients G[n] 
 Precompute (1D) permutation P[n]  
 For 3D grid point i, j, k :  
G(i,j,k) = G[ ( i + P[ (j + P[k]) mod n ] ) mod n ]  
 
 
 In practice only n gradients are stored! 
 But optimized so that they are well distributed 
54 Computing Pseudo-random Gradients</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 Thats All For Today! 
Justin Legakis Justin Legakis 
Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>From data : texture mapping  
 read color and other information  
from 2D images 
 
 
 
 Procedural : shader 
 write little programs that compute 
color/info as a function of location 
5 
Two Approaches 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>A scale is also called an octave in noise parlance 
 
55 Noise At One Scale 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Generating Normal Maps 
 Model a detailed mesh 
 Generate a UV parameterization for the mesh 
 A UV mapping such that each 3D point has unique 
image coordinates in the 2D texture map 
 This is a difficult problem, but tools are available 
 E.g., the DirectX SDK  has functionality to do this 
 Simplify the mesh (again, see DirectX SDK) 
 Overlay simplified and original model 
 For each point P on the simplified mesh, find 
closest point P on original model (ray casting) 
 Store the normal at P in the normal map. Done!</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Looks like marble! 
59 sin (x + sum 1/ f |noise|) 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Each vertex P stores 2D (u, v) texture coordinates 
 UVs determine the 2D location in the texture for the vertex  
 We will see how to specify them later 
 Then we interpolate using barycentrics 
11 UV Coordinates 
(u0, v0) 
(u1, v1) (u2, v2) u v (u0+u1+u2, 
v0+v1+v2)</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Slide from Epic Games 
3D Model UV Mapping 
 Epic Games Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Absolute value introduces C1 discontinuities 
58 sum 1/f |noise| 
 
 a.k.a. turbulence 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Programmable shader provide great flexibility 
 Shaders can be extremely complex 
 10,000 lines of code! 
 Writing shaders is a black art 
67 Bottom Line</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Noise: one ingredient of shaders 
 Can also use textures 
 Shaders control diffuse color, but also specular 
components, maybe even roughness (exponent), 
transparency, etc. 
 Shaders can be layered (e.g. a layer of dust, 
peeling paint, mortar between bricks).  
 Notion of shade tree  
 Pretty much algebraic tree 
 Assignment 5:  
checkerboard shader based on two shaders 
66 Shaders</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 Questions?</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>What of non-triangular geometry? 
 Spheres, etc. 
 
 No vertices, cannot specify UVs that way! 
 
 Solution: Parametric Texturing 
 Deduce (u, v) from (x, y, z) 
 Various mappings are possible.... 
20 Mathematical Mapping</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>The normal vector is really important in conveying 
the small-scale surface detail 
 Remember cosine dependence 
 The human eye is really good at 
picking up shape cues from lighting! 
 
 We can exploit this and look up also the normal 
vector from a texture map 
 This is called normal mapping or bump mapping 
 A coarse mesh combined with detailed normal maps can 
convey the shape very well! 
32 We Can Go Even Further...</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>That is, each octave f has weight 1/ f 
57 Sum 1/f noise 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Modeling from photographs 
 Using input photos as textures 
24 Projective Texture Example 
Figure from Debevec, Taylor &amp; Malik 
http://www.debevec.org/Research   ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Specify texture coordinates (u,v) at each vertex 
 Canonical texture coordinates (0,0)  (1,1) 
 Wrap around when coordinates are outside (0, 1) Texture Tiling 
seamless tiling (repeating) tiles with visible seams 
(0,0) (3,0) (0,3) 
(0,0) (3,0) (0,3) 
(0,0) (1,1) 
(0,0) (1,1) Note the range (0,1) unlike 
normalized screen coordinates!</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Texture mapping can be used to alter some or all 
of the constants in the illumination equation 
 Diffuse color kd, specular exponent q, specular color ks... 
 Any parameter in any BRDF model! 
 
 
 
kd in particular is often read from a  texture map 
29 Texture Mapping &amp; Illumination 
Constant Diffuse Color 
 Diffuse Texture Color 
 Texture used as Label 
 Texture used as Diffuse Color</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Texture Mapping 
Texture 
mapped model Image: Praun et al.  
Texture map (2D image) 
For each point 
rendered, look up 
color in texture map 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /. Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Gloss Mapping Example 
Spatially varying kd and ks Ron Frazier 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Pseudo random 
 For arbitrary dimension 
 4D is common for animation 
 Smooth 
 Band pass (single scale) 
 Little memory usage 
 
 How would you do it? 
47 Requirements</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Each vertex P stores 2D (u, v) texture coordinates 
 UVs determine the 2D location in the texture for the vertex  
 We will see how to specify them later 
 Then we interpolate using barycentrics 
12 UV Coordinates 
(u0, v0) 
(u1, v1) (u2, v2) u v</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39 Questions? Epic Games 
Image from Epic Games has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Given an input point P 
 For each of its neighboring grid points:  
 Get the "pseudo-random" gradient vector G 
 Compute linear function (dot product GdP)  
 Take weighted sum,  
using separable cubic  
weights  
[demo in 2D]  
53 Algorithm in 3D</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>A scale is also called an octave in noise parlance 
 But multiple octaves 
are usually used,  
where the scale  
between two octaves 
is multiplied by 2 
 hence the name 
octave 
56 Noise At Multiple Scales 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Questions? 
Image removed due to copyright restrictions.  Please the image of blueglass.gif from 
http://mrl.nyu.edu/~perlin/imgs/imgs.html.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Questions?</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Critical component of  
procedural textures 
 Pseudo-random function 
 But continuous 
 band pass (single scale) 
 Useful to add lots of visual detail 
http://www.noisemachine.com/talk1/index.html  
http://mrl.nyu.edu/~perlin/doc/oscar.html  
http://mrl.nyu.edu/~perlin/noise/  
http://en.wikipedia.org/wiki/Perlin_noise 
http://freespace.virgin.net/hugo.elias/models/m_perlin.htm   
 (not really Perlin noise but very good) 
http://portal.acm.org/citation.cfm?id=325247  
46 Perlin Noise 
 Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 n2 
n1 P  Compute the values from the two neighboring 
linear functions: n1 = dx*G1; n2=(dx-1)*G2 
 dot product in 3D.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>The corona was made as follows:  
 Create a smooth gradient function the drops off 
radially from bright yellow to dark red.  
 Phase shift this function by adding a turbulence 
texture to its domain.  
 Place a black cutout disk over the image.  
 Animation 
 Scale up over time 
 Use higher dim noise (for time) 
http://www.noisemachine.com/talk1/imgs/flame500.html   
63 Corona 
Slides by Ken Perlin Image of corona removed due to copyright restrictions.  
Please see the link below for further details.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 
BRDF in Matrix II &amp; III 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Effect of Textures 
Courtesy of Jeremy Birn.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 Normal Map Example 
Diffuse texture kd Normal Map 
Final render Models and images: Trevor Taylor 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Projective Mappings 
 A slide projector 
 Analogous to a camera! 
 Usually perspective 
projection tells us where 
points project to in our 
image plane 
 This time we will use 
these coordinates as UVs 
 No need to specify  
texture coordinates  
explicitly Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Projective Mappings 
 We are given the 
camera matrix H of the 
slide projector 
 For a given 3D point P 
 Project onto 2D space 
of slide projector: HP 
 results in 2D texture 
coordinates Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Marble 
 recall sin (x[0] + sum 1/ f |noise|)  
BoringMarble  = colormap  (sin(x[0]) 
Marble = colormap  (sin(x[0]+turbulence)) 
http://legakis.net/justin/MarbleApplet/   
 Wood 
replace x (or parallel plane)  
by radius 
Wood = colormap  (sin(r+turbulence)) 
 http://www.connectedpixel.com/blog/texture/wood 
62 Noise For Solid Textures 
 Ken Perlin . All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Texture Mapping 
Image of a cartoon of a man applying wall paper has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Cubic lattice  
 Zero at vertices 
 To avoid low frequencies 
 Pseudo-random gradient  
at vertices 
 define local linear functions 
 Splines to interpolate the values  
to arbitrary 3D points 
48 Perlin Noise</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Functions executed when light interacts with a 
surface 
 Constructor: 
 set shader parameters  
 Inputs: 
 Incident radiance 
 Incident and reflected light directions 
 Surface tangent basis (anisotropic shaders only) 
 Output: 
 Reflected radiance 
40 Shaders ( Material  class)</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Questions? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>For each shaded point, normal is given by a 2D 
image normalMap  that stores the 3D normal 
 For a visible point 
interpolate UV using barycentric  
       // same as texture mapping 
Normal = normalMap[U,V] 
compute shading (BRDF) using this normal 
33 Normal Mapping</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>34 Normal Map Example 
Original Mesh 
4M triangles Paolo Cignoni 
Image courtesy of Maksim on Wikimedia Commons. License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 
P dx: fractional x coordinate 
 Gradients G1 and G2 at neighboring vertices 
 Scalars in 1D. They are 3D vectors in 3D 
 We know that noise is zero at vertices</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>All materials seen so far are the same everywhere 
 In other words, we are assuming the BRDF is independent 
of the surface point x 
 No real reason to make that assumption 
3 Spatial Variation 
 ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission. source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Goal : flatten 3D object onto 2D UV coordinates 
 For each vertex, find coordinates U,V such that 
distortion is minimized 
 distances in UV correspond to distances on mesh 
 angle of 3D triangle same as angle of triangle in UV plane 
 Cuts are usually required (discontinuities) 
15 Texture UV Optimization 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 w1 w2 
n2 
n1 P  Compute the values from the two neighboring 
linear functions: n1 = dx*G1; n2=(dx-1)*G2 
 dot product in 3D 
 Weight w1=3dx22dx3 and w2=3(1dx)22(1dx)3
 
ie: noise=w1 G1 dx + w2 G2 (dx- 1)</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Questions?</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>sum 1/ f(noise ) sum 1/f( |noise | ) 
60 Comparison 
noise                               sin (x + sum 1/f(  |noise | ))  
 Ken Perlin . All rights reserved. 
This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Planar 
 Vertex UVs and 
linear interpolation 
is a special case! 
 Cylindrical 
 Spherical  
 Perspective  
Projection 
21 Common Texture Coordinate Mappings 
Planar 
Spherical Spherical Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Texture Mapping 
Texture 
mapped model Image: Praun et al.  
Texture map (2D image) 
We need a function 
that associates each 
surface point with a 
2D coordinate in the 
texture map 
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
 ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /. Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>We will allow BRDF parameters to vary over space 
 This will give us much more complex surface appearance 
 e.g. diffuse color kd vary with x  
 Other parameters/info can vary too: ks, exponent, normal 
4 Spatial Variation 
 ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission.  source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Video removed due to copyright restrictions.  Please see  
http://www.youtube.com/watch?v=RPhGEiM_6lM  for further details.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Advantages: 
 easy to implement in ray tracer  
 more compact than texture maps 
(especially for solid textures)  
 infinite resolution 
 
 Disadvantages 
non-intuitive  
 difficult to match existing texture 
44 Procedural Textures</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>31 Questions?</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 Procedural Textures 
Image by Turner Whitted 
 Alternative to 
texture mapping 
 Little program that 
computes color as a 
function of x,y,z: 
f(x,y,z) color 
 Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Per-vertex (u, v) texture coordinates are specified: 
 Manually, provided by user (tedious!) 
 Automatically using parameterization optimization 
 Mathematical mapping (independent of vertices) 
14 UV Coordinates? 
(u0, v0) 
(u1, v1) (u2, v2) u v</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Collision Detection and Response (PDF - 1.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec10/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>13</slideno>
          <text>Hierarchy of bounding spheres 
Organized in a tree  
Recursive test with early pruning 
14 Hierarchical Collision Test  
Root encloses 
whole object 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Robust Treatment of Simultaneous Collisions  
David Harmon, Etienne Vouga, Rasmus Tamstorf, Eitan  Grinspun  
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>boolean intersect(node1, node2) 
   // no overlap? ==&gt; no intersection! 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
    // recurse down the larger of the two nodes 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true 
 
   // no intersection in the subtrees? ==&gt; no intersection!    return false 
16 Pseudocode (simplistic version)</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Detection 
Response 
Overshooting problem  
(when we enter the solid) 
2 Collisions</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Using axis -aligned bounding box 
center=  
((xmin+xmax)/2, (ymin+ymax)/2, (zmin, zmax)/2) 
Better than the average of the vertices because does not suffer from non -uniform tessellation  
28 Bounding Sphere of a Set of Points 
 Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>A cloth has many points of contact 
Stays in contact 
Requires 
Efficient collision detection  
Efficient numerical treatment (stability)  
34 The Cloth Collision Problem 
Image from Bridson et al.   
 AC
M. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>http://isg.cs.tcd.ie/spheretree/ 
15 Examples of Hierarchy 
 Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/. Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
21  G
areth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4 Collision Response for Particles 
N v 
vn vt 
v=vn+vt 
normal component 
tangential component</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Imagine we have n objects. Can we test all pairwise 
intersections? 
Quadratic cost O(n2)! 
 
Simple optimization: separate static objects  
But still O(static  dynamic+ dynamic2) 
10 Collision Detection in Big Scenes</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Collision Response for Particles 
N v</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Use simpler conservative proxies  
(e.g. bounding spheres) 
 
Recursive (hierarchical) test 
Spend time only for parts of the scene that are close  
 
Many different versions, we will cover only one 
 
 
11 Hierarchical Collision Detection</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3Top-Down Construction - Recurse 
Questions? 
 Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
 Gareth Bradshaw. All rights reserved.
This content is excluded from our Creative
Commons license. For more information, 
see http://ocw.mit.edu/help/faq-fair-use/. 
This image is in the public domain.Source: Wikimedia Commons .
 Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.
32</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Tangential velocity vt  
often unchanged 
Normal velocity vn reflects: 
 
  
Coefficient of restitution  
 
When  = 1, mirror reflection 
5 Collision Response for Particles 
N v 
vn vt 
N v vnew 
N v vnew =1 
&lt;1</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
Solution: Back up 
Compute intersection point  
Ray- object intersection!  
Compute response there  
Advance for remaining  
fractional time step  
7 Collisions  Overshooting 
backtracking xi 
xi+1</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
 Sara McMains. All righ ts reserved. This contentTop-Down Construction - Recurse 
is excluded from our Creative Commons license.
For more information, seehttp://ocw.mit.edu/help/faq-fair-use/.
 Gareth Bradshaw. All rights reserved.This content is excluded from our CreativeCommons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.
This image is in the public domain.Source: Wikimedia Commons .
 Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.
31</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Reference 
Image of the cover of the book, "Real Time Collision Detection," by Christer Ericson has been removed
due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Two spheres, centers C1 and C2, radii r1 and r2 
Intersect only if ||C 1C2||&lt;r1+r2 
13 Sphere-Sphere Collision Test  
C1 C2 r1 r2 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Pong:  =? 
http://www.youtube.com/watch?v=sWY0Q_lMFfw  
http://www.xnet.se/javaTest/jPong/jPong.html  
9 Questions? 
 
Animation removed due to copyright restrictions.
Image courtesy of Chris Rand  on Wikimedia Commons. License:  CC-BY-SA.
This content is excluded from our Creative Commons license. For more info
rmation, see http://ocw.mit
.edu/help/faq-fair-use/ . This image is in the public domain.
Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
Solution: Back up 
Compute intersection point  
Ray- object intersection!  
Compute response there  
Advance for remaining  
fractional time step  
Other solution: 
Quick and dirty hack 
Just project back to object closest point 
8 Collisions  Overshooting 
fixing backtracking xi 
xi+1</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Place spheres around objects  
If spheres do not intersect, neither do the objects!  
Sphere-sphere collision test is easy. 
12 Bounding Spheres 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false  
   // if there is nowhere to go, test everything 
   if (node1- &gt;isLeaf() &amp;&amp; node2-&gt;isLeaf()) 
      perform full test between all primitives within nodes 
    // otherwise go down the tree in the non- leaf path 
   if ( !node2- &gt;isLeaf() &amp;&amp; !node1- &gt;isLeaf() ) 
      // pick the larger node to subdivide, then recurse 
   else       // recurse down the node that is not a leaf     return false 
23 Pseudocode (with leaf case)</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Take longest scene dimension 
 Cut in two in the middle 
 assign each object or triangle to one side 
 build sphere around it 
30 Top-Down Construction 
 Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.This image is in the public domain.
Source: Wikimedia Commons . Sara McMains . All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /. Gareth Bradshaw. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Using axis -aligned bounding box 
center=  
((xmin+xmax)/2, (ymin+ymax)/2, (zmin, zmax)/2) 
Better than the average of the vertices because does not suffer from non -uniform tessellation  
29 Bounding Sphere of a Set of Points 
Questions?  
 Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>http://www.youtube.com/watch?v=b_cGXtc-nMg 
http://www.youtube.com/watch?v=nFd9BIcpHX4&amp;f
eature=related 
http://www.youtube.com/watch?v=2SXixK7yCGU 
25 Questions?</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837  D
urand  
MIT EECS 6.837 Computer Graphics 
Collision Detection  
and Response 
Philippe Halsman : Dali Atomicus  MIT EECS 6.837  Matusik 
This image is in the public domain. Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
node 1 
node 2 
 G
areth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
 Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Axis Aligned Bounding Boxes  
R-Trees 
 
Oriented bounding boxes  
 S. Gottschalk, M. Lin, and D. Manocha. OBBTree: A hierarchical Structure 
for rapid interference detection, Proc. Siggraph 96. ACM Press, 1996 
 
Binary space partitioning trees; kd-trees  
24 Other Options</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Top down 
Divide and conquer  
 
Bottom up 
Cluster nearby objects 
 
Incremental 
Add objects one by one, binary-tree style.  
26 Hierarchy Construction</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Trivial given center C 
radius = max i ||C-Pi|| 
27 Bounding Sphere of a Set of Points 
C 
 Gareth Bradsha
w. All rights reserved. This content is excluded  from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Usually, we detect collision when it is too late: 
we are already inside 
6 Collisions  Overshooting 
xi 
xi+1</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Graphics Pipeline and Rasterization (PDF - 2.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec21/</lecture_pdf_url>
      <lectureno>21</lectureno>
      <slides>
        <slide>
          <slideno>69</slideno>
          <text>Compute the boundary pixels using line rasterization  
 Fill the spans 
70 Oldschool Rasterization 
More annoying to 
implement than edge 
functions 
 
Not faster unless 
triangles are huge Questions?</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>89 Modern Graphics Pipeline 
 Perform projection of 
vertices 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility, update frame 
buffer 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 A Solution: Clipping 
(eyex, eyey, eyez) 
image plane "clip" geometry to 
view frustum, discard 
outside parts 
z axis   + 
z=near  z=far</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 GPUs do Rasterization 
 The process of taking a 
triangle and figuring out 
which pixels it covers is 
called rasterization  
 Weve seen acceleration 
structures for ray 
tracing; rasterization is 
not stupid either 
 Were not actually going 
to test all pixels for each 
triangle 
Scene 
primitives Pixel raster Keep closest hit GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel?</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>We compute the line equation for many useless 
pixels 
 What could we do? 
62 Can We Do Even Better?</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Compute the boundary pixels using line rasterization  
 Fill the spans 
68 Oldschool Rasterization</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions E i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
56 Rasterization Pseudocode 
Bounding box clipping is easy, 
just clamp the coordinates to 
the screen rectangle Note: No 
visibility 
Questions?</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Orthographic 
 
 
 
 Perspective 
26 Orthographic vs. Perspective 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Rasterizes with plane tests instead of edge tests 
Removes the need for clipping! 
86 Homogeneous Rasterization Recap 
3D triangle 2D pixel 
(x, y, 1) 
Questions?</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Hierarchical rasterization! 
 Conservatively test blocks of pixels before 
going to per-pixel level (can skip large blocks at once) 
 Usually two levels 
65 Indeed, We Can Be Smarter 
Can also test if an entire 
block is inside the 
triangle; then, can skip 
edge functions tests for 
all pixels for even further 
speedups.(Must still test 
Z, because they might 
still be occluded.)</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? 
Scene 
primitives Scene 
primitives 
Pixel raster 
Pixel raster Keep closest hit Keep closest hit</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Brute Force Rasterizer 
Problem?  Compute E1, E2 , E3 coefficients from projected 
vertices 
 For each pixel (x, y) 
 Evaluate edge functions at pixel center 
 If all non-negative, pixel is in!</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>These projections matrices work perfectly in the 
sense that you get the proper 2D projections of 3D 
points. 
 However, since we are flattening the scene onto the 
z=1 plane, weve lost all information about the 
distance to camera. 
 We need the distance for Z buffering, i.e., figuring out 
what is in front of what! 
32 Caveat</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Rasterization Advantages Weiler, Atherton 1977  
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>How do we know which parts are visible/in front? 
90 Visibility</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions a ix + b iy + c i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
58 Can We Do Better?  
These are linear functions of 
the pixel coordinates (x,y), i.e., 
they only change by a constant 
amount when we step from x to 
x+1 (resp. y to y+1)</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Trivial: Just ass another dimension y and treat it like x 
 Different fields of view and non-square image aspect 
ratios can be accomplished by simple scaling of the x 
and y axes. 
31 
Extension to 3D</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Edge Functions 
49  The triangles 3D edges project to line segments in 
the image (thanks to planar perspective) 
 The interior of the triangle is the set of points that is 
inside all three halfspaces defined by these lines</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Avoid degeneracies  
 Dont draw stuff  
behind the eye 
 Avoid division  
by 0 and overflow 
76 
Why Clip? 
z=near  
z=far</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>What needs to be stored in memory in each case? 
10 What are the Main Differences? 
Ray Casting 
For each pixel (ray)  
  For each triangle  
    Does ray hit triangle?  GPU 
For each triangle  
  For each pixel  
    Does triangle cover pixel?  
Keep closest hit Keep closest hit 
Ray-centric Triangle-centric</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 For each pixel, 
test 3 edge equations 
 if all pass, draw pixel 
 
 Compute per-pixel color 
 Test visibility (Z-buffer), 
update frame buffer color 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 
Questions? 
Call of Duty: Modern Warfare 2 by Infinity Ward Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Idea: avoid projection (and division by zero) by 
performing rasterization in 3D  
 Or equivalently, use 2D homogenous coordinates 
(w=z after the projection matrix, remember) 
 
Motivation: clipping is annoying 
 
Marc Olano, Trey Greer: Triangle scan conversion 
using 2D homogeneous coordinates, Proc. ACM 
SIGGRAPH/Eurographics Workshop on Graphics 
Hardware 1997  
79 Homogeneous Rasterization</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 OpenGL Form of the Projection 
Input point in view 
coordinates Homogeneous coordinates 
within canonical view volume</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Perspective in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? 
Scene 
primitives Scene 
primitives 
Pixel raster 
Pixel raster Keep closest hit Keep closest hit 
Its just a different order of the loops!</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Given 3D triangle 
  setup plane equations 
  (plane through viewpoint &amp; triangle edge) 
  For each pixel x,y 
    compute plane equations for (x,y,1) 
    if all pass, draw pixel 
83 Homogeneous Rasterization 
3D triangle 2D pixel 
(x, y, 1) plane equation 
plane equation</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Perform projection of vertices 
 Rasterize triangle: find which 
pixels should be lit 
 Compute per-pixel color 
 Test visibility, 
update frame buffer color 
 Store minimum distance to camera 
for each pixel in Z-buffer 
 ~same as tmin in ray casting! 
if newz &lt;  zbuffer[x,y] 
    zbuffer[x,y] =new_z 
    framebuffer[x,y] =new_color 
21 Modern Graphics Pipeline 
Z buffer frame buffer  Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Graphics Pipeline &amp; Rasterization 
MIT EECS 6.837  Matusik Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Details/more intuition in handout 
 Understanding Projections and Homogenous 
Coordinates 
42 OpenGL Form of the Projection</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>The triangles 3D edges project to line segments in 
the image (thanks to planar perspective) 
 Lines map to lines, not curves 
48 Edge Functions</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Rasterization (Scan Conversion) 
glBegin(GL_TRIANGLES)  
glNormal3f(...)  
glVertex3f(...)  
glVertex3f(...)  
glVertex3f(...)  
glEnd();  Given a triangles vertices &amp;  
extra info for shading, figure 
out which pixels to "turn on"  
to render the primitive 
 Compute illumination values to 
"fill in" the pixels within the 
primitive 
 At each pixel, keep track of  
the closest primitive (z-buffer) 
 Only overwrite if triangle being 
drawn is closer than the previous 
triangle in that pixel 
 source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>z=(az+b)/z =a+b/z    
 where a &amp; b depend on near &amp; far 
 Similar enough to our basic idea: 
 z=1/z 
41 OpenGL Form of the Projection</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Improvement: Scan over only the pixels that overlap 
the screen bounding box  of the triangle 
 How do we get such a bounding box? 
 Xmin, Xmax, Ymin, Ymax of the projected triangle vertices 
54 Easy Optimization</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>For every triangle 
Compute Projection, color at vertices 
Setup line equations 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Increment line equations 
Compute curentZ 
Compute currentColor 
If all line equations&gt;0 //pixel [x,y] in triangle   
If currentZ&lt;zBuffer[x,y] //pixel is visible 
  Framebuffer[x,y]=currentColor 
zBuffer[x,y]=currentZ 
94 Z-buffer pseudo code</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Perspective in 2D 
The projected point in 
homogeneous 
coordinates 
(we just added w=1): 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Modern graphics hardware enables the execution of 
rather complex programs to compute the color of every 
single pixel 
 More later 
88 Pixel Shaders 
 iridescence Procedural texture,  
Anisotropic brdf 
Translucence 
Backlighting 
 NVIDIA. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Primitives are continuous geometric objects; 
screen is discrete (pixels) 
46 2D Scan Conversion</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Restricted to scan-convertible primitives 
 Pretty much: triangles  
 Faceting, shading artifacts 
 This is largely going away 
with programmable per-pixel 
shading, though 
 No unified handling of 
shadows, reflection, 
transparency 
 Potential problem of 
overdraw (high depth 
complexity) 
 Each pixel touched 
many times 
15 Rasterization Limitations 
scan conversion 
gouraud shading ray tracing 
scan conversion 
flat shading 
 Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Homogeneous Rasterization 
2D rasterization 
80</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Replace 2D edge equation by 3D plane equation 
 Treat pixels as 3D points ( x, y, 1) on image plane, test for 
containment in 3 halfspaces just like edge functions 
82 Homogeneous Rasterization 
2D rasterization 3D (homogenous) 
rasterization</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Modern scenes are more complicated than images 
 A 1920x1080 frame at 64-bit color and 32-bit depth per 
pixel is 24MB (not that much) 
 Of course, if we have more than one sample per pixel this gets 
larger, but e.g. 4x supersampling is still a relatively comfortable 
~100MB 
 Our scenes are routinely larger than this 
 This wasnt always true 
12 Rasterization Advantages</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>For every triangle  
ComputeProjection  
Compute bbox, clip bbox to screen limits  
For all scanlines y in bbox  
Evaluate all E is at (x0,y): E i = aix0 + b iy + ci 
For all pixels x in bbox  
    If all E i&gt;0  
     Framebuffer[x,y ] = triangleColor 
    Increment line equations: E i += ai 
 
 We save ~two multiplications and 
two additions per pixel when the 
triangle is large 
59 Incremental Edge Functions</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>How do we get Z? 
 Texture Mapping? 
96 More questions for next time</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Compute the boundary pixels using line rasterization  
 Fill the spans 
69 Oldschool Rasterization 
More annoying to 
implement than edge 
functions 
 
Not faster unless 
triangles are huge</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Advantages 
 Generality: can render anything 
that can be intersected with a ray 
 Easily allows recursion (shadows, reflections, etc.) 
 
 Disadvantages 
 Hard to implement in hardware (lacks computation 
coherence, must fit entire scene in memory, bad memory 
behavior) 
 Not such a big point any more given general purpose GPUs 
 Has traditionally been too slow for interactive applications 
 Both of the above are changing rather rapidly right now! 
16 Ray Casting / Tracing</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>z = 1 before homogenization 
z=1/z after homogenization 
34 Basic Idea: store 1/ z</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Hierarchical rasterization! 
 Conservatively test blocks of pixels before 
going to per-pixel level (can skip large blocks at once) 
 Usually two levels 
64 Indeed, We Can Be Smarter 
Conservative tests of 
axis-aligned blocks vs. 
edge functions are not 
very hard, thanks to 
linearity. See  Akenine-
Mller and Aila, Journal 
of Graphics Tools 10(3), 
2005.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Perform rotation/translation/other transforms to put 
viewpoint at origin and view direction along z axis 
 This is the OpenGL modelview matrix 
 
 Combine with projection matrix (perspective or 
orthographic) 
 Homogenization achieves foreshortening 
 This is the OpenGL projection matrix 
 
Corollary : The entire transform from object space to 
canonical view volume [-1,1]3 is a single matrix 
44 Recap: Projection Questions?</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>The final image is obtained by merely 
dropping the z coordinate after 
projection (orthogonal projection)  We can transform the frustum by a modified 
projection in a way that makes it a square (cube in 
3D) after division by w. 
36 The View Frustum in 2D 
x z 
x/w z/w</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 Homogeneous Rasterization 
2D rasterization 3D (homogenous) 
rasterization  Replace 2D edge equation by 3D plane equation 
 Plane going through 3D edge and viewpoint 
 Still a halfspace, just 3D</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Use graphics hardware, via OpenGL or DirectX 
 OpenGL is multi-platform, DirectX is MS only 
 
 
 
 
 
 
 
 
 Most global effects available in ray tracing will be 
sacrificed for speed, but some can be approximated 
3 How Do We Render Interactively? 
OpenGL rendering  Our ray tracer 
 Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>71 What if the pz is &gt; eyez? 
(eyex, eyey, eyez) 
image plane z axis   +</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Works for triangles behind eye 
 Still linear, can evaluate incrementally/hierarchically 
like 2D 
84 Homogeneous Rasterization 
3D triangle 2D pixel 
(x, y, 1)</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Edge Functions 
 The triangles 3D edges project to line segments in 
the image (thanks to planar perspective) 
 The interior of the triangle is the set of points that is 
inside all three halfspaces defined by these lines</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Test visibility (Z-buffer), 
update frame buffer color 
 
 Compute per-pixel color 
 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions E i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
55 Rasterization Pseudocode 
Bounding box clipping is easy, 
just clamp the coordinates to 
the screen rectangle Note: No 
visibility</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Perspective in 2D 
Well just copy z to w, and 
get the projected point 
after homogenization! 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>Next time: 
Screen-space interpolation, visibility, shading 
97 Thats All For Today! 
Uncharted 2 by Naughty Dog / Sony Screenshot from the video game Uncharted 2  has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>In this basic form, ray tracing needs the entire scene 
description in memory at once 
 Then, can sample the image completely freely 
 The rasterizer only needs one triangle at a time, plus 
the entire image and associated depth information for 
all pixels  11 What are the Main Differences? 
Ray Casting 
For each pixel (ray)  
  For each triangle  
    Does ray hit triangle?  GPU 
For each triangle  
  For each pixel  
    Does triangle cover pixel?  
Keep closest hit Keep closest hit 
Ray-centric Triangle-centric</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Compute E1, E2 , E3 coefficients from projected 
vertices 
 Called triangle setup, yields ai, bi, ci for i=1,2,3 
51 Brute Force Rasterizer</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Compute E1, E2 , E3 coefficients from projected 
vertices 
 For each pixel (x, y) 
 Evaluate edge functions at pixel center 
 If all non-negative, pixel is in! 
 
53 Brute Force Rasterizer 
If the triangle is 
small, lots of useless  
computation if we 
really test all pixels</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>95 Works for hard cases!</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>(In 3D this is a truncated pyramid.) 
37 The View Frustum in 2D 
image xmin image xmax</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 GPUs do Rasterization 
 The process of taking a 
triangle and figuring out 
which pixels it covers is 
called rasterization 
Scene 
primitives Pixel raster Keep closest hit GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel?</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>View Frustum Culling 
 Use bounding volumes/hierarchies to test whether any 
part of an object is within the view frustum 
 Need frustum vs. bounding volume intersection test 
 Crucial to do hierarchically when scene has lots of objects! 
 Early rejection (different from clipping) 
78 Related Idea 
See e.g. Optimized view 
frustum culling 
algorithms for bounding 
boxes , Ulf Assarsson 
and Tomas Mller, 
journal of graphics 
tools, 2000. Questions? 
 Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>For each triangle 
  transform into eye space 
  (perform projection) 
  setup 3 edge equations 
  for each pixel x,y 
    if passes all edge equations 
      compute z 
      if z&lt;zbuffer[x,y] 
        zbuffer[x,y]=z 
        framebuffer[x,y]=shade() 
23 Modern Graphics Pipeline 
Questions?  Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>For every triangle  
ComputeProjection  
Compute bbox, clip bbox to screen limits  
For all scanlines y in bbox  
Evaluate all E is at (x0,y): E i = aix0 + b iy + ci 
For all pixels x in bbox  
    If all E i&gt;0  
     Framebuffer[x,y ] = triangleColor 
    Increment line equations: E i += ai 
 
 We save ~two multiplications and 
two additions per pixel when the 
triangle is large 
60 Incremental Edge Functions 
Can also zig-zag to avoid 
reinitialization per scanline, 
just initialize once at x0, y0</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>View Frustum Culling 
 Use bounding volumes/hierarchies to test whether any 
part of an object is within the view frustum 
 Need frustum vs. bounding volume intersection test 
 Crucial to do hierarchically when scene has lots of objects! 
 Early rejection (different from clipping) 
77 Related Idea 
See e.g. Optimized view 
frustum culling 
algorithms for bounding 
boxes , Ulf Assarsson 
and Tomas Mller, 
journal of graphics 
tools, 2000. 
 Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>For a really HC piece of rasterizer engineering, see 
the hierarchical Hilbert curve rasterizer by McCool, 
Wales and Moule.  
 (Hierarchical? Well look at that next..) 
61 Questions? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Basic Idea: store 1/ z</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>In addition to frame buffer (R, G, B) 
 Store distance to camera ( z-buffer) 
 Pixel is updated only if newz is closer  
than z-buffer value 
93 Z buffer</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 
Clipping 
bottom  top 
right left 
near far  Eliminate portions of objects 
outside the viewing frustum 
 View Frustum  
 boundaries of the image  
plane projected in 3D 
 a near &amp; far  
clipping plane 
 User may define  
additional clipping  
planes 
Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Rasterizes with plane tests instead of edge tests 
Removes the need for clipping! 
85 Homogeneous Rasterization Recap 
3D triangle 2D pixel 
(x, y, 1)</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>In ray casting, use intersection with closest t 
 Now we have swapped the loops (pixel, object) 
 What do we do? 
92 Visibility</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Maintain intersection with closest object 
91 Ray Casting</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Projection 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility (Z-buffer), 
update frame buffer 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 We now have screen 
coordinates 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility (Z-buffer), 
update frame buffer 
 Khronos Group. All rights reserved. This  content is excluded
from our Creative Commons license. For more information,
see h t
tp://ocw.mit.edu/help/faq-fair-use/. source u n
known. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Henry Fuchs, Jack Goldfeather, Jeff Hultquist, Susan Spach, John 
Austin, Frederick Brooks, Jr., John Eyles and John Poulton, Fast 
Spheres, Shadows, Textures, Transparencies, and Image 
Enhancements in Pixel-Planes, Proceedings of SIGGRAPH 85 
(San Francisco, CA, July 2226, 1985). In Computer Graphics , 
v19n3 (July 1985), ACM SIGGRAPH, New York, NY, 1985. 
 Juan Pineda, A Parallel Algorithm for Polygon Rasterization, 
Proceedings of SIGGRAPH 88 (Atlanta, GA, August 15, 1988). 
In Computer Graphics , v22n4 (August 1988), ACM SIGGRAPH, 
New York, NY, 1988. Figure 7: Image from the spinn
ing teapot 
performance test. 
 Marc Olano Trey Greer, Triangle Scan Conversion using 2D 
Homogeneous Coordinates, Graphics Hardware 97 
http://www.cs.unc.edu/~olano/papers/2dh-tri/2dh-tri.pdf  
66 Further References</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Point of the exercise: This gives screen coordinates 
and depth values for Z-buffering with unified math 
 Caveat: OpenGL and DirectX define Z differently [0,1] vs.[-1,1] 
39 The Canonical View Volume 
x = -1 x = 1 z = -1 z = 1</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 What if the pz is &lt; eyez? 
(eyex, eyey, eyez) 
image plane z axis   +</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Perspective in 2D 
Projectively 
equivalent 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Perform rotation/translation/other transforms to put 
viewpoint at origin and view direction along z axis 
 This is the OpenGL modelview matrix 
 
 Combine with projection matrix (perspective or 
orthographic) 
 Homogenization achieves foreshortening 
 This is the OpenGL projection matrix 
 
Corollary : The entire transform from object space to 
canonical view volume [-1,1]3 is a single matrix 
43 Recap: Projection</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 What if the pz = eyez? 
(eyex, eyey, eyez) 
image plane ??? z axis   + When w = 0, point projects to infinity 
(homogenization is division by w)</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? 
Scene 
primitives 
Pixel raster Keep closest hit 
4</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions a ix + b iy + c i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
57 Can We Do Better?</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>For each triangle 
  transform into eye space 
  (perform projection) 
  setup 3 edge equations 
  for each pixel x,y 
    if passes all edge equations 
      compute z 
      if z&lt;zbuffer[x,y] 
        zbuffer[x,y]=z 
        framebuffer[x,y]=shade() 
22 Modern Graphics Pipeline 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Input 
 Geometric model 
 Triangle vertices, vertex normals, texture coordinates 
 Lighting/material model (shader) 
 Light source positions, colors, intensities, etc.  
 Texture maps, specular/diffuse coefficients, etc. 
 Viewpoint + projection plane 
 
 Output 
 Color (+depth) per pixel Modern Graphics Pipeline 
Colbert &amp; Krivanek 18 Image of Real-Time Rendering of the Stanford Bunny
with 40 Samples per Pixel removed due to copyright
restrictions -- please see Fig. 20-1 from http://http.
develop
er.nvidia.com/GPUGems3/gpugems3_ch20.html
for further details. Oscar Meruvia
-Pastor, Daniel Rypl.
All rights reserved. This content is
excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Modern scenes are more complicated than images 
 A 1920x1080 frame (1080p) at 64-bit color and 32-bit 
depth per pixel is 24MB (not that much) 
 Of course, if we have more than one sample per pixel (later) this 
gets larger, but e.g. 4x supersampling is still a relatively 
comfortable ~100MB 
 Our scenes are routinely larger than this 
 This wasnt always true 
 
 A rasterization-based renderer can stream over the 
triangles, no need to keep entire dataset around 
 Allows parallelism and optimization of memory systems 
14 Rasterization Advantages</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Modern Graphics Pipeline 
 Project vertices to 2D 
(image) 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility (Z-buffer), 
update frame buffer 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>87 Modern Graphics Pipeline 
 Perform projection of 
vertices 
 
 Rasterize triangle: find 
which pixels should be lit 
 
 Compute per-pixel color 
 
 Test visibility, update frame 
buffer 
 Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/. source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see  http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Far and near are kind of arbitrary 
 They bound the depth storage precision 
38 The View Frustum in 2D 
image xmin image xmax</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>We can transform the frustum by a modified 
projection in a way that makes it a square (cube in 
3D) after division by w. 
35 Full Idea: Remap the View Frustum 
x z 
x/w z/w 
viewpoint view frustum  
(visible part of the scene)</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Compute the boundary pixels using line rasterization 
67 Oldschool Rasterization</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 Indeed, We Can Be Smarter 
?</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Use graphics hardware, via OpenGL or DirectX  
 OpenGL is multi-platform, DirectX is MS only 
 
 
 
 
 
 
 
 
2 How Do We Render Interactively? 
OpenGL rendering  Our ray tracer 
 Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Primitives are continuous geometric objects; 
screen is discrete (pixels) 
 Rasterization computes a discrete approximation in 
terms of pixels (how?) 
47 2D Scan Conversion</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Ray Casting II (PDF - 2.0MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec12/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>35</slideno>
          <text>36 
Constructive Solid Geometry (CSG) 
Should only 
count overlap 
region once! Given overlapping shapes A and B: 
 
 
 
     
  Union                   Intersection            Subtraction</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Or write it as a 2 2 linear system 
P(,  ) = a + e1 + e2 
e1 = (b- a), e2 = (c-a) 
22 How Do We Compute , ,  ? 
c 
a b P 
where 
and &lt;a,b&gt; is the dot product.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Ray Casting then Intersection 
52 Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Can get it from a variable using &amp; 
 often a BAD idea. see next slide 
 Can be dereferenced with * 
 float *px=new float; // px is a memory address to a float 
 *px=5.0; //modify the value at the address px 
 Should be instantiated with new. See next slide 
3 Pointers</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Ray Casting then Intersection 
54 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 MIT EECS 6.837  Durand  CSG Examples 
 David Kurlander. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Edges in triangle meshes 
 Must report intersection (otherwise not watertight) 
 Hard to get right 
64 The Evil</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Transform point 
 
 
 
 Transform direction 
74 Transforming Points &amp; Directions 
Homogeneous Coordinates:  
(x,y,z,w) 
w = 0  is a point at infinity (direction) 
 If you do not store w you need different routines to apply M to a 
point and to a direction ==&gt; Store everything in 4D!</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Use ray-plane intersection followed by in-triangle test 
 Or try to be smarter 
 Use barycentric coordinates 
11 Ray-Triangle Intersection 
Ro Rd c 
a b P</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Questions?</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>We have seen that transformations such as affine 
transforms are useful for modeling &amp; animation 
 How do we incorporate them into ray casting? 
66 Transformations and Ray Casting</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Peter Shirley et al.: 
Fundamentals of  
Computer Graphic s 
AK Peters 
 
 Ray Tracing 
Jensen 
Shirley 
Glassner 
33 Books 
Remember the ones at 
books24x7 mentioned 
in the beginning! 
Images of three book covers have been removed due to copyright restrictions.  Please see the 
following books for more details: 
-Shirley P., M. Ashikhmin and S. Marschner , Fundamentals of Computer Graphics 
-Shirley P. and R.K. Morley, Realistic Ray Tracing 
-Jensen H.W., Realistic Image Synthesis Using Photon Mapping</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Ray Casting then Intersection 
57 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>...but very hard  if you actually try to compute an 
explicit representation of the resulting surface as a 
triangle mesh 
 In principle very simple, 
but floating point numbers are not exact  
 E.g., points do not lie exactly on planes... 
 Computing the intersection A vs B is not necessarily the 
same as B vs A... 
 The line that results from intersecting two planes does not 
necessarily lie on either plane... 
 etc., etc. 
42 CSG is Easy with Ray Casting...</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 Recap: How to Transform Normals? 
Object Space World Space nOS nWS</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Ratio of opposite sub-triangle area to total area 
   = Aa/A       = Ab/A       = Ac/A 
 Use signed areas for points outside the triangle 
    
18 How Do We Compute , ,  ? 
c 
a b P Aa A</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
30 
Ray Casting: Object Oriented Design</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>CSG then Ray Casting 
50 Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Questions? 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 Implementing CSG 
1.Test "inside" intersections: 
 Find intersections with A,  
test if they are inside/outside B 
 Find intersections with B, 
test if they are inside/outside A 
 
2.Overlapping intervals: 
 Find the intervals of "inside" 
along the ray for A and B 
 How? Just keep an entry / exit bit 
for each intersection 
 Easy to determine from intersection 
normal and ray direction 
 Compute 
union/intersection/subtraction of the 
intervals</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Ray Casting then Intersection 
58 Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Questions? 
Image by Henrik Wann Jensen 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Collect Intersections 
 
 
 
 
 
 
      Union               Intersection            Subtraction Each ray 
processed 
separately! 
38</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>If M includes scaling, directionOS ends up  
NOT be normalized after transformation  
 
 Two solutions 
 Normalize the direction  
 Do not normalize the direction 
71 What About t ?</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 
Barycentric Intersection Pros 
Ro Rd c 
a b P  Efficient 
 Stores no plane equation 
 Get the barycentric coordinates for free 
 Useful for interpolation, texture mapping</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Or write it as a 2 2 linear system 
P(,  ) = a + e1 + e2 
e1 = (b- a), e2 = (c-a) 
20 How Do We Compute , ,  ? 
c 
a b P This should be zero 
Somethings wrong... This 
is a linear system of 3 
equations and 2 
unknowns!</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>CSG then Ray Casting 
49 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Questions? 
 Image computed using 
the RADIANCE 
system by Greg Ward 
 Martin Moeck . All rights reserved. This content is excluded from our Creative Commons 
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>A neat way to build complex objects from simple 
parts using Boolean operations 
 Very easy when ray tracing 
 Remedy used this in the Max Payne games for 
modeling the environments 
 Not so easy when not ray tracing :) 
34 Constructive Solid Geometry (CSG) 
 Rockstar Games. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>P(,,) = a + b + c 
with ++ =1 parameterizes the entire plane 
15 Barycentric Definition of a Triangle 
c 
a b P</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>69 MIT EECS 6.837  Durand  (0,0) Transform Ray 
 Move the ray from World Space  to Object Space 
Object Space World Space r = 1 r 
major r 
minor 
(x,y) 
pWS  =  M    pOS 
pOS  =  M-1  pWS</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>CSG then Ray Casting 
46 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Again, set ray equation equal to barycentric equation 
                            P(t) = P(, )  
                Ro + t * Rd = a + (b-a) + (c-a)  
 Intersection if  +   1   &amp;   0   &amp;   0 
     (and t &gt; tmin  ) 
24 Intersection with Barycentric Triangle 
Ro Rd c 
a b P</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Used to solve for one variable at a time in system of equations 
26 Cramers Rule 
A R R a b a R R a b a R R a b a 
dz oz z z z dy oy y y y dx ox x x x 
- - - - - 
=  
A R a c a b a R a c a b a R a c a b a 
t oz z z z z z oy y y y y y ox x x x x x 
- - - - - - - - - 
= A R c a R a R c a R a R c a R a 
dz z z oz z dy y y oy y dx x x ox x - 
=  
|   | denotes the 
determinant 
 
Can be copied 
mechanically  
into code - 
- 
- - 
- -</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>What is a Visual Hull? 
43</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Complicated for many primitives 
68 Primitives Handle Transforms 
r 
major r 
minor 
(x,y) Sphere {  
    center 3 2 0   
    z_rotation 30 
    r_major 2 
    r_minor 1  
}</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Rendering Visual Hulls 
45 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Questions?</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Ray Casting II 
 
 
 
 
 
 
 
 
 
 
 
 
 
Henrik Wann Jensen  
MIT EECS 6.837  Matusik Courtesy 
of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Image Based Visual Hulls</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>3 ways to pass arguments to a function 
 by value, e.g. float f(float x) 
 by reference, e.g. float f(float &amp;x) 
 f can modify the value of x 
 by pointer, e.g. float f(float *x) 
 x here is a just a memory address 
 motivations:  
less memory than a full data structure if x has a complex type 
dirty hacks (pointer arithmetic),but just do not do it 
 clean languages do not use pointers 
 kind of redundant with reference 
 arrays are pointers 
2 C++</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Two ways to create objects 
 The BAD way, on the stack 
 myObject *f() { 
 myObject x; 
... 
 return &amp;x 
 will crash because x is defined only locally and the memory gets 
de-allocated when you leave function f 
 The GOOD way, on the heap 
 myObject *f() { 
 myObject *x=new myObject; 
... 
 return x  
 but then you will probably eventually need to delete it  
4 Pointers, Heap, Stack</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Values v1, v2, v3 defined at a, b, c 
 Colors, normal, texture coordinates, etc. 
P(,,) = a + b + c is the point... 
 v(,,) = v1 + v2 + v3 is the 
barycentric interpolation of 
v1,v2,v3 at point P 
 Sanity check: v(1,0,0) = v1, etc.  
 I.e, once you know , , 
you can interpolate values 
using the same weights. 
 Convenient! 
28 
Barycentric Interpolation 
v1 v2 
v3 P</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>New origin: 
 
 New direction: 
70 originOS  = M-1 originWS 
directionOS  = M-1 (originWS + 1 * directionWS)   -   M-1 originWS 
originOS originWS 
directionOS directionWS 
Object Space World Space  qWS = originWS + tWS * directionWS 
 qOS  = originOS + tOS * directionOS directionOS  = M-1  directionWS Transform Ray 
Note that the w 
component of 
direction is 0</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Ro + t * Rd = a + (b-a) + (c-a) 
    
 Rox + tRdx = ax + (bx-ax) + (cx-ax) 
 Roy + tRdy = ay + (by-ay) + (cy-ay) 
 Roz + tRdz = az + (bz-az)  + (cz-az) 
 
 Regroup &amp; write in matrix form Ax=b 
25 Intersection with Barycentric Triangle 
3 equations,  
3 unknowns</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>tOS   tWS    
and must be rescaled after intersection 
==&gt; One more possible failure case... 
72 1. Normalize Direction 
Object Space World Space tWS tOS</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>P(,,) = a + b + c 
 Condition to be barycentric coordinates: 
++ =1 
 Condition to be inside the triangle: 
, ,   0 
17 Barycentric Definition of a Triangle 
c 
a b P</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Reference 1 
Reference 2 Desired Image Based (2D) Intersection 
59</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 
The Evil  
reflection 
refraction shadow  In ray tracing, do NOT report intersection for rays 
starting on surfaces 
 Secondary rays start on surfaces 
 Requires epsilons 
 Best to nudge the starting 
point off the surface 
e.g., along normal</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>How Can We Implement CSG? 
 
 
 
 
 
 
      Union               Intersection            Subtraction Points on A, 
Outside of B Points on B, 
Outside of A 
Points on B, 
Inside of A Points on A, 
Inside of B 4 cases  
37</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Ray Casting then Intersection 
53 Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Intro to rendering 
 Producing a picture based on scene description 
 Main variants: Ray casting/tracing vs. rasterization 
 Ray casting vs. ray tracing (secondary rays) 
 Ray Casting basics 
 Camera definitions 
 Orthographic, perspective 
 Ray representation 
P(t) = origin + t * direction 
 Ray generation 
 Ray/plane intersection 
 Ray-sphere intersection 9 Thursday Recap 
This image is in the
public domain. Source:
openclipart</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>P(,,) = a + b + c 
with ++ =1 
 Is it explicit or implicit? 
14 Barycentric Definition of a Plane 
[Mbius, 1827] 
c 
a b P Fun to know: 
P is the barycenter , 
the single point upon which  
the triangle would balance if  
weights of size , , &amp;  are  
placed on points a, b &amp; c.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>CSG then Ray Casting 
47 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>P(,,) = a + b + c 
with ++ =1 parameterizes the entire plane 
 If we require in addition that 
, ,  &gt;= 0, we get just the triangle! 
 Note that with  ++ =1 this implies 
0    1   &amp;   0    1   &amp;   0    1  
 Verify: 
 =0  =&gt;  P lies on line b-c 
,  =0  =&gt;  P = c 
 etc. 
 
16 Barycentric Definition of a Triangle 
c 
a b P</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Transform Tangent Vector v 
v is perpendicular to normal n: 
nOST vOS  =  0 
 nOST  (M-1  M)  vOS  =  0 
 nWST =  nOST (M-1)  (nOST  M-1)  (M    vOS)  =  0 
 (nOST  M-1)  vWS  =  0 
 nWST vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M-1)T nOS nOS 
vWS nWS vOS Dot product</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>CSG then Ray Casting 
48 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>76 Transformation for Shear and Scale 
Incorrect 
Normal 
Transformation 
Correct 
Normal 
Transformation</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Or write it as a 2 2 linear system 
P(,  ) = a + e1 + e2 
e1 = (b- a), e2 = (c-a) 
21 How Do We Compute , ,  ? 
c 
a b P These should be zero 
Ha! Well take inner products of 
this equation with e1 &amp; e2</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>What happens when  
 Ray Origin lies on an object? 
 Grazing rays? 
 Problem with floating-point approximation 
62 Precision</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>TERRIBLE thing about segfault: the program does 
not necessarily crash where you caused the problem 
 You might write at an address that is inappropriate 
but that exists 
 You corrupt data or code at that location 
 Next time you get there, crash 
 
 When a segmentation fault occurs, always look for 
pointer or array operations before the crash, but not 
necessarily at the crash 
6 Segmentation Fault</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Position  
 transformed by the full homogeneous matrix M 
 Direction 
 transformed by M except the translation component 
 Normal  
 transformed by M-T, no translation component 
79 Position, Direction, Normal</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Or write it as a 2 2 linear system 
P(,  ) = a + e1 + e2 
e1 = (b- a), e2 = (c-a) 
23 How Do We Compute , ,  ? 
c 
a b P 
where 
and &lt;a,b&gt; is the dot product. Questions?</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Ray Casting then Intersection 
55 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Implementing CSG 
1.Test "inside" intersections: 
 Find intersections with A,  
test if they are inside/outside B 
 Find intersections with B, 
test if they are inside/outside A 
This would 
certainly work, but 
would need to 
determine if points 
are inside solids... :-( 
39</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Ray Casting then Intersection 
56 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Think about transforming the tangent plane   
to the normal, not the normal vector 
77 So How Do We Do It Right? 
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane, 
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41 Implementing CSG 
1.Test "inside" intersections: 
 Find intersections with A,  
test if they are inside/outside B 
 Find intersections with B, 
test if they are inside/outside A 
 
2.Overlapping intervals: 
 Find the intervals of "inside" 
along the ray for A and B 
 How? Just keep an entry / exit bit 
for each intersection 
 Easy to determine from intersection 
normal and ray direction 
 Compute 
union/intersection/subtraction of the 
intervals 
Problem reduces to 1D for each ray</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Barycentric Definition of a Plane 
[Mbius, 1827] c 
a b P Why? How? 
Ro Rd  A (non-degenerate) triangle ( a,b,c) defines a plane 
 Any point P on this plane can be written as 
    P(,,) = a + b + c, 
    with ++ = 1</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>80 Thats All for Today! 
Yu et al. 2009  Further reading 
Realistic Ray Tracing, 2nd ed.  
(Shirley, Morley) 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Ray Casting then Intersection 
51 
Reference 1 Reference 2 Desired</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>tOS =  tWS     convenient! 
 But you should not rely on tOS being true distance in 
intersection routines (e.g. a1 in ray-sphere test) 
73 2. Do Not Normalize Direction 
Object Space World Space tWS tOS</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>1.Make each primitive handle any applied 
transformations and produce a camera space 
description of its geometry 
 
 
 
 
 
 
2....Or Transform the Rays 
67 Incorporating Transforms 
Transform { 
    Translate { 1 0.5 0 } 
    Scale { 2 2 2 } 
    Sphere {  
        center 0 0 0  
        radius 1  
    }  
}</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Display as much information as you can 
 image maps (e.g. per-pixel depth, normal) 
 OpenGL 3D display (e.g. vectors, etc.) 
 cerr&lt;&lt; or cout&lt;&lt; (with intermediate values, a message 
when you hit a given if statement, etc.) 
 Doubt everything 
 Yes, you are sure this part of the code works, but test it 
nonetheless 
 Use simple cases 
 e.g. plane z=0, ray with direction (1, 0, 0) 
 and display all intermediate computation 
7 Debugging</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Since ++ =1, we can write  = 1   
 P(,,) = a + b + c 
  P(,)      = (1)a + b + c 
                   = a + (b-a) + (c-a) 
13 Barycentric Coordinates 
c 
a b P Non-orthogonal  
coordinate 
system 
on the plane! rewrite 
Vectors that lie on 
the triangle plane 
{ 
{</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>We want to be able to add primitives easily 
 Inheritance and virtual methods 
 Even the scene is derived from Object3D! 
 
 
 
 
 
 Also cameras are abstracted (perspective/ortho) 
 Methods for generating rays for given image coordinates 
31 Object-Oriented Design 
Object3D 
bool intersect(Ray, Hit, tmin) 
Plane 
bool intersect(Ray, Hit, 
tmin) Sphere 
bool intersect(Ray, Hit,  
tmin) Triangle Mesh 
bool intersect(Ray, Hit, 
 tmin) Group 
bool intersect(Ray, Hit,  
tmin)</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Or write it as a 2 2 linear system 
P(,  ) = a + e1 + e2 
e1 = (b- a), e2 = (c-a) 
19 How Do We Compute , ,  ? 
c 
a b P This should be zero</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>When you read or, worse, write at an invalid address 
 Easiest segmentation fault: 
 float *px; // px is a memory address to a float 
 *px=5.0; //modify the value at the address px 
 Not 100% guaranteed, but you havent instantiated px, it 
could have any random memory address. 
 2nd easiest seg fault 
 Vector&lt;float&gt; vx(3); 
 vx[9]=0; 
5 Segmentation Fault</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Write a basic ray caster 
 Orthographic and 
perspective cameras 
 Spheres and triangles 
 2 Display modes: color and distance 
 We provide classes for 
 Ray: origin, direction  
 Hit: t, Material, ( normal) 
 Scene Parsing 
 You write ray generation, 
hit testing, simple shading 
32 Assignment 4 &amp; 5: Ray Casting/Tracing</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Why Use a Visual Hull? 
 Can be computed robustly 
 Can be computed efficiently 
44 
- = 
background  
+  
foreground 
background   
 foreground</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Ray Tracing (PDF - 2.9MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec13/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>color = ambient*hit-&gt;getMaterial()-&gt;getDiffuseColor() 
   for every light  
      Ray ray2(hitPoint, directionToLi
ght) 
      Hit hit2(distanceToLight, NULL, NULL) 
      For every object 
         object-&gt;intersect(ray2, hit2, 0) 
      if (hit2-&gt;getT() = distanceToLight) 
         color += hit-&gt;getMaterial()-&gt;Shade 
                  (ray, hit, directionToLight, lightCo
lor) 
   return color How Can We Add Shadows? 
ambient = k a 
diffuseColor = k d 
7</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Has revolutionized lens design 
 E.g. zoom lenses are good now 
Application: CAD for lenses 
From Hecht's Optics 
37  Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>How Does a Rainbow Work? 
 From Color and Light in Nature 
by Lynch and Livingstone 
31  Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Recursion For Reflection: None 
55 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Ray tree 
 Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray This gets pretty complicated 
pretty fast! 
60</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Recursion For Reflection: 1 
56 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Make sure you know whether youre entering or leaving 
the transmissive material: 
 
 
 
 
 
 
 
 Note: We wont ask you to trace rays through 
intersecting transparent objects :-) Refraction &amp; Sidedness of Objects 
T T = material  
        index i=1 
N 
T T= 1 i = material  
       index 
N I 
I 
28</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Recursion For Reflection: 2 
57 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Lets Think About Shadow Rays 
Ro Rd P 
11  Whats special about                                                    
shadow rays compared to eye rays?</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Refraction 
I    = N cos i   M sin i 
M  = (N cos i   I) / sin i 
 
T  =  N cos T  + M sin T 
     =  N cos T + (N cos i  I) sin T / sin i 
     =  N cos T + (N cos i  I) r 
     = [  r cos i  cos T ] N  r I 
     = [ r cos i  1  sin2 T ] N  r I 
     = [ r cos i  1  r2 sin2 i ] N  r I 
     = [ r cos i  1  r2 (1  cos2 i ) ] N  r I 
     = [ r (N  I)   1  r2 (1  ( N  I)2 ) ] N  r I I 
T i 
T N 
-N M T i 
Snell-Descartes Law: 
 N cos i  M sin i 
lets get rid of  
the cos &amp; sin Plug M 
24 sin  
sin  =  
=   sin  =  sin</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Rainbow 
 Rainbow is caused by  
refraction + internal 
reflection + refraction 
 Maximum for angle 
around 42 degrees 
 Refraction depends on 
wavelength 
(dispersion) 
34 This image is in the public domain. Source:  Wikipedia.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Lets Think About Shadow Rays 
Ro Rd P 
12  Whats special about                                                    
shadow rays compared to eye rays? 
 We do not need to find the closest                                       
intersection, any will do!</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>One reflection ray per intersection 
perfect mirror Reflection 
  
44</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Soft Shadows 
 Multiple shadow rays 
to sample area light 
source 
one shadow ray  
(to random location) 
lots of shadow rays 
48</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Overview of Today 
 Shadows 
 
 
 Reflection 
 
 
 Refraction 
 
 
 Recursive Ray Tracing 
53</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>color = ambient*hit-&gt;getMaterial()-&gt;getDiffuseColor() 
   for every light  
      Ray ray2(hitPoint, directionTo
Light) 
      Hit hit2(distanceToLight, NULL, NULL) 
      For every object 
         object-&gt;intersect(ray2, hit2, 0) 
      if (hit2-&gt;getT() = distanceToLight) 
         color += hit-&gt;getMaterial()-&gt;Shade 
                  (ray, hit, directionToLight, lightCo
lor) 
   return color Problem: Self-Shadowing 
Without epsilon With epsilon epsilon) 
Bad Good 
8</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Wavelength 
Pittoni, 1725, Allegory to Newton 
Pink Floyd, The Dark Side of the Moon  Refraction is wavelength-
dependent (dispersion) 
 Refraction increases as the 
wavelength of light decreases 
 violet and blue experience more 
bending than orange and red  
Newtons  prism experiment 
Usually ignored in graphics 
32  source unknown. All right
s reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. The Fitzwilliam Museum. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Glossy Reflection 
 Multiple reflection rays 
polished surface   
Justin Legakis 
45 Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>The Ray Tree 
R2 
R1 R3 
L2 
L1 L3 N1 N2 
N3 T1 T3 
Ni surface normal 
Ri reflected ray 
Li shadow ray 
Ti transmitted (refracted) ray Eye 
L1 
T3 R3 L3 L2 T1 R1 
R2 Eye 
Complexity? 
58</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Dispersion  
 Image by Henrik Wann Jensen using Photon Mapping 
35 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Antialiasing  Supersampling 
 Multiple rays per pixel 
jaggies w/ antialiasing 
49</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Camera definitions 
 Perspective and orthographic 
 View coordinate system [-1,1] 
 field of view, aspect ratio, etc. 
 Ray representation 
 origin + t * direction 
 Generating rays based in image coordinates 
 Ray-geometry intersection 
 Planes, spheres, triangles (barycentric coordinates) 
 CSG 
 Transformations Earlier 
NVIDIA 
3  NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Stopping criteria: 
 Recursion depth 
 Stop after a 
number  
of bounces 
 Ray contribution 
 Stop if reflected /  
transmitted 
contribution  
becomes too small trace ray  
   Intersect all objects  
   color = ambient term  
   For every light  
      cast shadow ray  
      color += local shading term  
   If mirror 
      color += colorrefl *  
                trace reflected ray  
   If transparent  
      color += colortrans *  
               trace transmitted ray  
 
   Does it ever end? 
Recap: Ray Tracing 
54</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Stack Studios, Rendered using Maxwell 
Thats All for Today 
 
Further reading: 
- Shirley: Realistic Ray Tracing  
- Dutre et al.: Advanced 
Global Illumination 
61  Next Limit S.L. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Refraction 
I    = N cos i   M sin i 
M  = (N cos i   I) / sin i 
 
T  =  N cos T  + M sin T 
     =  N cos T + (N cos i  I) sin T / sin i 
     =  N cos T + (N cos i  I) r 
     = [  r cos i  cos T ] N  r I 
     = [ r cos i  1  sin2 T ] N  r I 
     = [ r cos i  1  r2 sin2 i ] N  r I 
     = [ r cos i  1  r2 (1  cos2 i ) ] N  r I 
     = [ r (N  I)   1  r2 (1  ( N  I)2 ) ] N  r I I 
T i 
T N 
-N M T i 
Snell-Descartes Law: 
 N cos i  M sin i 
lets get rid of  
the cos &amp; sin Plug M 
Total internal reflection when  
the square root is imaginary 
(no refraction, just reflection)  
 
 
25 sin  =  sin   
sin  
sin  =  
=</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Shadows 
 One shadow ray per 
intersection per point 
light source 
no shadow rays 
one shadow ray 
46</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Cool Refraction Demo 
Enright, D., 
Marschner, S. 
and Fedkiw, 
R., 
SIGGRAPH 
2002  
29 
 ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Today  Ray Tracing 
(Indirect illumination) 
Shadows Reflections Refractions 
(Caustics) Henrik Wann Jensen 
4 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Lets Think About Shadow Rays 
Ro Rd P 
9  Whats special about                                                    
shadow rays compared to eye rays?</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Refracted direction T? Refraction 
I 
T i 
T N 
-N M T i 
Snell-Descartes Law: 
 
23 Relative index of refraction Material 1, index of refraction  i 
Material 2, index of refraction  T 
sin  =  sin   
sin  
sin  =  
=</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Lets Pause for a Moment... 
 Do these pictures look real? 
39  Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Motion Blur 
 Sample objects 
temporally over 
time interval 
Rob Cook 
50  ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Total Internal Reflection 
No transmission 
26 Image courtesy of Frazzydee  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Perfect Mirror Reflection 
 Reflection angle = view angle 
 Normal component is negated 
 Remember particle collisions? 
R = V  2 (V  N) N 
R V 
 V  R N 
V N N V N N 
V 
17</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Questions? 
Henrik Wann Jensen 
14 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Overview of Today 
 Shadows 
 
 
 Reflection 
 
 
 Refraction 
 
 
 Recursive Ray Tracing 
15</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Whats Wrong then? 
 No surface is a perfect mirror, 
no material interface is perfectly smooth 
Adapted from blender.org 
Perfectly specular 
(mirror) reflection Perfectly specular 
refraction 1 ray in 1 ray out 1 ray in 
1 ray out 
1 ray out 
41</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>How Can We Add Shadows? 
6 For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Lets Think About Shadow Rays 
Ro Rd P 
10  Whats special about                                                    
shadow rays compared to eye rays?</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Questions? 
36 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Shadow Optimization 
 We only want to know whether there is an intersection, 
not which one is closest 
 Special routine Object3D::intersectShadowRay()  
 Stops at first intersection 
13</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Mirror Reflection 
 Cast ray symmetric with  
respect to the normal 
 Multiply by reflection  
coefficient ks (color) 
 Dont forget to add epsilon  
to the ray! 
Without epsilon 
With epsilon 
16</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Non-Ideal Reflection/Refraction 
images from blender.org Glossy (as opposed to mirror) reflection 
Glossy (as opposed to perfect) refraction 
43 Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Questions? 
Henrik Wann Jensen Sphereflake fractal 
19 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Refraction and the Lifeguard Problem 
 Running is faster than swimming  
Beach 
Person  
in trouble Lifeguard 
Water 
Run 
Swim 
30  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Whats Wrong then? 
 No surface is a perfect mirror, 
no material interface is perfectly smooth 
40  Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Total Internal Reflection 
27  Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Lens design by Ray Tracing 
 Used to be done 
manually, by rooms 
full of engineers who 
would trace rays. 
 Now software, e.g. 
Zemax 
 More in 6.815/6.865 
Computational 
Photography 
source: canon red book 
38  BBG Photographica. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Amount of Reflection 
 Traditional ray tracing (hack)  
 Constant ks 
 More realistic (well do this later): 
 Fresnel reflection term (more reflection at grazing angle) 
 Schlicks approximation: R( )=R0+(1-R0)(1-cos )5 
 Fresnel makes a big difference! 
metal 
 18 Dielectric (glass)</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade  
2 
Ray Casting</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Overview of Today 
 Shadows 
 
 
 Reflection 
 
 
 Refraction 
 
 
 Recursive Ray Tracing 
20</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Qualitative Refraction 
22  Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics 
Ray Tracing 
 
 
 
 
 
 
 
 
 
 
 
 
Wojciech Matusik, MIT EECS 
Many slides from Jaakko Lehtinen and Fredo Durand 
Henrik Wann Jensen  
1 Courtesy of Henrik Wann Jensen.
 Used with permission.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Non-Ideal Reflection/Refraction 
Non-ideal glossy 
reflection Non-ideal refraction  No surface is a perfect mirror, 
no material interface is perfectly smooth 
Adapted from blender.org 1 ray in 1 ray in 
many 
rays out many 
rays out 
42</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Ray tree 
 Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray 
59</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Shadows &amp; Light Sources 
http://www.pa.uky.edu/~sciworks/light/preview/bulb2.htm 
clear bulb frosted bulb 
http://3media.initialized.org/photos/2000-10-18/index_gall.htm http://www.davidfay.com/index.php  
47 Image remov
ed due to copyright restrictions.  
 David Fay Custom Furniture. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
 Joseph Straley and Sally Shafer Kovash. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Multiple rays per pixel: 
sample lens aperture 
MIT EECS 6.837  Durand 
  Depth of Field 
Justin Legakis focal length film out-of-focus blur 
out-of-focus blur 
51 Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Overview of Today 
 Shadows 
 
 
 Reflection 
 
 
 Refraction 
 
 
 Recursive Ray Tracing 
 Hall of mirrors 
5</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Transparency (Refraction) 
 Cast ray in refracted direction 
 Multiply by transparency coefficient kt (color) 
21</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Questions? 
Henrik Wann Jensen 
52 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Rainbow 
 Rainbow is caused by  
refraction + internal reflection + refraction 
 Maximum for angle around 42 degrees 
 Refraction depends on wavelength (dispersion) 
Color and Light in Nature  
by Lynch and Livingstone The outgoing 
angle is different 
for each 
wavelength 
33  Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Color (PDF - 3.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec05/</lecture_pdf_url>
      <lectureno>05</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>Spectrum 
7 Light is characterized by its 
spectrum:  
the amount of energy at each 
wavelength 
This is a full distribution:  
one value per wavelength 
(infinite number of values)</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Spectra are infinite-dimensional 
Only positive values are allowed 
Cones are non-orthogonal/overlap Fundamental problems 
47</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20  Big picture 
Its all linear! 
Light reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate 20  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Spectra 
Cones and spectral response 
Color blindness and metamers 
Color matching  
Color spaces Plan 
4</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Illuminant metamerism example 
Two grey patches in Billmeyer &amp; Saltzmans book 
look the same under daylight  
but different under neon or halogen  
(&amp; my camera agrees ;-) 
Daylight Scan (neon) 
Hallogen 37  source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>So far, physical side of colors: spectra 
an infinite number of values  
(one per wavelength) Questions? 
10 
  Sinauer Associates, Inc. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Take a given stimulus and the corresponding 
responses s, m, l (here 0.5, 0, 0) Additive Synthesis - wrong way 
44</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Now, our interactive 
feature! 
You are... 
THE LAB RAT 
55</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Whats going on?  
The three cone responses are not orthogonal 
i.e. they overlap and pollute each other 
46</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Cones 
We focus on low-level aspects of color 
Cones and early processing in the retina 
We wont talk about rods (night vision) 
15 
Spectral 
Sensibility 
of the  
L, M and S  
Cones S M L 
This image is in the public domain. Source: Wikimedia Commons.Image courtesy of Ivo Kruusamgi  on Wikimedia
Commons. License: CC- BY-SA. This content is
excluded from our Creative Commons license. For
more information, see htt
p://ocw.mit.edu/help/
faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Questions? 
reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate 22</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Good news: color reproduction 
3 primaries are (to a first order) enough to 
reproduce all colors 
34 
Image courtesy of Martin Apolin  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Meaning of these curves: a monochromatic 
wavelength  can be reproduced with  
b() amount of the 435.8nm primary, 
+g() amount of the 546.1 primary, 
+r() amount of the 700 nm primary 
 
This fully specifies the color  
perceived by a human 
 
Careful: this is not your usual rgb CIE color matching 
58</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Most standard color space: CIE XYZ 
LMS and the various flavor of RGB are just 
linear transformations of the XYZ basis 
3x3 matrices Overview 
51</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Meaning of these curves: a monochromatic 
wavelength  can be reproduced with  
b() amount of the 435.8nm primary, 
+g() amount of the 546.1 primary, 
+r() amount of the 700 nm primary 
 
This fully specifies the color  
perceived by a human 
However, note that one of  
the responses can be  
negative 
Those colors cannot be  
reproduced by those 3 primaries.  CIE color matching 
59</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>The human visual system is more sensitive to ratios 
Is a grey twice as bright as another one? 
If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
This is why a non-linear gamma remapping of about 2.0 
is applied before encoding 
True also of analog imaging to optimize signal-noise 
ratio 
 Color quantization gamma 
79</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Metamers under a given light source 
May not be metamers under a different lamp Metamerism &amp; light source 
36</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>From Greg Ward 
Only 6 bits for emphasis Gamma encoding 
80</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Different wavelength, different intensity  
But different response for different cones Response comparison 
24</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Why not measure cone sensitivity? 
Less directly measurable 
electrode in photoreceptor? 
not available when color spaces were defined 
Most directly available measurement:  
notion of metamers &amp; color matching 
directly in terms of color reproduction:  
given an input color,  
how to reproduce it with 3 primary colors? 
Commission Internationale de lEclairage 
(International Lighting Commission) 
Circa 1920 
Spectral 
Sensibility 
of the  
L, M and S 
Cones S M L 
52</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Spectrum demo 
Diffraction grating: 
shifts light as a function of 
wavelength 
Allows you to see spectra 
In particular, using a slit light 
source, we get a nice band 
showing the spectrum 
See the effect of filters 
See different light source 
spectra 
9 
Image courtesy of Cmglee  on Wikimedia  Commons. License:
CC-BY-SA. This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-f ai
r-use/.
This image is in the public do mai
n. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Tricky thing with spectra &amp; color: 
Spectrum for the stimulus / synthesis  
Light, monitor, reflectance 
Response curve for receptor /analysis 
Cones, camera, scanner 
They are usually not the same 
There are good reasons for this Warning 
43 
This image is in the public domain.  Source:
http://openclipart.org/detail/3405
1/digicam-
by-thesaurus.
Image courtesy of Pengo  on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Choose 3 synthesis primaries   
Seek to match any monochromatic light (400 to 700nm) 
Record the 3 values for each wavelength 
By linearity, this tells us how to match any light CIE color matching 
53</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 
Image courtesy of Cpesacreta on Wikimedia Commons. License: CC-BY. This
content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .Image courtesy of Spigget  on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Relation to cone curves 
Project to the same subspace 
b, g, and r are linear combinations of S, M and L  
Related by 3x3 matrix.  
Unfortunately unknown at that time. This would 
have made life a lot easier! 
61</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Questions? 
68</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Questions? 
40</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Summary  (and time for questions) 
Spectrum: infinite number of values 
can be multiplied 
can be added 
Light spectrum multiplied by reflectance 
spectrum 
spectrum depends on illuminant 
Human visual system is complicated 
16</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Selected Bibliography 
Vision and Art : The Biology of Seeing  by Margaret Livingstone, David H. Hubel  Harry N 
Abrams; ISBN: 0810904063  
208 pages (May 2002)  Vision Science by Stephen E. Palmer 
MIT Press; ISBN: 0262161834   
760 pages (May 7, 1999)   
 
Billmeyer and Saltzman's Principles of Color Technology, 3rd Edition  
by Roy S. Berns, Fred W. Billmeyer, Max Saltzman  
Wiley-Interscience; ISBN: 047119459X   
304 pages 3 edition (March 31, 2000)  
83 The Reproduction of Color by R. W. G. Hunt 
Fountain Press, 1995 
Color Appearance Models by Mark Fairchild 
Addison Wesley, 1998 
Color for the Sciences, by Jan Koenderink  
MIT Press 2010 .</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Analysis &amp; Synthesis 
Focus on additive color synthesis 
Well use 3 primaries (e.g. red green and blue) to 
match all colors 
 
 
 
 
What should those primaries be? 
How do we tell the amount of each primary 
needed to reproduce a given target color? 
42 
Image courtesy of Pengo on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Color gamut 
Given 3 primaries 
The realizable 
chromaticities lay in the 
triangle in xy 
chromaticity diagram 
Because we can only 
add light, no negative 
light C 
 source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .
This image is in the publ
ic domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Color blindness test 
30 
 source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
Image courtesy of Eddau processed File:  Ishihara 2.svg  by User:Sakurambo, with
http://www.vischeck.com/vischeck/vischeckURL.php  on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Questions? 
75</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Other primaries 
We want to use a new set of primaries 
e.g. the spectra of R, G &amp; B in a projector or monitor 
By linearity of color matching,  
can be obtained from XYZ by a 3x3 matrix 
one example RGB space 
69</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>For matrix lovers 
Spectrum: big long vector size N where N= 
Cone response: 3xN matrix of individual 
responses 
S 
L M cone spectral 
response 
kind of RGB observed  
spectrum 
19</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>What is Color? 
12 
Light 
 
Object 
 
 Observer</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>The human visual system is more sensitive to ratios 
Is a grey twice as bright as another one? 
If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
This is why a non-linear gamma remapping of about 2.0 
is applied before encoding 
True also of analog imaging to optimize signal-noise 
ratio 
 Color quantization gamma 
78</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21  Big picture 
Its all linear! 
multiply 
add 
But  
non-orthogonal 
basis 
infinite 
dimension 
light must be 
positive 
Depends on light 
source Light reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>CIEs problem  
Idea: 
Start with light sensor sensitive to all wavelength 
Use three filters with spectra b, r, g 
measure 3 numbers 
But for those primaries, we need negative spectra 
 
64</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Different wavelength, different intensity 
Same response A cone does not see colors  
23</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Short, Medium and Long wavelength 
Response for a cone  
=   stimulus() * response() d 
17 Cone spectral sensitivity</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Recap 
Spectrum: infinite number of values 
projected according to cone spectral response  
=&gt; 3 values 
metamers: spectra that induce the same response 
(physically different but look the same) 
 
 
Questions? 
35</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>If I have a given spectrum X 
I compute its response to the 3 matching curves 
(multiply and integrate) 
I use these 3 responses to  
scale my 3 primaries  
(435.8, 546.1 and 700nm) 
I get a metamer  of X 
(perfect color reproduction) CIE color matching: what does it mean? 
60</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Maze in subtle intensity contrast 
Visible only to color blinds 
Color contrast overrides intensity otherwise Color blindness test 
31  source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Spectrum 
6 
Light is a wave 
Visible: between 450 and 700nm</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Recap 
Spectra : infinite dimensional  
Cones: 3 spectral responses 
Metamers: spectra that look the same  
(same projection onto cone responses) 
CIE measured color response: 
chose 3 primaries 
tristimulus curves to reproduce any wavelength 
 
Questions? 
62</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Analysis &amp; Synthesis 
Now lets switch to technology 
We want to measure &amp; reproduce color  
as seen by humans 
No need for full spectrum 
Only need to match up to metamerism 
41</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Questions? 
49</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Color 
5 
Image courtesy of Ztonyi Sndor, (ifj.) Fizped on Wikimedia Commons.
License: CC-BY -SA. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Metamers 
We are all color blind! 
These two different 
spectra elicit the same 
cone responses 
Called metamers 
33 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Colors as relative responses 
(ratios) von Helmholtz 1859: Trichromatic theory 
Violet 
Blue 
Green 
Yellow 
Orange 
Red 
Short wavelength receptors 
Medium wavelength receptors 
Long wavelength receptors 
Receptor Responses 
Wavelengths (nm) 400  500 600 700 Violet 
Blue 
Green 
Yellow 
Orange 
Red 
25</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Questions? 
Links: 
Vischeck shows you what an image looks like to 
someone who is colorblind. 
http://www.vischeck.com/vischeck/ 
Daltonize, changes the red/green variation to 
brightness and blue/yellow variations. 
http://www.vischeck.com/dalton  
http://www.vischeck.com/daltonize/runDaltonize.php 
32</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Answer 
Its all linear algebra 
3</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Questions? 
26</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Some colors cannot be produced using only 
positively weighted primaries 
Solution: add light on the other side! Color Matching Problem 
57 
 source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Spectra 
Cones and spectral response 
Color blindness and metamers 
Color matching  
Color spaces Plan 
27</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Cone response 
Start from infinite 
number of values  
(one per 
wavelength) 
 
 
 
 
 
 
 
 
End up with 3 
values (one per 
cone type) 
Cone responses Stimulus 
Multiply wavelength by wavelength 
Integrate 
1 number 1 number 1 number 
18 
 source unknown. All rights reserved. This content is exclude
d from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>We need a principled color space 
Many possible definition 
Including cone response (LMS) 
Unfortunately not really used,  
(because not known at the time) 
 
The good news is that color vision is linear and  
3-dimensional, so any new color space based on 
color matching can be obtained using 3x3 matrix  
But there are also non-linear color spaces  
(e.g. Hue Saturation Value, Lab) Standard color spaces 
50</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Primaries (synthesis) at 435.8, 546.1 and 700nm  
Chosen for robust reproduction, good separation in red-green 
Dont worry, well be able to convert it to any other set of 
primaries (Linear algebra to the rescue!) 
Resulting 3 numbers for each input wavelength are 
called tristimulus values CIE color matching 
54</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Questions? 
82</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Classical case: 1 type of cone is missing (e.g. red)  
Makes it impossible to distinguish some spectra Color blindness 
differentiated Same responses 
28</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Chromaticity diagrams 
3D space are tough to visualize 
Usually project to 2D for clarity 
Chromaticity diagram: 
normalize against X + Y + Z: 
 
 
Perspective project
ion to plane  
X+Y+Z=1 
66  source unknown. All rights reserved. This content is
excluded from our C re
ative Commons license. For more
information, see http://ocw .
mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>THE standard for color specification 
Lots of legacy decision - I wish it were LMS 
Based on color matching  
3 monochromatic primaries 
Subjects matched every wavelength 
Tricks to avoid negative numbers 
These 3 values measure  
or describe a perceived color.  CIE XYZ -recap 
67</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Color 
Wojciech Matusik MIT EECS 
Many slides courtesy of Victor Ostromoukhov, Leonard McMillan, Bill Freeman, Fredo Durand  
Image courtesy of Chevre  on Wikimedia Commons.  License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .1</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>The human visual system is more sensitive to ratios 
Is a grey twice as bright as another one? 
If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
Ideal encoding? 
    Log 
Problems with log? 
    Gets crazy around zero 
Solution: gamma  
 
 Color quantization gamma 
77</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Does color puzzle you? 
2</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Questions? 
84 
Image courtesy of SharkD on Wikimedia Commons. License: CC-BY. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>CIEs problem  
Obvious solution:  
use cone response! 
but unknown at the time 
=&gt;new set of tristimulus curves 
linear combinations of b, g, r 
pretty much add enough b and g  
until r is positive 
65</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>What is Color? 
14 
Light 
Illumination Object 
Reflectance Final stimulus 
Spectral 
Sensibility 
of the  
L, M and S  
Cones S M L 
Then the cones in the eye interpret the stimulus</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Bad consequence: cloth matching 
Clothes appear to match in store (e.g. under neon) 
Dont match outdoor 
38</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>XYZ to RGB &amp; back 
e.g. 
http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html 
sRGB to XYZ                        XYZ to sRGB 
 
 
Adobe RGB to XYZ          XYZ to Adobe RGB 
 
 
NTSC RGB to XYZ          XYZ to NTSC RGB 0.412424    0.212656    0.0193324 
0.357579    0.715158    0.119193 
0.180464    0.0721856   0.950444 3.24071    -0.969258    0.0556352 
 -1.53726     1.87599    -0.203996 
 0.498571    0.0415557   1.05707  
0.576700    0.297361    0.0270328 
0.185556    0.627355    0.0706879 
0.188212    0.0752847   0.991248 2.04148    -0.969258    0.0134455 
 -0.564977    1.87599    -0.118373 
 -0.344713    0.0415557   1.01527  
0.606734    0.298839    0.000000 
0.173564    0.586811    0.0661196 
0.200112    0.114350    1.11491  1.91049    -0.984310    0.0583744 
-0.532592    1.99845    -0.118518 
-0.288284   -0.0282980   0.898611 71</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Other primaries 
We want to use a new set of primaries 
e.g. the spectra of R, G &amp; B in a projector or monitor 
By linearity of color matching,  
can be obtained from XYZ by a 3x3 matrix 
This matrix tells us how to match the 3 primary 
spectra from XYZ using the new 3 primaries 
one example RGB space 
70</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Digital images are usually not encoded linearly 
Instead, the value X 1/ is stored 
 
 
 
Need to be decoded if we want linear values Gamma encoding overview 
76</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Physical color 
Spectrum 
multiplication of light &amp; reflectance spectrum 
Perceptual color 
Cone spectral response: 3 numbers  
Metamers: different spectrum, same responses 
Color matching, enables color reproduction with 3 primaries 
Fundamental difficulty 
Spectra are infinite-dimensional (full function) 
Projected to only 3 types of cones 
Cone responses overlap / they are non-orthogonal 
Means different primaries for analysis and synthesis 
Negative numbers are not physical Summary 
48</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Spectra 
Cones and spectral response 
Color blindness and metamers 
Color matching  
Color spaces Plan 
11</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>How to build a measurement device? 
Idea: 
Start with light sensor sensitive to all wavelength 
Use three filters with spectra b, r, g 
measure 3 numbers 
This is pretty much what the eyes do! 
63</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Digital images are usually gamma encoded 
Often  = 2.2 (but 1.8 for Profoto RGB) 
To get linear values, you must decode 
apply x =&gt; x Important Message 
81</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>What is Color? 
13 
Illumination 
Reflectance Stimulus 
Cone 
responses</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Recap 
Spectrum is an infinity of numbers  
Projected to 3D cone-response space 
for each cone, multiply per wavelength and integrate 
a.k.a. dot product 
Metamerism: infinite-D points projected to the 
same 3D point 
(different spectrum, same perceived color) 
affected by illuminant 
enables color reproduction with only 3 primaries 
39</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Additive Synthesis - wrong way 
Use it to scale the cone spectra (here 0.5 * S) 
You dont get the same cone response!  
(here 0.5, 0.1, 0.1) 
45</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Its all about linear algebra 
Projection from infinite-dimensional spectrum to a 3D 
response 
Then any space based on color matching and 
metamerism can be converted by 3x3 matrix 
Complicated because 
Projection from infinite-dimensional space 
Non-orthogonal basis (cone responses overlap) 
No negative light 
XYZ is the most standard color space 
RGB has many flavors In summary 
74</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Dalton  
8% male, 0.6% female 
Genetic 
Dichromate (2% male) 
One type of cone missing 
L (protanope), M (deuteranope),  
S (tritanope) 
Anomalous trichromat 
Shifted sensitivity Color blindness  more general 
29</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Light-Matter Interaction 
8 Where spectra come from: 
- light source spectrum 
- object reflectance (aka spectral albedo) 
get multiplied wavelength by wavelength 
 
There are different physical processes that explain 
this multiplication 
e.g. absorption, interferences 
.* = 
Foundations of Vision, by Brian Wandell, Sinauer Assoc., 1995   Sinauer Associates, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
  </lectures>
</doc>
