<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/</course_url>
    <course_title>Multithreaded Parallelism: Languages and Compilers</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Software Design and Engineering </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>M- Structures: Programming with State and Nondeterminism</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l11istructuresprint/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L11-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
I -Structures and Open Lists 
Lecture 11 
http://www.csg.lcs.mit. edu/6.827 L11-2 
Arvind 
Array: An Abstract Datatype 
module Array (Array, mkArray, (!), bounds) 
where 
infix 9 (!) 
data (Ix a) =&gt; Array a t 
mkArray :: (Ix a) =&gt; (a,a) -&gt; (a-&gt;t) -&gt; 
(Array a t) 
(!) :: (Ix a) =&gt; (Array a t) -&gt; a -&gt; t 
bounds :: (Ix a) =&gt; (Array a t) -&gt; (a,a) 
Thus, 
type ArrayI t = Array Int t 
type MatrixI t = Array (Int,Int) t 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-3 
Arvind 
Index Type Class 
pH allows arrays to be indexed by any type 
that can be regarded as having a contiguous 
enumerable range 
range: Returns the list of index elements between a 
lower and an upper bound 
index : Given a range and an index, it returns an 
integer specifying the position of the index in the 
range based on 0 
inRange : Tests if an index is in the range class Ix a where 
range :: (a,a) -&gt; [a] 
index :: (a,a) -&gt; a -&gt; Int 
inRange :: (a,a) -&gt; a -&gt; Bool 
http://www.csg.lcs.mit. edu/6.827 L11-4 
Arvind 
Higher Dimensional Arrays 
x = mkArray ((l1,l2),(u1,u2)) f 
means x!(i,j) = f (i,j) l1 &lt; i &lt; u1 
l2 &lt; j &lt; u2 
Type 
x ::(Array (Int,Int) t) 
Assuming 
f :: (Int,Int) -&gt; t 
mkArray will work for higher dimensional matrices 
as well. 
2
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-7 
Arvind 
Array Comprehension: Wavefront 
x = array ((1,1),(n,n)) 
([((1,1), 1)] 
++ [((i,1), 1) | 
++ [((1,j), 1) | ++ [((i,j), x!(i
-1,j) + x!(i,j-1)) 
| 
]) x[i,j]= x[i -1,j] + x[i,j -1] 1 1 1 1 1 1 1 1 
1 
1 1 
1 
1 
1 
1 
] 
] 
http://www.csg.lcs.mit. edu/6.827 L11-8 
Arvind 
Computed Indices 
find x i = 
let % find j such that x!j = i 
step j = if x!j== i then j 
else step j+1 
in 
step 1 
y = mkArray (1,n) (find x) 2 x 
y Inverse permutation 
y ! (x ! i) = i 1 2 3 4 5 6 
y = array (1,n) [( -[1..n]] How many comparisons? Can we do better? 4 3 1 6 5 
)| i &lt;, 
4
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-23 
Arvind 
Map Using Open Lists 
 Inefficient because it is not tail recursive! 
 A tail recursive version can be written using open lists: 
map f xs = close (open_map f xs) 
where map f 
map f (x:xs) = (f x):(map f xs) 
open_map f [] INil, INil) 
open_map f (x:xs) = 
let tr = ICons {hd=(f x)} 
last = for x &lt;-xs do 
finally tr 
in (tr,last) = [] [] 
= (
http://www.csg.lcs.mit. edu/6.827 L11-24 
Arvind 
Implementing List Comprehensions 
[ e | x &lt;-xs, y &lt;-ys] 
concatMap (\x-&gt; 
concatMap (\y-&gt; [e]) ys) xs Functional 
solution 1 
[ e | x &lt;-xs, y &lt;-ys] 
let f [] = [] 
f (x:xs) = 
let g [] xs 
g (y:ys) = e:(g ys) 
in (g ys) 
in (f xs) Functional 
solution 2 = f 
12
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>--
 http://www.csg.lcs.mit. edu/6.827 L11-13 
Arvind 
The Unit Type 
data () = () 
means we cannot do much with an object of the 
unit type. However, it does allow us to drop _ = 
let 
y = iArray (1,n) [] 
for i &lt;-[1..n] do 
iAStore y (x!i) i 
finally () unit data type 
in 
y 
For better syntax replace 
iAStore y (x!i) i by y!(x!i) := i 
http://www.csg.lcs.mit. edu/6.827 L11-14 
Arvind 
I -Cell 
data ICell a = ICell {contents :: . a} 
I -Structure field Constructor 
ICell :: a -&gt; ICell a 
ICell e or ICell {contents = e} 
or create an empty cell and fill it 
ic = ICell {} 
contents ic := e 
Selector 
contents ic or 
case ic of 
ICell x -&gt; ... x ... 
7
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-17 
Arvind 
Types Issue (cont.) 
Hindley-Milner type system has to be extended 
to deal with I -structures 
? ref type --requires new rules 
more on this later... 
http://www.csg.lcs.mit. edu/6.827 L11-18 
Arvind 
All functional data structures in pH 
are implemented as I -structures. 
9
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-11 
Arvind 
Computed Indices Using I -structures 
let 
y = iArray (1,n) [] 
_ = for i &lt;-[1..n] do 
_ = iAStore y (x!i) i 
finally () % unit data type 
in 
y 
What if x contains a duplicate ? Inverse permutation 
y ! (x ! i) = i 2 x 
y  
1 2 3 4 5 6 4 3 1 6 5 
http://www.csg.lcs.mit. edu/6.827 L11-12 
Arvind 
Multiple-Store Error 
Multiple assignments to an iArray slot cause a 
multiple store error 
A program with exposed store error is 
suppose to blow up! 
Program --&gt; T 
The Top represents a contradiction 
6
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-27 
Arvind 
The example 
f x y = let x!1 := 10 
y!1 := 20 
in () 
let 
x = iArray (1,2) [] 
in 
f x x f iArray (1,2) []) 
(iArray (1,2) []) (
14
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-21 
Arvind 
Open List Operations 
A pair of I -list pointers for the header and the 
trailer cells. 
closing an open list joining two open lists 
... 1 2 10 
... 11 12 n 
... 1 2 10 
... 12 n 11 
... 1 10 
... 11 n 
http://www.csg.lcs.mit. edu/6.827 L11-22 
Arvind 
Open List Operation Definitions 
type open_list t = (( IList t), (IList t)) 
nil_ol = (INil, INil) 
close (hr,tr) = 
let 
case hr of 
INil -&gt; () 
ICons _ _ -&gt; {tl tr := INil} 
in cnv_Ilist_to_list hr 
join (hr1,tr1) (hr2,tr2) = 
case hr1 of 
INil -&gt; 
ICons _ _ -&gt; 
11
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-9 
Arvind 
In functional data structures, a single construct 
specifies: 
-The shape of the data structure 
-The value of its components 
These two aspects are specified separately using 
I -structures 
efficiency 
parallelism 
I -structures preserve determinacy but are not 
functional I -structures 
! 
http://www.csg.lcs.mit. /6.827 L11-10 
Arvind 
I -Arrays 
-Allocation expression 
iArray(1,n) [] 
-Assignment 
iAStore a 2 5 
or a!2 := 5 
provided the previous content was  
"The single assignment restriction. 
-Selection expression 
a!2 ( means empty ) 1 
1 
5 n . . . 2 
n . . . 2 . . . 
5 . . . 
5
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-5 
Arvind 
The Wavefront Example 
x = mkArray ((1,1),(n,n)) (f x) 
f x (i, j) = if i == 1 then 1 
else if j == l then 1 
else x!(i-1,j) + x!(i,j-1) xi,j = xi-1,j + xi,j-1 1 1 1 1 1 1 1 1 
1 
1 
1 
1 
1 
1 
1 2 3 
3 4 
6 
4 5 
10 
5 10 
http://www.csg.lcs.mit. edu/6.827 L11-6 
Arvind 
Array Comprehension 
A special function to turn a list of (index,value) 
pairs into an array 
array :: (Ix a) =&gt; (a,a) -&gt; [(a,t)] -&gt; (Array a t) 
array ebound 
([(ie1,e1) | gen-pred, ..] 
++ [(ie2,e2) | gen-pred, ..] ++ ) 
Thus, 
mkArray (l,u) f = 
array (l,u) [(j,(f j)) | j &lt; -range(l,u)] 
List comprehensions and function array provide 
flexibility in constructing arrays, and the compiler 
can implement them efficiently 
duplicates? 
3
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-19 
Arvind 
Array Comprehensions:
a packaging of I -structures 
array dimension 
([(ie1,e1) | x &lt; -xs, y &lt;-ys] 
++ [(ie2,e2) | z &lt; -zs] ) 
let a = iArray dimension [] 
for x &lt;-xs do 
for y &lt;-ys do 
a!ie1 := e1 
finally () 
finally () 
for z &lt;-zs do 
a!ie2 := e2 
finally () 
in cvt_IArray_to_Array a translated into 
http://www.csg.lcs.mit. edu/6.827 L11-20 
Arvind 
data IList t = INil 
| ICons {hd ::t, tl:: .(IList t)} 
Allocation 
x = ICons {hd = 5} 
Assignment 
tl x := e 
The single assignment restriction. 
If violated the program will blow up. 
Selection 
case xs of 
INil -&gt; ... 
ICons h t -&gt;  
we can also write ICons {hd=h, tl=t} -&gt;  I -lists 
I -Structure field 
10
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-25 
Arvind
Implementing List Comprehensions 
Using Open Lists 
let 
zs = nil_ol 
in 
for x &lt;-xs do 
z' = open_map (\y-&gt; e) ys 
next zs = join zs z' 
finally zs [ e | x &lt;-xs, y &lt;-ys] 
1. open lists , one for each x in xs 
2. Make n 
Join these lists together 
http://www.csg.lcs.mit. edu/6.827 L11-26 
Arvind 
I -structures are non functional 
let x = iArray (1,2) [] 
in f x x 
f iArray (1,2) []) (iArray (1,2) []) ? f x y = let x!1 := 10 
y!1 := 20 
in () 
(
13
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-15 
Arvind 
An Array of ICells 
Example: 
numbers precede the positive numbers 
2 -3 14 -5 
-3 -5 
Functional solutions are not efficient 
let y = array (1,n) [(i, ICell {})| i&lt;-[1..n]] 
(l,r) = (0,n+1) 
final_r = for j &lt;-[1..n] do 
(l,r,k) = 
contents (y!k) := x!j 
next l = l 
next r = r 
finally r 
in (y, final_r) Rearrange an array such that the negative 
8 2 7 
7 8 14 2 2 
http://www.csg.lcs.mit. edu/6.827 L11-16 
Arvind 
Type Issues 
In the previous example 
x :: Array Int 
y :: Array (Icell Int) 
1. We will introduce an I -Structure array to eliminate 
an extra level of indirection 
2. The type of a functional array (Array) is different 
from the type of an IArray. 
However, an IArray behaves like a functional 
after all its elements have been filled . 
We provide a primitive function for this conversion 
cvt_IArray_to_Array ia -&gt; a Array 
8
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Lists and Algebraic Types</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l08listsprint/</lecture_pdf_url>
      <lectureno>8</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Laboratory for Computer Science 
M.I.T. 
Lists and Algebraic Types 
October 2 , 2002 - 1 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Algebraic types 
 Algebraic types are tagged unions of products 
 Example 
data Shape = Line Pnt Pnt 
| Triangle Pnt Pnt Pnt 
| Quad Pnt Pnt Pnt Pntkeyword 
new type 
-new "constructors" (a.k.a. "tags", " disjuncts", "summands") 
-a kary constructor is applied to k type expressions "union" 
"products (fields) -2 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Constructors are functions 
 Constructors can be used as functions to 
create values of the type 
let 
l1 :: Shape 
l1 = Line e1 e2 
t1 :: Shape = Triangle e3 e4 e5 
q1 :: Shape = Quad e6 e7 e8 e9 
in 
... 
where each " eJ" is an expression of type " Pnt" -3 
L8-4 
Arvind 
Pattern -matching on algebraic types 
	Pattern-matching is used to examine values 
of an algebraic type 
anchorPnt :: Shape -&gt; Pnt
anchorPnt s = case s of
Line p1 p2 -&gt; p1
Triangle p3 p4 p5 -&gt; p3
Quad p6 p7 p8 p9 -&gt; p6
	A pattern -match has two roles: 
	A test: "does the given value match this pattern?" 
	Binding ("if the given value matches the pattern, bind 
the variables in the pattern to the corresponding parts 
of the value") 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Type Synonyms 
data 
versus 
type ,Int) 
Type Synonyms do not create new types. It is just a 
convenience to improve readability. 
move :: Point - , - &gt; Point 
) 
versus 
) -9 
Point = Point Int Int 
Point = (Int
&gt; (Int Int) 
move (Point x y) (sx,sy) = 
Point (x + sx) (y + sy
move (x,y) (sx,sy) = 
(x + sx, y + sy
L8-10 
Arvind 
Abstract Types 
A rational number is a pair of integers but suppose we want 
to express it in the reduced form only. Such a restriction 
cannot be enforced using an algebraic type. 
module Rationalpackage
(Rational,rational,rationalParts) where
data Rational = RatCons Int Int
rational :: Int -&gt; Int -&gt; Rational
rational x y = let
d = gcd x y
in RatCons (x/d) (y/d)
rationalParts :: Rational -&gt; (Int,Int)
rationalParts (RatCons x y)= (x,y)
No pattern matching on abstract data types 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
5 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-25 
Arvind 
Infinite Data Structures 
1. ints_from i = i:(
if n == 1 then x 
else nth (n -
&gt; ? 
2. ones = 1:ones 
nth 50 ones -- &gt; ? 
3. xs = [ f x | x &lt; - ] 
--&gt; ? 
These are well defined but deadly programs in 
pH. You will get an answer but the program may 
not terminate. ints_from (i+1)) 
nth n (x:xs) = 
1) xs 
nth 50 (ints_from 1) --
a:xs
nth 10 xs    
L8-26 
Arvind 
Primes: The Sieve of Eratosthenes 
primes = sieve [2..] 
sieve (x:xs) = x:(sieve (filter (p x) xs))
p x y = (y mod x)  0 
nth 100 primes
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
13 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-15 
Arvind 
Example: Split a list 
data 
Split a list of tokens into two lists a list words 
and a list of numbers. 
split :: (List Token) -&gt; 
split [] = ([],[]) 
? Token = Word String | Number Int 
((List String),(List Int)) 
split (t:ts) = 
L8-16 
Arvind 
Higher -order List abstractions 
map f [] = []
map f (x:xs ) = ?
foldl f z [] = z
foldl f z (x:xs ) = ?
foldr f z []    = z
foldr f z (x:xs
) = ?
filter p [] = []
filter p (x:xs
) = ?
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-19 
Arvind 
Zipping two lists 
= [] 
? - - - &gt; 
-&gt; 
- ) 
What does f do? 
Suppose xs is: 
x0 , x1 , x2 , ... , xn zipWith f [] []      
zipWith f (x:xs) (y:ys ) = zipWith :: (tx &gt; ty &gt; tz) 
(List tx) 
(List ty) &gt; (List tz
f xs = zipWith append xs (init ([]:xs)) 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-20 
Arvind 
Arithmetic Sequences: Special Lists 
[1 .. 4] [1,2,3,4] 
[1,3 .. 10] [1,3,5,7,9] 
[5,4 .. 1] [5,4,3,2,1] 
[5,5 .. 10] ? 
[5 .. ] ? [5,5,5,...] 
[5,6,7,...] 
10
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-11 
Arvind 
Examples of Algebraic types 
data Bool = False | True 
data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat 
data Maybe a = Nothing | Just a 
data List a = Nil | Cons a (List a) 
data Tree a = Leaf a | Node (Tree a) (Tree a) 
data Tree a b = Leaf a 
| Nonleaf b (Tree a b) (Tree a b) 
data Course = Course String Int String (List Course) 
name number description pre reqs 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-12 
Arvind 
Lists 
A list data type can be constructed in two 
different ways: 
an empty list Nil 
or a non -empty list Cons x xs 
-All elements of a list have the same type 
-The list type is recursive and polymorphic the first element the rest of 
the elements data List t = Nil | Cons t (List t) 
6
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-23 
Arvind 
Efficient Three -Partitions 
three_partitions m = 
[ (nc1,nc2,nc3) | nc1 &lt; -[0..floor(m/3)], 
nc2 &lt; ? 
L8-24 
Arvind 
The Power of List Comprehensions 
[ (i,j) | i &lt; -[1..n], j &lt; -[1..m] ]
using map 
point i j = (i,j)
points i = map (point i) [1..m]
all_points = map points [1..n] ?
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
12 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-13 
Arvind 
Infix notation 
Cons x xs 
This list may be visualized as follows: 
2 3 6 2:3:6:Nil 2:(3:(6:Nil)) [2,3,6] x:xs 
L8-14 
Arvind 
Simple List Programs 
Sum of numbers in a list 
sum [] = 0
sum (x:xs) = ?
Last element in a list 
last [] = x
last (x:xs
) = ?
All but the last element in a list 
init [] = []
init (x:xs
) = ?
What do the following do? 
init (a:xs )
(a:(init xs))
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
7 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-21 
Arvind List Comprehensions 
a convenient syntax 
[ e | 
Examples 
[ f x | x &lt; -xs ] 
means map f xs 
[ x | x &lt; -xs, (p x)] 
means 
[ f x y | x &lt; - - ys ] 
means the list 
which is defined by 
flatten (map ( \ x -&gt; (map ( \ y - ) gen, gen, ...] 
filter p xs 
xs, y &lt;
[(f x1 y1),...(f x1 yn), 
(f x2 y1),......(f xm yn)] 
&gt; e) ys xs)) 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-22 
Arvind 
Three -Partitions 
Generate a list containing all three -partitions 
(nc1, nc2, nc3) of a number m, such that 
 nc1 &lt; nc2 &lt; nc3 
 nc1 + nc2 + nc3 = m 
three_partitions m = 
[ (nc1,nc2,nc3) | nc1 &lt; -[0..m], 
nc2 &lt;-[0..m], 
? 
11
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Pattern -matching scope &amp; dont cares 
 Each clause starts a new scope : can re 
use bound variables 
 Can use "don't cares" for bound variables 
anchorPnt s = case s of 
Line p1 _ -&gt; p1 
Triangle p1 _ _ -&gt; p1 
Quad p1  _  _  _ -&gt; p1 -5 
anchorPnt :: Shape -&gt; Pnt 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Pattern -matching more syntax 
 Functions can be defined directly using 
pattern -matching 
 Pattern -matching can be used in list 
comprehensions ( later) anchorPnt (Line p1 _) = p1 
anchorPnt (Triangle p1 _ _) = p1 
anchorPnt (Quad p1 _ _ _) = p1 
(Line p1 p2) &lt; -shapes -6 
anchorPnt :: Shape -&gt; Pnt 
3
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8
Arvind 
Pattern -matching Type safety 
 Given a "Line" object, it is impossible to 
read "the field corresponding to the third 
point in a Triangle object because: 
 all unions are tagged unions 
 fields of an algebraic type can only be examined 
via pattern -matching -7 
L8-8 
Arvind 
Special syntax 
 Function type constructor 
Int -&gt; Bool
Conceptually: 
Function Int Bool 
i.e., the arrow is an "infix" type constructor 
 Tuple type constructor 
(Int, Bool )
Conceptually: 
Tuple2 Int Bool 
Similarly for Tuple3, ... 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>October 2, 2002 http://www.csg.lcs.mit. edu/6.827 L8-17 
Arvind 
Using maps and folds 
1. Write sum in terms of fold 
2. Write split using foldr 
split :: (List Token) -
3. What does function fy do? 
second (x,y) = y &gt; ((List String),(List Int)) 
fy xys = map second xys 
fy :: 
L8-18 
Arvind 
October 2, 2002 http://www.csg.lcs.mit. edu/6.827 
Flattening a List of Lists 
flatten :: (List (List t)) -&gt; (List t) 
flatten [] = [] 
: (concat xss ) append :: (List t) -&gt; (List t) -&gt; (List t) 
= ys 
) ys 
flatten (xs xss) = append xs append [] ys 
append (x:xs = (x:(append xs ys)) 
9 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bluespec - 4: Modules and Type Classes</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l20bluespec4/</lecture_pdf_url>
      <lectureno>20</lectureno>
      <slides>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-25 
Arvind 
Type "Integer" and class "Literal" 
 The type "Integer" refers to pure, 
unbounded, mathematical integers 
 and, hence, Integer is not in class Bits, which can 
only represent bounded quantities 
 Integers are used only as compile time entities 
 The class "Literal" contains a function: 
fromInteger :: Integer -&gt; t 
http://www.csg.lcs.mit. edu/6.827 L20-26 
Arvind 
Class "Literal" 
 Types such as (Bit n), ( Int n), (Uint n) 
are all members of class Literal 
 Thus, 
will represent the number 523 as a 13 -bit quantity 
 This is how all literal numbers in the 
program text, such as "0" or "1", or 
"23", or "523" are treated, i.e., they use 
the systematic overloading mechanism 
to convert them to the desired type (fromInteger 523) :: Bit 13 
13
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Replicator
LPM: Straight Pipeline Solution 
ROM IP Address Table 
Replicator 
start 
lookup 1 finish lookup 1, 
(start lookup 2) finish lookup 2, 
(start lookup 3) finish 
lookup 3 
fifo0 fifo1 fifo2 rom0 rom1 rom2 
ofifo 
IP addr 
18.100.32.127 Lookup Result 
(Egress port, ) 
http://www.csg.lcs.mit. edu/6.827 L20-3 
Arvind 
http://www.csg.lcs.mit. edu/6.827 L20-4 
Arvind 
Bluespec code: Straight pipeline 
mkLPM :: AsyncROM lat LuAddr -&gt; Module LPM 
mkLPM rom = 
module 
(rom0, rom1, rom2) &lt; -mk3ROMports rom 
fifo0 :: FIFO Mid &lt; -mkFIFO 
fifo1 :: FIFO Mid &lt; -mkFIFO 
fifo2 :: FIFO Mid &lt; -mkFIFO 
ofifo :: FIFO LuResult &lt;-mkFIFO 
rules 
... for Stages 1, 2 and Completion ... 
interface 
--Stage 0 
luReq ipa = action rom0.read (zeroExtend ipa[31:16]) 
fifo0.enq (Lookup (ipa &lt;&lt; 16)) 
luResp = ofifo.first 
luRespAck = ofifo.deq LuData 
2
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-21 
Arvind 
Class "(Bits)" for algebraic types 
 What if we had to inter -operate with hardware 
that used a different representation (e.g., 0 -5 
for M-Sa and 6 for Su)? 
 We use an explicit "instance" decl. instead of "deriving" 
data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat 
instance Bits Day 3 where 
pack Sun = 6 
pack Mon = 0 
... 
pack Sat = 5 
unpack 0 = Mon 
... 
unpack 6 = Sun 
http://www.csg.lcs.mit. edu/6.827 L20-22 
Arvind 
Class "(Bits)" for algebraic types 
 Explicit "instance" decls. may also permit more 
efficient packing 
data T = A (Bit 3) | B (Bit 5) | Ptr (Bit 31) 
instance Bits T 32 where 
pack (A a3) zeroExtend a3) 
pack (B b5) zeroExtend b5) 
pack (Ptr p31) = (1)::(Bit 1) ++ p31 
... 
unpack ... 
a3 
b5 
p31 1 0 1 0 0 = (00)::(Bit 2) ++ (
= (01)::(Bit 2) ++ (
11
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-23 
Arvind 
"deriving (Bits)" for structs 
 The canonical "pack" function simply 
bit-concatenates the packed versions of 
the fields: 
struct PktHdr = 
node --NodeID 
port --PortID 
cos :: Bit 3 --CoS 
dp :: Bit 2 --DropPrecedence 
ecn :: Bool 
res :: Reserved 1 
length --PacketLength 
crc :: Bit 32 
deriving (Bits) 
Bit 6 Bit 5 Bit 3 ... :: Bit 6 
:: Bit 5 
:: Bit 14 
http://www.csg.lcs.mit. edu/6.827 L20-24 
Arvind 
Class "Eq" 
 Class "Eq" contains the equality (==) and 
inequality (/=) operators 
 "deriving ( Eq)" will generate the natural 
versions of these operators automatically 
 Are the tags equal? 
 And, if so, are the corresponding fields equal? 
 An "instance" declaration may be used for 
other meanings of equality, e.g., 
 "two pointers are equal if their bottom 20 bits are equal" 
 "two values are equal if they hash to the same address" 
12
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-9 
Arvind 
Port replicator  after step 2 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO 
cnt0 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 &lt;-...similarly... 
port2 &lt;-...similarly... 
interface (port0, port1, port2) 
http://www.csg.lcs.mit. edu/6.827 L20-10 
Arvind 
Port replicator  final step 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 = interface 
read = Eread(1, rom, tags, cnt1) 
... 
port2 = interface ... 
interface (port0, port1, port2) Next step: 
substitute 
mk3ROMports 
into mkLPM 
5
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-5 
Arvind 
Straight pipeline cont. 
data Mid = Lookup IPaddr | Done LuResult 
mkLPM rom = 
module 
... state is rom0, rom1, rom2 , fifo0, fifo1, fifo2, ofifo 
rules 
--Stage 1: lookup, leaf 
--Stage 1: lookup, node 
interface 
... when Lookup ipa &lt;-fifo0.first, 
Leaf res &lt;-rom0.result 
==&gt; action fifo0.deq 
rom0.ack 
fifo1.enq (Done res) 
when Lookup ipa &lt;-fifo0.first, 
Node res &lt;-rom0.result 
==&gt; action fifo0.deq 
rom0.ack 
rom1.read (addr+(zeroExt ipa[31:24])) 
fifo1.enq (Lookup (ipa &lt;&lt; 8)) 
http://www.csg.lcs.mit. edu/6.827 L20-6 
Arvind 
LPM code structure 
mkLPM rom = 
module 
(rom0, rom1, rom2) &lt; -mk3ROMports rom 
fifo0 &lt;-mkFIFO 
fifo1 &lt;-mkFIFO 
fifo2 &lt;-mkFIFO 
ofifo &lt;-mkFIFO 
rules 
RuleStage1Leaf(fifo0, fifo1, rom0) 
RuleStage1Node(fifo0, fifo1, rom0, rom1) 
RuleStage2Noop(fifo1, fifo2) 
RuleStage2Leaf(fifo1, fifo2, rom1) 
RuleStage2Node(fifo1, fifo2, rom1, rom2) 
RuleCompletionNoop (fifo2, ofifo) 
RuleCompletionLeaf (fifo2, ofifo, rom2) 
RuleCompletionNode (fifo2, ofifo, rom2) 
interface 
luReq = EluReq(fifo0, rom0) 
luResp = EluResp(ofifo) 
luRespAck = EluRespAck(ofifo) Free variables of the rule 
3
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-19 
Arvind 
"deriving (Bits)" for algebraic types 
 Given an algebraic type such as: 
the canonical "pack" function created by 
"deriving (Bits)" produces packings as follows: 
where "tag" is 0 for C0, 1 for C1, and 2 for C2, 
and has enough bits to represent C2 data T = C0 ta tb | C1 tc | C2 td te tf 
deriving (Bits) 
tag 
pack tfpack te pack td pack tc pack tb pack ta 
http://www.csg.lcs.mit. edu/6.827 L20-20 
Arvind 
"deriving (Bits)" for algebraic types 
 Thus, for: 
the canonical "pack" function produces: 
where "tag" is 0 for Sun, 1 for Mon, ..., 6 for 
Sat, and is a Bit 3 data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat 
deriving (Bits) 
tag 
10
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-31 
Arvind 
The type ListN 
 Unlike the type "List t", which represents a list of 
zero or more elements of type t, the type 
ListN n 
represents a list of exactly n elements of type t 
 Advantage over List: 
 Can be converted into bits &amp; wires, stored in registers and 
FIFOs, etc., since size is known 
 Can assert exactly how many items there are, 
e.g., "The arbiter module has a list of 16 interfaces" 
 Disadvantage: 
 Cannot write recursive programs on ListN, if the size of 
the list keeps changing from call -to-call. 
 Alleviated by a rich library of functions like map, foldl, 
zip, ... where the size transformation is known (e.g., map 
preserves length) t 
http://www.csg.lcs.mit. edu/6.827 L20-32 
Arvind 
Examples of ListN functions 
 map preserves length 
 foldl's result has nothing to do with the 
input list's length 
 genList creates a list 1..n, but does not need 
an argument telling it about n! 
 The compiler figures it out from the type map :: (a-&gt;b) -&gt; ListN n a -&gt; ListN n b 
foldl :: (b-&gt;a-&gt;b) -&gt; b -&gt; ListN n a -&gt; b 
genList :: ListN n Integer 
16
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-33 
Arvind 
Examples of ListN functions cont. 
 Conversion to and from ListN and List 
toList :: ListN n a -&gt; List a 
toListN :: List a -&gt; ListN n a 
17
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L20-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
Bluespec -4 
Modules and Type Classes 
Lecture 20 
http://www.csg.lcs.mit. edu/6.827 L20-2 
Arvind 
Outline 
 Phase 1 compilation: Flattening the 
modules  
 Type classes 
 Class Eq 
 Type Bit and Class Bits 
 Type Integer and Class literal 
 ListN: Lists of fixed size 
1
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-15 
Arvind 
Type classes 
 Type classes may be seen as a 
systematic mechanism for overloading 
 Overloading: using a common name for similar, but 
conceptually distinct operations 
 Example: 
 n1 &lt; n2 where n1 and n2 are integers 
 s1 &lt; s2 where s1 and s2 are strings 
 Distinct: integer "&lt;" and string "&lt;" (using, say, 
lexicographic ordering) may not have anything to 
do with each other. 
implementations are likely to be totally different 
 Similar: integer "&lt;" and string "&lt;" may share 
some common properties, such as 
 transitivity a &lt; c) 
 irreflexivity (a &lt; b not b &lt; a) In particular, their 
(a &lt; b and b &lt; c 
http://www.csg.lcs.mit. edu/6.827 L20-16 
Arvind 
Type classes 
 A type class is a collection of types, all of 
which share a common set of operations 
with similar type signatures 
 Examples: 
 All types t in the " Eq" class have equality and 
inequality operations: 
 All types t and n in the "Bits" class have operations to 
convert objects of type t into bit vectors of size n and 
back: class Eq t where 
(==) :: t -&gt; t -&gt; Bool 
(/=) :: t -&gt; t -&gt; Bool 
class Bits t n where 
pack -&gt; Bit n 
unpack :: Bit n -&gt; t :: t 
8
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-11 
Arvind 
Port replicator call 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 = interface ... 
port2 = interface ... 
(rom0, rom1, rom2) = (port0, port1, port2) (rom0, rom1, rom2) &lt; -mk3ROMports rom 
substitutue 
for ports 
next 
http://www.csg.lcs.mit. edu/6.827 L20-12 
Arvind
After Port replicator call 
susbtitution 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let rom0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
rom1 = interface ... 
rom2 = interface ... (rom0, rom1, rom2) &lt; -mk3ROMports rom 
6
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-27 
Arvind 
Type classes for numeric types 
 More generally, type classes can be seen 
as constraints on types 
 Examples: 
 For all numeric types t1, t2, t3 in the "Add" class, the 
value of t3 is the sum of the values of t1 and t2. 
 For all numeric types t1, t2 in the "Log" class, the 
value of t2 is large enough that a (Bit t2) value can 
represent values in the range 0 to valueOf t1-1 
 These classes are used to represent/derive 
relationships between various "sizes" in a 
piece of hardware 
http://www.csg.lcs.mit. edu/6.827 L20-28 
Arvind 
Type classes for numeric types 
 Example: bit concatenation: 
and its inverse: (++) :: (Add n m k) =&gt; Bit n -&gt; Bit m -&gt; Bit k 
split :: (Add n m k) =&gt; Bit k -&gt; (Bit n,Bit m) 
14
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-17 
Arvind
How does a type become a 
member of a class? 
 Membership is not automatic: a type has to be 
declared to be an instance of a class, and 
implementations of the corresponding operations 
must be supplied 
 Until t is a member of Eq, you cannot use the "==" operation 
on values of type t 
 Until t is a member of Bits, you cannot store them in hardware 
state elements like registers, memories and FIFOs 
 The general way to do this is with an " instance " 
declaration 
 A frequent shortcut is to use a " deriving " clause 
when declaring a type 
http://www.csg.lcs.mit. edu/6.827 L20-18 
Arvind 
The Bits class 
 Example: 
 The "deriving" clause 
 Declares type Day to be an instance of the Bits class 
 Defines the two associated functions data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat 
deriving (Bits) 
pack -&gt; Bit 3 
unpack :: Bit 3 -&gt; Day :: Day 
9
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-7 
Arvind 
Port replicator code structure 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
let 
mkPort i = 
module 
out &lt;-mkSizedFIFO 
cnt &lt;-mkCounter 
rules 
RuleTags(i, rom, tags, out) 
interface 
read = Eread(i, rom, tags, cnt) 
result = Eresult(out) 
ack = Eack(out, cnt) 
port0 &lt;-mkPort 0 
port1 &lt;-mkPort 1 
port2 &lt;-mkPort 2 
interface (port0, port1, port2) substitute 
http://www.csg.lcs.mit. edu/6.827 L20-8 
Arvind 
Port replicator  after step 1 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
port0 &lt;-
module 
out &lt;-mkSizedFIFO 
cnt &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out) 
interface 
read = Eread(0, rom, tags, cnt) 
result = Eresult(out) 
ack = Eack(out, cnt) 
port1 &lt;-...similarly... 
port2 &lt;-...similarly... 
interface (port0, port1, port2) Step 2: 
Flatten 
the 
module 
renaming 
bound 
variables 
4
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-13 
Arvind 
LPM code after flattening 
mkLPM rom = 
module 
tags &lt;-mkSizedFIFO; 
out0 &lt;-mkSizedFIFO; cnt0 &lt;-mkCounter; 
out1 &lt;-mkSizedFIFO; cnt1 &lt;-mkCounter; 
out2 &lt;-mkSizedFIFO; cnt2 &lt;-mkCounter; 
fifo0 &lt;-mkFIFO; fifo1 &lt;-mkFIFO; fifo2 &lt;-mkFIFO; 
ofifo &lt;-mkFIFO; 
rules 
RuleTags(0, rom, tags, out0)... 
let rom0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
rom1 = interface ... ; r om2 = interface ... 
RuleStage1Leaf(fifo0, fifo1, rom0) ... 
interface 
luReq = EluReq(fifo0, rom0) 
luResp = EluResp(ofifo) 
luRespAck = EluRespAck(ofifo) 
http://www.csg.lcs.mit. edu/6.827 L20-14 
Arvind 
Outline 
 Phase 1 compilation: Flattening the 
modules  
 Type classes  
 Class Eq 
 Type Bit and Class Bits 
 Type Integer and Class literal 
 ListN: Lists of fixed size 
7
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L20-29 
Arvind 
Type classes for numeric types 
 Example: a lookup table containing up to 
n elements, each of type t 
 Suppose we store the elements in an array of n 
locations. 2 (n) 
bits to represent values in the range 0 to n -1 
mkTable :: (Log n k) =&gt; Table n t 
mkTable = 
module 
a :: Array (Bit k) t 
a &lt;-mkArrayFull 
index :: Reg (Bit k) 
index &lt;-mkRegU 
... An index into the array needs k=log
http://www.csg.lcs.mit. edu/6.827 L20-30 
Arvind 
Outline 
 Phase 1 compilation: Flattening the 
modules  
 Type classes  
 Class Eq 
 Type Bit and Class Bits 
 Type Integer and Class literal 
 ListN: Lists of fixed size  
15
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bluespec - 3: The IP Lookup Problem</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l19bluespec3/</lecture_pdf_url>
      <lectureno>19</lectureno>
      <slides>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-25 
Arvind 
Circular pipeline rules 
EnterEnter 
MoveMove CompleteComplete 
RecircRecirc RAM cb luReq leaf 
node luResp done getTokentf 
ops buf 
Enter: 
when (tok, ipa) &lt;-tf.first 
==&gt; action 
tf.deq 
rom.read (zeroExt ipa[31:16]) 
ops.enq (tok, ipa &lt;&lt; 16) 
http://www.csg.lcs.mit. edu/6.827 L19-26 
Arvind 
Circular pipeline rules Continued 
EnterEnter 
MoveMove CompleteComplete 
RecircRecirc RAM cb luReq leaf 
node luResp done getTokentf 
ops buf 
Complete: 
when (Leaf res) &lt;-rom.result, 
(tok, ipa) &lt;-ops.first 
==&gt; action 
rom.ack 
ops.deq 
cb.done tok.res 
Recirculate: 
when (Node addr) &lt;-rom.result, 
(tok, ipa) -ops.first 
==&gt; action 
rom.ack 
ops.deq 
buf.enq ((tok, ipa &lt;&lt; 8), 
addr+(zeroExt ipa[31:24]) &lt;
13
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-23 
Arvind 
Outline 
 Example: IP Lookup  
 Three solutions  
 Statically scheduled memory pipeline 
 Straight pipeline with uncoordinated memory 
references 
 Circular pipeline for 100% memory utilization 
 Modeling RAMs  
 Synchronous vs. Asynchonous view 
 Port replicator 
 Bluespec coding for straight pipeline  
 Bluespec coding for circular pipeline  
 Phase 1 compilation 
http://www.csg.lcs.mit. edu/6.827 L19-24 
Arvind 
Bluespec code: Circular pipeline 
mkLPMK :: AsyncROM lat LuAddr -&gt; Module LPM 
mkLPMK rom = 
module 
cb :: CBuffer NStage LuResult &lt;-mkCBuffer 
tf :: FIFO (CBToken NStage, IPaddr) &lt;-mkFIFO 
ops :: FIFO (CBToken NStage, IPaddr) &lt;-mkSizedFIFO (lat+1) 
buf :: FIFO ((CBToken NStage, IPaddr), LuAddr) 
&lt;-mkSizedFIFO (NStage+1) 
rules 
... rules for Entering, Completion, Recirculation &amp; Movement... 
interface 
luReq ipa = action tf.enq (cb.getToken, ipa) 
cb.getTokenAck 
luResp = cb.get 
luRespAck = cb.ack EnterEnter 
MoveMove CompleteComplete 
RecircRecirc RAM cb luReq leaf 
node luResp done getTokentf 
ops buf 
LuData 
12
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L19-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
Bluespec -3 
The IP Lookup Problem 
Lecture 19 
http://www.csg.lcs.mit. edu/6.827 L19-2 
Arvind 
The IP lookup problem 
 An IP lookup table contains IP prefixes 
and associated data 
 The problem: given an IP address, return 
the data associated with the longest 
prefix match ("LPM") 
F * E 5.*.*.* D 10.18.200.5 C 10.18.200.* B 7.14.7.3 A 7.14.*.* Data Prefix Result IP address 
5.13.7.2 
8.0.0.0 
10.18.200.7 7.14.7.2 F 10.18.201.5 F 10.7.12.15 F 7.13.7.3 Example 
Table Example 
lookups 
1
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-5 
Arvind 
Outline 
 Example: IP Lookup  
 Three solutions  
 Statically scheduled memory pipeline 
 Straight pipeline with uncoordinated memory 
references 
 Circular pipeline for 100% memory utilization 
 Modeling RAMs 
 Synchronous vs. Asynchonous view 
 Port replicator 
 Bluespec coding for straight pipeline 
 Bluespec coding for circular pipeline 
 Phase 1 compilation 
http://www.csg.lcs.mit. edu/6.827 L19-6 
Arvind 
Static scheduling solution 
 Assume the SRAM containing the table 
has latency of n cycles, lay out a pipeline 
so that the memory accesses are 
precisely scheduled 
 Issues: 
 Since an LPM may take 1 -3 mem accesses, unused 
slots may be left idle 
 May have to replan the pipeline for a different 
latency memory 
 Very difficult to plan if memory is also to be used 
for some unrelated task. 
3
</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-37 
Arvind 
LPM code after flattening 
mkLPM rom = 
module 
tags &lt;-mkSizedFIFO; 
out0 &lt;-mkSizedFIFO; cnt0 &lt;-mkCounter; 
out1 &lt;-mkSizedFIFO; cnt1 &lt;-mkCounter; 
out2 &lt;-mkSizedFIFO; cnt2 &lt;-mkCounter; 
fifo0 &lt;-mkFIFO; fifo1 &lt;-mkFIFO; fifo2 &lt;-mkFIFO; 
ofifo &lt;-mkFIFO; 
rules 
RuleTags(0, rom, tags, out0)... 
let rom0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
rom1 = interface ... ; r om2 = interface ... 
RuleStage1Leaf(fifo0, fifo1, rom0) ... 
interface 
luReq = EluReq(fifo0, rom0) 
luResp = EluResp(ofifo) 
luRespAck = EluRespAck(ofifo) 
19
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-15 
Arvind 
Port replicator code 
mk3ROMports :: AsyncROM lat Adr Dta -&gt; 
Module (AsyncROM (lat+1) Adr Dta, 
AsyncROM (lat+1) Adr Dta, 
AsyncROM (lat+1) Adr Dta) 
mk3ROMports rom = 
module 
tags :: FIFO Tag &lt; -mkSizedFIFO lat 
let mkPort :: Tag -&gt; Module (AsyncROM (lat+1) Adr ) 
mkPort i = 
module 
... 
port0 &lt;-mkPort 0 
port1 &lt;-mkPort 1 
port2 &lt;-mkPort 2 
interface (port0, port1, port2) not quite legal 
Dta
http://www.csg.lcs.mit. edu/6.827 L19-16 
Arvind 
Port replicator code cont. 
mkPort :: Tag -&gt; Module (AsyncROM (lat+1) Adr ) 
mkPort i = 
module 
out :: FIFO Dta &lt;-mkSizedFIFO lat 
rules 
when tags.first == i 
==&gt; action tags.deq 
rom.ack 
out.enq rom.result 
interface 
read a = action rom.read a 
tags.enq i 
result = out.first 
ack = out.deq 
Can one ports activity block another ports activity? Dta
8
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-29 
Arvind 
Outline 
 Example: IP Lookup  
 Three solutions  
 Statically scheduled memory pipeline 
 Straight pipeline with uncoordinated memory 
references 
 Circular pipeline for 100% memory utilization 
 Modeling RAMs  
 Synchronous vs. Asynchonous view 
 Port replicator 
 Bluespec coding for straight pipeline  
 Bluespec coding for circular pipeline  
 Phase 1 compilation  
http://www.csg.lcs.mit. edu/6.827 L19-30 
Arvind 
LPM code structure 
mkLPM rom = 
module 
(rom0, rom1, rom2) &lt; -mk3ROMports rom 
fifo0 &lt;-mkFIFO 
fifo1 &lt;-mkFIFO 
fifo2 &lt;-mkFIFO 
ofifo &lt;-mkFIFO 
rules 
RuleStage1Leaf(fifo0, fifo1, rom0) 
RuleStage1Node(fifo0, fifo1, rom0, rom1) 
RuleStage2Noop(fifo1, fifo2) 
RuleStage2Leaf(fifo1, fifo2, rom1) 
RuleStage2Node(fifo1, fifo2, rom1, rom2) 
RuleCompletionNoop (fifo2, ofifo) 
RuleCompletionLeaf (fifo2, ofifo, rom2) 
RuleCompletionNode (fifo2, ofifo, rom2) 
interface 
luReq = EluReq(fifo0, rom0) 
luResp = EluResp(ofifo) 
luRespAck = EluRespAck(ofifo) Free variables of the rule 
15
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-33 
Arvind 
Port replicator  after step 2 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO 
cnt0 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 &lt;-...similarly... 
port2 &lt;-...similarly... 
interface (port0, port1, port2) 
http://www.csg.lcs.mit. edu/6.827 L19-34 
Arvind 
Port replicator  final step 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 = interface 
read = Eread(1, rom, tags, cnt1) 
... 
port2 = interface ... 
interface (port0, port1, port2) Next step: 
substitute 
mk3ROMports 
into mkLPM 
17
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit.e edu/6.827 L19-9 
Arvind 
Outline 
 Example: IP Lookup  
 Three solutions  
 Statically scheduled memory pipeline 
 Straight pipeline with uncoordinated memory 
references 
 Circular pipeline for 100% memory utilization 
 Modeling RAMs  
 Synchronous vs. Asynchonous view 
 Port replicator 
 Bluespec coding for straight pipeline 
 Bluespec coding for circular pipeline 
 Phase 1 compilation 
http://www.csg.lcs.mit. edu/6.827 L19-10 
Arvind 
RAMs 
 Basic memory components are "synchronous": 
 Present an read -address AJ on clock J 
 Data DJ arrives on clock J+N 
 If you don't "catch" DJ on clock J+N, it may be lost, i.e., data 
DJ+1 may arrive on clock J+1+N 
 This kind of synchronicity can pervade the 
design and cause complications Synch Mem, 
Latency N Addr Data Clock 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-21 
Arvind 
Bluespec code: Straight pipeline 
data Mid = Lookup IPaddr | Done LuResult 
mkLPM :: AsyncROM lat LuAddr -&gt; Module LPM 
mkLPM rom = 
module 
(rom0, rom1, rom2) &lt; -mk3ROMports rom 
fifo0 :: FIFO Mid &lt; -mkFIFO 
fifo1 :: FIFO Mid &lt; -mkFIFO 
fifo2 :: FIFO Mid &lt; -mkFIFO 
ofifo :: FIFO LuResult &lt;-mkFIFO 
rules 
... for Stages 1, 2 and Completion ... 
interface 
--Stage 0 
luReq ipa = action rom0.read (zeroExtend ipa[31:16]) 
fifo0.enq (Lookup (ipa &lt;&lt; 16)) 
luResp = ofifo.first 
luRespAck = ofifo.deq LuData 
http://www.csg.lcs.mit. edu/6.827 L19-22 
Arvind 
Straight pipeline cont. 
data Mid = Lookup IPaddr | Done LuResult 
mkLPM rom = 
module 
... state is rom0, rom1, rom2 , fifo0, fifo1, fifo2, ofifo 
rules 
--Stage 1: lookup, leaf 
--Stage 1: lookup, node 
interface 
... when Lookup ipa &lt;-fifo0.first, 
Leaf res &lt;-rom0.result 
==&gt; action fifo0.deq 
rom0.ack 
fifo1.enq (Done res) 
when Lookup ipa &lt;-fifo0.first, 
Node res &lt;-rom0.result 
==&gt; action fifo0.deq 
rom0.ack 
rom1.read (addr+(zeroExt ipa[31:24])) 
fifo1.enq (Lookup (ipa &lt;&lt; 8)) 
11
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Replicator
LPM: Straight Pipeline Solution 
ROM IP Address Table 
Replicator 
start 
lookup 1 finish lookup 1, 
(start lookup 2) finish lookup 2, 
(start lookup 3) finish 
lookup 3 
fifo0 fifo1 fifo2 rom0 rom1 rom2 
ofifo 
IP addr 
18.100.32.127 Lookup Result 
(Egress port, ) 
http://www.csg.lcs.mit. edu/6.827 L19-7 
Arvind 
http://www.csg.lcs.mit. edu/6.827 L19-8 
Arvind 
Circular pipeline solution 
EnterEnter 
MoveMove CompleteComplete 
RecircRecirc RAM Completion 
buffer 
luReq leaf 
node luResp 
luRespAck 
done getToken 
getTokenAck 
tf 
ops buf 
4
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-19 
Arvind 
Some observations 
 Port replicator can be easily generalized 
to n ports 
 Port rules conflict with each other but 
serializable semantics preserves 
correctness 
http://www.csg.lcs.mit. edu/6.827 L19-20 
Arvind 
Outline 
 Example: IP Lookup  
 Three solutions  
 Statically scheduled memory pipeline 
 Straight pipeline with uncoordinated memory 
references 
 Circular pipeline for 100% memory utilization 
 Modeling RAMs  
 Synchronous vs. Asynchonous view 
 Port replicator 
 Bluespec coding for straight pipeline  
 Bluespec coding for circular pipeline 
 Phase 1 compilation 
10
</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-35 
Arvind 
Port replicator call 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let port0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
port1 = interface ... 
port2 = interface ... 
(rom0, rom1, rom2) = (port0, port1, port2) (rom0, rom1, rom2) &lt; -mk3ROMports rom 
substitutue 
for ports 
next 
http://www.csg.lcs.mit. edu/6.827 L19-36 
Arvind
After Port replicator call 
susbtitution 
tags &lt;-mkSizedFIFO 
out0 &lt;-mkSizedFIFO ; cnt0 &lt;-mkCounter 
out1 &lt;-mkSizedFIFO ; cnt1 &lt;-mkCounter 
out2 &lt;-mkSizedFIFO ; cnt2 &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out0) 
RuleTags(1, rom, tags, out1) 
RuleTags(2, rom, tags, out2) 
let rom0 = interface 
read = Eread(0, rom, tags, cnt0) 
result = Eresult(out0) 
ack = Eack(out0, cnt0) 
rom1 = interface ... 
rom2 = interface ... (rom0, rom1, rom2) &lt; -mk3ROMports rom 
18
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-17 
Arvind 
A general port replicator fixed 
x y when tag matches, 
forward y, deq tag 
shared 
tag FIFO 
Client 1 Client 2 forward x, 
enq tag base module 
replicator 
x y x y ... 
cnt cnt 
deq 
cnt++ cnt-
cnt &gt; 0 
ready ack cnt-
cnt &gt; 0 
ready deq 
ack cnt++ 
http://www.csg.lcs.mit. edu/6.827 L19-18 
Arvind 
Port replicator code fixed 
mkPort :: Tag -&gt; Module (AsyncROM (lat+1) Adr ) 
mkPort i = 
module 
out :: FIFO Dta &lt;-mkSizedFIFO lat 
cnt :: Counter (log ( lat+1)) &lt;-mkCounter lat 
rules 
when tags.first == i 
==&gt; action tags.deq 
rom.ack 
out.enq rom.result 
interface 
read a = action rom.read a 
tags.enq i 
cnt.down 
when cnt.value &gt; 0 
result = out.first 
ack = action out.deq 
cnt.up Dta
9
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-31 
Arvind 
Port replicator code structure 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
let 
mkPort i = 
module 
out &lt;-mkSizedFIFO 
cnt &lt;-mkCounter 
rules 
RuleTags(i, rom, tags, out) 
interface 
read = Eread(i, rom, tags, cnt) 
result = Eresult(out) 
ack = Eack(out, cnt) 
port0 &lt;-mkPort 0 
port1 &lt;-mkPort 1 
port2 &lt;-mkPort 2 
interface (port0, port1, port2) substitute 
http://www.csg.lcs.mit. edu/6.827 L19-32 
Arvind 
Port replicator  after step 1 
mk3ROMports rom = 
module 
tags &lt;-mkSizedFIFO 
port0 &lt;-
module 
out &lt;-mkSizedFIFO 
cnt &lt;-mkCounter 
rules 
RuleTags(0, rom, tags, out) 
interface 
read = Eread(0, rom, tags, cnt) 
result = Eresult(out) 
ack = Eack(out, cnt) 
port1 &lt;-...similarly... 
port2 &lt;-...similarly... 
interface (port0, port1, port2) Step 2: 
Flatten 
the 
module 
16
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-27 
Arvind 
Circular pipeline rules Continued -2 
EnterEnter 
MoveMove CompleteComplete 
RecircRecirc RAM cb luReq leaf 
node luResp done getTokentf 
ops buf 
Move: 
when (tokipa, addr) &lt;-buf.first 
==&gt; action 
buf.deq 
rom.read addr 
ops.enq tokipa 
Enter: 
when (tok, ipa) &lt;-tf.first 
==&gt; action 
tf.deq 
rom.read (zeroExt ipa[31:16]) 
ops.enq (tok, ipa &lt;&lt; 16) notice the 
conflicts! 
http://www.csg.lcs.mit. edu/6.827 L19-28 
Arvind 
Some observations 
 Timing Closure 
 Insert more pipeline stages (i.e. FIFO buffers)! 
 Circular pipeline solution trivially extends 
to IPv6 
14
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>L19-3 
Arvind 
Sparse tree representation 
3 A  
A  B 
C  
C  5 D F  
F  14 A  
A  7 
F  
F  200 F  
F  18 F * E 5.*.*.* D 10.18.200.5 C 10.18.200.* B 7.14.7.3 A 7.14.*.* 
3 2 M Ref Result IP address 
E 5.13.7.2 
C 10.18.200.7 A 7.14.7.2 F 10.18.201.5 F 7.13.7.3 F  
F  F 
F  E5 
7 
10 
255 0 
http://www.csg.lcs.mit. edu/6.827 L19-4 
Arvind 
Table representation issues 
 LPM is used for CIDR (Classless Inter -
Domain Routing) 
 Number of memory accesses for an LPM? 
 Too many difficult to do LPMs at line rate 
 Table size? 
 Too big bigger SRAM more latency, cost, power 
 Control-plane issues: 
 incremental table update 
 size, speed of table maintenance software 
 In this lecture (so code will fit on slides!): 
 Level 1: 16 bits, Levels 2 and 3: 8 bits 
 So: from 1 to 3 memory accesses for an LPM 
2
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-13 
Arvind 
A common subproblem : port replicator 
 Given a base module s.t.: 
 It generates response y to a particular request 
x after some number of cycles 
 It can accept requests and produce responses 
on every cycle 
 Construct a mechanism so that multiple 
client modules can utilize the base 
module with full utilization e.g., SRAM, IP lookup 
x y ... 
ReplicatorReplicator 
http://www.csg.lcs.mit. edu/6.827 L19-14 
Arvind 
A general port replicator 
x y when tag matches, 
forward y, deq tag 
shared 
tag FIFO 
Client 1 Client 2 forward x, 
enq tag base module 
replicator 
x y x y ... 
7
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L19-11 
Arvind 
Asynchronous RAMs 
It's easier to work with an "asynchronous" block: 
Synch Mem 
Latency N Addr Data Ready ctr Ack( ctr &gt; 0) ctr++ 
ctr-deq 
Data 
Ready 
http://www.csg.lcs.mit. edu/6.827 L19-12 
Arvind 
RAMs: Synchronous vs Asynchronous 
 The asynch mem has interface: 
 A synch mem can be converted into an 
asynch mem with a Bluespec function: interface AsyncROM addr data = 
read addr -&gt; Action 
result :: data 
ack :: Action 
syncToAsync :: SyncROM lat addr data -&gt; 
AsyncROM addr data :: 
6
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bluespec - 5: Programming Examples</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l21bluespec5print/</lecture_pdf_url>
      <lectureno>21</lectureno>
      <slides>
        <slide>
          <slideno>7</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-15 
Arvind 
Outline 
 Lennarts problem  
 Instruction Enco ding  
 Pack an d Unpack 
 Wallace  Tree Addition  
 Solution to Lenn arts problem 
http:// www.cs g.lcs.m it.edu/6.827 L21-16 
Arvind 
Wallace addition 
a0 a1 a2 am-1 
b0 b1 b2 bm-1 
c0 c1 c2 cm-1 
Bits at 20Bits at 21Bits at 22Bits at 2m-1 Add several m-bit numbe rs 
8
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-13 
Arvind 
Instructi on Decode - Unpack 
instance Bits Instruction 32 where 
unpack :: Bit 32 -&gt; Instruction 
unpack bs when isImmInstr bs = Immediate {
op = unpack bs[31:26];
rs = unpack bs[25:21];
rt = unpack bs[20:16];
imm = unpack bs[15:0];  } 
unpack bs when isREGIMMInstr bs = RegImm {
rs = unpack bs[25:21];
op = unpack bs[20:16];
imm = unpack bs[15:0];  } 
unpack bs when isJumpInstr bs = Jump {
op = unpack bs[31:26];
target = unpack bs[25:0];} 
... 
http:// www.cs g.lcs.m it.edu/6.827 L21-14 
Arvind 
Decodi ng Functi ons 
isImmInstr :: Bit (SizeOf Instruction) -&gt; Bool 
isImmInstr bs = not (isSpecialInstr bs || isREGIMMInstr bs 
|| isJumpInstr bs ) 
isREGIMMInstr :: Bit (SizeOf Instruction) -&gt; Bool 
isREGIMMInstr bs = bs[31:26] == (1::Bit 6) 
isJumpInstr :: Bit (SizeOf Instruction) -&gt; Bool 
isJumpInstr bs = isJumpOp (unpack bs[3 1:26]) 
isSpecialInstr :: Bit (SizeOf Inst ruction) -&gt; Bool 
isSpecialInstr bs = bs[31:26] == (0::Bit 6) 
7
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-23 
Arvind 
Wallace algorithm 
while p f x = if p x then (while p f (f x)) 
else x 
isLengthGT2 x = (length x) &gt; 2 
isAnyLengthGT2 xs = foldr (or) False (map isLengthGT2 xs) 
wallace :: List BitBag -&gt; List BitBag
wallace bitbags = 
let twoNumbers = 
while isAnyLengthGT2 wallaceStep bitbags
in fastAdd2 twoNumbers 
wallaceAdder = pack  (map head)  wallace  
padWithNil  transpose  (map unpack) 
http:// www.cs g.lcs.m it.edu/6.827 L21-24 
Arvind 
State ful Wallace Step using wallaceSte p 
wallaceStepM :: (Bit n *k) -&gt; Modul e (Bit n*k)
wallaceStepM inReg = 
Module 
regOut :: (Register (Bit n*k)) &lt;-mkReg _
inBitbagsN :: ListN n (ListN k (Bit 1))
inBitbagsN = unpack inReg
inBitbags :: List (List (Bit 1))
inBitbags  toList (map toList inBitbagsN)
outBitbags :: List (List (Bit 1))
outBitbags = wallaceStep inBitbags
outBitbagsN :: ListN n (ListN k (Bit 1))
outBitbagsN = toListN (map toListN outBitbags)
rules 
when True ==&gt; regOut := pack outBitbagsN 
interface 
regOut.read =
12
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-27 
Arvind 
Manual  unro lling 
wallaceStepM :: (Bit n *k) -&gt; Modul e (Bit n*k) 
wallaceM :: (Bit n*k) -&gt; Module (Bit n*2)
wallaceM x = 
do 
x :: (Bit n*k)  k is 2 * ceiling (k/3)
x wallaceStepM x 
x :: (Bit n*k)  k is 2 * ceiling (k/3)
x &lt;-wallaceStepM x 
... 
return 
xfinal &lt;-
http:// www.cs g.lcs.m it.edu/6.827 L21-28 
Arvind 
Lennarts Borneo Numbers 
Determine if a n-b it number contains exactly one 1. 
data Borneo = Zero | One | Many 
toB :: Bit 1 -&gt; Borneo 
toB 0 = Zero 
toB 1 = One 
isMany :: Borneo -&gt; Bool 
isMany Many = True 
isMany _ = False 
addB :: Borneo -&gt; Borneo -&gt; Borneo 
addB Zero n = n 
addB One Zero = One 
addB  _ = Many _
14
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-7 
Arvind 
MIPS Instructi on Type 
data Instruction = 
Immediate op Op
rs CPUReg
rt CPUReg
imm :: UInt16 
| Register rs :: CPUReg
rt :: CPUReg
rd :: CPUReg
sa :: UInt5 
funct :: Funct 
| RegImm rs :: CPUReg
op :: REGIMM 
imm :: UInt16 
| Jump op :: Op
target :: UInt26 
| Nop 
Need to define CPUReg, UInt5, UInt1 6, UInt26, REGIMM ,
Op and Funct :: 
:: 
:: 
http:// www.cs g.lcs.m it.edu/6.827 L21-8 
Arvind 
CPUReg Type: MIPS Instructions 
data CPUReg = eg0 | Reg1 | Reg2  Reg3
| Reg4 | Reg5 | Reg6 | Reg7 
| Reg8 | Reg9 | Reg10 | Reg11 
| Reg12 | Reg13 | Reg14 | Reg15 
| Reg16 | Reg17 | Reg18 | Reg19 
| Reg20 | Reg21 | Reg22 | Reg23 
| Reg24 | Reg25 | Reg26 | Reg27 
| Reg28 | Reg29 | Reg30 | Reg31 
deriving (Bits, Eq, Bounded) 
type UInt32 = Bit 32 
type UInt26 = Bit 26 
type UInt16 = Bit 16 
type UInt5 = Bit R |
5 
4
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mi t.edu/6 .827 L21- 1 
Arvind 
Labor atory for Computer Science 
M.I.T. 
Bluespec-5 
Programming Examp les 
Lecture 21 
http:// www.cs g.lcs.m it.edu/6.827 L21-2 
Arvind 
Quiz 
 Determine if a n-bit number contains 
exactly one 1. 
 solution will be giv en at the en d of the class 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-3 
Arvind 
Outline 
 Lennarts problem  
 Instruction Enco ding  
 Pack an d Unpack 
 Wallace  Tree Addition 
 Solution to Lenn arts problem 
http:// www.cs g.lcs.m it.edu/6.827 L21-4 
Arvind 
"deriving (Bi ts)" for al gebrai c types 
 the cano nical "pack " function created by 
"deriving (Bits)" pr oduces packings as follows: data T = A (Bit 3) | B (Bit 5) | Ptr (Bit 31)
deriving (Bits) 
a3 
b5 
p31 1 1 0 0 
0 1 
33 b it encoding ! 
2
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-9 
Arvind 
Op Type: MIPS Instructions 
data Op = SPECIAL | REGIMM 
| J | JAL | BEQ | BNE | BLEZ | BGTZ 
| ADDI | ADDIU | SLTI | SLTIU | ANDI | ORI | XORI | LUI 
| COP0 | COP1 | COP2 | OP19 
| BEQL | BNEL | BLEZL | BGTZL
| DADDIe | DADDIUe | LDLe | LDRe 
| OP28 | OP29 | OP30 | OP31 
| LB | LH | LWL | LW | LBU | LHU | LWR | LWUe 
| SB | SH | SWL | SW | SDLe | SDRe | SWR | CACHEd 
| LL | LWC1 | LWC2 | OP51 | LLDe | LDC1 | LDC2 | LDe 
| SC | SWC1 | SWC2 | OP59 | SCDe | SDC1 | SDC2 | SDe 
deriving (Eq, Bits) 
http:// www.cs g.lcs.m it.edu/6.827 L21-10 
Arvind 
Funct Type: MIPS Instructions 
data Funct = SLL | F1 | SRL SRA 
| SLLV | F5 | SRLV | SRAV 
| JR | JALR | F10 F11 
| SYSCALL | BREAK| F14 | SYNC 
| MFHI | MTHI | MFLO | MTLO 
| DSLLVe | F15 | DSRLVe | DSRAVe 
| MULT | MULTU | DIV | DIVU 
| DMULTe | DMULTUe | DDIVe | DDIVUe 
| ADD | ADDU | SUB | SUBU 
| AND | OR | XOR | NOR 
| F40 | F41 | SLT | SLTU 
| DADDe | DADDUe | DSUBe | DSUBUe 
| TGE | TGEU | TLT | TLTU 
| TEQ | F53 | TNE | F55 
| DSLLe | F57 | DSRLe | DSRAe 
| DSLL32e | F61 | DSRL32e | DSRA32e 
deriving (Bits,Eq) | 
| 
5
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-11 
Arvind 
Funct Type: MIPS Instructions 
data REGIMM = BLTZ | BGEZ | BLTZL | BGEZL 
| R4 | R5 | R6 | R7 
| TGEI | TGEIU | TLTI | TLTIU
| TEQI | R13 | TNEI | R15 
| BLTZAL | BGEZAL | BLTZALL | BGEZALL 
| R20 | R21 | R22 | R23 
| R24 | R25 | R26 | R27 
| R28 | R29 | R30 | R31 
deriving (Bits,Eq) 
http:// www.cs g.lcs.m it.edu/6.827 L21-12 
Arvind 
Instructi on Decode- Pack 
instance Bits Instruction 32 where 
pack :: Instruction -&gt; Bit 32 
pack (Immediate op rs rt imm) = 
pack (Register rs rt rd sa funct) = 
pack (RegImm rs op imm) = 
pack (Jump op target) = 
pack (Nop) = 0 
6
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-17 
Arvind 
Basic step: idea 
smaller (1/3) 
bag o f 
Bits at 2j bag o f 
Bits at 2j aj 
cj bj 
smaller 
bag o f 
Bits at 2j+1 FA 
FA 
FA 
http:// www.cs g.lcs.m it.edu/6.827 L21-18 
Arvind 
Step, across all  the bags of bits 
at 20at 21at 2n-1 FAs FAs FAs FAs 
append append append append 
at 22at 23 at 20at 21at 2n-1 at 22 
append Nil 
(discard ) N 
ceiling(N/3) 
2ceiling(N/3) One full wallace step 
9
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-25 
Arvind 
Pipelined Wall ace 
while :: (t-&gt;Bool) -&gt; (t-&gt;t) -&gt; t -&gt; t 
while p f x = if p x then (while p f (f x)) else x 
whileM :: (t-&gt;Bool) -&gt; (t-&gt;(Module t)) -&gt; t -&gt; (Module t)
whileM p f x = if p x then do 
x &lt;-f x 
(whileM p f x)
else do 
return x 
wallaceM :: (Bit n*k) -&gt; Module (Bit n*2)
wallaceM = whileM isAnyLengthGT2 wallaceStepM 
wallaceM does not work because  of types! 
http:// www.cs g.lcs.m it.edu/6.827 L21-26 
Arvind 
Alternatives 
 Write a less parameterized solution. 
 Given a k we can figure out how many wallace 
iterat ions are n eeded an d do all th e unfolding 
manually 
 Keep the register size the same after 
every iteration 
 need to pack the bits in some suitable order 
 extra hardware an d may b e messy co ding 
 different termination condition 
 Fix the language! 
 discussions underway 
13
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-21 
Arvind 
Basic step: Full adders on a list of bits 
type BitBag = List (Bit 1)
step :: (BitBag, BitBag) -&gt; BitBag -&gt; (BitBag, BitBag)
step (cs,ss) Nil = (cs,ss)
step (cs,ss) (Cons x Nil) = (cs,(Cons x ss))
step (cs,ss) (Cons x (Cons y Nil)) = 
let (c,s) = halfAdd x y
in ((Cons c cs),(Cons s ss))
step (cs,ss) (Cons x (Cons y (Cons z bs))) = 
let (c,s) = fullAdd x y z
in step ((Cons c cs),(Cons s ss)) bs 
Apply step to bitbags , i.e. to bag0, bag1, ..., bagn-1 
http:// www.cs g.lcs.m it.edu/6.827 L21-22 
Arvind
Combine: 
carry-bi tbagi and sum-bi tbagi+1 
combine :: List (BitBag, BitBag) -&gt; List BitBag 
combine csbags = 
zipWith append 
wallaceStep :: List BitBag -&gt; List BitBag
wallaceStep bitbags = 
combine (map bitbags) carry sum 
11
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.827 L21-19 
Arvind 
Putting it all together 
wallaceStep at 20at 21at 2n-1 at 22 
wallaceStep 
until e very bag has  2 bits  in it, 
at whic h point we  can use normal adder 
http:// www.cs g.lcs.m it.edu/6.827 L21-20 
Arvind 
Putting it all together 
Given a list of numbe rs x0, x1, ..., xk-1, 
 unpack each number in to m bits  b0, b1, ..., bm-1 (thus the first 
elemen t of list will contain the least significant bit of x 
 transpose the list of bitba gs such that the ith elemen t of the 
list contains the ith bit of each of the k numbers 
 pad the list with sufficient Nils (empty bitba gs) so that its 
length is equal to n, the desired number of bits in the a nswer 
 apply  the Wallace algori thm 
 extract the bit f rom each of the n bitba gs 
 pack the n bits  to form the answer 
wallaceAdder = pack  (map head)  wallace  
padWithNil  transpose  (map unpack) 
10
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>http:// www.cs g.lcs.m it.edu/6.82 L21-5 
Arvind 
Explicit pack &amp; unpack 
 Explicit "instance" decls. ma y permit more 
efficient pack ing 
instance Bits T 32 where 
pack (A a3) = 0b00 ++ (zeroExtend a3)
pack (B b5) = 0b01 ++ (zeroExtend b5)
pack (Ptr p31) = 
unpack x = if x[31:30] == 0b00 then A x[2:0]
elseif x[31:30] == 0b01 then B x[4:0]
elseif 
a3 
b5 
p31 1 0 0 
0 1 data T = A (Bit 3) | B (Bit 5) | Ptr (Bit 31)
deriving (Bits) 
32bit 
encoding! 
http:// www.cs g.lcs.m it.edu/6.827 L21-6 
Arvind 
Instructi on Encodi ng: MIP S 
Reg-Reg 
Reg-Imm 
Branch 
Jump/Call Op  Rs1 Rs2 d Const Opx 6 5 5 5  5 6 
Op  Rs1 Rd  Const 
Op  Opx s1 Const 
Op  Const R
R
3
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bluespec - 2: Bluespec Compilation Model &amp; Introduction to programming</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l18bluespec2/</lecture_pdf_url>
      <lectureno>18</lectureno>
      <slides>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-9 
Arvind 
Conflict-Free Scheduler 
 Partition rules into maximum number of 
disjoint sets such that 
 a rule in one set may conflict with one or more 
rules in the same set 
 a rule in one set is conflict free with respect to all 
the rules in all other sets 
( Best case: All sets are of size 1!!) 
 Schedule each set independently 
 Priority Encoder, Round -Robin Priority Encoder 
 Enumerated Encoder 
The state update logic remains unchanged 
http://www.csg.lcs.mit. edu/6.827 L18-10 
Arvind 
Multiple-Opper-Cycle Scheduler 
Scheduler12 
n 12 
n 
1. i  i 
2. 1  2  ....  n  1  2  ....  n 
3. Multiple operations such that 
i  j  Ri and Rj are conflict -free Scheduler 
Scheduler 
5
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L18-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
Bluespec -2 
Bluespec Compilation Model 
&amp; Introduction to programming 
Lecture 18 
http://www.csg.lcs.mit. edu/6.827 L18-2 
Arvind 
Outline 
 Bluespec compilation  
 Bluespec programming 
 Example: Barrel shifter 
1
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-19 
Arvind 
mkLs fifo0 = 
foldlM mkLsStep fifo0 (upto 0 (valueOf m  1)) Pipelined shifter continued 
mkLsStep:: FIFO (Bit n,Bit m) -&gt; (Bit m) -&gt; 
-&gt; Module (FIFO (Bit n,Bit m)) 
mkLsStep fIn j = 
module 
fOut :: FIFO (Bit n,Bit m) &lt; -mkFIFO 
rules 
when (x,s) &lt;-fIn.first 
==&gt; action fIn.deq 
fOut.enq (step s x j, s) 
return fOut State 
Internal 
behavior 
External 
interface 
 Iterate mkLsStep m times: 
start by supplying the leftmost FIFO 
http://www.csg.lcs.mit. edu/6.827 L18-20 
Arvind 
Pipelined shifter remarks 
 The program to generate the circuit is 
parametric 
 n bits represent the datawidth in the FIFO 
 m represents the number of bits needed to specify 
the shift (= log n) 
 The language scaffolding needed to 
express, for example, iteration disappears 
after the first phase of compilation 
 no circuit penalty for using high -level language 
constructs 
10
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 
From TRS to Synchronous CFSM 
Transition 
Logic I 
O SNext SCollection 
of 
State 
Elements 
http://www.csg.lcs.mit. edu/6.827 L18-4 
Arvind 
TRS Execution Semantics 
Given a set of rules and an initial term s 
While ( some rules are applicable to s ) 
 choose an applicable rule 
(non-deterministic) 
 apply the rule atomically to s 
The trick to generating good hardware is to schedule as 
many rules in parallel as possible without violating the 
sequential semantics given above 
2
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-11 
Arvind 
Multiple Rewrites Per Cycle 
Fetch: 
when True 
==&gt; action pc := pc+1 
bu.enq ( imem.read pc) 
 Bz Taken: 
when (pc , Bz rc ra) &lt;bu.first, rf! rc == 0 
==&gt; action pc := rf! ra 
bu.clear 
Can these rules be executed simultaneously? 
Yes, as long as the action of Bz Taken rule dominates ! 
many other possibilities for parallel execution ... 
http://www.csg.lcs.mit. edu/6.827 L18-12 
Arvind 
Outline 
 Bluespec compilation  
 Bluespec programming  
 Example: Barrel shifter 
6
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-13 
Arvind 
Left-shifting a value by 3 
0 0 0 x 
f3 x 
In Bluespec: 
f3 :: (Bit 10) -&gt; (Bit 10) 
f3 x = x &lt;&lt; 3 
More generally: 
f3 :: (Bit n) -&gt; (Bit n) f3 
http://www.csg.lcs.mit. edu/6.827 L18-14 
Arvind 
Shifting by a variable amount (0 -7) 
f :: (Bit n) -&gt; (Bit 3) 
-&gt; (Bit n) 
f0 x = x &lt;&lt; 0 
... 
f7 x = x &lt;&lt; 7 
f x s = 
case s of 
0 -&gt; f0 x 
1 -&gt; f1 x 
2 -&gt; f2 x 
... 
7 -&gt; f7 x 
But this is an expensive solution ! s f 
mux x 
f x s f0 
f1 
f2 
f7 3 
n n 
7
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-17 
Arvind 
Barrel Shifter: a types issue 
f :: (Bit n) -&gt; (Bit m) -&gt; (Bit n) 
f x s = let 
step s x j = if s[j:j]==0 then x 
else (x &lt;&lt; (1 &lt;&lt; j)) 
in 
foldl (step s) x (upto 0 (m  1)) f2 s 
x m ux m ux m ux f1 f2m s0 s1 sm 
n n 
x 0 x 1 x m m f 
m in (Bit m) has something to do with types. We need to 
use valueOf(m) for m in expressions. valueOf(m) 
http://www.csg.lcs.mit. edu/6.827 L18-18 
Arvind 
Pipelined shifter 
 In the j th step 
 shift by 0 or 2j depending on the j th bit of s ls2 j s 
x m ux m ux m ux ls2 0 ls2 m -1 s0 sj sm -1 
n n m 
step s x j = if s[j:j]==0 then x 
else (x &lt;&lt; (1 &lt;&lt; j)) 
 given the input FIFO fIn, produce the circuit and 
the FIFO fOut 2j 
9
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-21 
Arvind 
Monadic Fold 
foldl :: (tz -&gt; tx -&gt; tz) -&gt; tz -&gt; 
(List tx) -&gt; tz 
foldl f z Nil = z 
foldl f z (Cons x xs) = foldl f (f z x) xs 
foldlM :: (tz -&gt; tx -&gt; Module tz) -&gt; tz -&gt; 
(List tx) -&gt; (Module tz) 
foldlM f z Nil = return z 
foldlM f z (Nil x xs) = module 
z &lt;-(f z x) 
foldlM f z xs 
http://www.csg.lcs.mit. edu/6.827 L18-22 
Arvind 
Unfolding during Compilation 
foldlM f z Nil = return z 
foldlM f z (Cons x xs) = module 
z &lt;-(f z x) 
foldlM f z xs 
Suppose the list is {x1,x2,x3]. The compiler will unfold 
foldlM as follows: 
module 
z1 &lt;-f z x0 
module 
z2 &lt;-f z1 x1 
module 
z3 &lt;-f z2 x2 
return 
z3 module 
z1 &lt;-f z x0 
z2 &lt;-f z1 x1 
z3 &lt;-f z2 x2 
return 
z3 
11
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-5 
Arvind 
Compiling a Rule 
pc 
rf 
bfcurrent 
state next 
state 
values   enable 
pc 
rf 
bd  Bz Taken: 
when (Bz rc ra) &lt;bu.first, rf! rc == 0 
==&gt; action pc := rf! ra 
bu.clear 
 = enabling condition 
 = action signals &amp; values 
http://www.csg.lcs.mit.edu/6.827 L18-6 
Arvind 
Combining State Updates 
next state 
value latch 
enable 
R Scheduler: 
Priority 
Encoder OR 1 
n 1 
n 
1,R 
n,R OR s from rules 
that update R 
s from rules 
that update R 
Scheduler ensures that at most one i is true 
3
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-15 
Arvind 
Shifting by a variable amount:
solution 2 
 three cascaded steps such that the j th step shifts 
by 0 or 2j depending on the j th bit of s 
f x s = let 
x0 = if s[0:0] == 0 then x 
else (x 
x1 = if s[1:1] == 0 then x0 
else (x0 &lt;&lt; (1 &lt;&lt; 1)) 
x2 = if s[2:2] == 0 then x1 
else (x1 &lt;&lt; (1 &lt;&lt; 2)) 
in 
x2 22 f2 s 
x m ux m ux m ux f1 f4 s0 s1 s2 
n n 
x 0 x 1 x 2 3 f 
&lt;&lt; (1 &lt;&lt; 0)) 
http://www.csg.lcs.mit. edu/6.827 L18-16 
Arvind 
Shifting by a variable amount:
generalization 
f :: (Bit n) -&gt; (Bit 3) -&gt; (Bit n) 
f x s = ... m 
generalize to 
m stages? 
 In the j th step shift by 0 or 2j depending on the j th 
bit of s 
step s x j = if s[j:j]==0 then x 
else (x &lt;&lt; (1 &lt;&lt; j)) 2j 
f x s = foldl (step s) x (upto 0 (m  1)) f2 s 
x m ux m ux m ux f1 f4 s0 s1 s2 
n n 
x 0 x 1 x2 3 f 
 Apply this step m times to the initial value of x 
8
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-23 
Arvind 
Compilation of Pipelined shifter 
Suppose m is 3. The compiler will unfold foldlM as follows: mkLs fifo0 = 
foldlM mkLsStep fifo0 (upto 0 (valueOf m  1)) 
module 
fifo1 &lt;-mkLsStep fifo0 0 
fifo2 &lt;-mkLsStep fifo1 1 
fifo3 &lt;-mkLsStep fifo2 2 
return 
fifo3 
http://www.csg.lcs.mit. edu/6.827 L18-24 
Arvind 
Compilation of Pipelined shifter
continued 
module 
fifo1 &lt;-
module 
fOut &lt;-mkFIFO 
rules 
when (x,s) &lt;-fifo0.first 
==&gt; action fifo0.deq 
fOut.enq (step s x 0, s) 
return fOut 
fifo2 &lt;-mkLsStep fifo1 1 
fifo3 &lt;-mkLsStep fifo2 2 
return 
fifo3 
12
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-25 
Arvind 
Compilation of Pipelined shifter
continued -2 
module 
let fifo1 = fOut 
fOut &lt;-mkFIFO 
rules 
when (x,s) &lt;-fifo0.first 
==&gt; action fifo0.deq 
fOut.enq (step s x 0, s) 
fifo2 &lt;-mkLsStep fifo1 1 
fifo3 &lt;-mkLsStep fifo2 2 
return 
fifo3 
13
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L18-7 
Arvind 
Executing Multiple Rules Per Cycle 
Fetch: 
when True 
==&gt; action 
bu.enq ( imem.read pc) 
Add: 
when (Add rd rs rt) &lt;bu.first 
==&gt; action rf!rd := rf! rs + rf! rt 
bu.deq 
Can these rules be executed simultaneously? 
These rules are  conflict free  because they 
manipulate different parts of the state 
(i.e., pc and rf), and enq and deq on a FIFO 
can be done simultaneously. pc := pc+1 
http://www.csg.lcs.mit. edu/6.827 L18-8 
Arvind 
Conflict-Free Rules 
Rulea and Ruleb are conflict -free if 
s . a( s)  b( s)  
1. a( b( s))  b( a( s)) 
2. a( b( s)) == b( a( s)) 
3. a( b( s)) == a(s)b( s) 
where  is a sort of LUB operator 
Theorem: Conflict -free rules can be executed 
concurrently without violating TRSs sequential 
semantics 
4
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Term Rewriting Systems</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l22trsprint/</lecture_pdf_url>
      <lectureno>22</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-13 
Arvind 
Special Notation for Applicative TRS 
An infix version of Ap 
((S.x).y).z  (x.z).(y.z) 
(K.x).y  x 
The "." is often suppressed in programming 
((S  (x 
(K  x 
and by convention parentheses associative to the left 
S  x 
K  x z y) x) z) z) (y 
y x) 
z y x z) z (y 
y x 
http://www.csg.lcs.mit. edu/6.827 L22-14 
Arvind 
The SK Combinatory System 
S  x 
K  x 
Any computable function can be expressed 
using Ss and Ks ! 
Example: Identity function I  x 
S K K x  z y x z) z (y 
y x 
x 
7
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-25 
Arvind 
Orthogonal TRSs 
A TRS is Orthogonal if it is: 
1. Left Linear: has no multiple occurrences of a 
variable on the LHS of any rule, and 
2. Non Interfering: patterns of rewrite rules are 
pairwise non -interfering 
Theorem: An Orthogonal TRS is Confluent. 
http://www.csg.lcs.mit. edu/6.827 L22-26 
Arvind 
Orthogonal TRS: Examples 
A(x,0)  x 
A(x,S(y))  S(A(x,y)) 
M(x,0)  0 
M(x,S(y)) ??A(M(x,y),x) 
Ack(0,x)  S(x) 
Ack(S(y),0)  Ack(x,S(0)) 
Ack(S(x),S(y))  Ack(x,Ack(S(x),y)) 
S  x 
K  x z y x z) z (y 
y x 
13
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-19 
Arvind 
Underlined Version of a TRS 
Combinatory Logic 
S  x 
K  x 
Its underlined version 
--Extend the signature by S and K 
S x  x 
K x  x 
Is the underlined version SN ? z y x z) z (y 
y x 
z y z) z (y 
y 
http://www.csg.lcs.mit. edu/6.827 L22-20 
Arvind 
Underlined TRS 
Given a TRS R, its underlined version R is defined as 
follows: 
1. The signature of R contains all the symbols of R 
and the underlined version of each symbol of R. 
2. For each rule in R, R contains a rule gotten by 
replacing the left most symbol of the rule in R by 
its underlined version. 
10
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-11 
Arvind 
Rewriting 
One-step rewriting  
Application of one rule in a context 
Multiple-step rewriting 
t ?t1? ?t2  ?...? ?tn ?s 
may be rewritten as s 
Rewriting can be thought of as 
on terms, thus 
= Transitive , reflexive closure of  
In any semantic model, the terms t1, t2, ..., tn 
must have the same meaning! t 
inducing a relation 
http://www.csg.lcs.mit. edu/6.827 L22-12 
Arvind 
Applicative TRS 
A TRS that consists of a one special binary operator 
called application ( Ap), and some constants. 
Example: Combinatory Logic 
Constants: S, K 
Rewrite rules: 
Ap( Ap( Ap(S,x),y),z)  Ap( Ap(x,z),Ap(y,z)) 
Ap( Ap(K,x),y)  x 
6
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-7 
Arvind 
Syntax: Terms 
A signature  consists of a set of constants, 
function symbols and infinitely many variables. 
terms over  
t = x | c | Fk(t1, ...,t k) 
variable 
Open term : A term that contains a variable. 
Closed term: A term without a variable. 
a.k.a. Ground term application constant 
http://www.csg.lcs.mit. edu/6.827 L22-8 
Arvind 
Rewrite Rules 
t1  t2 
1. t1 must not be a variable; 
2. Free variables of t2 must be contained in 
in the free variables of t1 
Examples of illegal rules 
x  A(x,0) 
F(x)  y 
Sometimes it is convenient to disallow rules to 
rewrite constants , the 0-arity function symbols. 
Variables of a rule are sometimes called the meta 
variables and range over all terms in the signature . 
4
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-23 
Arvind 
Confluence aka Church-Rosser Property 
A reduction system R is said to be confluent (CR) , 
if t t 1 and t t 2 then there exits a t3 such that 
t 1 t 3 and t2 t 3. 
t 2 t 3 
Fact: In a confluent system, if a term has a normal form 
then it is unique . 
Are all TRSs confluent? 
http://www.csg.lcs.mit. edu/6.827 L22-24 
Arvind 
Confluence is difficult to Prove 
A(x,0)  x 
A(x,S(y))  S(A(x,y)) 
M(x,0)  0 
M(x,S(y)) ??A(M(x,y),x) 
Ack(0,x)  S(x) 
Ack(S(y),0)  Ack(x,S(0)) 
Ack(S(x),S(y))  Ack(x,Ack(S(x),y)) 
S  x 
K  x z y x z) z (y 
y x 
12
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-9 
Arvind 
Substitution 
A(x,0)  x (1) 
A(x,S(y))  S(A(x,y)) (2) 
M(x,0)  0 (3) 
M(x,S(y))  A(M(x,y),x) (4) 
Does any rule apply to the term 
M(S(S(0)),S(0)) ? 
http://www.csg.lcs.mit. edu/6.827 L22-10 
Arvind 
Pattern of a Rule 
A(x,0)  x 
A(x,S(y))  S(A(x,y)) 
M(x,0)  0 
M(x,S(y))  ??A(M(x,y),x) 
Replace variables on the LHS by  
?????A M 
????????0  S ????????0  S 
  
A rule applies to a term if the rule pattern matches some 
node in the syntax tree of the term ( ?matches any node) M A 
5
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-5 
Arvind 
Decision Procedure 
Is there a procedure to decide 
if E | --t1 = t2 
In general , 
The notion of reduction or rewriting was originally 
developed to understand questions regarding 
decision procedures. NO! 
http://www.csg.lcs.mit. edu/6.827 L22-6 
Arvind 
A TRS is a ( ?, R) 
where ?is a signature and 
R is a set of rewrite rules for terms over  
A(x,0)  x 
R  S(A(x,y)) 
M(x,0)  0 
M(x,S(y))  A(M(x,y),x) 
??for R 
Function symbol Arity 
0 0 Constants 
S 1 
A 2 
M 2 
A(S(0),S(0))  Term Rewriting Systems (TRS) 
A(x,S(y)) 
aka 
3
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L22-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
Term Rewriting Systems 
Lecture 22 
http://www.csg.lcs.mit. edu/6.827 L22-2 
Arvind 
Outline 
 Motivation for rewriting 
 TRS Syntax 
 applicative TRS 
 Some properties of TRSs 
 Strong normalization 
 Confluence 
 Some special TRSs 
 underlined TRS 
 orthogonal TRS 
 Recursive Program Schemes (RPS) 
 Applicative RPS 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>-----------------------------------------------------
----------------------------------------------------- http://www.csg.lcs.mit. edu/6.827 L22-3 
Arvind 
Equational Specifications 
A(x,0) = x 
A(x,S(y)) = S(A(x,y)) 
M(x,0) = 0 
M(x,S(y)) = A(M(x,y),x) E 
E is an equational specification of natural numbers. 
An equation is between terms 
The signature ??for E 
Function symbol Arity 
0 0 aka Constants 
S 1 
A 2 
M 2 
http://www.csg.lcs.mit. edu/6.827 L22-4 
Arvind 
Equational Theory 
"E |--t = s" means that t = s can be derived from the 
equations in E by the following rules: 
Substitution: 
E | --t (x1, ... , xn) = s (x1, ... ,xn) 
E | --t (t1, ... , tn) s (t1, ... ,tn) 
Forming Contexts: 
E | --t = s &amp; 
E | --C[ t ] = C[ s ] 
Symmetry, Reflexivity and Transitivity of "=" : 
E | --t = s  E | --s = t 
E | --t = t 
E | --t = s &amp; E | --s = t'  E | --t = t' = 
] is a context C[ 
2
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-21 
Arvind 
Underlining and Development 
Underline some redexes in a term. 
Development is a reduction of the term such that only 
underlined redexes are done. 
Complete Development is a reduction sequence such 
that all the underlined redexes have been performed. 
( S K K y 
 ( S K  K K y K y 
 K y  K K y 
 K y 
By underlining redexes we can distinguish between old 
and newly created redexes in a reduction sequence. (x z)) 
y) x ( ((x z ) z )) 
y) (x ((x y z)) 
y) (x 
http://www.csg.lcs.mit. edu/6.827 L22-22 
Arvind 
Underlined TRS 
Theorem: For every TRS R, R is strongly normalizing. 
The proof is based on assigning weights to each rule 
such that there is a Decreasing weight property for 
each redex. 
11
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-15 
Arvind 
Mixed Notation 
We can mix applicative and functional notation 
S  x 
K  x 
D(x,x)  E 
The above system is very different from 
S  x 
K  x 
D x x  E 
where D is a constant, that is, 
Ap( Ap(D,x),x)  E z y x z) z (y 
y x 
z y x z) z (y 
y x 
http://www.csg.lcs.mit. edu/6.827 L22-16 
Arvind 
Arity -some bad terminology 
A bad terminology is to say that 
the "arity" of S is 3, 
or the "arity" of S is variable. 
S is a constant , or a zero arity function symbol; 
Ap has arity 2, and the rewrite rule for S requires 
three Ap symbols and three arguments 
S  t5 t4 t3 t2 t1 
8
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-27 
Arvind 
Recursive Program Scheme (RPS) 
An RPS is a TRS such that 
G = { G1, ... , Gn } are base functions with non -interfering 
rules 
F = { F1, ... , Fm } are user -defined functions such that 
1. G ?F =  
??2. There is at most one rule for each Fi in F 
Fi (x1, ... , xk) = t i where each xi is distinct and each t i is built 
from x1,...,x k, and symbols from F and G 
Fact: An RPS is an orthogonal TRS. 
 ??RPS is confluent! 
http://www.csg.lcs.mit. edu/6.827 L22-28 
Arvind 
Applicative RPS 
It is the same as a functional RPS except that it is defined 
using applicative format. 
We can generating an applicative TRS Rap from a functional 
TRS R as follows: 
For each rule t1  t2 in R, Rap contains the rule 
t1ap  t2ap where tap means 
F ( t1,..., tn ) ap ?????F ap... tnap 
Theorem: If R is confluent then so is Rap. t1
14
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L22-17 
Arvind 
Normal Form 
Let ( , R) be a TRS and t be a term 
t is in normal form if it cannot be reduced any further. 
Term t is strongly normalizing (SN) if every reduction 
sequence starting from t terminates eventually. 
R is strongly normalizing (SN) if for all terms every 
reduction sequence terminates eventually. 
R is weakly normalizing (WN) if for all terms there is 
some reduction sequence that terminates. 
http://www.csg.lcs.mit. edu/6.827 L22-18 
Arvind 
Strongly Normalizing? 
1. Arb(x,y)  x 
Arb(x,y)  y 
2.  F(x,x,x) 
3. Arb(x,y)  x 
Arb(x,y)  y 
F(0,1,x)  F(x,x,x) F(0,1,x) 
9
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>The Hindley-Milner Type System (Continued)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l07hindleymilner2print/</lecture_pdf_url>
      <lectureno>7</lectureno>
      <slides>
        <slide>
          <slideno>11</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-23 
Arvind 
Overloaded Constants 
(Num t) is read as a predicate 
t is an instance of class Num 
sqr :: (Num a) =&gt; a -&gt; a 
sqr x = x * x 
What about constants? Consider 
plus1 x = x + 1 
If 1 is treated as an integer then plus1 cannot be 
overloaded. In pH numeric literals are overloaded 
and considered a short hand for 
(fromInteger the_integer_1_value ) 
where 
fromInteger :: (Num a) =&gt; Integer -&gt; a 
L7-24 
Arvind 
The Equality Operator 
Equality is an overloaded and not a polymorphic 
function 
classEq a where
(==) :: a -&gt; a -&gt; Bool
(/=) :: a -&gt; a -&gt; Bool
Thus equality needs to be defined for each type of 
interest. 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
12 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-17 
Arvind 
Extensions 
 Type Declarations 
Sanity check; can relax restrictions 
 Incremental Type checking 
The whole program is not given at the same 
time, sound inferencing when types of some 
functions are not known 
 Typing references to mutable objects 
Hindley -Milner system is unsound for a 
language with refs (mutable locations) 
 Overloading Resolution 
L7-18 
Arvind 
Overloading ad hoc polymorphism 
A symbol can represent multiple values each with a 
different type. For example: 
+ represents
plusInt :: Int -&gt; Int -&gt; Int
plusFloat :: Float -&gt; Float -&gt; Float
The context determines which value is denoted. 
The overloading of an identifier is resolved when 
the unique value associated with the symbol in that 
context can be determined. 
Compiler tries to resolve overloading but sometimes 
can't. The user must declare the type explicitly in 
such cases. 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
9 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-19 
Arvind 
Overloading vs. Polymorphism 
Both allow a single identifier to be used for 
multiple types. 
However, two concepts are very different: 
1. All specific types of a polymorphic identifier 
are instances of a most general type. 
2. A polymorphic identifier represents a 
single function semantically. 
L7-20 
Arvind 
The Most General Type 
The most general type of twice is 
t.(t -&gt; t) -&gt; (t -&gt; t) 
Any type can be substituted for t to get an instance 
of twice : 
(Int-&gt; Int) -&gt; (Int - &gt; Int) 
(String -&gt; String) -&gt; (String -&gt; String)
Overloaded + does not have a most general type. 
An overloaded function may perform semantically 
unrelated operations in different contexts. 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-21 
Arvind 
Overloading in Haskell 
Haskell has one of the most sophisticated 
overloading mechanism called type classes 
Type classes allow overloading of user defined 
symbols 
sqr x = x * x 
Is the type of sqr intSqr or FloatSqr ? 
intSqr 
floatSqr :: Float -&gt; Float 
In Haskell sqrcan be overloaded and resolved 
based on its use. :: Int -&gt; Int 
L7-22 
Arvind Type Classes 
making overloading less ad hoc 
Often a collection of related functions (e.g., +, -, 
*) need a common overloading mechanism and 
there is a collection of types (e.g., Int, Float) over 
which these functions need to be overloaded. 
Type classes bring these two concepts together 
class Num a where 
(==), (/=) :: a -&gt; a -&gt; Bool 
(+), (-), (*) :: a -&gt; a -&gt; a 
negate :: a -&gt; a 
... 
instance Num Int where
x == y = integer_eq x y
x + y = integer_add x y

instance Num Float where ...
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
11 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L7
Arvind 
Laboratory for Computer Science 
M.I.T. 
The Hindley -Milner Type System 
( Continued) 
September 30, 2002 - 1 
L7-2 
Arvind 
Outline 
 Hindley -Milner Type inference rules 
 Type inference algorithm 
 Overloading 
 Type classes 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
1 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-13 
Arvind 
Inference Algorithm 
W(TE, e) returns (S, ) such that S (TE) | --e :  
The type environment TE records the most 
general type of each identifier while the 
substitution S records the changes in the type 
variables 
Def W(TE, e) = 
Case e of 
x = ... 
x.e = ... 
(e1 e2) = ... 
let x = e1 in e2 = ... 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-14 
Arvind 
Inference Algorithm (cont.) 
Def W(TE, e) = 
Case e of 
x = 
if (x ?Dom(TE)) then Fail 
else let t 1...t n. = TE(x); 
in ( { }, [ ui / t i] ) 
x.e = 
let (S1, 1) = W(TE + { x : u }, e); 
in (S1, S1(u) --&gt; 1) 
(e1 e2) = ... 
let x = e1 in e2 
= ... us 
represent 
new type 
variables 
7
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>-- --
--
--
--September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7
Arvind 
Type Inference Rules 
Typing: TE |-e :  
Suppose we want to assert (prove) that give some type 
environment TE, the expression (e1 e2) has the type  . 
Then it must be the case that the same TE implies that e1 
has type --&gt;  and e2 has the type  . -9 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-10 
Arvind 
Type Inference Rules 
Typing: TE |-e :  
(App) TE |--e1 : --&gt;  TE |--e2 :  
? TE |--(e1 e2) :  
(Abs) 
TE | x.e :   &gt;  
( Var) 
TE | x :  
(Const) 
TE | c :  
(Let) 
TE | ( let x = e1 in e2) :  
5
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7
Arvind A mini Language 
to study Hindley -Milner Types 
 There are no types in the syntax of the language! 
 The type of each subexpression is derived by the 
Hindley -Milner type inference algorithm. Expressions 
E ::= c constant 
| x variable 
| x. E abstraction 
| (E1 E2) application 
| let x = E1 in E2 let-block -3 
Note, all the s occur in the beginning of a type scheme, 
i.e., a type  cannot contain a type scheme  
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
L7-4 
Arvind 
A Formal Type System 
Types 
 ::=  
| t 
| --&gt; 2 base types 
type variables 
Function types
?? 
Type Schemes 
 ::= 
| t. ?
Type Environments 
TE ::= Identifiers --&gt; Type Schemes 
2 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-25 
Arvind 
Read and Show Functions 
The raw input from a key board or output to the 
screen or file is usually a string. However, different 
programs interpret the string differently depending 
upon their type signature. 
A program to calculate monthly mortgage payments 
may assign the following signatures: 
read :: String -&gt; Int -principal, duration 
read :: String -&gt; Float -rate 
show :: Float -&gt; String monthly payments 
what is the type of read and show ? 
read :: String 
show :: a -&gt; String Polymorphic ? -&gt; a 
L7-26 
Arvind 
Overloaded Read and Show 
Haskell has a type class Read of readable types 
and a type class Show of showable types 
read :: Read a =&gt; String -&gt; a
show :: Show a =&gt; a -&gt; String
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
13 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>--
--e1: --e2:
--
--
--
--e1 --e2
--L
A
Generalization is restricted! 7-11 
rvind
( Var) (x : )  TE    
TE | x :  
(Let) TE+{x: } |  TE+{x:Gen(TE, )} |  
TE | ( let x = e1 in e2) :  
(Gen) TE | e :  t  FV(TE) 
TE | e : t. 
(Spec) TE |--e : t. 
TE |--e :  [t/t] 
( Var) (x : )  TE 
TE |--x :  
(Let) TE+{x: } | :  TE+{x: } | :  
TE | ( let x = e1 in e2) :  
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 Contrast: 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-12 
Arvind 
Soundness 
 The proposed type system is sound, i.e. 
if e :  then e indeed evaluates to a 
value in . 
 A method of proving soundness: 
 The semantics of the language is defined in 
terms of a value space that has integer 
values, Boolean values etc. as subspaces. 
 Any expression with a type error evaluates to 
a special value wrong. 
 There is no type expression that denotes the 
subspace wrong. 
6
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>L7-15 
Arvind 
Inference Algorithm (cont.) 
Def W(TE, e) = 
Case e of 
x = ... 
x.e = ... 
(e1 e2) = us 
let (S1, 1) = W(TE, e1); represent 
(S2, 2) = W(S1(TE), e2) new type 
S3 = Unify(S2( 1), 2 --&gt; u); variables 
in (S3 S2 S1, S3(u)) 
let x = e1 in e2 = 
let 	 (S1, 1) = W(TE + {x : u}, e1); 
S2?= Unify(S1(u), 1); 
?= Gen(S2 S1(TE), S2( 1) ); 
(S3, 2) = W(S2 S1(TE) + {x : }, e2); 
in	 (S3 S2 S1, 2) 
September 30, 2002 http://www.csg.lcs.mit .edu/6.827 
L7-16 
Arvind 
Properties of HM Type Inference 
	It is sound with respect to the type system. 
An inferred type is verifiable. 
	It generates most general types of expressions. 
Any verifiable type is inferred. 
	Complexity
PSPACE -Hard
DEXPTIME -Complete
Nested let blocks
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7
Arvind 
Generalization aka Closing 
 Generalization introduces polymorphism 
 Quantify type variables that are free in  
but not free in the type environment (TE) 
 Captures the notion of new type variables 
of  Gen(TE, ) =  t 1...t n.  
where { t1...t n } = FV( ) -FV(TE) -7 
L7-8 
Arvind 
Type Inference 
	Type inference is typically presented in two 
different forms: 
	Type inference rules: Rules define the type of each 
expression 
 Needed for showing that the type system is sound 
	Type inference algorithm: Needed by the compiler 
writer to deduce the type of each subexpression or to 
deduce that the expression is ill typed. 
	Often it is nontrivial to derive an inference 
algorithm for a given set of rules. There can be 
many different algorithms for a set of typing rules. 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7-27 
Arvind 
Ambiguous Overloading 
identity :: String -&gt; String 
identity x = show (read x) 
What is the type of (read x) ? 
Cannot be resolved ! Many different types would do. 
Compiler requires type declarations in such cases. 
identity :: String -&gt; String 
identity x = show ((read x) :: Int) 
L7-28 
Arvind 
Implementation 
How does sqr find the correct function for * ? 
sqr :: (Num a) =&gt; a -&gt; a
sqr x = x * x
An overloaded function is compiled assuming 
an extra dictionary argument. 
sqr = \ class_inst x -&gt; 
(class_inst.(*)) x x
Then (sqr 23) will be compiled as 
sqr IntClassInstance 23
Most dictionaries can be eliminated at compile 
time by function specialization. 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 
14 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7
ArvindUnification 
An essential subroutine for type inference 
def Unify( 1, 2) = 
case ( 1, 2) of 
( 1, t2) = [1 / t2] 
(t1, 2) = [2 / t1] 
( 1, 2) = if ( eq? 1 2) then [ ] 
else fail 
( 11 --&gt; 12, 21 --&gt; 22) 
= let S1=Unify( 11, 21) 
S2=Unify(S1( 12), S1( 22)) 
in S2 S1 
otherwise = fail Unify( 1, 2) tries to unify 1 and 2 and returns a 
substitution if successful 
Order in which sub -expressions 
are unified does not matter. -5 
September 30, 2002 http://www.csg.lcs.mit. edu/6.827 L7
Arvind 
Instantiations 
 Type scheme  can be instantiated into a type  by 
substituting types for the bound variables of , i.e., 
 = S  for some S s.t. Dom( S)  BV() 
- is said to be an instance of  (  &gt; ) 
- is said to be a generic instance of  when S 
maps variables to new variables.  = t 1...t n.  
Example: 
 = t 1. t1 --&gt; t2 
t 3 --&gt; t2 is a generic instance of  
Int --&gt; t2 is a non generic instance of  -6 
3
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>M- Structures Continued</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l13mstructures2print/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-7 
Arvind 
Avoiding out -of-order insertion 
insertm ys x = 
case ys of 
MNil -&gt; MCons x MNil 
MCons y ys -&gt; 
if x == y then ys 
else let 
tl ys := insertm (tl&amp;ys) x 
in ys 
Notice (tl&amp;ys) cant be read again before (tl ys) is set 
http://www.csg.lcs.mit. edu/6.827 L13-8 
Arvind 
Membership and Insertion 
insertm' is the same as insertm except that it also 
returns a flag that indicates if a match was found 
insertm' ys x = 
case ys of 
MNil -&gt; (False,(MCons x MNil)) 
MCons y ys -&gt; 
if x == y then (True,ys) 
else let 
(flag,ys) = (insertm (tl&amp;ys) x) 
tl ys := ys 
in 
(flag, ys) 
4
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-21 
Arvind 
The S Calculus 
 An extention of let with side -effects and 
barriers 
http://www.csg.lcs.mit. edu/6.827 L13-22 
Arvind 
S Syntax 
E ::= x.E in E } 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 | CNk(E1,...,Ek) | CNk(x1,...,x k) 
| allocate() 
| oi object descriptors 
PF1 ::= negate | not | ... | Prj1| Prj2 | ... | ifetch | mfetch 
... 
CN0 ::= Number | Boolean | () 
S ::=  | x = E 
| S &gt;&gt;&gt; S 
| sstore(E,E) 
| allocator | empty( oi) | full(oi,E) | error( oi) Not in initial 
expressions | x { S | E E | 
S; S | 
11
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-17 
Arvind 
Notebook Representation: Tree 
We can maintain the notebook as a (balanced) binary tree 
data Tree = TEmpty | TNode Int Tree Tree 
Nodes above the point of insertion have 
to be copied in a functional solution 
http://www.csg.lcs.mit. edu/6.827 L13-18 
Arvind 
data MList t = MNil 
| MCons {hd::t, tl::&amp;(MList t)} 
mkNotebook () = 
mArray (0,hmax) [(j,MNil) | j &lt;-[0..hmax]] Notebook Representation: Hash Table 
0 
hmax c 
bw xad 
9
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-3 
Arvind 
M-Cell: Dynamic Behavior 
 Let allocated M -cells be represented by objects o1, o2, ... 
 Let the states of an M -cell be represented as: 
empty(o) | full(o,v) | error(o) 
 When a cell is allocated it is assigned a new object 
descriptor o and is empty, i.e., empty(o) 
 Reading an M -cell 
(x=mFetch(o) ; full(o,v)) (x=v ; empty(o)) 
 Storing into an M -cell 
( mStore(o,v) ; empty(o))  full(o,v) 
( mStore(o,v) ; full(o,v)) ?(error(o); full(o,v)) 
http://www.csg.lcs.mit. edu/6.827 L13-4 
Arvind 
Barriers 
 Barriers are needed to control to the 
execution of some operations 
 A barrier discharges when all the 
bindings in its pre -region terminate, i.e., 
all expressions become values. 
{ ( y = 1+7 
&gt;&gt;&gt; 
z = 3 ) 
in 
z } 
2
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L13-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
M-Structures Continued 
Lecture 13 
http://www.csg.lcs.mit. edu/6.827 L13-2 
Arvind 
Mutable Lists 
data MList t = MNil 
| MCons {hd::t, tl::&amp;(MList t) 
Allocate 
x = MCons {hd = 5} 
Take 
tl &amp; x 
Put 
tl x := v Any field in an algebraic type can be specified as an 
M-structure field by marking it with an &amp; 
No side-effects while pattern matching M-structure slot 
1
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-5 
Arvind 
Insert: Functional and Non Functional 
Functional solution: 
insertf [] 
insertf (y:ys) x = if (x==y) then y:ys 
else y:(insertf ys x) 
M-structure solution: 
insertm ys x = 
case ys of 
MNil -&gt; MCons x MNil 
MCons y ys -&gt; 
if x == y then ys 
else let tl ys := insertm (tl&amp;ys) x 
in ys 
Can we replace tl&amp;ys by ys? In pattern matching 
m -fields have the 
examine semantics x = [x] 
http://www.csg.lcs.mit. edu/6.827 L13-6 
Arvind 
Out-of-order Insertion 
ys2 
b a ... Can the following list be produced? ys1 = insertm ys a 
ys2 = insertm ys1 b ys1 = insertf ys a 
ys2 = insertf ys1 b Compare ys2s assuming a and b are not in ys. 
ys1can be returned before the insertion of a is 
complete. 
3
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-25 
Arvind 
Barrier Rules 
 Barrier discharge 
(  &gt;&gt;&gt; S) S 
 Barrier equivalence 
((H ; S1 ) &gt;&gt;&gt; S2) (H ; (S1 &gt;&gt;&gt; S2)) 
(H &gt;&gt;&gt; S) ??(H ; S) (derivable) 
http://www.csg.lcs.mit. edu/6.827 L13-26 
Arvind 
Multiple-Store Error 
A program with exposed store error is 
suppose to blow up! 
Program --&gt; T 
The Top represents a contradiction 
Exposed error: A error(o) cell that is not 
below a barrier, inside an arm of a conditional 
or inside a lambda abstraction 
13
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-11 
Arvind 
Mutable Markings 
marked node = let m = flag &amp; node &gt;&gt;&gt; 
flag node := True 
in 
m data GNode = GNode {id::Nodeid, val::Int, 
nbrs::[GNode], flag::&amp;Bool} Keep an updateable boolean flag to record if a 
node has been visited. Initially the flag is set to 
false in all nodes. 
A procedure to return the current flag value of a 
node and to simultaneously set it to true 
http://www.csg.lcs.mit. edu/6.827 L13-12 
Arvind 
Graph Traversal: Mutable Markings 
rsum node = 
if marked node then 0 
else 
(val node) 
+ sum (map rsum (nbrs node)) E,3 C,2 
D,3 A,5 data GNode = 
GNode {id Nodeid, 
val :: Int, 
nbrs:: [GNode] 
flag::&amp;Bool } :: 
6
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-23 
Arvind 
Values and Heap Terms 
Values 
V x.E | CN0 | CNk(x1,...,x k) | oi 
Simple expressions 
SE ::= 
Heap Terms 
H ::= allocator 
| empty( oi) oi,V) 
Terminal Expressions 
ET ::= V | let H in SE ::= 
x | V 
x = V | H; H | 
| full(
http://www.csg.lcs.mit. edu/6.827 L13-24 
Arvind 
Side-effect Rules 
 Allocation rule 
( allocator; x=allocate())  
(allocator; x = o; empty(o)) 
where o is a new object descriptor 
 Fetch and Take rules 
(x=iFetch(o) ; full(o,v)) (x=v ; full(o,v)) 
(x=mFetch(o) ; full(o,v)) (x=v ; empty(o)) 
 Store rules 
( mStore(o,v) ; empty(o))  full(o,v) 
( mStore(o,v) ; full(o,v)) ?(error(o); full(o,v)) 
 Lifting rules 
sstore({ S in e }, e2) ( S ; sstore(e,e2)) 
sstore(e1, { S in e }) ??( S ; sstore(e1,e)) 
12
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-13 
Arvind 
Book-Keeping Information 
The graph should not be mutated! 
Keep the visited flags in a separate data structure -
a notebook with the following functions data GNode = GNode {id::Nodeid, val::Int, 
nbrs::[GNode], flag::&amp;Bool} 
Immutable (functional) notebook 
insert :: Notebook -&gt; Nodeid -&gt; Notebook 
Mutable notebook: insertion causes a side -effect 
insert :: Notebook -&gt; Nodeid -&gt; () mkNotebook :: () -&gt; Notebook 
member -&gt; Nodeid -&gt; Bool :: Notebook 
http://www.csg.lcs.mit. edu/6.827 L13-14 
Arvind 
Graph Traversal: Immutable Notebook 
data GNode = 
GNode {id::Nodeid, val::Int, nbrs::[GNode]} 
rsum node = 
let nb = mkNotebook () --a new notebook 
(s,_) = thread (0, nb) node 
thread (s,nb) (GNode x i nbs) = 
if member nb x then (s,nb) 
else let nb = insert nb x 
s = s + i 
in ? 
in s Thread the notebook and the current sum through 
the reachable nodes of the graph in any order 
7
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-9 
Arvind 
Graph Traversal 
data GNode = 
GNode {id Nodeid, 
val :: Int, 
nbrs:: [GNode] } 
a = GNode A 5 [b] 
b = GNode B 7 [d] 
c = GNode C 2 [b] 
d = GNode D 3 [a] 
e = GNode E 3 [c,d] E,3 C,2 
D,3 A,5 
Write function rsum to sum the nodes reachable 
from from a given node. 
rsuma ==&gt; ? :: 
http://www.csg.lcs.mit. edu/6.827 L13-10 
Arvind 
Graph Traversal: First Attempt 
rsum (GNode x i nbs) = 
i + sum (map rsum nbs) E,3 C,2 
D,3 A,5 data GNode = 
GNode {id Nodeid, 
val :: Int, 
nbrs:: [GNode] } :: 
5
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-19 
Arvind 
isMemberInsert 
isMemberInsert nb x = 
let i = hash x 
ys = nb!&amp;i 
(flag, ys) = insertm' ys x 
nb!i := ys' 
in flag 
insertm' is the same as insertm except that it 
also returns a flag to indicate if a match was 
found 
http://www.csg.lcs.mit. edu/6.827 L13-20 
Arvind 
Summary 
 M-structures have been used heavily to 
program 
 Monsoon run -time system, including I/O 
 Id compiler in Id 
 Non-deterministic numerical algorithms 
 Programming with M -structures is full of 
perils! 
 Encapsulate M -structures in functional data 
structures, if possible 
10
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L13-15 
Arvind 
Graph Traversal: Mutable Notebook 
rsum node = 
let nb = mkNotebook () --a new notebook 
rsum (GNode x i nbs) = 
if (member nb x) then 0 
else let 
insert nb x &gt;&gt;&gt; 
s = i + sum (map rsum nbs) 
in s 
in rsum node 
-No threading 
-No copying 
http://www.csg.lcs.mit. edu/6.827 L13-16 
Arvind 
Mutable Notebooks : revisited 
isMemberInsertm :: Notebook -&gt; Nodeid -&gt; Bool 
rsum node = 
let nb = mkNotebook () --a new notebook 
rsum (GNode x i nbs) = 
if (isMemberInsert nb x) 
then 0 
else i + sum (map rsum nbs) 
in 
rsum node The test for membership and subsequent 
insertion has to be done atomically to avoid 
races. 
8
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>I- Structures and Open Lists</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l11istructuresprint/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L11-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
I -Structures and Open Lists 
Lecture 11 
http://www.csg.lcs.mit. edu/6.827 L11-2 
Arvind 
Array: An Abstract Datatype 
module Array (Array, mkArray, (!), bounds) 
where 
infix 9 (!) 
data (Ix a) =&gt; Array a t 
mkArray :: (Ix a) =&gt; (a,a) -&gt; (a-&gt;t) -&gt; 
(Array a t) 
(!) :: (Ix a) =&gt; (Array a t) -&gt; a -&gt; t 
bounds :: (Ix a) =&gt; (Array a t) -&gt; (a,a) 
Thus, 
type ArrayI t = Array Int t 
type MatrixI t = Array (Int,Int) t 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-3 
Arvind 
Index Type Class 
pH allows arrays to be indexed by any type 
that can be regarded as having a contiguous 
enumerable range 
range: Returns the list of index elements between a 
lower and an upper bound 
index : Given a range and an index, it returns an 
integer specifying the position of the index in the 
range based on 0 
inRange : Tests if an index is in the range class Ix a where 
range :: (a,a) -&gt; [a] 
index :: (a,a) -&gt; a -&gt; Int 
inRange :: (a,a) -&gt; a -&gt; Bool 
http://www.csg.lcs.mit. edu/6.827 L11-4 
Arvind 
Higher Dimensional Arrays 
x = mkArray ((l1,l2),(u1,u2)) f 
means x!(i,j) = f (i,j) l1 &lt; i &lt; u1 
l2 &lt; j &lt; u2 
Type 
x ::(Array (Int,Int) t) 
Assuming 
f :: (Int,Int) -&gt; t 
mkArray will work for higher dimensional matrices 
as well. 
2
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-7 
Arvind 
Array Comprehension: Wavefront 
x = array ((1,1),(n,n)) 
([((1,1), 1)] 
++ [((i,1), 1) | 
++ [((1,j), 1) | ++ [((i,j), x!(i
-1,j) + x!(i,j-1)) 
| 
]) x[i,j]= x[i -1,j] + x[i,j -1] 1 1 1 1 1 1 1 1 
1 
1 1 
1 
1 
1 
1 
] 
] 
http://www.csg.lcs.mit. edu/6.827 L11-8 
Arvind 
Computed Indices 
find x i = 
let % find j such that x!j = i 
step j = if x!j== i then j 
else step j+1 
in 
step 1 
y = mkArray (1,n) (find x) 2 x 
y Inverse permutation 
y ! (x ! i) = i 1 2 3 4 5 6 
y = array (1,n) [( -[1..n]] How many comparisons? Can we do better? 4 3 1 6 5 
)| i &lt;, 
4
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-23 
Arvind 
Map Using Open Lists 
 Inefficient because it is not tail recursive! 
 A tail recursive version can be written using open lists: 
map f xs = close (open_map f xs) 
where map f 
map f (x:xs) = (f x):(map f xs) 
open_map f [] INil, INil) 
open_map f (x:xs) = 
let tr = ICons {hd=(f x)} 
last = for x &lt;-xs do 
finally tr 
in (tr,last) = [] [] 
= (
http://www.csg.lcs.mit. edu/6.827 L11-24 
Arvind 
Implementing List Comprehensions 
[ e | x &lt;-xs, y &lt;-ys] 
concatMap (\x-&gt; 
concatMap (\y-&gt; [e]) ys) xs Functional 
solution 1 
[ e | x &lt;-xs, y &lt;-ys] 
let f [] = [] 
f (x:xs) = 
let g [] xs 
g (y:ys) = e:(g ys) 
in (g ys) 
in (f xs) Functional 
solution 2 = f 
12
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>--
 http://www.csg.lcs.mit. edu/6.827 L11-13 
Arvind 
The Unit Type 
data () = () 
means we cannot do much with an object of the 
unit type. However, it does allow us to drop _ = 
let 
y = iArray (1,n) [] 
for i &lt;-[1..n] do 
iAStore y (x!i) i 
finally () unit data type 
in 
y 
For better syntax replace 
iAStore y (x!i) i by y!(x!i) := i 
http://www.csg.lcs.mit. edu/6.827 L11-14 
Arvind 
I -Cell 
data ICell a = ICell {contents :: . a} 
I -Structure field Constructor 
ICell :: a -&gt; ICell a 
ICell e or ICell {contents = e} 
or create an empty cell and fill it 
ic = ICell {} 
contents ic := e 
Selector 
contents ic or 
case ic of 
ICell x -&gt; ... x ... 
7
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-17 
Arvind 
Types Issue (cont.) 
Hindley-Milner type system has to be extended 
to deal with I -structures 
? ref type --requires new rules 
more on this later... 
http://www.csg.lcs.mit. edu/6.827 L11-18 
Arvind 
All functional data structures in pH 
are implemented as I -structures. 
9
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-11 
Arvind 
Computed Indices Using I -structures 
let 
y = iArray (1,n) [] 
_ = for i &lt;-[1..n] do 
_ = iAStore y (x!i) i 
finally () % unit data type 
in 
y 
What if x contains a duplicate ? Inverse permutation 
y ! (x ! i) = i 2 x 
y  
1 2 3 4 5 6 4 3 1 6 5 
http://www.csg.lcs.mit. edu/6.827 L11-12 
Arvind 
Multiple-Store Error 
Multiple assignments to an iArray slot cause a 
multiple store error 
A program with exposed store error is 
suppose to blow up! 
Program --&gt; T 
The Top represents a contradiction 
6
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-27 
Arvind 
The example 
f x y = let x!1 := 10 
y!1 := 20 
in () 
let 
x = iArray (1,2) [] 
in 
f x x f iArray (1,2) []) 
(iArray (1,2) []) (
14
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-21 
Arvind 
Open List Operations 
A pair of I -list pointers for the header and the 
trailer cells. 
closing an open list joining two open lists 
... 1 2 10 
... 11 12 n 
... 1 2 10 
... 12 n 11 
... 1 10 
... 11 n 
http://www.csg.lcs.mit. edu/6.827 L11-22 
Arvind 
Open List Operation Definitions 
type open_list t = (( IList t), (IList t)) 
nil_ol = (INil, INil) 
close (hr,tr) = 
let 
case hr of 
INil -&gt; () 
ICons _ _ -&gt; {tl tr := INil} 
in cnv_Ilist_to_list hr 
join (hr1,tr1) (hr2,tr2) = 
case hr1 of 
INil -&gt; 
ICons _ _ -&gt; 
11
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-9 
Arvind 
In functional data structures, a single construct 
specifies: 
-The shape of the data structure 
-The value of its components 
These two aspects are specified separately using 
I -structures 
efficiency 
parallelism 
I -structures preserve determinacy but are not 
functional I -structures 
! 
http://www.csg.lcs.mit. /6.827 L11-10 
Arvind 
I -Arrays 
-Allocation expression 
iArray(1,n) [] 
-Assignment 
iAStore a 2 5 
or a!2 := 5 
provided the previous content was  
"The single assignment restriction. 
-Selection expression 
a!2 ( means empty ) 1 
1 
5 n . . . 2 
n . . . 2 . . . 
5 . . . 
5
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-5 
Arvind 
The Wavefront Example 
x = mkArray ((1,1),(n,n)) (f x) 
f x (i, j) = if i == 1 then 1 
else if j == l then 1 
else x!(i-1,j) + x!(i,j-1) xi,j = xi-1,j + xi,j-1 1 1 1 1 1 1 1 1 
1 
1 
1 
1 
1 
1 
1 2 3 
3 4 
6 
4 5 
10 
5 10 
http://www.csg.lcs.mit. edu/6.827 L11-6 
Arvind 
Array Comprehension 
A special function to turn a list of (index,value) 
pairs into an array 
array :: (Ix a) =&gt; (a,a) -&gt; [(a,t)] -&gt; (Array a t) 
array ebound 
([(ie1,e1) | gen-pred, ..] 
++ [(ie2,e2) | gen-pred, ..] ++ ) 
Thus, 
mkArray (l,u) f = 
array (l,u) [(j,(f j)) | j &lt; -range(l,u)] 
List comprehensions and function array provide 
flexibility in constructing arrays, and the compiler 
can implement them efficiently 
duplicates? 
3
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-19 
Arvind 
Array Comprehensions:
a packaging of I -structures 
array dimension 
([(ie1,e1) | x &lt; -xs, y &lt;-ys] 
++ [(ie2,e2) | z &lt; -zs] ) 
let a = iArray dimension [] 
for x &lt;-xs do 
for y &lt;-ys do 
a!ie1 := e1 
finally () 
finally () 
for z &lt;-zs do 
a!ie2 := e2 
finally () 
in cvt_IArray_to_Array a translated into 
http://www.csg.lcs.mit. edu/6.827 L11-20 
Arvind 
data IList t = INil 
| ICons {hd ::t, tl:: .(IList t)} 
Allocation 
x = ICons {hd = 5} 
Assignment 
tl x := e 
The single assignment restriction. 
If violated the program will blow up. 
Selection 
case xs of 
INil -&gt; ... 
ICons h t -&gt;  
we can also write ICons {hd=h, tl=t} -&gt;  I -lists 
I -Structure field 
10
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-25 
Arvind
Implementing List Comprehensions 
Using Open Lists 
let 
zs = nil_ol 
in 
for x &lt;-xs do 
z' = open_map (\y-&gt; e) ys 
next zs = join zs z' 
finally zs [ e | x &lt;-xs, y &lt;-ys] 
1. open lists , one for each x in xs 
2. Make n 
Join these lists together 
http://www.csg.lcs.mit. edu/6.827 L11-26 
Arvind 
I -structures are non functional 
let x = iArray (1,2) [] 
in f x x 
f iArray (1,2) []) (iArray (1,2) []) ? f x y = let x!1 := 10 
y!1 := 20 
in () 
(
13
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L11-15 
Arvind 
An Array of ICells 
Example: 
numbers precede the positive numbers 
2 -3 14 -5 
-3 -5 
Functional solutions are not efficient 
let y = array (1,n) [(i, ICell {})| i&lt;-[1..n]] 
(l,r) = (0,n+1) 
final_r = for j &lt;-[1..n] do 
(l,r,k) = 
contents (y!k) := x!j 
next l = l 
next r = r 
finally r 
in (y, final_r) Rearrange an array such that the negative 
8 2 7 
7 8 14 2 2 
http://www.csg.lcs.mit. edu/6.827 L11-16 
Arvind 
Type Issues 
In the previous example 
x :: Array Int 
y :: Array (Icell Int) 
1. We will introduce an I -Structure array to eliminate 
an extra level of indirection 
2. The type of a functional array (Array) is different 
from the type of an IArray. 
However, an IArray behaves like a functional 
after all its elements have been filled . 
We provide a primitive function for this conversion 
cvt_IArray_to_Array ia -&gt; a Array 
8
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Using Monads to Structure Computation</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l16monadcomputation/</lecture_pdf_url>
      <lectureno>16</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-19 
Maessen 
Combining Monads 
 To simulate I/O, combine State and Maybe. 
 There are two ways to do this combination: 
newtype SM s a  = SM (s -&gt; (s, M aybe a))
newtype MS s a  = MS (s -&gt; Maybe  (s, a)) 
SM MS 
([],) ,)
do putChar H ([],H) ,H)
a &lt;-getChar ([],H) hing
putChar I skipped 
`mplus` putCha r ! ([],H!) ([] ,!) ([]
([]
Not
http://www.cs g.lcs.m it.edu/6.827 L13-20 
Maessen 
Monad Transformers 
 State and error h andling are sep arate features 
 We can plug them tog ether in multiple ways 
 Other monads have a similar flavor 
 Monad Transformer: ad d a feature to  a Monad . 
instance (Mona d m) =&gt; Monad (Er rorT m)
instance (Mona d m) =&gt; Monad (St ateT s m) 
type ErrorM = ErrorT Id 
type StateM s = StateT s Id 
type SM s a = StateT s (ErrorT Id)
type MS s a = ErrorT (StateT s Id) 
10
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-9 
Maessen 
Base case 
putString [] = return () 
[] = bs 
putString [] &gt; &gt; putString bs 
 return ()  &gt;&gt; putString bs
 putString bs 
 putString ([]++bs) ++ bs 
http://www.cs g.lcs.m it.edu/6.827 L13-10 
Maessen 
Inducti ve case 
putString (a:a s) = putChar a &gt;&gt; putString as 
(a:as) ++ bs = a : (as ++ b s) 
putString (a:a s) &gt;&gt; putString b s 
 (putChar a&gt;&gt;putString as) &gt;&gt;  putString bs 
 putChar a  &gt;&gt; (putString as&gt;&gt; putString bs)
 putChar a  &gt;&gt; (putString (as ++ bs))
 putString  (a : (as ++ bs))
 putString ((a:as) ++ bs) 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-21 
Maessen 
Special Monads 
 Operations ine xpressible in pure Haske ll 
 IO Monad 
Primitives must actually call the OS 
Also used to embed C code 
 State Transfo rmer Monad 
Embe ds arb itrary mutable state 
Alternative to M-structures + b arriers 
http://www.cs g.lcs.m it.edu/6.827 L13-22 
Maessen 
The S tate Transformer Monad 
instance Monad  (ST s) 
newSTRef a -&gt; ST s (STRef s a)
readSTRef STRef s a -&gt; ST s  a 
writeSTRef :: STRef s a -&gt; a -&gt;  ST s () 
runST :: ( s. ST s a) -&gt; a 
 The special type of runST guaran tees that a n 
STRef will not escape from its computation. :: 
:: 
11
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-29 
Maessen 
Monads and Orderi ng 
 Monads arent inherently ordered (Id) 
 But stateful computations must be ordered 
 For ST and  IO, at least the side-effecting 
computations are ordered. 
The unsafeInterl eaveIO construct relaxes 
this ordering, but is impure. 
 On the other hand, barriers ord er all 
computation, including non-mondic execution. 
There is still room for ex perimentation! 
15
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-13 
Maessen 
The S implest Monad 
newtype Id a =  Id a 
instance Monad  Id where 
return a  Id a 
Id a &gt;&gt;= f =  f a 
runId (Id a) =  a 
 This monad has no special operations! 
 Indeed, we could just have used let 
The runId operation runs our computation =
http://www.cs g.lcs.m it.edu/6.827 L13-14 
Maessen 
The S tate Monad 
 Allow the use of a sin gle piece of mutable state 
put :: s -&gt; St ate s ()
get :: State s  s 
runState :: s -&gt; State s r -&gt; ( s,r) 
instance Monad  (State s) 
7
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-7 
Maessen 
Outline 
 Monadic operations and their properties 
 Reasoning about monadic programs 
 Creating our own mon ads: 
Id: The  simplest monad 
State 
Supplying unique names 
Emulating simple I/O 
Exceptions 
 Composing monad transfo rmers 
 IO and ST: two very special monads 
 Using ST for imperative comp utation 
 Ordering issues 
http://www.cs g.lcs.m it.edu/6.827 L13-8 
Maessen 
Proving simple prope rties 
putString [] = return ()
putString (c:c s) = putChar c &gt;&gt; putString cs 
[] = bs 
(a:as) ++ bs = a : (as ++ b s) 
Show: 
putString as &gt; &gt; putString bs 
 putString (as++bs) ++ bs 
4
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-15 
Maessen 
Generati ng Uni que Identifiers 
type Uniq = In t 
type UniqM = S tate Int 
runUniqM :: Un iqM r -&gt; r 
runUniqM comp = snd (runState 0  comp) 
uniq :: UniqM Uniq
uniq = do u &lt;- get 
put (u+1)
return u 
http://www.cs g.lcs.m it.edu/6.827 L13-16 
Maessen 
State 
newtype State s r = S (s -&gt; (s, r)) 
instance Monad  (State s) where
return r = S (\s -&gt; (s,r))
S f &gt;&gt;= g = S (\s -&gt; let (s,  r) = f s 
S h = g r
in ) 
get = S (\s -&gt; (s, s))
put s = S (\o -&gt; (s,  ())
runState s (S c) = c s h s
8
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mi t.edu/6 .827 L13- 1 
Jan-Willem Maessen 
Labor atory for Computer Science 
M.I.T. 
Using Monads to S tructure 
Computation 
Lecture 16 
http://www.cs g.lcs.m it.edu/6.827 L13-2 
Maessen 
Monadi c I/O 
IO a: computation which does some I/O, 
then produces a value of type a. 
(&gt;&gt;)  -&gt; IO b -&gt; IO b 
(&gt;&gt;=)  -&gt; (a -&gt; IO b) - &gt; IO b 
return :: a -&gt; IO a 
Primitive actions: 
getChar O Char 
putChar har -&gt; IO ()
openFile, hClo se, ... 
Monadic I/O is a clever, type-safe idea wh ich has 
become very popular in the FL community. :: IO a
:: IO a
:: I
:: C
1
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-11 
Maessen 
Representati on Independ ence 
 Our proof did not depend on the behavior of I/O! 
 Uses prope rties of Monads 
Requires some function 
putChar :: Cha r -&gt; m () 
A monadic com putation has two se ts of operations: 
 The monadic operations, with general properties 
 Specific operations with unique properties 
http://www.cs g.lcs.m it.edu/6.827 L13-12 
Maessen 
Fib in Monadic S tyle 
fib n = fib n = 
if (n&lt;=1) th en n if (n&lt;=1) then n 
else else 
let 
n1 = n - 1 n1 &lt;-return (n-1)
n2 = n - 2 n2 &lt;-return (n-2)
f1 = fib  n1  f1 &lt;-fib n1 
f2 = fib  n2  f2 &lt;-fib n2 
in f1 + f2 return (f1+f2) 
Note the awk ward st yle: everything must be named! do 
6
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-25 
Maessen 
Insert using RList 
insertr RNil x = rCons x RNil 
insertr ys@(RC ons y yr) x =
if x==y then  return ys
else do ys &lt;-readSTRef yr
ys &lt;- insertr ys x 
writeSTRef yr ys
return ys 
http://www.cs g.lcs.m it.edu/6.827 L13-26 
Maessen 
Graph traversal : ST notebook 
data GNode = G Node NodeId Int [ GNode] 
rsum node = do 
nb &lt;-mkNotebook 
let rsum (G Node x i nbs) = d o 
seen &lt;-memberAndInsert  nb x 
if seen 
then return 0 
else do nbs &lt;-mapM rsum nbs 
return (i + sum  nbs) 
13
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-27 
Maessen 
A traversal n otebook 
type Notebook s = STRef s (RList s Nodeid) 
mkNotebook = newSTRef RNil 
memberAndInsert nb id = do 
ids &lt;-readSTRef nb 
case ids of 
MNil -&gt; do t &lt;- rCons id MNil 
writeSTRef nb t 
return False 
MCons id nb 
| id==id | otherwise = memberAndInsert nb id = return True 
http://www.cs g.lcs.m it.edu/6.827 L13-28 
Maessen 
Problems wi th Monadi c Style 
 We need a new versions of common functions: 
mapM f [] 
mapM f (x:xs) = do
a &lt;-f x 
as &lt;-mapM f xs
return (a:as) 
mapM f [] 
mapM f (x:xs) = do
as &lt;-mapM f xs 
a f x 
return (a:as) = return []
= return []
&lt;-
14
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-3 
Maessen 
Monadi c sequenci ng 
a &gt;&gt; b  a &gt;&gt;= (\_ -&gt; b) 
return a &gt;&gt;= \x -&gt; m  (\x -&gt; m) a 
m &gt;&gt;= \x -&gt; return x  m 
(m &gt;&gt;= \x -&gt; n ) &gt;&gt;= \y -&gt; o
 m &gt;&gt;= \x -&gt; (n &gt;&gt;= \y -&gt; o)
x  FV(o) 
A derived ax iom: 
m &gt;&gt; (n &gt;&gt; o)  (m &gt;&gt; n) &gt;&gt; o 
http://www.cs g.lcs.m it.edu/6.827 L13-4 
Maessen 
Syntact ic sug ar: do 
do e -&gt; e 
do e ; dostmts -&gt; e &gt;&gt; do dostmts 
do p&lt;-e ; dostmts -&gt; e &gt;&gt;= \ p-&gt; do dostmts 
do let p=e ; dostmts -&gt; let p=e in do dostmts 
do a ; b  do _ &lt;- a ; b 
do x &lt;- return a ; b  (\x -&gt; do b) a 
do x &lt;- m ; return x  m 
do y &lt;- (do x &lt;-m ; n) ; o
 do x &lt;- m; (do y &lt;-n; o) 
2
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-5 
Maessen 
Monads and Let 
Monadic binding behaves like let: 
do a ; b  do _ &lt;- a ; b 
do x &lt;- return a ; b  (\x -&gt; do b) a
do x &lt;- m ; return x  m 
do y &lt;- (do x &lt;-m ; n) ; o
 do x &lt;-m; (do y &lt;- n; o) 
let x = a in m  (\x -&gt; m) a
let x = m in x  m 
let y = ( let x = m in n) in o 
 let x = m in (let y = n in o)
x  FV(o) 
http://www.cs g.lcs.m it.edu/6.827 L13-6 
Maessen 
Monads and Let 
 Relationship between monads and let is deep 
 Use this to embed languages inside Haskell 
 IO is a special sublanguage with side effects 
class Monad m where 
return :: a -&gt; m a 
(&gt;&gt;=) a -&gt; (a -&gt; m b) - &gt; m b 
(&gt;&gt;) a -&gt; m b -&gt; m b 
fail ring -&gt; m a --* :: m 
:: m :: St
3
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-17 
Maessen 
Poor Mans I/ O 
type PoorIO a = State (String, String) 
putChar :: Cha r -&gt; PoorIO ()
putChar c = do  (in, out) &lt;- get 
put (in, out++[c ]) 
getChar :: Poo rIO Char 
getChar = do ( in, out) &lt;- get
case in of 
a:as -&gt; do put ( as, out)
return a 
[] -&gt; fail EO F 
http://www.cs g.lcs.m it.edu/6.827 L13-18 
Maessen 
Error Handlin g using Mayb e 
instance Monad  Maybe where
return a = J ust a 
Nothing &gt;&gt;= f = Nothing
Just a f = f a 
fail _ othing 
Just a ` b = Just a 
Nothing `mplus ` b = b 
do m &lt;- matrixInverse m 
y matrixVectMult m x 
return y &gt;&gt;= 
= N
`mplus
&lt;-
9
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-23 
Maessen 
Independ ent S tate Transformers 
In ST s t , the type s represents the worl d. 
 We can ha ve multiple independent worlds. 
The type of runST keeps them from interacting. 
ST q t ST s t 
ST r t 
http://www.cs g.lcs.m it.edu/6.827 L13-24 
Maessen 
Mutabl e lists usi ng ST 
We can cr eate as m any mutable references as 
we like, allowing us to build mutable 
structures just as w e would with I-and M-
cells. 
data RList s t  = RNil 
| RCons t (STRef  s t) 
rCons :: t-&gt; R List s t-&gt; ST s ( RList s t)
rCons t ts = d o r &lt;-newSTRef t s 
return (RCons t  r) 
12
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>A &#1490; - calculus with Let - blocks (continued)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l05lambdalet2print/</lecture_pdf_url>
      <lectureno>5</lectureno>
      <slides>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L5
Arvind 
Laboratory for Computer Science 
M.I.T. 
A -calculus with Let -blocks 
(continued) 
September 18, 2002 - 1 
L5-2 
Arvind 
Outline 
 The let Calculus 
 Some properties of the letCalculus 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
1 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5
Arvind 
Values and Simple Expressions 
Values 
V ::= x.E | CN0 | CNk(SE1,...,SEk ) 
Simple expressions 
SE ::= x | V -9 
L5-10 
Arvind 
Contexts for Expressions 
A context is an expression (or statement) with a 
hole such that if an expression is plugged in 
the hole the context becomes a legitimate 
expression: 
C[] ::= [] 
| x.C[] 
| C[] E | E C[] 
| let S in C[] 
| let SC[] in E 
Statement Context for an expression 
SC[] ::= x = C[] 
| SC[] ; S | S; SC[] 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
5 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-11 
Arvind 
let Instantiation Rules 
A free variable in an expression can be instantiated 
by a simple expression 
Instantiation rule 2 
(x = a ; SC[x])  (x = a ; SC[a]) simple expression free occurrence 
of x in some 
context C renamed C[ ] to 
avoid free -
variable capture Instantiation rule 1 
( let x = a ; S in C[x])  ( let x = a ; S in C[a]) 
Instantiation rule 3 
x = a  x = C[C[x]] where a = C[x] 
L5-12 
Arvind 
Lifting Rules: Motivation 
let 
f = let S1 in x.e1 
y = f a 
in 
((let S2 in x.e2) e3) 
How do we juxtapose 
( x.e1) a 
or 
( x.e2) e3 ? 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
6 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-17 
Arvind 
Instantaneous Information 
Instantaneous information (info) of a term is 
defined as a (finite) trees 
TP ::= | ?| CN0 | CNk (TP1,...,TPk) 
Info: E  TP 
Info[{S in E}] = Info [E] 
Info[x.E] =  
Info[CN0] = CN0 
Info[ CNk(a1,...,ak)] 
= CNk(Info[a1],...,Info[ ak ]) 
Info[E] = otherwise 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
Proposition Reduction is monotonic wrt Info: 
If e e1 then Info[e]  Info[e1]. 
Proposition Confluence wrt Info: 
If e e1 and e e2 then 
 e3 s.t. e1 e3 and Info[e2]  Info[e3]. L5-18 
Arvind 
Reduction and Info 
Terms can be compared by their Info value 
  t (bottom) 
t  t (reflexive) 
CNk(v1,...,v ,...,vk)  CNk(v1,...,v,...,vk)i i
if vi ?vi 
9 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-19 
Arvind 
Print: Unwinding of a term 
Print : E  {TP} 
Unwind a term as much as possible using the 
following instantiation rule (Inst): 
( let x = v; S in C[x])  ?(let x = v; S in C[v]) 
and keep track of all the unwindings 
Print[e] = {Info[e1] | e e1 using the Inst rule} ? 
Terms with infinite unwindings lead to infinite sets. 
L5-20 
Arvind 
Garbage Collection 
Let-blocks often contain bindings that are not 
reachable from the return expression, e.g., 
let x = e in 5 
Such bindings can be deleted without affecting 
the meaning of the term. 
GC-rule 
( let SG; S in e)  ( let S in e) 
provided  x.(x  (FV(e) U FVS(S)) 
 x  BVS(SG) 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5
Arvind 
-calculus with Letrec 
E ::= x | x.E | E E 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 
| CNk(E1,...,Ek) | CNk(SE1,...,SEk) 
| let S in E 
PF1 ::= negate | not | ... | Prj1| Prj2 | ... 
PF2 ::= + | ... 
CN0 ::= Number | Boolean 
CN2 ::= cons | ... 
Statements 
S ::=  | x = E | S; S 
Variables on the LHS in a let expression must be 
pairwise distinct not in 
initial 
terms -3 
L5-4 
Arvind 
Let-block Statements 
 ;  is associative and commutative 
SS1 ; S2  S2 ; S1 
1 ; (S2 ; S3)  (S1 ; S2 ) ; S3 
 ; S ?S
let  in E  E 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-15 
Arvind 
Confluenence and Letrecs 
odd = n.Cond(n=0, False, even (n 1)) (M) 
even = n.Cond(n=0, True, odd (n 1)) 
substitute for even (n 1) in M 
odd = n.Cond (n=0, False, 
Cond (n-1 = 0 , True, odd ((n 1)-1))) (M1) 
even = n.Cond (n=0, True, odd (n 1)) 
substitute for odd (n 1) in M 
odd = n.Cond (n=0, False, even (n 1)) (M2) 
even = n.Cond (n=0, True, 
Cond ( n1 = 0 , False, even ((n 1)-1))) 
Can odd in M1 and M2 be reduced to the same expression ? 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-16 
Arvind 
 versus let Calculus 
Terms of the let calculus can be translated into 
terms of the  calculus by systematically 
eliminating the let blocks. Let T be such a 
translation. 
Suppose e e1 in let then does there exist a 
reduction such that T[[e]] T[[e1]] in  ? 
8
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5
Arvind 
Free Variables of an Expression 
FV(x) = {x} 
FV(E1 E2) = FV(E1) U FV(E2) 
FV(x.E) = FV(E) -{x} 
FV(let S in E) = FVS(S) U FV(E)  BVS(S) 
FVS() = {} 
FVS(x = E; S) = FV(E) U FVS(S) 
BVS() = {} 
BVS(x = E; S) = {x} U BVS(S) -5 
L5-6 
Arvind 
 -Renaming (to avoid free variable capture) 
Assuming t is a new variable, rename x to t : 
x.e  t.(e[t/x]) 
let x = e ; S in e0 
 let t = e[t/x] ; S[t/x] in e0[t/x] 
where [t/x] is defined as follows: 
x[t/x] = t 
y[t/x] = y if x  y 
(E1 E2 )[t/x] = (E1[t/x] E2[t/x]) 
( x.E)[t/x] = x.E 
( y.E)[t/x] = ?y.E[t/x] if x  y 
( let S in E)[t/x] 
= ? ( let S in E) if x  FV(let S in E) 
( let S[t/x] in E[t/x]) if x  FV(let S in E) 
[t/x] =  
(y = E)[t/x] = ?(y = E[t/x]) 
(S1; S2)[t/x] = ? (S1[t/x]; S2[t/x]) 
September 18, 2002 http://www.csg.lcs.mit .edu/6.827 
3 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-21 
Arvind 
Unrestricted Instantiation 
let instantiation rules allow only values &amp; variables 
to be substituted. Let 0 be a calculus that permits 
substitution of arbitrary expressions: 
Unrestricted Instantiation Rules of 0 let x = e; S in C[x]  let x = e; S in C[e] 
(x = e; SC[x])  (x = e; SC[e]) 
x = e  x = C[e] where e  C[x] 
Is 0 more expressive than let ? 
L5-22 
Arvind 
Semantic Equivalence 
	What does it mean to say that two terms 
are equivalent? 
	Do any of the following equalities imply 
semantic equivalence of e1 and e2 
Syntactic equality of -convertability : e1 = e2 
Print equality: Print(e1) = Print(e2) 
No observable difference in any context: 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
11 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-13 
Arvind 
Lifting Rules 
( let S in e) is the ? -renamed ( let S in e) to 
avoid name conflicts in the following rules: 
x = let S in e  x = e; S 
let S1 in ( let S in e)  let S1; S in e 
( let S in e) e1  let S in e e1 
Cond ((let S in e), e1, e2) 
 let S in Cond (e, e1, e2) 
PFk (e1,...,(let S in e),..., ek ) 
 let S in PFk (e1,...,e,..., ek) 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5-14 
Arvind 
Outline 
 The let Calculus 
 Some properties of the let Calculus 
7
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>September 18, 2002 http://www.csg.lcs.mit. edu/6.827 L5
ArvindPrimitive Functions and 
Datastructures 
-rules 
+( n, m )  n+m 
... 
Condrules 
Cond(True, e1, e2 )  e1? 
Cond(False, e1, e2 )  e2 
Data -structures 
CNk (e1,...,ek )  
let t 1 = e1; ... ; t k = ek 
in CNk(t1,...,t k ) 
Prji( CNk (a1,...,ak ))  ai -7 
L5-8 
Arvind 
The -rule 
The normal -rule 
( x.e) ea  ?e [ea/x] 
is replaced the following -rule 
( x.e) ea  ?let t = ea in e[t/x] 
where t is a new variable 
and the Instantiation rules which are used to 
refer to the value of a variable 
September 18, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>The Hindley-Milner Type System</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l06hindleymilnerprint/</lecture_pdf_url>
      <lectureno>6</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
Type Safety 
 A language is type safe if only type 
correct programs can be written in that 
language. 
 Most languages are not type safe, i.e., 
have holes in their type systems. 
Fortran: Equivalence, Parameter passing 
Pascal: Variant records, files 
C, C++: Pointers, type casting 
However, Java, CLU, Ada, ML, Id, Haskell, pH 
etc. are type safe. -5 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
Type Declaration vs Reconstruction 
 Languages where the user must declare the types 
 CLU, Pascal, Ada, C, C++, Fortran, Java 
 Languages where type declarations are not needed 
and the types are reconstructed at run time 
 Scheme, Lisp 
 Languages where type declarations are generally not 
needed but allowed, and types are reconstructed at 
compile time 
 ML, Id, Haskell, pH 
A language is said to be statically typed if type -checking 
is done at compile time -6 
3
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
Laboratory for Computer Science 
M.I.T. 
The Hindley -Milner Type System 
September 25, 2002 - 1 
L6-2 
Arvind 
Outline 
 General issues 
 Type instances 
 Type Unification 
 Type Generalization 
 A formal type system 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
1 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-17 
Arvind 
A Formal Type System 
Note, all the s occur in the beginning of a type scheme, 
i.e., a type  cannot contain a type scheme  
A type ?is said to be polymorphic if it contains a type 
variable Types 
? ::=  base types 
| t type variables 
| 
?? --&gt; 2 Function types 
Type Schemes 
 ::= ? 
|  t. ? 
Type Environments 
TE ::= Identifiers --&gt; Type Schemes 
{ + :: Int --&gt; Int --&gt; Int, 
f ::  t. t --&gt; t --&gt; Bool }Example TE 
L6-18 
Arvind 
Free and Bound Variables 
 = ?t 1..t . n
BV() = { t1,..., t }n FV() = {type variables of } -{ t1,..., t }n 
The definitions extend to Type Environments in an 
obvious way 
Example: 
 ? = ? t 1. (t1 --&gt; t2) 
FV() = 
BV() = 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
9 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-19 
Arvind 
Type Substitutions 
A substitution is a map 
S : Type Variables --&gt; Types 
S = [?/ t1?????????,..., n ? / t n] 
 = S   is a Substitution Instance of  
 = S  Applied only to FV( ), with renaming of BV( ) 
as necessary 
similarly for Type Environments 
Examples: 
S = [(t2 --&gt; Bool) / t1] 
S( t1 --&gt; t1) = ( t2 --&gt; Bool) --&gt; ( t2 --&gt; Bool ) 
S( t 1.t1 --&gt; t2) = ? 
S( t 2.t1 --&gt; t2) = ? 
Substitutions can be composed, i.e., S2 S1 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-20 
Arvind 
Instantiations 
 Type scheme  can be instantiated into a type  by 
substituting types for BV( ), that is, 
 = S  for some S s.t. Dom( S)  BV() 
-? is said to be an instance of  (  &gt; ) 
- is said to be a generic instance of ?when S 
maps variables to new variables.  =  t 1..t n.  
Example: 
 =  t 1. t1 --&gt; t2 
a generic instance of ?is ? 
10
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-15 
Arvind 
Inferring Polymorphic Types 
Constraints: let 
id = x. x 
in 
... (id True) ... (id 1) ... 
id :: t1 --&gt; t1 id :: Int --&gt; t2 id :: Bool --&gt; t3 
id :: 1. t1 --&gt; t1 
Different uses of a generalized type variable 
may be instantiated differently 
id2 : Bool --&gt; Bool 
id1 : Int --&gt; Int Solution: Generalize the type variable: 
?? t 
Generalization is Restricted L6-16 
Arvind 
f = g. ...(g True) ... (g 1) ... 
Can we generalize the type of g to ? 
t1 t2. t1 --&gt; t2 ? 
There will be restrictions on g from the 
environment, the place of use, which may 
make this deduction unsound (incorrect) 
Only generalize  new type variables, the 
variables on which all the restrictions are 
visible. 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
Polymorphism 
 In a monomorphic language like Pascal, 
one defines a different length function for 
each type of list 
 In a polymorphic language like ML, one 
defines a polymorphic type (list t), where t 
is a type variable, and a single function 
for computing the length 
 pH and most modern functional languages 
have polymorphic objects and follow the 
Hindley-Milner type system . -7 
L6-8 
Arvind 
Type Instances 
The type of a variable can be instantiated 
differently within its lexical scope. 
let
id = \x.x
in
((id1 5), (id2 True))
id1:: ?
id2:: ?
Both id1 and id2 can be regarded as instances of type 
?
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-11 
Arvind A mini Language 
to study Hindley-Milner Types 
 There are no types in the syntax of the language! 
 The type of each subexpression is derived by the 
Hindley-Milner type inference algorithm. Expressions 
E ::= c constant 
| x variable 
| ??x. E abstraction 
| (E1 E2) application 
| let x = E1 in E2 let-block 
Types 
 ::=  base types ( Int, Bool ..) 
| t type variables 
| 1 ? --&gt; 2 Function types 
L6-12 
Arvind 
Type Inference Issues 
	What does it mean for two types a ?and b to be equal? 
	Structural Equality 
Suppose = --&gt; 2a 1 
b = --&gt; 4
3 ?
Is = b?
a 
	Can two types be made equal by choosing appropriate 
substitutions for their type variables?
	Robinsons unification algorithm 
Suppose  --&gt; Bool 
a = t1 
b = Int ?
--&gt; t2
Are and b unifiable ?
a 
Suppose  = t 1--&gt; Bool 
a
b = Int ?
--&gt; Int
Are and b unifiable ?
a 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
6 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-13 
Arvind 
Simple Type Substitutions 
A substitution is a map 
S : Type Variables --&gt; Types 
S = [?/ t1,..., n ? / t n] 
 = S   is a Substitution Instance of  
Example: 
S = [(t --&gt; Bool) / t1] 
S( t1 --&gt; t1) = ? Types 
 ::=  base types ( Int, Bool ..) 
| t type variables 
| 1 ? --&gt; 2 Function types 
Substitutions can be composed, i.e., S2 S1 Example: 
S1 = [(t --&gt; Bool) / t1] ; S2 = [Int / t] 
S2 S1 ( t1 --&gt; t1) = ? 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
def Unify(1, 2) = 
case ( 1, 2) of 
( 1, t2) = [1 / t2] 
(t1, 2) = [2 / t1] 
( 1, 2) = if ( eq? 1 2) then [ ] 
else fail 
( 11 --&gt; 12, 21 --&gt; 22) 
= let S1=Unify( 11, 21) 
S2=Unify(S1( 12), S1( 22)) 
in S2 S1 
otherwise = fail 
Does the order 
matter? L6-14 
ArvindUnification 
An essential subroutine for type inference 
Unify(1, 2) tries to unify 1 and 2 and returns a 
substitution if successful 
7 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-21 
Arvind 
Generalization aka Closing 
 Generalization introduces polymorphism 
 Quantify type variables that are free in ? 
but not free in the type environment (TE) 
 Captures the notion of new type variables 
of  Gen(TE, ) =  t 1..t n.  
where { t1...t n } = FV( ) -FV(TE) 
L6-22 
Arvind 
Type Inference 
	Type inference is typically presented in two 
different forms: 
	Type inference rules: Rules define the type of each 
expression 
 Needed for showing that the type system is sound 
	Type inference algorithm: Needed by the compiler 
writer to deduce the type of each subexpression or to 
deduce that the expression is ill typed. 
	Often it is nontrivial to derive an inference 
algorithm for a given set of rules. There can be 
many different algorithms for a set of typing rules. 
next lecture ... 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
11 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
What are Types? 
 A method of classifying objects (values) in 
a language 
x :: ? 
says object x has type ??or object x 
belongs to a type ? 
  denotes a set of values. 
This notion of types is different from languages 
like C, where a type is a storage class specifier . -3 
L6-4 
Arvind 
Type Correctness 
	If x :: , then only those operations that are 
appropriate to set  may be performed on x. 
	A program is type correct if it never performs 
a wrong operation on an object. 
-Add an Int and a Bool 
-Head of an Int 
-Square root of a list 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6
Arvind 
Type Instances: another example 
twice1 :: ? 
twice2 :: ? let 
twice :: (t -&gt; t) -&gt; t -&gt; t 
twice f x = f (f x) 
in 
twice1 twice2(plus 3) 4 -9 
September 25, 2002 http://www.csg.lcs.mit. edu/6.827 L6-10 
Arvind 
Type Instantiation:
-bound vs Let-bound Variables 
Only let -bound identifiers can be instantiated 
differently. 
let 
twice f x = f (f x) 
in 
twice twice (plus 3) 4 
vs. 
let 
twice f x = f (f x) 
foo g = (g g (plus 3)) 4 
in 
foo twice 
Generic vs. Non -generic type variables 
5
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bluespec - 1: A language for hardware design, simulation and synthesis</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l17bluespec1print/</lecture_pdf_url>
      <lectureno>17</lectureno>
      <slides>
        <slide>
          <slideno>12</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-25 
Arvind 
Rule: As a State Transformer 
 A rule may be decomposed into two parts (s) 
and (s) such that 
snext = if ( s) then ( s) else s 
( s) is expressed as (atomic) actions on the 
state elements. These actions can be enabled 
only if ( s) is true 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-26 
Arvind 
Compiling a Rule 
pc 
rf 
bfcurrent 
state next 
state 
values   enable 
pc 
rf 
bd  Bz Taken: 
when ( Bz rc ra ) &lt;-bu.first, rf! rc == 0 
==&gt; action pc := rf! ra 
bu.clear 
 = enabling condition 
 = action signals &amp; values 
13
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-21 
Arvind 
Bluespec: A two -level language 
Source code 
Intermediate form: 
Rules and Actions 
(Term Rewriting System) 
Object code 
(Verilog/C) Level 1 compilation 
Level 2 compilation  Type checking 
 Massive partial evaluation 
 Rule conflict analysis 
 Rule scheduling 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
From TRS to Synchronous CFSM 
Transition 
Logic I 
O SNext SCollection 
of 
State 
Elements 
11
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
TRS have an old venerable history  an example 
Terms 
GCD(x,y) 
Rewrite rules 
GCD(x, y)  GCD(y, x) if x&gt;y, y 0 (R1 ) 
GCD(x, y)  GCD(x, y -x) if x y, y0 (R2) 
Initial term 
GCD( initX ,initY ) 
Execution Term Rewriting Systems (TRS) 
GCD(6, 15)  -7 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
TRS as a Description of Hardware 
Terms represent the state : registers, FIFOs , memories, ... 
Rewrite Rules (condition action) 
represent the behavior in terms of atomic actions on 
the state -8 
4
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-31 
Arvind 
Multiple -rewrite -per-cycle Scheduler 
Scheduler: 
Priority 
Encoder 12 
n 12 
n 
1. i i 
2. 1 2  .... n 1 2  .... n 
3. i j  Rulei and Rulej are conflict free  
         
 
L17-32 
Arvind 
Multiple Rewrites Per Cycle 
Fetch:
when True
==&gt; action pc := pc+1
bu.enq (imem .read pc) 
Bz Taken:
when (pc , Bz rc ra ) &lt;-bu.first, rf!rc == 0
==&gt; action pc := rf!ra
bu.clear 
Can these rules be executed simultaneously? 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
16 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-29 
Arvind 
Executing Multiple Rules Per Cycle 
Fetch: 
when True 
==&gt; action pc := pc+1 
bu.enq ( imem .read pc) 
Add: 
when (Add rd rs rt) &lt;-bu.first 
==&gt; action rf!rd := rf! rs + rf! rt 
bu.deq 
Can these rules be executed simultaneously? 
L17-30 
Arvind 
Conflict -Free Rules 
Rulea and Ruleb are conflict -free if 
s . a( s)  b( s)  
1. a( b( s))  b( a( s)) 
2. a( b( s)) == b( a( s)) 
3. a( b( s)) == a(s)b( s) 
Theorem: Conflict -free rules can be executed 
concurrently without violating TRSs sequential 
semantics 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
15 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind
Language support to organize 
state and rules into modules 
interface module 
Modules are like objects (private state, interface methods, rules). 
Rules can manipulate state in other modules only via their interfaces. -9 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-10 
Arvind 
GCD in Bluespec 
mkGCD :: Module GCD 
mkGCD = 
module 
x :: Reg ( Int 32) 
x mkReg _ 
y :: Reg ( Int 32) 
y mkReg 0 
rules 
when x &gt; y, y /= 0 
==&gt; action x := y 
y := x 
when x &lt;= y, y /= 0 
==&gt; action y := y  x 
interface 
start ix iy = action x := ix 
y := iy when y == 0 
result = x when y == 0 State 
Internal 
behavior 
External interface &lt; -
&lt; -
5
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
Laboratory for Computer Science 
M.I.T. 
Bluespec 1: 
A language for hardware 
design, simulation and synthesis 
November 13 , 2002 - 1 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
C/C++ 
model Current ASIC Design Flow 
Verilog RTL 
netlist synthesis place &amp; route 
final 
netlist timing &amp; area 
violations 
Functional 
Verification bugs by 
hand 
Physical design Tapeout -2 
1
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-15 
Arvind 
Outline 
 Preliminaries  
 A new semantic model for hardware 
description: TRS  
 An example: A simple pipelined CPU 
 Bluespec compilation 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-16 
Arvind 
CPU with 2 stage Pipeline 
fetch execute pc 
imem dmem Reg file CPU 
bu 
mkCPU :: Imem &gt; Dmem &gt; Module CPUinterface 
mkCPU imem dmem = 
module 
pc :: Reg Iaddress mkReg 0 
rf :: Array RName (Bit 32) &lt; mkArray 
bu :: FIFO Instr mkFIFO 
rules  
interface  &lt; -
&lt; -
8
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
Goals of high -level synthesis 
 Reduce time to market 
 Same specification for simulation, verification and 
synthesis 
 Rapid feedback  architectural exploration 
 Enable hierarchical design methodology 
Without sacrificing performance 
area, speed, implementability ,  
 Reduce manpower requirement 
 Facilitate maintenance and evolution of IPs 
These goals are increasingly urgent, but 
have remained elusive -3 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
Whither High -level Synthesis? 
Despite concerted efforts for well over a 
decade the compilers seem to not produce 
the quality of design expected by 
the semiconductor industry  
BehavioralVerilog System-C 
.. -4 
2
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>enab
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-13 
Arvind 
FIFO 
interface FIFO a = 
enq :: a &gt; Action --enqueue an item 
deq :: Action --remove the oldest entry 
first :: a --inspect the oldest item 
 when appropriate notfull and notempty are implicit 
conditions on FIFO operations 
 mkFIFO interfaces to a Verilog implementation of FIFO 
n = # of bits needed 
to represent the 
values of type "a" rdy n 
n rdy enab 
rdy 
finot full 
not empty 
not empty 
le enq deq rst 
FI FO 
m odu
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-14 
Arvind 
Array 
Arrays are a useful abstraction for modeling register files 
interface Array index a = 
uda :: index &gt; a &gt; Action --store an item 
(!) :: index &gt; a --retrieve an item 
mkArray :: Module (Array index a) 
 There are many implementations of mkArray depending 
upon the degree of concurrent accesses 
7
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-11 
Arvind 
External Interface: GCD 
interface GCD = 
start :: (Int 32) &gt; (Int 32) &gt; Action 
result :: Int 32 
Many different implementations 
(including in Verilog) can provide the 
same interface 
mkGCD :: Module GCD 
mkGCD =  
. 
. 
. 
mkGCD1 :: Module GCD 
mkGCD1 =  
L17-12 
Arvind 
Basic Building Blocks: Registers 
	Bluespec has no built -in primitive modules 
	there is, however, a systematic way of providing a 
Bluespec view of Verilog (or C) blocks 
interface Reg a = 
get :: a --reads the value of a register 
set :: a -&gt; Action --sets the value of a register 
Special syntax: 
 x means x.get 
 x := e means x.set e 
mkReg :: a -&gt; Module (Reg a) 
The mkReg procedure interfaces to a Verilog 
implementation of a register 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
6 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-23 
Arvind 
Synchronous State Elements 
RD 
LE Q WA 
WD 
WE 
RA1RA2RA3 RD1RD2RD3 A ED 
EE first 
DE 
CE F _full 
_empty 
Bit[N] 
Tag[N] Array Fifo 
L17-24 
Arvind 
TRS Execution Semantics 
Given a set of rules and an initial term s 
While ( some rules are applicable to s ) 
 choose an applicable rule 
(non-deterministic) 
 apply the rule atomically to s 
The trick to generating good hardware is to schedule as 
many rules in parallel as possible without violating the 
sequential semantics given above 
November 13, 2002 http://www.csg.lcs.mit .edu/6.827 
12 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17
Arvind 
Bluespec: So where is the magic? 
 A new semantic model for which a path to 
generating efficient hardware exists 
 Term Rewriting Systems (TRS) 
 The key ingredient: atomicity of rule -firings 
 James Hoe [MIT '00 ] CMU and Arvind [MIT] 
 A programming language that embodies ideas 
from advanced programming languages 
 Object oriented 
 Rich type system 
 Higher -order functions 
 transformable 
 Borrows heavily from Haskell 
 designed by Lennart Augustsson [Sandburst] 
Overall impementation : Lennart Augustsson , Mieszko Lis -5 
L17-6 
Arvind 
Outline 
	Preliminaries  
	A new semantic model for hardware 
description: TRS 
	An example: A simple pipelined CPU 
	Bluespec compilation 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
3 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-19 
Arvind 
Processor Execute Rules 
fetch execute pc rf CPU 
bu 
Add: 
when (Add rd rs rt) &lt;-bu.first 
==&gt; action rf!rd := rf! rs + rf! rt 
bu.deq 
 Bz Not Taken: 
when ( Bz rc ra ) &lt;-bu.first, rf! rc /= 0 
==&gt; action bu.deq 
 Bz Taken: 
when ( Bz rc ra ) &lt;-bu.first, rf! rc == 0 
==&gt; action pc := rf! ra 
bu.clear 
L17-20 
Arvind 
Outline 
	Preliminaries  
	A new semantic model for hardware 
description: TRS  
	An example: A simple pipelined CPU  
	Bluespec compilation 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-17 
Arvind 
CPU Instructions 
data RName = R0 | R1 | R2 |  | R31 
type Src = RName 
type Dest = RName 
type Cond = RName 
type Addr = RName 
type Val = RName 
data Instr = Add Dest Src Src 
| Jz Cond Addr 
| Load Dest Addr 
| Store Val Addr 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-18 
Arvind 
Processor Fetch Rules 
fetch execute pc rf CPU 
bu 
Fetch: 
when True 
==&gt; action pc := pc + 1 
bu.enq ( imem .read pc) 
Note that this rule pays no special attention to branch instructions 
9
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-27 
Arvind 
Combining State Updates 
next state 
values from 
different rules 
that update PC next 
state 
value OR latch 
enable enables from 
different rules 
that update PC 
0,PC 
1,PC 
n,PC 01 
n 
sel PC 
What if more than 
one rule is enabled? 
November 13, 2002 http://www.csg.lcs.mit. edu/6.827 L17-28 
Arvind 
Single -rewrite -per-cycle Scheduler 
Scheduler: 
Priority 
Encoder 12 
n 12 
n 
1. i i 
2. 1 2  .... n 1 2  .... n 
3. One rewrite at a time 
i.e. at most one i is true  
         
14
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>The Confluence of the &#1490; - calculus</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l23confluenceprint/</lecture_pdf_url>
      <lectureno>23</lectureno>
      <slides>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-5 
Arvind 
WCR does not imply CR 
Example: 
F(x)  G(x) 
F(x)  1 
G(x)  F(x) 
G(x)  0 
http://www.csg.lcs.mit. edu/6.827 L23-6 
Arvind 
Why WCR does not imply CR 
Suppose R is WCR 
Completing this diagram 
looks like proving the CR 
theorem again! 
The diagram may 
not complete! 
There will be no 
problem if all the 
reduction paths 
were finite 
3
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-7 
Arvind 
Strongly Normalizing Systems 
Let ( , R) be a TRS and t be a term 
t is in normal form if it cannot be reduced any further. 
Term t is strongly normalizing (SN) if every reduction 
sequence starting from t terminates eventually. 
R is strongly normalizing (SN) if for all terms every 
reduction sequence terminates eventually. 
R is weakly normalizing (WN) if for all terms there is 
some reduction sequence that terminates. 
http://www.csg.lcs.mit. edu/6.827 L23-8 
Arvind 
Neumann's Lemma 
If a reduction system R is SN and WCR then 
R is CR. 
How does it help us when an R is not SN ? 
Only old redexes need to be 
performed to close the diagram 
define a new reduction system for 
doing just theold redexes. 
Is such a system SN? 
4
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-15 
Arvind 
Lemma: There exits an initial weight assignment 
for each M such that M has dwp. 
Proof: 
1. Assign the weight 2m to the m th variable 
occurrence from the right 
| m | 
M = 
 |x| = 2m 
2. dwp since 
2n &gt; n-1 + 2n-2 + ... + 1 
Example: 
(x y ((z.z) Initial Weight Assignment 
. . . x . . . . . . 
M has the 
2
(x x))) 
http://www.csg.lcs.mit. edu/6.827 L23-16 
Arvind 
Lemma: If M has dwp and M --&gt; N then |N| &lt; |M| 
Proof: 
Suppose (( x.P) Q) is the redex that is reduced 
when --&gt; N. 
Cases 
(i) x is not in FV(P) : 
(ii) x is in FV(P) : Reduction Decreases the Weight
of a term with dwp 
M 
8
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-23 
Arvind 
Finite Development Theorem 
Suppose M is a -term and F is a set of redexes 
in M, then 
1. All developments of M related to F are finite 
2. All complete developments of M related to F 
end with the same term. 
The proof follows from the fact that the -calculus 
is SN and WCR 
http://www.csg.lcs.mit. edu/6.827 L23-24 
Arvind
CD Reduction has the Diamond 
Property 
M 1 
M M3 F2 F1 
M3 is a CD of M with respect to F1 U F2 
M 1 
M2 M3 M
M
12
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-17 
Arvind 
Lemma: If M --&gt; N and M has dwp then so does N. 
Proof: Suppose M --&gt; N by doing the redex 
R0  ( x.P0) Q0. 0 -reduction 
on some other redex R1  ( y.P1) Q1 in M. 
Cases on relative position of R0 and R1 
1. 0 and R1 are disjoint 
2. 1 is inside R0 (effect on subterms ) 
3. 0 is inside R1 (effect on the context) dwp is Preserved Under Reduction 
Examine the effect of R
R
R
R
http://www.csg.lcs.mit. edu/6.827 L23-18 
Arvind 
Suppose M --&gt; N by doing the redex R0  ( x.P0) Q0. 
Examine the effect of R0 -reduction on R1 ( y.P1) Q1. 
Case 2. 1 is inside R0 (effect on subterms ) 
2.1 R1 is inside the rator, x.P0 
R0  ( x....((y.P1) Q1)...) Q0 
2.2 R1 is inside the rand, Q0 
R0  ( x.P0) 1...) dwp is Preserved Under Reduction 
continued -1 
R
(...R
9
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-11 
Arvind 
Complete Development An Example 
M = (x.x x) (I (I a)) where I = ( x.x) 
Underline some redexes 
M = (x.x x) (I (I a)) 
 ( I (I a)) (I (I a)) 
 (I a) (I (I a)) 
 (I a) (I a)  ( x.x x) (I a) 
 (I a) (I a) 
http://www.csg.lcs.mit. edu/6.827 L23-12 
Arvind 
Underlined Reduction Systems are SN 
Theorem: For every reduction system R, R is strongly 
normalizing. 
Proof strategy: 
Assign a weight to each term M such that the weight 
decreases after each reduction. 
M --&gt; N ????|N| &lt; |M| 
where |M| represents the weight of M. 
Decreasing weight property Thus, if 
M --&gt; M1 --&gt; M2 --&gt; ... 
 |M| &gt; |M1| &gt; |M2| &gt; ... 
 since for all M, |M| &gt; 0, the reduction terminates! 
6
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-27 
Arvind 
Orthogonal TRSs are CR 
Proof outline: 
1. R is orthogonal  R is orthogonal. 
2. R is orthogonal ??R is WCR  ??R is WCR. 
3. R is SN 
4. From 2. and 3. R is CR 
5. Transitive Closure of R = Transitive closure of R 
 R is CR. (Neumann's Lemma) 
http://www.csg.lcs.mit. edu/6.827 L23-28 
Arvind 
If R is orthogonal then R is WCR 
  
Case 1:  and  are disjoint 
 ?and  commute (trivially) 
Case 2:  is a subexpression of  
(   cannot be a subexpression of ? 
?????Case 2a: ?is reduced before  
Since R is orthogonal, reducing ? 
cannot affect  
?????Case 2b: ?is reduced before  
???????????????  can destroy or duplicate ???????????????????? 
  
   
 
 
14
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-25 
Arvind 
Orthogonal TRS 
 Confluence of orthogonal TRSs can be 
shown in the same way. 
http://www.csg.lcs.mit. edu/6.827 L23-26 
Arvind 
Orthogonal TRSs 
A TRS is Orthogonal if it is: 
1. Left Linear: has no multiple occurrences of a 
variable on the LHS of any rule, and 
2. Non Interfering: patterns of rewrite rules are 
pairwise non -interfering 
Theorem: An Orthogonal TRS is Confluent. 
13
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L23-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
The Confluence of the  calcu lus 
Lecture 23 
http://www.csg.lcs.mit. edu/6.827 L23-2 
Arvind 
Confluence aka Church-Rosser Property 
A reduction system R is said to be confluent (CR) , 
if t t 1 and t t 2 then there exits a t3 such that 
t 1 t 3 and t2 t 3. 
t 2 t 3 
Fact: In a confluent system, if a term has a normal form 
then it is unique . 
Theorem: The calculus is confluent. 
Theorem: An orthogonal TRS is confluent. 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-3 
Arvind 
The Diamond Property 
A reduction system R is said to have the diamond 
property , if t --&gt; t1 and t --&gt; t2 then there exits a t3 
such that t1 --&gt; t3 and t2 --&gt; t3. 
t t 
t 2 t 3 
Theorem: If R has the diamond property then 
R is confluent. 
Fact: The -calculus does not have the diamond 
property. 
http://www.csg.lcs.mit. edu/6.827 L23-4 
Arvind 
Weak Confluence 
A reduction system R is said to be weakly confluent 
(WCR),  t 1 and t  t 2 then there exits a t3 such 
that t1 t 3 and t2 t 3. 
t t 
t 2 t 3 
In a WCR system one step divergence can be contained! 
Theorem: If R is CR then R is also WCR. 
Theorem: If R is WCR then R is also WCR. if t 
2
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-19 
Arvind 
Suppose M --&gt; N by doing the redex R0  ( x.P0) Q0. 
Examine the effect of R0 -reduction on R1 ( y.P1) Q1. 
Case 3. 0 is inside R1 (effect on the context) 
3.1 R0 is inside the rator of R1 
R1  ( y....((x.P0) Q0)...) Q1 
3.2 R0 is inside the rand of R1 
R1  ( y.P1) (...((x.P0) Q0)...) dwp is Preserved Under Reduction 
continued -2 
R
http://www.csg.lcs.mit. edu/6.827 L23-20 
Arvind 
Proof Strategy for CR 
Define a new type of reduction called complete 
developments (CD) using the underlined -
calculus. 
Prove the diamond property for CD reductions, 
i.e., show that CD is SN and CD is WCR. 
The proof of confluence for the -calculus follows: 
Each reduction 
can be viewed as 
a CD Since CD reductions 
have the diamond 
property 
10
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-13 
Arvind 
Assigning Weights (The calculus) 
Associate a positive integer to each variable 
occurrence in M 
| M |: 
| xw | = w 
| x.M | = | M | 
| x.M | = | M | 
| M N | = | M | + | N | 
Weights, like underlined , are carried 
through the reduction unchanged. sum of the weights occurring in M 
http://www.csg.lcs.mit. edu/6.827 L23-14 
Arvind 
Decreasing Weight Property ( dwp) 
M has decreasing weight property if for every 
 -redex ((x.P) Q) in M, |x| &gt; |Q| for each free 
occurrence of x in P 
Examples 
M1 = (x. x6 x7) (y. y2 y3) 
M2 = (x. x4 x7) (y. y2 y3) 
7
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-9 
Arvind 
Underlining and Development 
Underline some redexes in a term. 
Development is a reduction of the term such that only 
underlined redexes are done. 
Complete Development is a reduction sequence such 
that all the underlined redexes have been performed. 
( S K K y 
 ( S K  K K y K y 
 K y  K K y 
 K y 
By underlining redexes we can distinguish between old 
and newly created redexes in a reduction sequence. (x z)) 
y) x ( ((x z ) z )) 
y) (x ((x y z)) 
y) (x 
http://www.csg.lcs.mit. edu/6.827 L23-10 
Arvind 
E = x | x.E | E E | ( x.E) E 
Reduction rules: 
: ???????( x.M) A --&gt; ??M[A/x] the -calculus 
: ( x.M) A --&gt;M[A/x] the -calculus 
 =  U  The Underlined -calculus 
Erasure: 
? Er?: -term --&gt; -term 
 Facts: 
M N M N 
?Er Er Er Er 
M ????? N M N 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L23-21 
Arvind 
-calculus is WCR 
Suppose M --&gt; M1 by doing redex R1 and M --&gt; M2 
by doing redex R2 . 
We want to show that there exists an M3 such that 
M1 --&gt;&gt; M3 and M2 --&gt;&gt; M3. 
Cases on relative position of R1 and R2 in M. 
1. R1 and R2 are disjoint 
2. Without loss of generality assume R1 is inside R2 
2.1 R1 is in the rator of R2 
from the substitution lemma 
2.2 R1 is in the rand of R2 
http://www.csg.lcs.mit. edu/6.827 L23-22 
Arvind 
Substitution Lemma 
If x is not equal to y and x is not in FV(L) then 
M [N/x] [L/y] 
( y.(x.M) N) L = M [L/y] [N[L/y]/x] 
11
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Implicitly Parallel Programming in pH: Functions and Types</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l02ph_functionalprint/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Why Declarative Programming? 
 Implicit Parallelism 
 language only specifies a partial order on operations 
 Powerful programming idioms and efficient 
code reuse 
 Clear and relatively small programs 
 Declarative language semantics have good 
algebraic properties 
 Compiler optimizations go farther than in imperative 
languages -3 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind
pH is Implicitly Parallel and 
a Layered Language 
cleaner semantics 
more expressive power Non-Deterministic Extensions 
-structures 
Deterministic Extensions 
- I -structures 
Purely Functional 
-higher order 
-non strict 
-strongly typed + polymorphic -4 
M-
2
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-15 
Arvind 
Local Function Definitions 
Improve modularity and reduce clutter. 
integrate dx a b f = 
(sum dx b f (a+dx/2) 0) * dx 
sum dx b f x tot = 
if x &gt; b then tot 
else sum dx b f (x+dx) (tot+(f x)) 
integrate dx a b f = 
let 
sum x tot = 
if x &gt; b then tot 
else sum (x+dx) (tot+(f x)) 
in 
sum (a+dx/2) 0 Free 
variables 
of sum 
? 
L2-16 
Arvind 
Loops (Tail Recursion) 
	Loops or tail recursion is a restricted form of 
recursion but it is adequate to represent a 
large class of common programs. 
	Special syntax can make loops easier to read and write 
	Loops can often be implemented with greater efficiency 
integrate dx a b f =
let
x = a + dx/2 
tot = 0
in
(while x &lt;= b do
next x = x + dx 
next tot = tot + (f x)
finally tot) * dx
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-13 
Arvind 
Curried functions 
plus x y = x + y 
let 
f = plus 1 
in 
f 3 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-14 
Arvind 
Recursion 
integrate dx a b f = 
(sum dx b f (a+dx/2) 0) * dx 
sum dx b f x tot = 
if x &gt; b then tot 
else sum dx b f (x+dx) (tot+(f x)) f(x) 
a b x dx 
Integral(a,b) = (f(a + dx/2) + f(a + 3dx/2) + ...) ?dx integrate f(x) 
from a to b 
using 
trapezoidal 
rule 
7
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-27 
Arvind 
Another Example: Compose 
compose f g x = f (g x) 
What is the type of compose ? 
1. Assign types to every subexpression 
x :: t0 f :: t1 g :: t2 
g x :: t3 f (g x) :: t4 
compose :: 
L2-28 
Arvind 
Hindley -Milner Type System 
pH and most modern functional languages follow 
the Hindley -Milner type system. 
The main source of polymorphism in this system 
is the Let block . 
The type of a variable can be instantiated 
differently within its lexical scope. 
much more on this later ... 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
14 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-25 
Arvind 
Polymorphism 
twice f x = f (f x) 
1. twice (plus 3) 4 
twice :: ? 
2. twice ( appendR "two") "Desmond" 
twice :: ? 
where appendR  " "foobaz" baz" foo
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-26 
Arvind 
Deducing Types 
1. Assign types to every subexpression 
x :: t0 f :: t1 
f x :: t2 f (f x) :: t3 
twice :: t1 &gt; t3) twice f x = f (f x) 
What is the most "general type" for twice? 
2. Set up the constraints 
t1 = t0 -&gt; t2 because of (f x) 
t1 = t2 -&gt; t3 because of f (f x) 
3. Resolve the constraints 
t0 -&gt; t2 = t2 -&gt; t3 
t0 = t2 and t2 = t3 t0 = t2 = t3 
twice :: (t0 (t0 -&gt; t0) -&gt; (t0 -
-&gt; t0) -&gt; 
13
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Blocks 
let 
x = a * a 
y = b * b 
in 
(x -y)/(x + y) 
 a variable can have at most one definition 
in a block 
 ordering of bindings does not matter -7 
L2-8 
Arvind 
Layout Convention 
This convention allows us to omit many delimiters 
let
x = a * a
y = b * b
in
(x -y)/(x + y)
is the same as 
let
{x = a * a ;
y = b * b ;}
in
(x -y)/(x + y)
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-19 
Arvind 
Type of an expression 
(sq 529) :: Int 
sq 
" sq is a function, which when applied to an integer 
produces an integer." 
" Int -&gt; Int is the set of functions which when 
applied to an integer produce an integer." 
"The type of sq is Int -&gt; Int." :: Int -&gt; Int 
L2-20 
Arvind 
Type of a Curried Function 
plus x y = x + y 
(plus 1) 3 :: Int 
(plus 1) :: Int -&gt; Int
plus :: ? 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-11 
Arvind 
Lexical Scoping and -renaming 
plus x y = x + y 
plus' a b = a + b 
plus and plus' are the same because plus' 
can be obtained by systematic renaming of 
bound identifiers of plus 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-12 
Arvind 
Capture of Free Variables 
f x = . . . 
g x = . . . 
foo f x = f (g x) 
Suppose we rename the bound identifier f to g 
in the definition of foo 
foo' g x = g (g x) 
foo foo' ? 
While renaming, entirely new names should be 
introduced! 
6
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Lexical Scoping 
let 
y = 2 * 2 
x = 3 + 4 
z = let 
x = 5 * 5 
w = x + y * x 
in 
w 
in 
x + y + z 
Lexically closest definition of a variable prevails. -9 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-10 
Arvind 
Renaming Bound Identifiers 
( -renaming) 
let 
y = 2 * 2 x = 3 + 4 
z = let 
x = 5 * 5 
w = x + y * x 
in 
w 
in 
x + y + z let 
y = 2 * 2 x = 3 + 4 
z = let 
x = 5 * 5 
w = x + y * x 
in 
w 
in 
x + y + z 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-21 
Arvind 
-Abstraction 
Lambda notation makes it explicit that a value 
can be a function. Thus, 
(plus 1) can be written as \y -&gt; (1 + y) 
plus x y = x + y 
can be written as 
plus = \x -&gt; \y -&gt; (x + y) 
or as 
plus = \x y -&gt; (x + y) 
( \x is a syntactic approximation of x in Haskell) 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-22 
Arvind 
Parentheses Convention 
f e1 e2 ((f e1) e2) 
f e1 e2 e3 (((f e1) e2) e3) 
application is left associative 
Int -&gt; (Int -&gt; Int) Int -&gt; Int 
type constructor  is right associative -&gt; Int 
-&gt;
11
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Function Execution by Substitution 
plus x y = x + y 
1. plus 2 3 2 + 3 5 
2. plus (2*3) (plus 4 5) -5 
L2-6 
Arvind 
Confluence 
All Functional pH programs (right or wrong) 
have repeatable behavior 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
3 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-17 
Arvind 
Higher -Order Computation Structures 
apply_n f n x = if (n == 0) then x 
else apply_n f (n -1) (f x) 
succ x = x + 1 
apply_n succ b a ? 
succ can be written as ((+) 1) also because of 
the syntactic convention: x + y (+) x y 
apply_n ((+) 1) b a 
mult a b = apply_n ? 
L2-18 
Arvind 
Types 
All expressions in pH have a type 
23 :: Int
" 23 belongs to the set of integers" 
"The type of 23 is Int" 
true :: Bool
"hello" :: String 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
9 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Laboratory for Computer Science 
M.I.T. 
Implicitly Parallel Programming 
in pH: Functions and Types 
September 9, 2002 - 1 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2
Arvind 
Explicitly Parallel Fibonacci 
cilk 
{if (n &lt; 2) 
return n; 
else 
{
x = spawn fib(n-1); 
y = spawn fib(n-2); 
sync; 
return x + y; 
} 
} {if (n &lt; 2) 
return n; 
else 
return 
fib(n-1)+fib(n -2); 
} 
} C code Cilk code 
C dictates that fib(n -1) be executed before fib(n -2) 
 annotations ( spawns and sync) for parallelism 
Alternative: declarative languages -2 
int fib (int n) 
int x, y; int fib (int n) 
1
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>September 9, 2002 http://www.csg.lcs.mit. edu/6.827 L2-23 
Arvind 
Type of a Block 
(let 
x1 = e1 
. 
. 
. 
xn = en 
in 
e ) :: t 
provided 
e :: t 
L2-24 
Arvind 
Type of a Conditional 
(if e then e1 else e2 ) :: t
provided 
eee :: Bool
1 ::t
2 ::t
The type of expressions in both branches 
of conditional must be the same. 
September 9, 2002 http://www.csg.lcs.mit. edu/6.827 
12 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Programming with Arrays</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l10ph_arraysprint/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-19 
Arvind 
Inner Product:  ai bi 
vp a let 
elem i = a!i * b!i 
in 
mkArray (bounds a) elem 
ip a foldArray (vp a b) (+) 0 = b 
= b 
http://www.csg.lcs.mit. edu/6.827 L10-20 
Arvind 
Index Type Class 
pH allows arrays to be indexed by any type 
that can be regarded as having a contiguous 
enumerable range 
range: Returns the list of index elements between a 
lower and an upper bound 
index : Given a range and an index, it returns an 
integer specifying the position of the index in the 
range based on 0 
inRange : Tests if an index is in the range class Ix a where 
range :: (a,a) -&gt; [a] 
index :: (a,a) -&gt; a -&gt; Int 
inRange :: (a,a) -&gt; a -&gt; Bool 
10
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L10-1 
Arvind 
Laboratory for Computer Science 
M.I.T. 
Programming with Arrays 
Lecture 10 
http://www.csg.lcs.mit. edu/6.827 L10-2 
Arvind 
Pattern Matching 
1
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-15 
Arvind 
Dragging a Shape 
Move a k -sided polygon in an n -dimensional 
space by distance delta as delta bs 
http://www.csg.lcs.mit. edu/6.827 L10-16 
Arvind 
k-sided polygon: An array of points 
A point in n -dimensional space 
distance delta in n -dimensional space 1 n . 1 n . 
. 1 
k . . . . . 
as delta bs 
1 n . 
move_shape as delta = 
mapArray as ? (scale delta) . . 
. 
. 
8
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-7 
Arvind 
Refutable vs Irrefutable Patterns 
Patterns are used in binding for destructuring an 
expression ---but what if a pattern fails to match? 
let (x1, x2) 
x : xs = e2 
y1: y2 : ys = e3 
in 
e 
what if e2 evaluates to [] ? 
e3 to a one-element list ? 
Should we disallow refutable patterns in bindings? 
Too inconvenient! 
Turn each binding into a case expression = e1 
http://www.csg.lcs.mit. edu/6.827 L10-8 
Arvind 
Arrays 
Cache for function values on a regular subdomain 
x = mkArray (1, n) f 
(f i) means x!i = (f i) 
1 &lt; i &lt; n 1 n 
Selection: x!ireturns the value of the ith slot 
Bounds: (bounds x) returns the tuple containing 
the bounds 
4
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-3 
Arvind 
Pattern Matching: Syntax &amp; Semantics 
Let us represent a case as (case e of C) 
where C is 
C = P -&gt; e -&gt; e) , C 
P = x | CN0 | CNk(P1, ,Pk) 
The rewriting rules for a case may be stated as 
follows: 
(case e of P -&gt; e1, C) 
e1 if match(P,e) 
if ~match(P,e) 
(case e of P -&gt; e1) 
e1 if match(P,e) 
if ~match(P,e) | (P 
http://www.csg.lcs.mit. edu/6.827 L10-4 
Arvind 
The match Function 
match[[x, t]] = True 
match[[CN0, t]] = CN0 == tag(t) 
match[[CNk(P1, ,Pk), t]] = 
if tag(t) == CNk 
then 
(match[[P1, proj1(t)]] &amp;&amp; 
. 
. 
. 
match[[Pk, projk(t)]]) 
else 
False P = x | CN0 | CNk(P1, ,Pk) 
2
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-25 
Arvind 
Matrices 
add 
mkArray ((1,1),(n,n)) ? 
i j i + j (i,j) = 
add 
http://www.csg.lcs.mit. edu/6.827 L10-26 
Arvind 
Transpose 
transpose a = 
let 
((l1,l2),(u1,u2)) = bounds a 
f (i,j) = ? 
in 
mkArray f (j,i) 
((l2,l1),(u2,ui)) 
13
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-5 
Arvind 
pH Pattern Matching 
TE[[(case e of C)]] = 
(let t = e in TC[[t, C]]) 
TC[[t, (P -&gt; e)]] = 
if match[[P, t]] 
then (let bind[[P, t]] in e) 
else error match failure 
TC[[t, ((P -&gt; e),C)]] = 
if match[[P, t]] 
then (let bind[[P, t]] in e) 
else TC[[t, C]] 
http://www.csg.lcs.mit. edu/6.827 L10-6 
Arvind 
Pattern Matching: bind Function 
bind[[x, t]] x = t 
bind[[CN0 , t]] = 
bind[[CNk(P1, ,Pk) , t]] = 
bind[[ P1, proj1(t) ]] ; 
. 
. 
. 
bind[[ Pk, projk(t) ]] = 
3
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-17 
Arvind 
High-level Programming 
mapArray2 f 
let 
elem i = f (a!i) (b!i) 
in 
mkArray (bounds a) elem f 
vs = mapArray2 
vvs = mapArray2 vs 
vvvs = mapArray2 vvs 
... b = a 
(+) 
http://www.csg.lcs.mit. edu/6.827 L10-18 
Arvind 
Fold Array 
foldArray a f so = 
let (l,u) = bounds a 
one fold s i = 
if i &gt; u then s 
else one_fold (f s (a!i)) (i+1) 
in 
one_fold so l f f f a 
so . sn 
foldArray a 
foldArray a . . 
0 (+) 
infinity min 
9
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-21 
Arvind 
Examples of Index Type 
data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat 
An index function may be defined as follows: 
index (Sun,Sat) Wed = 3 
index (Sun,Sat) Sat = 6 
... 
A two dimentional space may be indexed as followed: 
index ((li,lj), (ui,uj)) (i,j) = 
(i-li)*((uj-lj)+1) + j -lj 
This indexing function enumerates the space in the 
row major order 
http://www.csg.lcs.mit. edu/6.827 L10-22 
Arvind 
Arrays With Other Index Types 
module Array (Array, mkArray, (!), bounds) 
where 
infix 9 (!) 
data (Ix a) =&gt; Array a t 
mkArray :: (Ix a) =&gt; (a,a) -&gt; (a-&gt;t) -&gt; 
(Array a t) 
(!) :: (Ix a) =&gt; (Array a t) -&gt; a -&gt; t 
bounds :: (Ix a) =&gt; (Array a t) -&gt; (a,a) 
Thus, 
type ArrayI t = Array Int t 
type MatrixI t = Array (Int,Int) t 
11
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-13 
Arvind 
Vector Sum -Error Behavior 
vs a b let 
esum i = a!i + b!i 
in 
mkArray (bounds a) esum 
Suppose 
b a 1. 
b 2. 
b3. 
= 
http://www.csg.lcs.mit. edu/6.827 L10-14 
Arvind 
Map Array 
mapArray f a = let 
g i = f (a!i) 
in 
mkArray (bounds a) g . 
. . a 
b f f f 
Example: 
such that bi = s * ai 
vscale a s = mapArray a ?((*) s) . . 
. . . . 
scale a vector, that is, produce b 
7
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-9 
Arvind
Efficiency is the Motivation 
for Arrays 
(f i)is computed once and stored 
x!i is simply a fetch of a precomputed value 
and should take constant time 1 n 
(f i) 
http://www.csg.lcs.mit. edu/6.827 L10-10 
Arvind 
A Simple Example 
x = mkArray (1,10) 
Type 
x ArrayI t) 
assuming 
f :: Int -&gt; t 6 
(plus 5) 
(:: 15 7 
5
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-23 
Arvind 
Higher Dimensional Arrays 
x = mkArray ((l1,l2),(u1,u2)) f 
means x!(i,j) = f (i,j) l1 &lt; i &lt; u1 
l2 &lt; j &lt; u2 
Type 
x ::(Array (Int,Int) t) 
Assuming 
f :: (Int,Int) -&gt; t 
mkArray will work for higher dimensional matrices 
as well. 
http://www.csg.lcs.mit. edu/6.827 L10-24 
Arvind 
Array of Arrays 
(Array a (Array a t)) (Array (a,a) t) 
This allows flexibility in the implementation of 
higher dimensional arrays. 
12
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-27 
Arvind 
The Wavefront Example 
x = mkArray ((1,1),(n,n)) (f x) 
f x (i, j) = if i == 1 then 1 
else if j == l then 1 
else x!(i-1,j) + x!(i,j-1) xi,j = xi-1,j + xi,j-1 1 1 1 1 1 1 1 1 
1 
1 1 
1 
1 
1 
1 
http://www.csg.lcs.mit. edu/6.827 L10-28 
Arvind 
Compute the least fix point. 
1 1 1 1 1 1 1 1 
1 1 
1 
1 
1 
1 
1 
x = mkArray ((1,1),(n,n)) (f x) 
f x (i, j) = if i == 1 then 1 
else if j == l then 1 
else x!(i-1,j) + x!(i,j-1) 
14
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text> http://www.csg.lcs.mit. edu/6.827 L10-11 
Arvind 
Array: An Abstract Data Type 
module ArrayI (ArrayI, mkArray, (!), bounds) 
where 
infix 9 (!) 
data ArrayI t 
mkArray ::(Int,Int) -&gt; (Int-&gt; t) -&gt; (ArrayI t) 
(!) ::(ArrayI t) -&gt; Int -&gt; t 
bounds ::(ArrayI t) -&gt; (Int,Int) 
Selection: x!i returns the value of the ith slot 
Bounds: (bounds x) returns the tuple containing 
the bounds 
http://www.csg.lcs.mit. edu/6.827 L10-12 
Arvind 
Vector Sum 
vs a b = let 
esum i = a!i + b!i 
in 
mkArray (bounds a) esum 
+ 
6
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Desugaring List Comprehensions and Pattern Matching</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l09lists2print/</lecture_pdf_url>
      <lectureno>9</lectureno>
      <slides>
        <slide>
          <slideno>7</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-15 
Arvind List Comprehensions: 
Second Functional Implementation -Wadler 
TE[[[ e | Q] ]] = TQ[[[e | Q] ++ [] ]] 
TQ[[[ e | x &lt;1, Q] ++ L ]] = 
let f [] = L 
f (x: TQ[[[ e | Q] ++ (f xs)]] 
in 
(f L1) 
TQ[[[ e | B, Q] ++ L ]] = 
if B then TQ[[[ e | Q] ++ L ]] 
else L 
TQ[[ [ e | ] ++ L ]] = e : L 
This translation is efficient because it never flattens. 
The list is built right -to-left, consumed left -to-right. - L
xs) = 
L9-16 
Arvind 
The Correctness Issue 
How do we decide if a translation is correct? 
 if it produces the same answer as some 
reference translation, or 
 if it obeys some other high -level laws 
In the case of comprehensions one may want 
to prove that a tra nslation satisfies the 
comprehension rewrite rules. 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-11 
Arvind 
Eliminate the intermediate list 
[ e | x &lt; - concat (map ( ) 
Notice map creates a list which is immediately 
consumed by concat . This intermediate list is 
avoided by concatMap 
= [] 
) 
[ e | x &lt; - concatMap 
[ e | x &lt; - -
concatMap 
[ e | x &lt; - - -
concatMap xs] \x-&gt; [e]) xs
concatMap f []  
concatMap f (x:xs) = (f x) ++ (concatMap f xs
xs] (\x-&gt; [e]) xs 
xs, y &lt; ys] 
(\x-&gt; 
xs, y &lt; ys, z &lt; zs] 
(\x-&gt; 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-12 
Arvind 
List Comprehensions with Predicates 
[ e | x &lt; -xs, p ] 
(map ( &gt; e) (filter ( xs) 
concatMap &gt; if p then [e] else []) xs 
[ e | x &lt; -xs, p, y &lt; -ys] 
concatMap &gt; if p then \x- \x-&gt; p) 
(\x-
(\x-
6
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-17 
Arvind 
Pattern Matching 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-18 
Arvind 
Desugaring Function Definitions 
Function def -expression + Case 
map f [] = [] 
map f (x: xs) = (f x):(map f xs) 
We compile the pattern matching using a tuple . map = (\t1 t2 -&gt;
case (t1,t2) of
(f, []) -&gt; []
(f,(x:xs)) -&gt; (f x):(map f xs)
9 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9
Arvind 
Primes: The Sieve of Eratosthenes 
primes = sieve [2..] 
p x y = (y mod x)  0 
nth 100 primes -3 
sieve (x:xs) = x:(sieve (filter (p x) xs)) 
L9-4 
Arvind 
Desugaring ! 
	Most high -level languages have constructs whose 
meaning is difficult to express precisely in a 
direct way 
	Compilers often translate ( desugar ) high -level 
constructs into a simpler language 
	Two examples: 
	List comprehensions: eliminate List 
compressions usings maps etc. 
	Pattern Matching: eliminate complex pattern 
matching using simple case -expressions 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9
Arvind 
List Comprehensions -5 
L9-6 
Arvind 
List Comprehensions: Syntax 
[ e | Q ] where e is an expression and Q is a list of 
generators and predicates 
There are three cases on Q 
1. First element of Q is a generator
[ e | x &lt; -L, Q ]
2. First element of Q is a predicate 
[ e | B, Q ]
3. Q is empty 
[ e | ]
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
3 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9
Arvind 
Eliminating Generators 
[ e | x &lt; -xs] map (
[ e | x &lt; -xs, y &lt;-ys] 
[ e | x &lt; -xs, y &lt;-ys, z &lt;-zs] where concat flattens a list: 
concat[] = [] 
concat (xs) = xs ++ (concat xss ) -9 
\x-&gt; e) xs 
:xss
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-10 
Arvind 
A More General Solution 
 Flatten the list after each map. 
 Start the process by turning the expression 
into a one element list 
[ e | x &lt; -
concat (map ( xs) 
[ e | x &lt; -xs, y &lt;-ys] 
concat (map (
[ e | x &lt; -xs, y &lt;-ys, z &lt;-zs] 
concat (map (xs] 
\x-&gt; [e]) 
\x-&gt; 
\x-&gt; 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-21 
Arvind 
Order of Evaluation and Strictness 
Is there a minimum possible evaluation of an 
expression for pattern matching ? 
case (x,y,z) of case (z,y,x) of 
(x,y,1) -&gt; e1 (1,y,x) -&gt; e1 
(1,y,0) -&gt; e2 vs (0,y,1) -&gt; e2 
(0,1,0) -&gt; e3 (0,1,0) -&gt; e3 
Very subtle differences programmer should write 
order-insensitive, disjoint patterns. 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
The rewriting rules for a case may be stated as 
follows: 
(case e of P -&gt; e1, C) 
e1 if match(P,e) 
if ~match(P,e) 
(case e of P -&gt; e1) 
e1 if match(P,e) 
if ~match(P,e) L9-22 
Arvind 
Pattern Matching: Syntax &amp; Semantics 
Let us represent a case as (case e of C) 
where C is 
C = P -&gt; e | (P -&gt; e) , C
P = x | CN0 | CNk(P1, ,Pk)
11 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-25 
Arvind 
Pattern Matching: bind Function 
bind[[x, t ]] = x = t 
bind[[CN0 , t]] = 
bind[[CNk(P1, ,Pk) , t ]] = 
bind[[ P1, proj1(t) ]] ; 
. 
. 
. 
bind[[ Pk, projk(t) ]] 
L9-26 
Arvind 
Refutable vs Irrefutable Patterns 
Patterns are used in binding for destructuring an 
expression ---but what if a pattern fails to match? 
let (x1, x2) = e1
x :xs = e2 
y1: y2 : ys = e3
in 
e
what if e2 evaluates to [] ? 
e3 to a one-element list ? 
Should we disallow refutable patterns in bindings? 
Too inconvenient! 
Turn each binding into a case expression 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
13 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-19 
Arvind 
Complex to Simple Patterns 
last [] = e1 
last [x] = e2 
last (x1:(x2: xs)) = e3 
t 
case t of 
[] -&gt; e1 
(t1:t2) last = \ -&gt; 
-&gt; 
L9-20 
Arvind 
Pattern Matching and Strictness 
pH uses top -to-bottom, left -to-right order in 
pattern matching. This still does not specify if 
the pattern matching should force the evaluation 
of an expression 
case (e1,e2) of
([] , y) -&gt; eb1
((x:xs), z) -&gt; eb2
Should we valuate e2? 
If not then the above expression is the same as
pH tries to evaluate minimum number of arguments.
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>L9-23 
Arvind 
The match Function 
P = x | CN0 | CNk(P1, ,Pk) 
match[[x, t ]] = True 
match[[CN0, t]] = CN0 == tag(t) 
match[[CNk(P1, ,Pk), t ]] = 
if tag(t) == CNk 
then 
(match[[P1, proj1(t)]] &amp;&amp; 
. 
. 
. 
match[[Pk, projk(t)]]) 
else 
False 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
pH Pattern Matching L9-24 
Arvind 
TE[[(case e of C)]] = 
(let t = e in TC[[t, C ]]) 
TC[[t, (P -&gt; e) ]] = 
if match[[P, t ]], 
then (let bind[[P, t ]] in e) 
else error match failure 
TC[[t, ((P -&gt; e),C) ]] = 
if match[[P, t ]] 
then (let bind[[P, t ]] in e) 
else TC[[t, C ]] 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
12 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L9
Arvind 
Laboratory for Computer Science 
M.I.T. 
Desugaring List Comprehensions 
and 
Pattern Matching 
October 7 , 2002 - 1 
L9-2 
Arvind 
Infinite Data Structures 
1. ints_from i = i:( ints_from (i+1)) 
nth n (x:xs) = if n == 1 then x 
else nth (n -1) xs 
nth 50 (ints_from 1) -- &gt; ? 
2.	ones = 1:ones 
nth 50 ones -- &gt; ? 
3.	xs = [ f x | x &lt; -a:xs] 
nth 10 xs    -- &gt; ? 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
1 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9
Arvind 
List Comprehensions Semantics 
Rule 1.1 [ e | x &lt; -[], Q ] 
Rule 1.2 [e | x &lt; -(ex : exs ), Q ] 
Rule 2.1 [ e | False, Q ] 
Rule 2.2 [ e | True , Q ] 
Rule 3 [ e | ] -7 
L9-8 
Arvind 
Desugering : First Attempt 
TE[[[ e | ] ]] = e :[] 
TE[[[ e | B, Q] ]] = 
if B then TE[[[e | Q] ]] else [] 
TE[[ [ e | x &lt; -L, Q] ]] = 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-13 
Arvind List Comprehensions: 
First Functional Implementation -Wadler 
TE[[[ e | x &lt; -L, Q] ]] = 
concatMap TE[[[e | Q] ]]) L 
TE[[[ e | B, Q] ]] = 
if B then TE[[[e | Q] ]] else [] 
TE[[[ e | ] ]] = e :[] 
Can we avoid concatenation altogether? (\x-&gt; 
October 7, 2002 http://www.csg.lcs.mit. edu/6.827 L9-14 
Arvind 
Building the output from right -to-left 
[ e | x &lt; -xs, y &lt;-ys] 
concat (map ( ys) 
[ e | x &lt; -xs, y &lt;-ys] 
let f [] = [] 
) = 
let g [] 
g (y:ys ) 
in 
) 
in 
(f xs) versus \x-&gt; map (\y-&gt; e) ) xs
f (x:xs
= f xs 
) = e:(g ys
(g ys
7
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Using Monads for Input and Output</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l15monadsio/</lecture_pdf_url>
      <lectureno>15</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-13 
Arvind 
Maessen 
An Examp le 
main = 
let 
islc c = putCh ar (if (a&lt;=c)&amp;&amp; (c&lt;=z)
then y
else n)
in 
getChar &gt;&gt;= is lc 
http://www.cs g.lcs.m it.edu/6.827 L13-14 
Arvind 
Maessen
Turning expressions into actions 
return :: a -&gt; IO a 
getLine :: IO String 
getLine = getC har &gt;&gt;= \c -&gt; 
if (c == \n) then 
return  
else getLine &gt; &gt;= \s -&gt; 
return (c:s) 
where \n represents the newline character 
7
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-19 
Arvind 
Maessen
Calling WC 
main :: IO () 
main = do [filename] &lt;-getArgs
(nc,nw,nl) &lt;- wc filename 
putStr  
putStr (show n c)
putStr  putStr (show n w)
putStr  putStr (show n l)
putStr  
putStr filenam e 
putStr \n  
 
 
 
http://www.cs g.lcs.m it.edu/6.827 L13-20 
Arvind 
Maessen 
Error Handlin g 
Monad ca n abort if an error occur s. 
Can add a func tion to handl e errors: 
catch :: IO a -&gt; (IOError -&gt; IO  a) -&gt; IO a 
ioError :: IOE rror -&gt; IO a 
fail ing -&gt; IO a 
catch echo (\e rr -&gt; 
fail (I/O err or: ++show err)) :: Str
10
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mi t.edu/6 .827 L13- 1 
Arvind 
Jan-Willem Maessen 
Labor atory for Computer Science 
M.I.T. 
Using Monads for Input and 
Output 
Lecture 15 
http://www.cs g.lcs.m it.edu/6.827 L13-2 
Arvind 
Maessen 
Functi onal Languages and I/O 
z := f(x) + g(y); 
In a functional language f and g can be 
evaluate d in any order but not in a language 
with side-effects. 
Conside r inserting print statements (say for 
debugging) in f and g. 
An im perative language must take a position 
on evalu ation ord er; if there is any doubt, 
must write it as 
a := f(x); b := g(y); z := a+b; 
I/O is all about side-effects. 
Is I/O incompatible with FL? 
1
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-21 
Arvind 
Maessen 
An Examp le 
processFile ileName = 
getContents fi leName &gt;&gt;= \inp - &gt; 
print (process Input inp) 
main = 
putStrLn Give  me a file name &gt;&gt; 
getLine &gt;&gt;= \f ileName -&gt; 
catch (process File f)
(\err -&gt;
print err &gt;&gt;
main) f
http://www.cs g.lcs.m it.edu/6.827 L13-22 
Arvind 
Maessen
The Modul arity Probl em 
Inserting a print (say for debugging):
sqrt :: Float -&gt; Float 
sqrt x = 
let 
... 
a = (putSt rLn ...) :: IO St ring
in result 
The binding does nothing! 
The I/O has to  be exposed to the caller: 
sqrt :: Float -&gt; IO Float 
sqrt x = 
let ... 
a = (putSt rLn ...) :: IO St ring
in a &gt;&gt; return result 
11
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-5 
Arvind 
Maessen 
Need for S equenci ng 
echo :: () -&gt; ()
echo () =
let c = getCha r()
in if c==\n then ()
else let putChar c 
&gt;&gt;&gt; 
echo ()
in () 
http://www.cs g.lcs.m it.edu/6.827 L13-6 
Arvind 
Maessen 
What about modul arity? 
Barriers are too coarse -graine d: 
myProgram () =
let input = pr oduceAllTheInput( )
consumeAnd Output input
in () 
Interleave producer and consumer 
Very com plex in general 
3
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-23 
Arvind 
Maessen 
Monadi c I/O is S equenti al 
do (nc1,nw1,nl 1) &lt;-wc filename 1 
(nc2,nw2,nl 2) &lt;-wc filename 2 
return (nc1+nc2, nw1+nw2, nl1+nl2) 
The two wc calls are totally independent but the 
IO they perform must be sequentialized! 
We can imagine doing them in parallel: 
parIO :: IO a -&gt; a 
let (nc1,nw 1,nl1) = parIO (wc filename1)
(nc2,nw2,nl2) = parIO (wc filename2)
in (nc1+nc2 , nw1+nw2, nl1+nl 2) 
http://www.cs g.lcs.m it.edu/6.827 L13-24 
Arvind 
Maessen 
Overcomi ng the Probl ems 
The limitations are f undamental and can be over-
come only by abandoning the purely functional 
character of the language. 
let (nc1,nw1,n l1) = doIO (wc fi lename)
writeFile filename Hello W orld!\n 
(nc2,nw2,n l2) = doIO (wc fi lename)
in (nc1+nc2, n w1+nw2, nl1+nl2) 
let (nc1,nw1,n l1) = doIO (wc fi lename)
writeFile filename Hello W orld!\n 
(nc2,nw2,n l2) = (nc1,nw1,nl 1)
in (nc1+nc2, n w1+nw2, nl1+nl2) 
Suddenly program semantic s are much more fuzzy! 
12
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-25 
Arvind 
Maessen
Monadi c sequenci ng 
return a &gt;&gt;= \x -&gt; m  (\x -&gt; m) a 
m &gt;&gt;= \x -&gt; return x  m 
(m &gt;&gt;= \x -&gt; n ) &gt;&gt;= \y -&gt; o
 m &gt;&gt;= \x -&gt; (n &gt;&gt;= \y -&gt; o)
x  FV(o)
True in every monad b y definition. 
A derived axiom: 
m &gt;&gt; (n &gt;&gt; o)  (m &gt;&gt; n) &gt;&gt; o 
http://www.cs g.lcs.m it.edu/6.827 L13-26 
Arvind 
Maessen
Monads and Let 
Monadic binding behaves like let: 
return a &gt;&gt;= \x -&gt; m  (\x -&gt; m) a
m &gt;&gt;= \x -&gt; return x  m 
(m &gt;&gt;= \x -&gt; n ) &gt;&gt;= \y -&gt; o
 m &gt;&gt;= \x -&gt; (n &gt;&gt;= \y -&gt; o)
x  FV(o) 
let x = a in m  (\x -&gt; m) a
let x = m in x  m 
let y = ( let x = m in n) in o 
 let x = m in (let y = n in o)
x  FV(o) 
13
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-3 
Arvind 
Maessen 
What other languages do 
 Execute programs in a fixed order: 
(define (hello )
(princ Hell o )
(princ Worl d )) 
 Sequentiality simplifies the problem 
 Weaker equational behavior: 
(let ((a (f x) )) (let ((b (g y) ))
(let ((b (g y ))) (let ((a (f x )))
(+ a b))) (+ a b))) 
http://www.cs g.lcs.m it.edu/6.827 L13-4 
Arvind 
Maessen
Print stri ng 
printString ::  String -&gt; ()
printString H ello World! 
but what about 
let 
printString H ello  
printString W orld! 
in () 
The string may be printed all jumbled up. 
alternat ives: 
Output conven tion 
Force d sequencing (Usually not available 
in pure FLs) 
2
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-17 
Arvind 
Maessen 
Example: Word Count Program 
type Filepath = String
data IOMode = ReadMode | WriteM ode | ...
data Handle = ... implemented as built-in type 
openFile :: Fi lePath -&gt; IOMode -&gt; IO Handle 
hClose ndle -&gt; IO () 
hIsEOF ndle -&gt; IO Bool 
hGetChar :: Ha ndle -&gt; IO Char 
wc :: String -&gt; IO (Int,Int,In t)
wc filename = 
do h &lt;- openFile filename ReadM ode 
(nc,nw,nl) &lt;-wch h False 0 0 0 
hClose h 
return (nc,nw,nl) :: Ha
:: Ha
http://www.cs g.lcs.m it.edu/6.827 L13-18 
Arvind 
Maessen 
Word Count Program cont. 
wch :: Handle -&gt; B ool -&gt; Int -&gt; Int  -&gt; Int 
-&gt; IO (Int,In t,Int)
wch h inWord n c nw nl = 
do eof &lt;- hIsEOF h 
if eof then return (nc,nw,nl )
else 
do c &lt;- hGetChar h 
if (c==\n) then 
wch h False (nc+1) n w (nl+1)
else if (isSpace c) the n 
wch h False (nc+1) nw nl 
else if (not inWord) th en 
wch h True (nc+1) (n w+1) nl
else 
wch h True (nc+1) nw  nl 
9
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-7 
Arvind 
Maessen 
Magic return val ue 
getChar returns a magic  value in addition to the 
character in dicating that further I/O is safe. 
echo :: World -&gt; World 
echo world0 = 
let (c, world1 ) = getChar world 0 
in if c==\n then ()
else let world2 = putChar c wor ld1 
world3 = e cho world2 
in world3 
Used in Id and Clean 
http://www.cs g.lcs.m it.edu/6.827 L13-8 
Arvind 
Maessen 
The Mi nd-Body Probl em 
RTS/OS provides the initial state of the world 
main :: World -&gt; World 
Link Computation with Action: 
Computation: parallel, data constrains 
I/O Action: world imposes order 
4
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-11 
Arvind 
Maessen 
Sequencing 
We need a way  to compose actionspecs: 
(&gt;&gt;) ) -&gt; IO () -&gt; IO () 
Examp le: 
putChar H &gt;&gt;  putChar i &gt;&gt; 
putChar ! :: IO () 
putString :: S tring -&gt; IO ()
putString  = done 
putString (c:cs) =
putChar c &gt;&gt; putString cs :: IO (
http://www.cs g.lcs.m it.edu/6.827 L13-12 
Arvind 
Maessen
Monads: Co mposi ng Actionspecs 
We need some  way to get at the results of getChar 
(&gt;&gt;=)  -&gt; (a -&gt; IO b) - &gt; IO b 
We read the b ind operator as fol lows: 
x1 &gt;&gt;= \a -&gt; x2 
 Perform the action represented by x1, 
producing a value of type a 
Apply function \a -&gt; x2 to that value, 
producing a new actionspec x2 :: IO b 
 Perform the action represented by x2, 
producing a value of type b 
Examp le: getChar &gt;&gt;= pu tChar 
the same as getChar &gt;&gt;= \c -&gt; pu tChar c :: IO a
6
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-15 
Arvind 
Maessen
Monadi c I/O 
Separate  compu tation from  sequencing 
IO a: computation which does some I/O, 
then produces a value of type a. 
(&gt;&gt;)  -&gt; IO b -&gt; IO b 
(&gt;&gt;=)  -&gt; (a -&gt; IO b) - &gt; IO b 
return :: a -&gt; IO a 
Primitive actionspecs: 
getChar O Char 
putChar har -&gt; IO ()
openFile, hClo se, ... 
Monadic I/O is a clever, type-safe idea wh ich has 
become very popular in the FL community. :: IO a
:: IO a
:: I:: C
http://www.cs g.lcs.m it.edu/6.827 L13-16 
Arvind 
Maessen 
Syntact ic sug ar: do 
do e -&gt; e 
do e ; dostmts -&gt; e &gt;&gt; do dostmts 
do p&lt;-e ; dostmts -&gt; e &gt;&gt;= \ p-&gt; do dostmts 
do let p=e ; dostmts -&gt; let p=e in do dostmts 
getLine = do c &lt;-getChar
if (c == \ n) then 
return  
else 
do s &lt;- getLine 
return (c:s) 
8
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L13-9 
Arvind 
Maessen
Role of Program Dr iver 
Suppose by convention 
main :: [strin g]
main = [Hello , world!] 
or 
main = let a = Hello 
b = World! 
in [a,b] 
Program is a specification of intended effect to be 
performed by the program driver 
The driver, a primitive one indeed, takes a string 
and treats it as a se quence of comma nds to print. 
http://www.cs g.lcs.m it.edu/6.827 L13-10 
Arvind 
Maessen
Monadi c I/O in Haske ll and pH 
Monad ic I/O tre ats a sequence of I/O comman ds 
as a spe cification to interact with the outside world. 
The program produces an actionspec , which the 
program driver turns in to real I/O actions. 
A program  that produces an  actionspec remains 
purely functional! 
main :: IO ()
putChar :: Cha r -&gt; IO ()
getChar :: IO Char 
main = putChar  a 
is an actionspec that says that character a is to be 
output to some standard output device 
How can we  sequence actio nspecs? 
5
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Expressing Parallel Computation</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l01introduction/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>L1-7 
Arvind 
Par allelizing Com piler s 
After 30 years of intensive research 
	only limited success in parallelism detection 
and program transformations 
	instruction -level parallelism at the basic -block level can 
be detected 
	parallelism in nested for -loops containing arrays with 
simple index expressions can be analyzed 
	analysis techniques, such as data dependence analysis, 
pointer analysis, flow sensitive analysis, abstract 
interpretation, ... when applied across procedure 
boundaries often take far too long and tend to be fragile, 
i.e., can break down after small changes in the 
program. 
	instead of training compilers to recognize 
parallelism, people have been trained to 
write programs that parallelize 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>L1-13 
Arvind 
+ Good implementations 
available 
-Difficult to write programs 
+ Easy to debug programs 
because of a single thread 
+ Implicit synchronization 
and communication 
-Limited compositionality ! communicate 
compute 
communicate 
compute ? are Data Parallel Model
For general -purpose programming , which has more 
unstructured parallelism , we need more flexibility in 
scheduling. 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>L1-14 
Arvind 
Fully Par allel, Mult it hr eaded Model 
Tree of Global Heap of 
Shared Objects Activation 
Frames 
h: g: f: 
loop threads 
asynchronous 
at all levels active
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>L1-15 
Arvind 
Explicit vs I m plicit Mult it hr eading 
Explicit: 
	C + forks + joins + locks 
multithreaded C: Cid, Cilk, ... 
 easy path for exploiting coarse -grain parallelism 
in existing codes 
error -prone if locks are used 
Implicit: 
 languages that specify only a partial order on 
operations 
functional languages : Id, pH, ... 
	safe, high -level, but difficult to implement 
efficiently without shared memory &amp; ... 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>L1-5 
Arvind 
Why not use sequent ial languages ? 
Algorithm with parallelism 
encode 
Program with sequential semantics 
detect parallelism 
Parallel code 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>L1-2 
Arvind 
 
symmetric multiprocessors ( SMPs ) Main St r eam Par allel Com put ing 
Most server class machines these days are 
 PC class SMPs 
 2 to 4 processors 
 cheap 
 run Windows &amp; Linux 
 track technology 
 Delux SMPs 
 8 to 64 processors 
 expensive (16 -way SMP costs &gt;&gt; 4 x 4 -way SMPs ) 
 Applications 
 databases, OLTP, Web servers, Internet commerce... 
 potential applications: EDA tools, technical computing,... 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>L1-19 
Arvind 
Future
Id 
multithreaded intermediate language HPF Cilk pH 
notebooks SMPs MPPs 
Freshman will be taught sequential programming 
as a special case of parallel programming 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>L1-11 
Arvind 
Dat a Par allel Pr ogr am m ing Model 
All data structures are assigned to a	 communicate 
grid of virtual processors. 
	Generally the owner processor computes 
the data elements assigned to it. (global) 
compute 
	Global communication primitives allow 
processors to exchange data. (local) 
communicate 	Implicit global barrier after each 
communication. 
 All processors execute the same program . compute (global) 
(local) 
http://www. csg.lcs.mit.edu/6.827 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>L1-1
Expressing Parallel Computation
Arvind
Laboratory for Computer Science
M.I.T.
Lecture 1
http://www. csg.lcs.mit.edu/6.827
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>L1-6 
Arvind 
Mat r ix Mult iply 
C = A x B Ci,j= k Ai,kBk,j 
All Ci,j's can be computed in parallel.
In fact, all multiplications can be done in parallel!
Fortran 
do i = 1,n
do j = 1,n
do k = 1,n
s = s + A(i,k)*B(k,j)
continue
C(i,j) = s
continue 
continue Parallelism? 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>L1-16 
Arvind 
Explicitly Parallel Matrix Multiply 
cilk void 
matrix_multiply( int** A, int** B, int** C, 
int n)
{	...
...
for (i = 0; i &lt; n; i++)
for (j = 0; j &lt; n; j++)
C[i][j] = spawn IP(A, B, i, j, n);
sync;
...
...
}
intIP( ... ) { ... }
 Cilk program 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>L1-3 
Arvind 
 
processors are build as clusters of SMPs Lar ge Scale Par allel Com put ing 
Most parallel machines with hundreds of 
 usually custom built with government funding 
 expensive: $10M to $100M 
 are treated as a national or international resource 
 Total sales are a tiny fraction of server sales 
 hard time tracking technology 
 Applications 
 weather and climate modeling 
 drug design 
 code breaking (NSA, CIA, ...) 
 basic scientific research 
 weapons development 
Few independent software developers; 
Programmed by very smart people 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>L1-4 
Arvind 
Paucit y of Par allel Applicat ions 
	Applications follow cost -effective hardware 
which has become available only since 1996 
	Important applications are hand crafted 
(usually from their sequential versions) to run 
on parallel machines 
 explicit, coarse -grain multithreading on SMPs 
 most business applications 
 explicit, coarse -grain message passing on large clusters 
 most technical/scientific applications 
 Technical reasons: 
 automatic parallelization is difficult 
 parallel programming is difficult 
 parallel programs run poorly on sequential machines 
Can the entry cost of parallel programming be lowered? 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>L1-20 
Arvind 6.827
Multithreaded Languages and Compilers
This subject is about 
 implicit parallel programming in pH 
	functional languages and the  calculus 
because they form the foundation of pH 
	multithreaded implementation of pH aimed 
at SMPs 
	some miscellaneous topics from functional 
languages, e.g., abstract implementation, 
confluence, semantics, TRS... 
This term I also plan to give 6 to 8 lectures on Bluespec, 
a new language for designing hardware. Bluespec also 
boroughs heavily from functional languages but has a 
completely different execution model. 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>L1-17 
Arvind 
I m plicit ly Par allel Mat r ix Mult iply 
make_matrix ((1,1),(n,n)) f
where f is the filling function 
\(i,j).(IP (row i A) (column j B))
make_matrix does not specify the order in which 
the matrix is to be filled! 
no implication regarding the distribution of 
computation and data over a machine. 
pH program 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>?L1-10 
Arvind 
Safer Way s of Expr essing Par allelism 
Data parallel: Fortran 90, HPF, ... 
-sources of parallelism: vector operators, forall 
-communication is specified by shift operations . 
Implicit Parallel Programming: Id, pH, Sisal, ... 
-functional and logic languages specify only a partial 
order on operations. 
Determinacy of programs is guaranteed 
??????????????????????????????????????????? ?easier debugging !!! 
Programming is independent of machine 
configuration. 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>L1-8 
Arvind 
Par allel Pr ogr am m ing Models 
If parallelism cant be detected in sequential 
programs automatically then design new parallel 
programming models ... 
 High -level 
 Data parallel: Fortran 90, HPF, ... 
	Multithreaded: Cid, Cilk,... 
Id, pH, Sisal, ... 
 Low-level 
 Message passing: PVM, MPI, ... 
	Threads &amp; synchronization: 
Futures, Forks, Semaphores, ... 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>L1-18 
Arvind 
I m plicit ly Par allel Languages 
Expose all types of parallelism, 
permit very high level programming 
but 
may be difficult to implement efficiently 
Why? 
 some inherent property of the language? 
 lack of maturity in the compiler? 
 the run -time system? 
 the architecture? 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>L1-9 
Arvind 
Pr oper t ies of Models 
Determinacy -is the behavior of a program 
repeatable? 
Compositionality -can independently created 
subprograms be combined in a meaningful way? 
Expressiveness -can all sorts of parallelism 
be expressed? 
Implementability -can a compiler generate 
efficient code for a variety of architectures? 
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>L1-12 
Arvind 
Dat a Par allel Mat r ix Mult iply 
Real Array(N,N) :: A, B, C 
Layout A(:NEWS, :NEWS), B(:NEWS, :NEWS) each element is on a 
virtual processor of 
2D grid a 
C(:NEWS, :NEWS) 
... set up the initial distribution of data elements ... 
Do i = 1,N -1
!Shift rows left and columns up
A = CShift(A, Dim=2, Shift=1) 
B = CShift(B, Dim=1, Shift=1) 
C = C + A * B 
communication 
End Do
data parallel 
operations Connection 
Machine 
Fortran
http://www. csg.lcs.mit.edu/6.827 
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>A &#1490; - calculus: A Basis for Functional Languages</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l03lambdacalculusprint/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
-substitution 
( x.E) Ea  E[Ea /x] 
replace all free occurrences of x in E with Ea 
E[A/x] is defined as follows by case on E: 
variable 
y[Ea/x]= Ea if x  y 
y[Ea/x]= y otherwise 
application 
(E1 E2 )[Ea/x] = (E1[Ea/x] E2[Ea/x]) 
abstraction 
( y.E1)[Ea/x] = y.E1 if x  y 
( y.E1)[Ea/x] = ?z.((E1[z/y])[Ea/x]) otherwise 
where z ?FV(E1) U FV(Ea) U FV(x) -7 
L3-8 
Arvind 
-substitution: an example 
( p.p (p q)) [(a p b) / q] 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
4 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>------ ------ ------ ------
------
-----------
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-15 
Arvind 
Choosing Redexes 
1. ((x.M) A) (( x.N) B) 
1 2 
2. ((x.M) ((y.N)B)) 
------2 
------------- 1 
Does 1 followed by 2?produce the same 
expression as 2 followed by 1? 
Notice in the second example 1 can destroy 
or duplicate 2 . 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-16 
Arvind 
Church -Rosser Property 
A reduction system is said to have the 
Church-Rosser property , if E E1 and 
E E2 then there exits a E3 such that 
E1 E3 and E2 E3. 
E E1 
E2 E3 
also known as CR or Confluence 
Theorem: The -calculus is CR. 
(Martin -Lof &amp; Tate) 
8
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>------
------------
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-19 
Arvind 
Reduction Strategies 
There are many methods of choosing redexes 
in an expression 
((x.M) ((y.N)B)) 
------2 
-------------- 1 
 applicative order: leftmost innermost redex 
-would reduce 2 before 1 
 normal order: leftmost (outermost) redex 
-would reduce 1 before 2 
L3-20 
Arvind 
Facts 
1. Every -expression does not have an answer 
i.e., a NF or HNF or WHNF 
( x. x x) ( x. x x) =  
  
2. CR implies that if NF exists it is unique 
3. Even if an expression has an answer, not all 
reduction strategies may produce it 
( x.y. y)  
leftmost redex : ( x.y. y)    y. y 
innermost redex : ( x.y. y)   
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
-Calculus as a Reduction System 
Syntax 
E = x | ?x.E | E E 
Reduction Rule 
? -rule: x.E  y.E [y/x] if y  FV(E) 
? -rule: ( x.E) Ea  ?E [Ea/x] 
 rule: ( x.E x)  E if x  FV(E) 
Redex 
( x.E) Ea 
Normal Form 
An expression without redexes -9 
L3-10 
Arvind 
 and  Rules 
 -rule says that the bound variables can be 
renamed systematically: 
(x.x (x.a x)) b  (y.y (x.a x)) b
 -rule can turn any expression, including a 
constant, into a function: 
x.a x  a
  -rule does not work in the presence of types 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
5 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-11 
Arvind 
A Sample Reduction 
C x.y.f.f x y 
H  f.f (x.y. x) 
T  f.f (x.y. y) 
What is H (C a b) ?  
L3-12 
Arvind 
Integers: Church's Representation 
0  x.y. y
1  x.y. x y
2  x.y. x (x y)
...
n  x.y. x (x...(x y)...)
succ ? 
If n is an integer, then (n a b) gives n 
nested as followed by b 
 the successor of n should be a (n a b) 
succ  n.a.b.a (n a b) 
plus  m.n.m succ n 
mul  ? 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
6 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-23 
Arvind 
A Call -by-value Interpreter 
Answers: WHNF 
Strategy: leftmost -innermost redex but not 
inside a -abstraction 
cv(E): Definition by cases on E 
E = x | ?x. E | E E 
cv(x) = x 
cv( x.E) = x.E 
cv( E1 E2 ) = let f = cv(E1) 
a = cv(E2) 
in 
case f of 
x. E3 = cv(E3[a/x]) 
_ = (f a) 
L3-24 
Arvind 
More Facts 
For computing WHNF 
the call -by-name interpreter is normalizing 
but the call -by-value interpreter is not 
e.g. 
( x.y) (( x.x x) ( x.x x)) 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
12 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
Laboratory for Computer Science 
M.I.T. 
-calculus: 
A Basis for Functional Languages 
September 11, 2002 - 1 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
Functions 
f may be viewed as 
 a set of ordered pairs &lt; d , r &gt; where d  D 
and r  R 
 a method of computing value r corresponding 
to argument d 
some important notations 
 -calculus (Church) 
 Turing machines (Turing) 
 Partial recursive functions ... . 
. 
. 
Domain Range 
f : D ?R -2 
1
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3
ArvindThe -calculus: 
a simple type -free language 
 to express all computable functions 
 to directly express higher -order functions 
 to study evaluation orders , termination , 
uniqueness of answers ... 
 to study various typing systems 
 to serve as a kernel language for functional 
languages 
 However, -calculus extended with constants and let -
blocks is more suitable -3 
L3-4 
Arvind 
-notation 
	a way of writing and applying functions 
without having to give them names 
	a syntax for making a function expression 
from any other expression 
	the syntax distinguishes between the 
integer "2 and the function "always_two" 
which when applied to any integer returns 2 
always_two x = 2;
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-21 
Arvind 
Normalizing Strategy 
A reduction strategy is said to be normalizing 
if it terminates and produces an answer of an 
expression whenever the expression has an 
answer. 
aka the standard reduction 
Theorem: Normal order (left most) reduction 
strategy is normalizing for the ?-calculus. 
L3-22 
Arvind 
A Call -by-name Interpreter 
Answers: WHNF 
Strategy: leftmost redex 
cn(E): Definition by cases on E 
E = x | ?x. E | E E 
cn(x) = x 
cn( x.E) = x.E 
cn(E1 E2) = let f = cn(E1) 
in 
case f of 
x. E3 = cn(E3[E2/x]) 
_ = (f E2) 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
11 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-17 
Arvind 
Interpreters 
An interpreter for the -calculus is a program to 
reduce -expressions to answers. 
It requires: 
 the definition of an answer 
 a reduction strategy 
-a method to choose redexes in an expression 
 a criterion for terminating the reduction 
process 
L3-18 
Arvind 
Definitions of Answers 
 Normal form (NF): an expression without redexes 
 Head normal form (HNF): 
x is HNF 
( x.E) is in HNF if E is in HNF 
(x E1 ... En) is in HNF 
Semantically most interesting -represents the 
information content of an expression 
 Weak head normal form (WHNF): 
An expression in which the left most application is not a 
redex . 
x is in WHNF 
( x.E) is in WHNF 
(x E1 ... En) is in WHNF 
Practically most interesting ?Printable Answers 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
9 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
Pure -calculus: Syntax 
variable abstraction application E = x | x.E | E E 
1. application E1 E2 
function argument 
-application is left associative 
E1 E2 E3 E4  ((( E1 E2 ) E3 ) E4 ) 
2. abstraction x.E 
bound variable body 
or formal parameter 
-the scope of the dot in an abstraction extends as 
far to the right as possible 
x.x y  x.(x y) ?(x.(x y))  ( x.x y) ? x.x) y -5 
?? ( 
L3-6 
Arvind 
Free and Bound Variables 
 -calculus follows lexical scoping rules 
	Free variables of an expression 
FV(x) = {x}
FV(E1 E2) = FV(E1) U FV(E2) 
FV(x.E) = FV(E) -{x}
	A variable occurrence which is not free in an 
expression is said to be a bound variable of 
the expression 
	combinator : a -expression without free 
variables, 
aka closed -expression 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 
3 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-13 
Arvind 
Booleans and Conditionals 
True x.y.x 
False x.y.y 
zero?  n. n (y.False) True 
zero? 0 ? 
zero? 1 ? 
cond b.x.y. b x y 
cond True E1 E2 ? 
cond False E1 E2 ?  
 
 
September 11, 2002 http://www.csg.lcs.mit. edu/6.827 L3-14 
Arvind 
Recursion ? 
 Assuming suitable combinators , fact can 
be rewritten as: 
fact = n. cond (zero? n) 1 ( mul n (fact (sub n 1))) 
 How do we get rid of the fact on the RHS? fact n = if (n == 0) then 1 
else n * fact (n -1) 
7
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>&#955;S: A Lambda Calculus with Side - effects</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l14lambdaside/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides>
        <slide>
          <slideno>13</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-27 
Arvind 
B Garbage Coll ection Rul e 
GC0-rule 
{ SG ; S in e }  { S in e } 
if forall x, x  (FV(e) U FV(S)) the n x  BV(SG) 
GCv-rule 
{ H ; S in e }  { S in e } 
if forall x, x  (FV(e) U FV(S)) the n x  BV(H) 
While both GC0 and G Cv rules are correct for let, 
only the GCv -rule is correct for B. 
http://www.cs g.lcs.m it.edu/6.827 L14-28 
Arvind 
S Syntax 
E ::= x | x.E E E | { S in E } 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 | CNk(E1,...,Ek) | CNk(x1,...,xk) 
| allocate() 
| oi object descriptors 
PF1 ::= ne gate | not | ... | Prj1| Prj2 | ... | ifetch | mfetch 
... 
CN0 ::= Number  | Boolean | () 
S ::=  | x = E | S; S 
| S &gt;&gt;&gt; S | sstore(E,E) 
| allocator | empty( o
i) | full(oi,E) | error(oi) Not in initial 
expressions | 
14
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-13 
Arvind 
C Block F latten ing and Lif ting Rules 
 Block Fl atten 
x = {  S in e}  (x = e ; S) 
 Lifting rules 
{ S1 in { S2 in e } }  { S1; S2 in e } 
{ S in e} e2  { S in e e2 } 
Cond({ S in e}, e1, e2)  { S in Cond (e, e1, e2) } 
PFk(e1,...{ S in e },...ek )  { S in PFk(e1,...e,...ek) } 
{ S in e } is the -renaming of { S in e } to 
avoid name conflicts 
http://www.cs g.lcs.m it.edu/6.827 L14-14 
Arvind 
Non-confl uence 
odd = n.Cond(n=0,  False, even (n-1)) ----(M) 
even = n.Cond(n=0, True, odd (n -1)) 
substitute  for even (n-1) in M 
odd = n.Cond(n=0,  False, 
Cond(n-1 = 0, True, odd ((n-1)-1))) (M1) 
even = n.Cond(n=0, True, odd (n -1)) 
substitute  for odd (n-1) in M 
odd = n.Cond(n=0,  False, even (n-1)) ----(M2) 
even = n.Cond(n=0, True, 
Cond( n-1 = 0,  False, even ((n-1)-1))) 
M1 and M2 cannot be reduced to the same expression! 
Ariola &amp; Klop (LICS 9 4) ----
7
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-15 
Arvind 
Printable Values 
Printable value s are trees and c an be infinite 
We w ill compute the printable value of a  term in 2 steps: 
Info: E --&gt; TP (trees) 
Print: E --&gt; {TP} 
(downward closed sets of trees) 
where 
TP ::=  | | CN0 | CNk(TP1,...,TPk) 
 t (bottom) 
t  t (reflexive) 
CNk(v1,...,vi,...,vk)  CNk(v1,...,v i,...,vk) 
if vi  vi  
http://www.cs g.lcs.m it.edu/6.827 L14-16 
Arvind 
Info Procedure 
Info : E --&gt; TP 
Info [ { S in E } ] = Info [E] 
Info [x.E] =  
Info [CN0] = 0 
Info [CNk(a1,...,ak)] = k(Info[a1],...,Info[ak]) 
Info [E] =  
otherwise 
Proposition Reduction is monotonic wrt Info: 
If e -&gt;&gt; e1 then Info[e]  Info[e1]. 
Proposition Confluence wrt Info: 
If e -&gt;&gt; e1 and e -&gt;&gt; e2 then 
 e3 s.t. e1 -&gt;&gt; e3 and Info[e2]  Info[e3]. CN
CN
8
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-31 
Arvind 
Nondetermi nistic Choi ce 
choose = x. { m = allocate(); 
sstore (m, True ); 
( y = mfetch(m) 
&gt;&gt;&gt; 
sstore(m, False ) ); 
(  = mfetch(m) 
&gt;&gt;&gt; 
sstore(m,True) ) 
in z } 
choose 100 z
? 
16
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-9 
Arvind 
Equivalence Rul es 
 -renaming 
x.e  x.(e[x/ x]) 
{x=e; S in e0}  {x=e; S in e0}[x/x] 
 Properties of  ;  
 ; S  S 
S1 ; S2  S2 ; S1 
S1 ; (S2 ; S3)  (S1 ; S2 ) ; S3 
http://www.cs g.lcs.m it.edu/6.827 L14-10 
Arvind 
let Instanti ation Ru les 
a is a Simple Expression; 
[x] is a fre e occurrence of x in C[x] or SC[x] 
 Instantiation Rule 1 
{ x = a  ; S in C[x] }  { x = a ; S i n C[a] } 
 Instantiation Rule 2 
(x = a ; S C[x])  (x = a ; SC [a]) 
 Instantiation Rule 3 
x = C[ x]  x = C[C[x]] 
where C[x] is simple 
5
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-21 
Arvind 
Stabili ty and Termi nation 
Definition: Expression e is said to be stable if 
when e -&gt;&gt; e1, Print[e] = Pri nt[e1] 
In general, an expression cannot be tested for stability. 
Terminated Terms 
ET ::= V | {H in SE} 
H ::= x = V | H; H 
Proposition: All terminated terms are stable. 
http://www.cs g.lcs.m it.edu/6.827 L14-22 
Arvind 
Values and Heap Terms 
Value s 
V ::= x.E | CN0 | CNk(x1,...,xk) 
Simple expressions 
SE ::= x | V 
Terminated Term s 
ET ::= V | {H in SE} 
H ::= x = V | H; H 
11
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-29 
Arvind 
Values and Heap Terms 
Value s 
V ::= x.E | CN0 | CNk(x1,...,xk) | oi 
Simple expressions 
SE ::= x | V 
Heap Terms 
H ::= x = V | H; H | allocator 
| empty(oi) | full(oi,V) 
Terminal Ex pressions 
ET ::= V | let H in SE 
http://www.cs g.lcs.m it.edu/6.827 L14-30 
Arvind 
Side-effect Rules 
 Allocation rule 
(allocator; x=allocate())allocator; x = o; empty(o)) 
where o is a w object descriptor 
 Fetch and T ake rules 
(x=ifetch(o) ; full(o,v))  (x=v ; full(o,v)) 
(x=mfetch(o) ; full(o,v))  (x=v ; empty(o)) 
 Store rules 
(sstore(o,v) ; empty(o))  full(o,v) 
(sstore(o,v) ; full(o,v))  (error(o); full(o,v)) 
 Lifting r ules 
sstore({ S in e}, e2)  ( S ; sstore(e,e2)) 
sstore(e1, { S in e})  ( S ; sstore(e1,e)) ne
15
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-5 
Arvind 
 +Let : A way to model sharing 
Instead of the normal -rule 
(x.e) ea  e [ea/x] 
use the ollowing let rule 
(x.e) ea  { let t = ea in e[t/x] } 
where t is a new variable 
and o nly allow the subs titution of values 
and variables to preserve sharing f
http://www.cs g.lcs.m it.edu/6.827 L14-6 
Arvind 
Previous work on Sharing 
Differen ces are mainly regarding 
 where variables can be instantiated 
 the source language 
 
or  + let 
or  + letrec 
 Graph reduction and l azy evaluation 
Wadsworth (71),  Launchbur y (POPL93) 
 Environments and Expl icit Subs titution 
Abadi, Car delli, Cur ien &amp; Levy (POPL 92, JFP) 
 Letrecs but no reductions inside -abstractions 
Ariola, F elleisen, Wadler, ...(POPL 95) 
Letrecs 
Ariola et al. (96) 
3
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-25 
Arvind 
Properties of B 
Proposition Barriers are associative: 
S1 &gt;&gt;&gt; (S2 &gt; &gt;&gt; S3) = (S1 &gt;&gt;&gt; S2) &gt;&gt;&gt; S 3 
in all contexts. 
Proposition Barriers re duce results: 
Every reduction in C[S1 &gt;&gt;&gt; S2] can b e modeled by a 
reduction in C[S1 ; S2]. 
Proposition Postregions can be  postponed: 
If C1[S1 &gt;&gt;&gt;  S2] -&gt;&gt; C3[S3 &gt;&gt;&gt; S4] where the barrier is 
the same in both terms, there is a C2 s uch that: 
C1[S1 &gt;&gt;&gt; S2] -&gt;&gt; C 2[S3 &gt;&gt;&gt; S2] -&gt; &gt; C3[S 3 &gt;&gt;&gt; S4] 
http://www.cs g.lcs.m it.edu/6.827 L14-26 
Arvind 
Garbage Col lection 
A Garbage collection rule erases part of a term. 
Definition: 
A garbage collection rule, GC, is said to be correct 
if for all e, Print*(e) = Pr int*(GC(e)) 
13
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-19 
Arvind 
B Syntax 
E ::=  x | x.E | E | { S in E } 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 | CNk(E1,...,Ek) | CNk(x1,...,xk) 
PF1 ::= negate | not | ... | Prj1| Prj2 | ... 
... 
CN0 ::= Number | Boolean 
S ::=  | x = E | S; S  &gt;&gt;&gt; S 
Not in initial 
expressions E 
| S
http://www.cs g.lcs.m it.edu/6.827 L14-20 
Arvind 
Barriers 
{ ( y = 1+7 
&gt;&gt;&gt; 
z = 3 ) 
in 
z } { ( y = 8 
&gt;&gt;&gt; z = 3 ) 
in 
z } { y = 8 ; 
( z = 3 ) 
in 
z } { y = 8 ; 
z = 3 
in 
3 }    
Barriers discharge when all the bindings in 
the pre-region terminate, i.e., all expressions 
become value s. 
10
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-17 
Arvind 
Print Procedu re 
Print : E --&gt; { TP} 
Print[e] = { i | i  Info[e1] and e i &gt;&gt; e1}  
i &gt; is simple instantiation: 
let x = v ; S in C[x] i &gt; let x = v ; S in C[v] 
Unwind the  value as much as possible 
Keep track of all the unwindings 
Terms with infinite unwindings lead to infinite sets. 
http://www.cs g.lcs.m it.edu/6.827 L14-18 
Arvind 
Print*: Maximum Printab le Info 
Print*[e] i Print[si] | s  PRS(e ) } 
where 
Definition: Reduction Sequence 
RS(e) = { s | s0 = e, si-1 -&gt; si , 0 &lt; i &lt; |s| } 
Definition: Progressive Reduction Sequence 
PRS(e) = { s | s  RS(e), and 
i j &gt; i .  sj -&gt;&gt; t k . Print[t]  Print[sk] } 
Proposition: 
if e -&gt;&gt; e1 then Print*[e] = Print*[e1]. 
Print*[e] has precisely one element. = { U
9
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-3 
Arvind 
The B Calcu lus : C + Bar riers 
 Even adding barriers to a purely functional 
calculus (without side-effects) is significant 
 Observability of Termination 
Using B as a s tepping stone to S allows us 
to ana lyze the semantic effects of barrie rs 
separate  from si de-effects, s implifying the 
analys is 
 S = B + side-effects 
http://www.cs g.lcs.m it.edu/6.827 L14-4 
Arvind 
Outline 
Background 
The C calcul us:  + letrecs 
 Observable values 
The B calculus: C + barriers 
 Garbage collection 
The S calculus: B + side -effects 
2
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-7 
Arvind 
C Syntax 
E ::=  x | x.E | E | { S in E } 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 | CNk(E1,...,Ek) | CNk(SE1,...,SEk) 
PF1 ::= negate | not | ... | Prj1| Prj2 | ... 
... 
CN0 ::= Number | Boolean 
CN2 ::= Cons | ... 
S ::=  | x = E  | S; S 
Not in initial 
expressions E 
http://www.cs g.lcs.m it.edu/6.827 L14-8 
Arvind 
C Syntax 
Value s 
V ::= x.E | CN0 | CNk(SE1,...,SEk) 
Simple expressions 
SE ::= x | V 
4
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-23 
Arvind 
Barrier Ru les 
 Barrier discharge 
( &gt;&gt;&gt; S)  S 
 Barrier equivalence 
((H ; S1 ) &gt;&gt;&gt; S2)  (H ; (S1 &gt;&gt;&gt; S2)) 
(H &gt;&gt;&gt;  S)  (H ; S) (derivable) 
http://www.cs g.lcs.m it.edu/6.827 L14-24 
Arvind 
C Versus B 
In B termination of a term is observable. 
Thus, 
5  {x =  in 5} 
Consider the context: 
{ (y = [ ] 
&gt;&gt;&gt; 
z = 3) 
in 
z } 
 equality in C does not imply equality in B 
However, barriers can only make a term less 
defined. 
12
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>http://www.cs g.lcs.m it.edu/6.827 L14-11 
Arvind 
C Rules 
 Cond-rules 
Cond (True, e1, e2 )  e1 
Cond (False, e1, e2 )  e2 
 Constructors 
CNk(e1,...,ek)  {t1 = e1 ;...; tk = ek in CNk(t1,...,tk)} 
 -rules 
PFk(v1,...,vk)  pfk(v1,...,vk) 
Prji(CNk(x1,...,xi,...,xk ))  xi 
http://www.cs g.lcs.m it.edu/6.827 L14-12 
Arvind 
Need for L ifting Rules 
{f = { S1 in x.e1 }; 
y = f a ; 
in 
({ S2 in x.e2 } e3 ) } 
How do we j uxtapose 
(x.e1) 
or 
(x.e2) 3 ? a 
e
6
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mi t.edu/6 .827 L14- 1 
Arvind 
delivered by J acob Schwar tz 
Labor atory for Computer Science 
M.I.T. 
S : A Lambda Calcu lus with 
Side-effects 
Lecture 14 
http://www.cs g.lcs.m it.edu/6.827 L14-2 
Arvind 
M-Structures  and Barr iers 
 Some problems can not be expressed 
functionally 
 Input / Output 
 Gensym: Generate unique iden tifiers 
 Gathering statistics 
 Graph algorith ms 
 Non-determ inistic algor ithms 
 Once side-effects are i ntroduced, barriers 
are needed to control the execution of 
some  operations 
The S calculus 
 C + side-eff ects an d barriers 
1
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>A &#1490; - calculus with Constants and Let - blocks</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-827-multithreaded-parallelism-languages-and-compilers-fall-2002/resources/l04lambdaletprint/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides>
        <slide>
          <slideno>4</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
Constants and the -rule 
 -rule no longer works for all expressions: 
3  x.(3 x) 
one cannot treat an integer as a function ! 
 -rule is not useful if does not apply to all 
expressions because it is trivially true for -
abstractions 
assuming x  FV(y.M), is 
x.(y.M x) = y.M ? 
x.(y.M x) 
 -9 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-10 
Arvind 
Recursion 
 fact can be rewritten as: 
fact = n. Cond (Zero? n) 1 ( Mul n (fact (Sub n 1))) 
 How to get rid of the fact on the RHS? fact n = if (n == 0) then 1 
else n * fact (n -1) 
Idea: pass fact as an argument to itself 
5
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-23 
Arvind 
Lifting Rules 
In the following rules ( let S in e) is the ? -
renaming of (let S in e) to avoid name conflicts 
x = let S in e  x = e; S 
let S1 in ( let S in e)  let S1; S in e 
( let S in e) e1  let S in e e1 
Cond ((let S in e), e1, e2) 
 let S in Cond (e, e1, e2) 
PFk (e1,...,(let S in e),..., ek ) 
 let S in PFk (e1,...,e,..., ek) 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-24 
Arvind 
Datastructure Rules 
CNk(e1,...,ek ) 
 let t 1 = e1; ... ; t k = ek in CNk(t1,...,t k ) 
Prji( CNk(a1,...,ak )) 
 ai 
12
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-17 
Arvind 
-calculus with Combinator Y 
Recursive programs can be translated into the 
-calculus with constants and Y combinator. 
However, 
 Y combinator violates every type discipline 
 translation is messy in case of mutually 
recursive functions 
 
extend the -calculus with recursive let 
blocks. 
L4-18 
Arvind 
let: A -calculus with Letrec 
Expressions 
E ::= x | x.E | E E | let S in E 
Statements 
S ::=  | x = E | S; S 
 ;  is associative and commutative 
SS1 ; S2  S2 ; S1 
1 ; (S2 ; S3)  (S1 ; S2 ) ; S3 
 ; S ?S
let  in E  E 
Variables on the LHS in a let expression must 
be pairwise distinct 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
9 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-19 
Arvind 
 Renaming 
Needed to avoid the capture of free variables. 
Assuming t is a new variable 
x.e  t.(e[t/x]) 
let x = e ; S in e0 
 let t = e[t/x] ; S[t/x] in e0[t/x] 
where S[t/x] is defined as follows: 
[t/x] =  
(y = e)[t/x] = ? (y = e[t/x]) 
(S1; S2)[t/x]= ? (S1[t/x]; S2[t/x]) 
( let S in e)[t/x] 
( let S in e) if x  FV(let S in e) 
( let S[t/x] in e[t/x]) if x  FV(let S in e) = ? 
L4-20 
Arvind 
The -rule 
The normal -rule
( x.e) ea  ?
e [ea/x]
is replaced the following -rule
( x.e) ea  ?
let t = ea in e[t/x] 
where t is a new variable 
and the Instantiation rules which are used for 
substitution 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
10 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-15 
Arvind 
Y : A Fixed Point Operator 
Notice 
Y F   x.F (x x)) ( x.F (x x)) 
 Y  f.(x. (f (x x))) ( x.(f (x x))) 
? ( 
L4-16 
Arvind 
Mutual Recursion 
odd n = if n==0 then False else even (n-1)
even n = if n==0 then True else odd (n-1)
odd = H1 even 
even = H2 odd 
where 
HH1= f.n.Cond(n=0, False, f(n -1)) 
2= f.n.Cond(n=0, True, f(n -1)) 
substituting H2 odd for even 
odd = H1 (H2 odd) 
= H odd where H = 
 ?odd = Y H 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
8 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-21 
Arvind 
let Instantiation Rules 
A free variable in an expression can be instantiated 
by a simple expression 
V ::= x.E values 
SE ::= x | V simple expression 
(x = a ; SC[x])  (x = a ; SC[a]) 
x = a  x = C[C[x]] where a = C[x] simple expression free occurrence 
of x in some 
context C renamed C[ ] to 
avoid free -
variable capture Instantiation rules 
let x = a ; S in C[x]  let x = a ; S in C[a] 
L4-22 
Arvind 
Lifting Rules: Motivation 
let 
f = let S1 in x.e1 
y = f a 
in 
((let S2 in x.e2) e3) 
How do we juxtapose 
( x.e1) a 
or 
( x.e2) e3 ? 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
11 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>L4-25 
Arvind 
Confluenence and Letrecs 
odd = n.Cond(n=0, False, even (n -1)) (M) 
even = n.Cond(n=0, True, odd (n -1)) 
substitute for even (n -1) in M 
odd = n.Cond (n=0, False, 
Cond (n-1 = 0 , True, odd ((n 1)-1))) (M1) 
even = n.Cond (n=0, True, odd (n 1)) 
substitute for odd (n -1) in M 
odd = n.Cond (n=0, False, even (n -1)) (M2) 
even = n.Cond (n=0, True, 
Cond ( n-1 = 0 , False, even ((n -1)-1))) 
M1 and M2 cannot be reduced to the same expression! 
Proposition: let is not confluent . 
Ariola &amp; Klop 1994 
September 16, 2002 http://www.csg.lcs.mit .edu/6.827 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-26 
Arvind 
Contexts for Expressions 
Expression Context for an expression 
C[] ::= [] 
| x.C[] 
| C[] E | E C[] 
| let S in C[] 
| let SC[] in E 
Statement Context for an expression 
SC[] ::= x = C[] 
| SC[] ; S | S; SC[] 
13 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-11 
Arvind 
Self-application and Paradoxes 
Self application, i.e., (x x) is dangerous. 
Suppose: 
u  y. if (y y) = a then b else a 
What is (u u) ? 
L4-12 
Arvind 
Recursion and Fixed Point Equations 
Recursive functions can be thought of as 
solutions of fixed point equations:
fact = n. Cond (Zero? n) 1 ( Mul n (fact (Sub n 1))) 
Suppose 
H = f.n.Cond (Zero? n) 1 ( Mul n (f (Sub n 1))) 
then 
fact = H fact 
fact is a fixed point of function H! 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
6 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4-13 
Arvind 
Fixed Point Equations 
f : D ?D 
A fixed point equation has the form 
f(x) = x 
Its solutions are called the fixed points of f 
because if xp is a solution then 
xp = f(xp) = f(f(xp)) = f(f(f(xp))) = ... 
Examples: f: Int ?Int Solutions 
f(x) = x2 - 2 
f(x) = x2 + x + 1 
f(x) = x 
L4-14 
Arvind 
Least Fixed Point 
Consider 
f n = if n=0 then 1 
else ( if n=1 then f 3 else f (n-2)) 
H = f.n.Cond (n=0 , 1, Cond (n=1, f 3, f (n -2)) 
Is there an fsuch that f= H f ?p p p 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
7 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>http://www.csg.lcs.mit. edu/6.827 L3
Arvind 
Laboratory for Computer Science 
M.I.T. 
A -calculus with Constants and 
Let-blocks 
September 16, 2002 - 1 
L4-2 
Arvind 
Interpreters 
An interpreter for the -calculus is a program to 
reduce -expressions to answers. 
Two common strategies 
	applicative order: left-most innermost redex 
aka call by value evaluation 
	normal order: left-most (outermost) redex 
aka call by name evaluation 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
1 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
A Call -by-value Interpreter 
Answers: WHNF 
Strategy: leftmost -innermost redex but not 
inside a -abstraction 
cv(E): Definition by cases on E 
E = x | ?x.E | E E 
cv(x) = x 
cv( x.E) = x.E 
cv( E1 E2 ) = let f = cv(E1) 
a = cv(E2) 
in 
case f of 
x.E3 = cv(E3[a/x]) 
_ = (f a) -3 
L4-4 
Arvind 
A Call -by-name Interpreter 
Answers: WHNF 
Strategy: leftmost redex 
cn(E): Definition by cases on E 
E = x | ?x.E | E E 
cn(x) = x 
cn( x.E) = x.E 
cn(E1 E2) = let f = cn(E1) 
in 
case f of 
x.E3 = cn(E3[E2/x]) 
_ = (f E2) 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 
2 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
Normalizing Strategy 
A reduction strategy is said to be normalizing 
if it terminates and produces an answer of an 
expression whenever the expression has an 
answer. 
aka the standard reduction 
Theorem: Normal order (left most) reduction 
strategy is normalizing for the ?-calculus. -5 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
Example 
For computing WHNF 
the call -byname interpreter is normalizing 
but the call -by-value interpreter is not ( x.y) (( x.x x) ( x.x x)) 
call by value 
reduction call by name 
reduction -6 
3
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
-calculus with Constants 
E ::= x | x.E | E E 
| Cond (E, E, E) 
| PFk(E1,...,Ek) 
| CN0 
| CNk(E1,...,Ek) 
PF1 ::= negate | not | ... | Prj1| Prj2 | ... 
PF2 ::= + | ... 
CN0 ::= Number | Boolean 
CN2 ::= cons | ... 
It is possible to define integers , booleans , and 
functions on them in the pure -Calculus but the 
-calculus extended with constants is more 
useful as a programming language -7 
September 16, 2002 http://www.csg.lcs.mit. edu/6.827 L4
Arvind 
Primitive Functions and Constructors 
-rules 
+( n, m )  n+m 
... 
Condrules 
Cond(True, e1, e2 )  e1? 
Cond(False, e1, e2 )  e2 
Projection rules 
Prji(CNk (e1,...,ek ))  ei 
-calculus with constants is confluent provided 
the new reduction rules are confluent -8 
4
</text>
        </slide>
      </slides>
    </lecture>
    <videos>
      <video>
        <video_url/>
        <video_title/>
        <transcript>
          <slice>
            <text_slice/>
            <time_slice/>
          </slice>
        </transcript>
      </video>
    </videos>
  </lectures>
</doc>
