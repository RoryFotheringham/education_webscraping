<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/</course_url>
    <course_title>Practical Programming in C</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Software Design and Engineering </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>C standard library: stdio.h, ctype.h, stdlib.h, assert.h, stdarg.h, time.h</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec10/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>&lt;stdio.h&gt;: Opening, closing les
FILE fopen(const c har lename,const c har mode) 
mode can be "r"(read),"w"(wr ite),"a"(append).  
"b" can be appended f or binar y input/output (unnecessar y  
in *nx)
returns NULL on error .
  
FILE freopen(const c har lename,const c har mode,FILE  stream) 
 redirects the stream to the le . 
 returns NULL on error . 
 Where can this be used? (redirecting stdin,stdout,stderr) 
int fush (FILE stream) 
ushes an y unwr itten data.  
if stream is NULL ushes all outputs streams .  
returns EOF on error .  
5</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&lt;stdlib.h&gt;:Utility
doub le atof(const c har s) 
int atoi (const c har s) 
long atol(const c har s) 
converts char acter to oat,integer and long respectiv ely.  
int rand() 
returns a pseduo-r andom n umbers betw een 0 and  
RAND_MAX 
void sr and(unsigned int seed) 
sets the seed f or the pseudo-r andom gener ator!  
13</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&lt;time.h&gt;
size_t strftime (char s,size_t smax,const c har fmt,const struct tm  tp) 
returns time in the desired f ormat.  
 does not write more than smax characters into the string s. 
%a abbreviated w eekda y name 
%A full w eekda y name 
%b abbreviated month name 
%B full month name 
%d day of the month 
%H hour (0-23) 
%I hour (0-12) 
%m month 
%M minute 
%p AM/PM 
%S second 
24</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&lt;stdlib.h&gt;:Searchign and sorting
void  bsearch ( const void  key , const   void base , 
size _t n, size _t size , 
int (cmp ) ( const void keyval , const void datum ) ); 
	searches base[0] through base[n-1] for *key. 
	function cmp() is used to perf orm compar ison. 
	returns a pointer to the matching item if it e xists and NULL 
otherwise . 
void qsort ( void base,size _t n, 
size _t sz , 
int (cmp ) ( const void  , const void  ))! 
	sorts base[0] through base[n-1] in
ascending/descending order .
	function cmp() is used to perf orm compar ison. 
16</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&lt;time.h&gt;
time_t ,clock_t, struct tm data types associated with time . 
struct tm:
int tm_sec seconds 
int tm_min minutes 
int tm_hour hour since midnight (0,23) 
int tm_mda y day of the month (1,31) 
int tm_mon month 
int tm_y ear years since 1900 
int tm_wda y day since sunda y (0,6) 
int tm_yda y day since J an 1 (0,365) 
int tm_isdst DST ag 
21</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&lt;stdlib.h&gt;: Exiting
void abor t(void) 
 causes the prog ram to ter minate abnor mally . 
void exit (int status ) 
	causes nor mal prog ram ter mination. The v alue status is 
returned to the oper ating system. 
	0 EXIT_SUCCESS indicates successful ter mination. Any 
other v alue indicates f ailure (EXIT_FAILURE) 
14</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>6.087 Lecture 10  Jan uary 25, 2010
Review 
Standard Libr ary 
&lt;stdio .h&gt; 
&lt;ctype .h&gt; 
&lt;stdlib .h&gt; 
&lt;asser t.h&gt; 
&lt;stdarg.h&gt; 
&lt;time .h&gt; 
2</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Libraries
	linking: binds symbols to addresses . 
	static linkage: occurs at compile time (static libr aries). 
	dynamic linkage: occurs at r un time (shared libr aries). 
shared libr aries:  
ld.so - locates shared libr aries  
	ldcong - updates links seen b y ld.so 
	dlopen(),dlsym(),dlclose() -load shared libr aries 
on demand. 
	compiling static libr aries: gcc,ar 
	compiling shared libr aries: gcc,ldcong 
2</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6.087 Lecture 10  Jan uary 25, 2010
Review 
Standard Libr ary 
&lt;stdio .h&gt; 
&lt;ctype .h&gt; 
&lt;stdlib .h&gt; 
&lt;asser t.h&gt; 
&lt;stdarg.h&gt; 
&lt;time .h&gt; 
5</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&lt;stdio.h&gt;: File position
int fseek(FILE  stream, long offset ,int origin ) 
sets le position in the stream. Subsequent read/wr ite  
begins at this location
origin can be SEEK_SET, SEEK_CUR, SEEK_END.
  
returns non-z ero on error .  
long ftell (FILE stream) 
returns the current position within the le . (limitation? long  
data type).
returns -1L on error .
 
int rewind(FILE  stream) 
sets the le pointer at the beginning.  
equiv alent to fseek(stream,0L,SEEK_SET);  
9</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&lt;ctype.h&gt;: Testing characters
isalnum(c) isalpha (c) || isdigit (c) 
iscntr l (c) control char acters 
isdigit (c) 0-9 
islower(c) a-z 
isprint (c) printab le char acter (includes space) 
ispunct (c) punctuation 
isspace(c) space , tab or ne w line 
isupper(c ) A-Z 
11</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Outline
Review 
Standard Libr ary 
&lt;stdio .h&gt; 
&lt;ctype .h&gt; 
&lt;stdlib .h&gt; 
&lt;asser t.h&gt; 
&lt;stdarg.h&gt; 
&lt;time .h&gt; 
1</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>&lt;stdio.h&gt;: Raw I/O
size_t fread (void ptr,size_t size,size_t nobj,FILE stream) 
reads at most nobj items of siz e size from stream into  
ptr.
returns the n umber of items read.
  
feof and ferror must be used to test end of le .  
size_t fwrite (const v oid ptr,size_t size,size_t nobj,FILE stream) 
write at most nobj items of siz e size from ptr onto  
stream.
returns number of objects wr itten.
  
8</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&lt;stdarg.h&gt;:Variable argument lists
Variable argument lists: 
functions can v ariable number of arguments .  
the data type of the argument can be diff erent f or each  
argument.
atleast one mandator y argument is required.
  
Declar ation:  
int printf (char fmt ,...); /fmt is last named argument / 
va_list ap 
ap denes an iter ator that will point to the v ariable  
argument.
before using, it has to be initializ ed using va_start.
 
18</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: BTree
	gener alized search treem ultiple children. 
	except f or root, each node can ha ve betw een t and 2t 
children. 
	tree is al ways balanced. 
	Used in le systems , databases etc. 
3</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&lt;string.h&gt;: Memory functions
void memcp y(void dst,const v oid src,siz e_t n) 
copies n bytes from src to location dst  
returns a pointer to dst.  
src and dst cannot o verlap.  
void memmo ve(void dst,const v oid src,siz e_t n) 
beha ves same as memcpy() function.  
src and dst can o verlap.  
int memcmp(const v oid cs,const v oid ct,int n) 
compares rst n bytes betw een cs and ct.  
void memset(v oid dst,int c,int n) 
lls the rst n bytes of dst with the v alue c.  
returns a pointer to dst  
12</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&lt;time.h&gt;
clock_t clock() 
returns processor time used since beginning of prog ram.  
divide b y CLOCKS_PER_SEC to get time in seconds .  
time_t time(time_t  tp) 
returns current time (seconds since J an 1 1970).  
if tp is not NULL, also populates tp .  
doub le difftime (time_t t1,time_t t2) 
returns diff erence in seconds .  
time_t mktime(struct tm  tp) 
converts the str ucture to a time_t object.  
returns -1 if con version is not possib le.  
22</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&lt;stdio.h&gt;: File errors
void clearerr (FILE stream) 
clears EOF and other error indicators on stream.  
int feof(FILE stream) 
 return non-z ero (TR UE) if end of le indicator is set f or 
stream. 
 only w ay to test end of le f or functions such as 
fwrite(),fread() 
int ferror (FILE stream) 
returns non-z ero (TR UE) if an y error indicator is set f or  
stream. 
10</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&lt;stdlib.h&gt;:Exiting
void atexit (void (fcn)(void)) 
	registers a function fcn to be called when the prog ram 
terminates nor mally; 
	returns non z ero when registr ation cannot be made . 
	After exit() is called, the functions are called in re verse 
order of registr ation. 
int system(const c har cmd) 
	executes the command in str ing cmd. 
	if cmd is not n ull, the prog ram e xecutes the command and 
returns exit status retur ned b y the command. 
15</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&lt;stdio.h&gt;:Temporary les
FILE tmple (void) 
creates a tempor ary le with mode "wb+".  
the le is remo ved automaticall y when prog ram  
terminates . 
char tmpnam(c har s[L_tmpnam]) 
creates a str ing that is not the name of an e xisting le .  
return reference to inter nal static arr ay if s is NULL.  
Populate s otherwise .
gener ates a ne w name e very call.
  
7</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&lt;stdarg.h&gt;:Variable argument list
va_star t( va_list ap, lastarg ) 
ap lastarg ref ers to the name of the last named argument.  
va_star t is a macro .  
va_arg( va_list ap, type) 
each call of va_arg points ap to the ne xt argument.  
type has to be inf erred from the x ed argument (e .g. printf)  
or deter mined based on pre vious argument(s). 
va_end(v a_list ap) 
must be called bef ore the function is e xited.  
19</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Review: Priority Queue
 abstr act data str ucture: many implementations 
 common implementations: heaps ,bst,link ed list 
 elements are queued and dequeued in order of pr iority. 
 operations: 
peek(),insert(),extract-max()/extract-min() 
4</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&lt;assert.h&gt;:Diagnostics
void asser t(int expression) 
used to chec k for invariants/code consistency dur ing  
debugging.
does nothing when e xpression is tr ue.
  
prints an error message indicating, e xpression, lename  
and line n umber . 
Alternativ e ways to pr int lename and line n umber dur ing 
execution is to use: __FILE__,__LINE__ macros . 
17</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&lt;stdio.h&gt;: File operations
int remo ve(const c har lename) 
remo ves the le from the le system.  
retrn non-z ero on error .  
int rename(const c har oldname,const c har newname) 
renames le  
returns non-z ero on error (reasons?: permission,  
existence) 
6</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&lt;stdarg.h&gt;:Variable argument list(cont.)
int sum( int num, . . . ) 
{ 
va _list ap; int total =0; 
va _start (ap,num); 
while (num&gt;0) 
{ 
t o t a l +=va_arg ( ap , int ); 
num;
}
va_end(ap );
return total ;
} 
int suma=sum(4 ,1 ,2 ,3 ,4); /  called with five args  / 
int sumb=sum(2 ,1 ,2); /  called with three args  / 
20</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&lt;time.h&gt;
char asctime(const struct tm  tp) 
returns str ing representation of the f orm "Sun J an 3  
15:14:13 1988".
returns static ref erence (can be o verwritten b y other calls).
  
struct tm localtime (const time_t  tp) 
converts calendar time to local time".  
char ctime(const time_t  tp) 
converts calendar time to str ing representation of local  
time".
equiv alent to sctime(loc ltime(tp))!
  
23</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>More control flow. Input and output.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec04/</lecture_pdf_url>
      <lectureno>4</lectureno>
      <slides>
        <slide>
          <slideno>30</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>printf f ormat specication (cont.)
%[ags ][width ][. precision ][modier ]&lt;type&gt; 
modier: 
modier meaning 
h interpreted as shor t. Use with i,d,o ,u,x 
l interpreted as long. Use with i,d,o ,u,x 
L interpreted as doub le. Use with e ,f,g 
16</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Command line input (cont.)
int main(int argc,char argv[]) 
	argc: count of arguments . 
	argv[]: an arr ay of pointers to each of the arguments 
	note: the arguments include the name of the prog ram as 
well. 
Examples: 
	./cat a.txt b .txt (argc=3,argv[0]="cat" argv[1]="a.txt"
argv[2]="b .txt"
	./cat (argc=1,argv[0]="cat") 
27</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Standar d input and output
What does the f ollowing code do? 
int main () 
{ 
char c; 
while ((c=getchar ())!= EOF) 
{ 
if ( c&gt;=A &amp;&amp; c&lt;=Z )
c=cA+a ;
putchar (c );
}
return 0;
} 
To use a le instead of standard input, use &lt; oper ator (*nix). 
	Normal in vocation: ./a.out 
	Input redirection: a.out &lt; le .txt. Treats le .txt as source of 
standard input.This is an OS f eature , not a language 
feature . 
10</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>File I/O(cont.)
int fclose (FILE fp) 
	closes the stream (releases OS resources). 
	fclose() is automatically called on all open les when 
program ter minates . 
23</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>File input
int getc(FILE fp) 
	reads a single char acter from the stream. 
	returns the char acter read or EOF on error/end of le . 
Note: getchar simply uses the standard input to read a 
character . We can implement it as f ollows: 
#dene getchar() getc(stdin ) 
char[] fgets (char line [], int maxlen,FILE  fp) 
	reads a single line (upto maxlen char acters) from the input 
stream (including linebreak). 
	returns a pointer to the char acter arr ay that stores the line 
(read-only)
return NULL if end of stream.
  
24</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Standar d input and output
int putchar( int) 
	putchar(c) puts the char acter c on the standard output. 
 it retur ns the char acter pr inted or EOF on error . 
int getchar () 
	returns the ne xt char acter from standard input.
it retur ns EOF on error .
  
9</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>printf f ormat specication (cont.)
%[ags ][width ][. precision ][modier ]&lt;type&gt; 
ag: 
format output 
printf ("%d,%+d,%+d",10,10) 10,+10,-10 
printf ("%04d",10) 0010 
printf ("%7s","hello") bbhello 
printf ("%-7s","hello") hellob b 
14</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6.087 Lecture 4  Jan uary 14, 2010
Review 
Control o w 
I/O 
Standard I/O 
String I/O 
File I/O 
5</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>File output
int putc(int c,FILE fp) 
 writes a single char acter c to the output stream. 
returns the char acter wr itten or EOF on error .  
Note: putchar simply uses the standard output to wr ite a 
character . We can implement it as f ollows: 
#dene putchar(c) putc (c,stdout ) 
int fputs (char line [], FILE fp) 
 writes a single line to the output stream. 
 returns zero on success , EOF otherwise . 
int fscanf (FILE fp,char format[],arg1,arg2) 
 similar to scanf ,sscanf 
 reads items from input stream fp . 
25</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Digression: character arra ys
Since w e will be reading and wr iting str ings, here is a br ief 
digression 
 strings are represented as an arr ay of char acters 
 C does not restr ict the length of the str ing. The end of the 
string is specied using 0. 
For instance , "hello" is represented using the arr ay 
{h,e,l,l,\0} . 
Declar ation e xamples: 
 char str []="hello"; /compiler tak es care of siz e/ 
 char str[10]="hello"; /make sure the arr ay is large enough / 
 char str []={ h,e,l,l,0}; 
Note: use \" if y ou w ant the str ing to contain ". 
17</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 4  Jan uary 14, 2010
Review 
Control o w 
I/O 
Standard I/O 
String I/O 
File I/O 
1</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Preliminaries
	Input and output f acilities are pro vided b y the standard 
library &lt;stdio .h&gt; and not b y the language itself . 
	A text stream consists of a ser ies of lines ending with \n. 
The standard libr ary tak es care of con version from 
\r\n \n 
	A binar y stream consists of a ser ies of r aw bytes. 
	The streams pro vided b y standard libr ary are b uffered. 
8</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Conditional b locks
switch..case is used to test m ultiple conditions (more efcient 
than if else ladders). 
switch ( opt ) 
{ 
case A : 
/  execute if opt == A  / 
break ;
case B :
case C :
/  execute if opt == B || opt == C  / 
default : 
} 
3</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Command line input
	In addition to taking input from standard input and les, you 
can also pass input while in voking the prog ram. 
	Command line parameters are v ery common in *nix 
environment. 
	So far, we have used int main() as to in voke the main 
function. However, main function can tak e arguments that 
are populated when the prog ram is in voked. 
26</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Iterative b locks
 while loop tests condition bef ore e xecution of the b lock. 
 do..while loop tests condition after e xecution of the b lock. 
 for loop provides initialization, testing and iteration together . 
4</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Conditional b locks
if ... else..else if is used f or conditional br anching of e xecution 
if ( cond ) 
{ 
/  code executed if cond is true  / 
} 
else 
{ 
/  code executed if cond is false  / 
} 
2</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Spaghetti code
Dijkstr a. Go To Statement Considered Harmful. 
Comm unications of the A CM 11(3),1968 
 Excess use of goto creates sphagetti code. 
 Using goto makes code harder to read and deb ug. 
 Any code that uses goto can be wr itten without using one . 
6</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>6.087 Lecture 4  Jan uary 14, 2010
Review 
Control o w 
I/O 
Standard I/O 
String I/O 
File I/O 
8</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Formatted input
int scanf(c har format ,...) is the input analog of pr intf. 
	scanf reads char acters from standard input, inter preting 
them according to f ormat specication 
	Similar to printf , scanf also tak es variable number of
arguments .
	The f ormat specication is the same as that f or printf 
	When m ultiple items are to be read, each item is assumed 
to be separ ated b y white space .
It retur ns the n umber of items read or EOF .
  
	Impor tant: scanf ignores white spaces . 
	Impor tant: Arguments ha ve to be address of v ariables 
(pointers). 
19</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Bloc ks
 Blocks combine m ultiple statements into a single unit. 
 Can be used when a single statement is e xpected. 
 Creates a local scope (v ariables declared inside are local 
to the b lock).
Blocks can be nested.
  
{ 
int x=0; 
{ 
int y=0; /  both x and y visible  /
}
/  only x visible  / 
} 
1</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>printf f ormat specication (cont.)
%[ags ][width ][. precision ][modier ]&lt;type&gt; 
precision: 
format output 
printf ("%.2f,%.0f,1.141,1.141) 1.14,1 
printf ("%.2e,%.0e,1.141,100.00) 1.14e+00,1e+02 
printf ("%.4s","hello") hell 
printf ("%.1s","hello") h 
15</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Digression: character arra ys
Compar ing str ings: the header le &lt;string.h&gt; provides the 
function int strcmp(c har s [],char t []) that compares tw o strings in 
dictionar y order (lo wer case letters come after capital case). 
the function retur ns a v alue &lt;0 if s comes bef ore t  
the function retur n a v alue 0 if s is the same as t  
the function retur n a v alue &gt;0 if s comes after t  
 strcmp is case sensitiv e 
Examples 
 strcmp("A","a") /&lt;0/ 
 strcmp("IRONMAN","BATMAN") /&gt;0/ 
 strcmp("aA","aA") /==0/ 
 strcmp("aA","a") /&gt;0/ 
18</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Standar d output:f ormatted
int printf (char format[],arg1,arg2 ,...) 
	printf() can be used f or formatted output. 
	It tak es in a v ariab le number of arguments . 
	It retur ns the n umber of char acters pr inted. 
	The f ormat can contain liter al str ings as w ell as f ormat 
speciers (star ts with %). 
Examples: 
printf ( "hello world\n" ); 
printf ( "%d\n" ,10); /  format: %d (integer),argument:10  / 
printf ( "Prices:%d and %d\n" ,10 ,20); 
11</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>printf f ormat specication
The f ormat specication has the f ollowing components 
%[ags ][width ][. precision ][length ]&lt;type&gt; 
type: 
type meaning example 
d,i integer printf ("%d",10); / prints 10/ 
x,X integer (he x) printf ("%x",10); / print 0xa/ 
u unsigned integer printf ("%u",10); / prints 10/ 
c character printf ("%c",A); /pr ints A/ 
s string printf ("%s","hello"); /pr ints hello/ 
f oat printf ("%f",2.3); / prints 2.3/ 
d doub le printf ("%d",2.3); / prints 2.3/ 
e,E oat(e xp) 1e3,1.2E3,1E3 
% literal % printf ("%d %%",10); /pr ints 10%/ 
12</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>error handling 
Language lik e C++ and J ava pro vide e xception mechanism to 
recover from errors . In C, goto provides a convenient way to exit 
from nested b locks. 
cont _flag =1; 
for (..) 
for ( . . ) { 
{ for ( i n i t ; c o n t _ f l a g ; i t e r ) 
for ( . . ) { 
{ i f ( error_cond ) 
i f ( error_cond ) { 
goto e r r o r ; c o n t _ f l a g =0; 
/  skips 2 blocks  / break ; 
} } 
} /  i n n er loop  / 
e r r o r : } 
i f ( ! c o n t _ f l a g ) break ; 
/  outer loop  / 
} 
7</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>printf f ormat specication (cont.)
%[ags ][width ][. precision ][modier ]&lt;type&gt; 
width: 
format output 
printf ("%d",10) "10" 
printf ("%4d",10) bb10 (b:space) 
printf ("%s","hello") hello 
printf ("%7s","hello") bbhello 
13</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>String input/output
Instead of writing to the standard output, the formatted data can
be wr itten to or read from char acter arr ays.
int sprintf (char string [], char format[],arg1,arg2)
	The f ormat specication is the same as pr intf. 
	The output is wr itten to str ing (does not chec k size). 
	Retur ns the n umber of char acter wr itten or negativ e value 
on error . 
int sscanf(c har str [], char format[],arg1,arg2) 
	The f ormat specication is the same as scanf; 
	The input is read from str v ariable. 
	Retur ns the n umber of items read or negativ e value on 
error. 
21</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>File I/O
So far, we have read from the standard input and wr itten to the
standard output. C allo ws us to read data from te xt/binar y les
using fopen ().
FILE fopen(c har name[],c har mode[])
	mode can be "r" (read only),"w" (wr ite only),"a" (append) 
among other options . "b" can be appended f or binar y les . 
	fopen retur ns a pointer to the le stream if it e xists or
NULL otherwise .
	We dont need to kno w the details of the FILE data type . 
	Impor tant: The standard input and output are also FILE* 
datatypes (stdin,stdout). 
	Impor tant: stderr corresponds to standard error
output(diff erent from stdout).
22</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>goto
	goto allows you to jump unconditionall y to arbitr ary part of 
your code (within the same function). 
	the location is identied using a label. 
a label is a named location in the code . It has the same  
form as a v ariable followed by a : 
start : 
{ 
if ( cond ) 
goto outside ; 
/  some code  / 
goto start ; 
} 
outside : 
/  outside block  / 
5</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Formatted input
int scanf(c har format ,...) is the input analog of pr intf. 
Examples: 
printf ("%d",x) scanf("%d",&amp;x) 
printf ("%10d",x) scanf("%d",&amp;x) 
printf ("%f",f) scanf("%f",&amp;f) 
printf ("%s",str) scanf("%s",str) /note no &amp; required/ 
printf ("%s",str) scanf("%20s",str) /note no &amp; required/ 
printf ("%s %s",fname,lname) scanf("%20s %20s",fname,lname) 
20</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>External libraries. B-trees, priority queues.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec09/</lecture_pdf_url>
      <lectureno>9</lectureno>
      <slides>
        <slide>
          <slideno>13</slideno>
          <text>Static and d ynamic linka ge
	Functions , global v ariables m ust be allocated memor y 
before use 
	Can allocate at compile time (static) or at r un time (shared) 
	Advantages/disadv antages to both 
	Symbols in same le , other .o les, or static libr aries 
(archiv es, .a les)  static linkage 
	Symbols in shared libr aries (.so les)  dynamic linkage 
	gcc links against shared libr aries b y def ault, can f orce 
static linkage using -static ag 
11</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Inser ting elements
	Inser tion complicated due to maxim um n umber of k eys 
	At high le vel: 
1. traverse tree do wn to leaf node 
2. if leaf already full, split into tw o lea ves: 
(a)	move median k ey element into parent (splitting parent 
already full) 
(b) split remaining k eys into tw o lea ves (one with lo wer, one with 
higher elements) 
3. add element to sor ted list of k eys 
	Can accomplish in one pass , splitting full parent nodes 
during tr aversal in step 1 
26</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Linking e xternal libraries
	Prog rams link ed against C standard libr ary by def ault 
	To link against libr ary libnamespec.so or 
libnamespec.a, use compiler ag -lnamespec to link 
against libr ary 
	Library must be in libr ary path (standard libr ary director ies 
+ director ies specied using -L directory compiler ag 
	Use -static for force static linkage 
	This is enough f or static linkage; libr ary code will be added 
to resulting e xecutab le 
15</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Loading shared libraries
	Shared libr ary located dur ing compile-time linkage , but 
needs to be located again dur ing run-time loading 
	Shared libr aries located at r un-time using link er libr ary 
ld.so 
	Whene ver shared libr aries on system change , need to r un 
ldconfig to update links seen b y ld.so 
	During loading, symbols in dynamic libr ary are allocated 
memor y and loaded from shared libr ary le 
16</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Static linka ge
	What happens if w e statically link against the libr ary? 
athena% gcc -Wall -static hello.o -o hello 
	Our e xecutab le no w contains the symbol puts: 
. . . 
00000000004014c0 W puts 
. . . 
0000000000400304 T main 
. . . 
000000000046cd04 R msg 
. . . 
	W: link ed to another dened symbol 
12 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>6.087 Lecture 9  Jan uary 22, 2010
Review 
Using Exter nal Libr aries 
Symbols and Linkage 
Static vs . Dynamic Linkage 
Linking Exter nal Libr aries 
Symbol Resolution Issues 
Creating Libr aries 
Data Str uctures 
B-trees 
Priority Queues 
21</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Deletion e xamples
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] 
Courtesy of MIT Press. Used with permission. 
32</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Deletion e xamples
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] Courtesy of MIT Press. Used with permission. 
33</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Heaps
	Heap - tree with heap-order ing proper ty: priority(child) 
priority(parent) 
	More sophisticated heaps e xist  e .g. binomial heap , 
Fibonacci heap 
	Well focus on simple binar y heaps 
	Usually implemented as an arr ay with top element at 
beginning 
	Can sor t data using a heap  O(n log n) worst case 
in-place sor t! 
35</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6.087 Lecture 9  Jan uary 22, 2010
Review 
Using Exter nal Libr aries 
Symbols and Linkage 
Static vs . Dynamic Linkage 
Linking Exter nal Libr aries 
Symbol Resolution Issues 
Creating Libr aries 
Data Str uctures 
B-trees 
Priority Queues 
5</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Review: Hash tab les
	Hash tab le (or hash map): array of link ed lists f or stor ing 
and accessing data efciently 
	Each element associated with a k ey (can be an integer , 
string, or other type) 
	Hash function computes hash v alue from k ey (and tab le 
size); hash v alue represents inde x into arr ay 
	Multiple elements can ha ve same hash v alue  results in 
collision; elements are chained in link ed list 
4</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>msg, main(), puts(), others instdio.h
Functions and v ariab les as symbols
 Consider the simple hello w orld prog ram wr itten belo w: 
#include &lt;stdio .h&gt; 
const char msg[] = "Hello, world." ; 
int main ( void ){
puts (msg);
return 0;
} 
 What v ariables and functions are declared globally? 
6</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Inser ting elements
B-tree with t =3 (nodes ma y have 25 keys):
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] Courtesy of MIT Press. Used with permission. 
27</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Creating libraries
	Libraries contain C code lik e any other prog ram 
	Static or shared libr aries compiled from (un-link ed) object 
les created using gcc 
	Compiling a static libr ary: 
	compile , but do not link source les: 
athena% gcc -g -Wall -c infile.c -o 
outfile.o 
	collect compiled (unlink ed) les into an archiv e: 
athena% ar -rcs libname.a outfile1.o 
outfile2.o ... 
21 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Initializing a B-tree
	Initially , B-tree contains root node with no children (leaf 
node), no k eys 
	Note: root node e xempt from minim um children 
requirement 
25</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>B-tree structure
	Binar y search tree with v ariable number of children (at 
least t, up to 2t) 
Tree is balanced  all lea ves at same le vel  
	Node contains list of k eys  divide r ange of elements in 
children 
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.]	Courtesy of MIT Press. Used with permission. 
24</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Functions and v ariab les as symbols
	Consider the simple hello w orld prog ram wr itten belo w: 
#include &lt;stdio .h&gt; 
const char msg[] = "Hello, world." ; 
int main ( void ){
puts (msg);
return 0;
} 
	What v ariables and functions are declared globally? 
msg, main(), puts(), others in stdio.h 
6</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Deletion
	Deletion complicated b y minim um children restr iction 
	When tr aversing tree to nd element, need to ensure child 
nodes to be tr aversed ha ve enough k eys 
	if adjacent child node has at least t keys, move separ ating 
key from parent to child and closest k ey in adjacent child to 
parent 
	if no adjacent child nodes ha ve extra keys, merge child 
node with adjacent child 
	When remo ving a k ey from a node with children, need to 
rearr ange k eys again 
	if child bef ore or after remo ved key has enough k eys, move 
closest k ey from child to parent 
	if neither child has enough k eys, merge both children 
	if child not a leaf , have to repeat this process 
30</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Loading shared libraries on demand
	In Lin ux, can load symbols from shared libr aries on 
demand using functions in dlfcn.h 
	Open a shared libr ary for loading: 
void  dlopen(const c har le, int mode); 
values f or mode: combination of RTLD_LAZY (lazy loading 
of libr ary), RTLD_NOW (load no w), RTLD_GLOBAL (mak e 
symbols in libr ary availab le to other libr aries yet to be 
loaded), RTLD_LOCAL (symbols loaded are accessib le 
only to y our code) 
17</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Extracting data
Heap-order ing proper ty maxim um pr iority element at 	 
top of heap 
	Can peek b y looking at top element 
	Can remo ve top element, mo ve last element to top , and 
swap top element do wn with its children until it satises 
heap-order ing proper ty: 
1. start at top 
2. nd largest of element and left and r ight child; if element is 
largest, w e are done 
3. otherwise , swap element with largest child and repeat with 
element in ne w position 
36</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Example of inser ting data
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] 
Courtesy of MIT Press. Used with permission. 
38</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Creating shared libraries
	Compile and do not link les using gcc: 
athena% gcc -g -Wall -fPIC -c infile.c -o 
outfile.o 
	-fPIC option: create position-independent code , since 
code will be repositioned dur ing loading 
	Link les using ld to create a shared object (.so) le: 
athena% ld -shared -soname libname.so -o 
libname.so.version -lc outfile1.o 
outfile2.o ... 
	If necessar y, add director y to LD_LIBRARY_PATH 
environment v ariable, so ld.so can nd le when loading 
at run-time 
	Congure ld.so for ne w (or changed) libr ary: 
athena% ldconfig -v 
22 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Inser ting elements
More inser tion e xamples:
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] Courtesy of MIT Press. Used with permission. 
28</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Functions and v ariab les as symbols
	Lets compile , but not link, the le hello .c to create hello .o: 
athena% gcc -Wall -c hello.c -o hello.o 
	-c: compile , but do not link hello .c; result will compile the 
code into machine instr uctions b ut not mak e the prog ram 
executab le 
	addresses f or lines of code and static and global v ariables 
not y et assigned 
	need to perf orm link step on hello.o (using gcc or ld) to 
assign memor y to each symbol 
	linking resolv es symbols dened else where (lik e the C 
standard libr ary) and mak es the code e xecutab le 
7 1
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Functions and v ariab les as symbols
	Lets look at the symbols in the compiled le hello .o: 
athena% nm hello.o 
	Output: 
0000000000000000 T main
0000000000000000 R msg
U puts
	T  (te xt) code; R  read-only memor y; U - undened 
symbol 
	Addresses all z ero bef ore linking; symbols not allocated 
memor y yet 
	Undened symbols are dened e xternally, resolv ed dur ing 
linking 
8 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. . 1
1</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Loading shared libraries on demand
	Get the address of a symbol loaded from the libr ary: 
void  dlsym(v oid  handle, const c har  symbol_name); 
handle from call to dlopen; retur ned address is pointer to 
variable or function identied b y symbol_name 
	Need to close shared libr ary le handle after done with 
symbols in libr ary: 
int dlclose (void  handle); 
	These functions are not par t of C standard libr ary; need to 
link against libr ary libdl: -ldl compiler ag 
18</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: Function pointer s
int strcmp_wrapper ( void pa , void pb) {   
return strcmp (( const char  )pa, ( const char )pb ); 
} 
	Can assign to a function pointer :
int (fp )(void , void ) = strcmp_wr apper; or
int (fp )(void , void ) = &amp;strcmp_wr apper;
	Can call from function pointer : (str1 and str2 are 
strings) 
int ret =fp(str1, str2); or 
int ret =(fp )( str1 , str2 ); 
3</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 9  Jan uary 22, 2010
Review 
Using Exter nal Libr aries 
Symbols and Linkage 
Static vs . Dynamic Linkage 
Linking Exter nal Libr aries 
Symbol Resolution Issues 
Creating Libr aries 
Data Str uctures 
B-trees 
Priority Queues 
1</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Symbols and libraries
	Exter nal libr aries pro vide a w ealth of functionality  
example: C standard libr ary 
	Prog rams access libr aries functions and v ariables via 
identiers kno wn as symbols 
	Header le declar ations/prototypes mapped to symbols at 
compile time 
	Symbols link ed to denitions in e xternal libr aries dur ing 
linking 
	Our o wn prog ram produces symbols , too 
5</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Symbol resolution issues
	How about if w e dene puts() in a shared libr ary and 
attempt to use it within our prog rams? 
	Symbols resolv ed in order the y are loaded 
	Suppose our libr ary containing puts() is libhello.so, 
located in a standard libr ary director y (like /usr/lib), 
and w e compile our hello.c code against this libr ary: 
athena% gcc -g -Wall hello.c -lhello -o 
hello.o 
	Libraries specied using -l ag are loaded in order 
specied, and bef ore C standard libr ary 
	Which puts() gets used here? 
athena% gcc -g -Wall hello.c -lc -lhello -o 
hello.o 
20 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Functions and v ariab les as symbols
	Lets look at the symbols no w: 
athena% nm hello 
	Output: 
(other def ault symbols)
.
. . 
0000000000400524 T main 
000000000040062c R msg 
U	puts@@GLIBC_2.2.5 
	Addresses f or static (allocated at compile time) symbols 
	Symbol puts located in shared libr ary GLIBC_2.2.5 (GNU 
C standard libr ary) 
	Shared symbol puts not assigned memor y until r un time 
10 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Priority queue
	Abstr act data str ucture order ing elements b y priority 
	Elements enqueued with pr iority, dequeued in order of 
highest pr iority 
	Common implementations: heap or binar y search tree 
	Oper ations: inser tion, peek/e xtract max-pr iority element, 
increase element pr iority 
34</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Functions and v ariab les as symbols
	Why arent symbols listed f or other declar ations in 
stdio.h? 
	Compiler doesnt bother creating symbols f or un used 
function prototypes (sa ves space) 
	What happens when w e link? 
athena% gcc -Wall hello.o -o hello 
	Memor y allocated f or dened symbols 
	Undened symbols located in e xternal libr aries (lik e libc 
for C standard libr ary) 
9 Athena is MIT's UNIX-based computing environment. OCW does not provide access to it.1
1</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Data structures
	Many data str uctures designed to suppor t certain 
algor ithms 
	B-tree -gener alized binar y search tree, used for databases 
and le systems 
	Priority queue - order ing data b y priority, used f or sor ting, 
event sim ulation, and man y other algor ithms 
23</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Deletion e xamples
[Cormen, Leiserson, Riv est, and Stein. Introduction to Algor ithms, 2nd ed. 
MIT Press , 2001.] 
Courtesy of MIT Press. Used with permission. 
31</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Symbol resolution issues
	Symbols can be dened in m ultiple places 
	Suppose w e dene our o wn puts() function 
	But, puts() dened in C standard libr ary 
	When w e call puts(), which one gets used? 
	Our puts() gets used since ours is static , and puts() in 
C standard libr ary not resolv ed until r un-time 
	If statically link ed against C standard libr ary, linker nds 
two puts() denitions and abor ts (m ultiple denitions not 
allowed) 
19</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Function pointer s
	Functions not v ariables, but also reside in memor y (i.e . 
have an address)  w e can tak e a pointer to a function 
	Function pointer declar ation: 
int (cmp)(v oid , void ); 
	Can be treated lik e any other pointer 
	No need to use &amp; operator (b ut you can) 
	Similar ly, no need to use * operator (b ut you can) 
2</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Static linka ge
	At link time , statically link ed symbols added to e xecutab le 
	Results in m uch larger e xecutab le le (static  688K, 
dynamic  10K) 
	Resulting e xecutab le does not depend on locating e xternal 
library les at r un time 
	To use ne wer version of libr ary, have to recompile 
13</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Inser ting data/increasing priority
 Inser t element at end of heap , set to lo west pr iority  
 Increase pr iority of element to real pr iority: 
1. start at element 
2. if new priority less than parent s, we are done 
3. otherwise , swap element with parent and repeat 
37</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Dynamic linka ge
	Dynamic linkage occurs at r un-time 
	During compile , linker just looks f or symbol in e xternal 
shared libr aries 
	Shared libr ary symbols loaded as par t of prog ram star tup 
(before main()) 
	Requires e xternal libr ary to dene symbol e xactly as 
expected from header le declar ation 
	changing function in shared libr ary can break y our prog ram 
	version inf ormation used to minimiz e this prob lem 
	reason wh y common libr aries lik e libc rarely modify or 
remo ve functions , even brok en ones lik e gets() 
14</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>6.087 Lecture 9  Jan uary 22, 2010
Review 
Using Exter nal Libr aries 
Symbols and Linkage 
Static vs . Dynamic Linkage 
Linking Exter nal Libr aries 
Symbol Resolution Issues 
Creating Libr aries 
Data Str uctures 
B-trees 
Priority Queues 
23</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: Void pointer s
	Void pointer  points to an y data type: 
int x; void  px=&amp;x; / implicit cast to (void ) / 
oat f; void  pf =&amp;f; 
	Cannot be deref erenced directly; v oid pointers m ust be 
cast pr ior to deref erencing:
printf ( "%d %f\n" ,  ( int  )px ,  ( float  )pf );
1</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Ourputs() gets used since ours isstatic ,andputs() in
Cstandard librarynotresolv eduntil run-time
Ifstatically linkedagainst Cstandard library,linkernds
twoputs() denitions andaborts(multiple denitions not
allowed)
Symbol resolution issues
 Symbols can be dened in m ultiple places 
 Suppose w e dene our o wn puts() function 
 But, puts() dened in C standard libr ary 
 When w e call puts(), which one gets used? 
19</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Sear ching a B-tree
 Search lik e searching a binar y search tree: 
1. start at root. 
2. if node empty , element not in tree 
3. search list of k eys for element (using linear or binar y 
search) 
4. if element in list, retur n element 
5. otherwise , element betw een k eys, and repeat search on 
child node f or that r ange 
 Tree is balanced  search tak es O(log n) time 
29</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Summar y
Topics co vered: 
 Using e xternal libr aries 
	symbols and linkage 
	static vs . dynamic linkage 
	linking to y our code 
	symbol clashing 
	Creating libr aries
Data str uctures
 
B-tree 
	priority queue 
39</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Multithreading and concurrency.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec12/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>17</slideno>
          <text>Example
#define NELEMENTS 5000 
#define BLK_SIZE 1000 
#define NTHREADS (NELEMENTS/BLK_SIZE) 
int main ( int argc , char argv []) 
{ 
pthread_t thread [NUM_THREADS] ; 
pthread _attr _t attr ;
int rc ; long t; void status ;
/ Initialize and set thread detached attribute / 
pthread _attr _init(&amp;attr );
pthread _attr_setdetachstate(&amp;attr , PTHREAD_CREATE_JOINABLE);
for ( t =0; t &lt;NUM_THREADS; t ++) {
printf("Main: creating thread %ld\n ", t);
rc = pthread_create(&amp;thread[t], &amp;attr , work, ( void  )( t BLK_SIZE ) ) ;
if (rc) {
printf("ERROR; return code from pthread_create() is %d\n ", rc); exit( 1);
}
}
/ Free attribute and wait for the other threads / 
pthread_attr _destroy(&amp;attr ); 
for ( t =0; t &lt;NUM_THREADS; t ++) {
rc = pthread _join(thread[t], &amp;status);
if (rc) {
printf("ERROR; return code from pthread _join() is %d\n ", rc);exit( 1); 
}
}
printf("Main: program completed. Exiting.\n ");
} 15</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Outline
Review 
Multithreaded prog ramming 
Concepts 
Pthread 
API 
Mute x 
Condition v ariables 
1</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Preliminaries: Parallel computing
	Parallelism: Multiple computations are done 
simultaneously . 
	Instruction le vel (pipelining) 
	Data par allelism (SIMD) 
	Task par allelism (embarr assingly par allel) 
	Concurrency: Multiple computations that ma y be done in 
parallel. 
	Concurrency vs . Parallelism 
4</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Not all multi-threaded code is safe
int balance =500; 
void deposit ( int sum ) { 
int currbalance=balance ; / read balance / 
... 
currbalance+=sum ; 
balance=currbalance ; / write balance / 
} 
void withdraw ( int sum ) { 
int currbalance=balance ; / read balance / 
if ( currbalance &gt;0) 
currbalance=sum ; 
balance=currbalance ; / write balance / 
} 
.. 
deposit (100); / thread 1/ 
.. 
withdraw (50);/ thread 2/ 
.. 
withdraw (100); / thread 3/ 
... 
 minimiz e use of global/static memor y 
 Scenar io: T1(read),T2(read,wr ite),T1(wr ite) ,balance=600 
 Scenar io: T2(read),T1(read,wr ite),T2(wr ite) ,balance=450 
9</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Creating threads
int	pthread_create ( pthread_t thread ,  
const pthread _attr _t attr ,  
void ( start _routine )( void  ), void arg );  
	creates a ne w thread with the attr ibutes specied b y attr. 
Default attr ibutes are used if attr is NULL.  
	On success , stores the thread it into thread 
	calls function start_routine(arg) on a separ ate
thread of e xecution.
	returns zero on success , non-z ero on error . 
void pthread_e xit(void value_ptr); 
	called implicitly when thread function e xits. 
	analogous to exit(). 
11</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Sync hronization: joining
Figure: https://computing.llnl.gov/tutorials/pthreads 
int pthread_join (pthread_t thread , void value_ptr); 
	pthread_join () blocks the calling thread until the specied thread 
terminates . 
	If value_ptr is not n ull, it will contain the retur n status of the 
called thread 
Other w ays to synchroniz e: mutex,condition v ariables 
Courtesy of Lawrence Livermore National Laboratory. Used with permission. 14 Lawrence Livermore National Laboratory. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Output
In main : c r e a t i n g thread 0 In main : c r e a t i n g thread 0 
In main : c r e a t i n g thread 1 Hello World ! I t  s me, thread #0! 
Hello World ! I t  s me, thread #0! In main : c r e a t i n g thread 1 
Hello World ! I t  s me, thread #1! Hello World ! I t  s me, thread #1! 
In main : c r e a t i n g thread 2 In main : c r e a t i n g thread 2 
In main : c r e a t i n g thread 3 Hello World ! I t  s me, thread #2! 
Hello World ! I t  s me, thread #2! In main : c r e a t i n g thread 3 
Hello World ! I t  s me, thread #3! Hello World ! I t  s me, thread #3! 
In main : c r e a t i n g thread 4 In main : c r e a t i n g thread 4 
Hello World ! I t  s me, thread #4! Hello World ! I t  s me, thread #4! 
13</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Using mutex
int balance =500;
pthread_mutex_t mutexbalance=PTHREAD_MUTEX_INITIALIZER;
void deposit ( int sum ) { 
pthread_mutex_lock(&amp;mutexbalance ); 
{ 
int currbalance=balance ; / read balance / 
...
currbalance+=sum ;
balance=currbalance ; / write balance /
}
pthread_mutex_unlock(&amp;mutexbalance );
} 
void withdraw ( int sum ) { 
pthread_mutex_lock(&amp;mutexbalance ); 
{ 
int currbalance=balance ; / read balance / 
if ( currbalance &gt;0) 
currbalance=sum ;
balance=currbalance ; / write balance /
}
pthread_mutex_unlock(&amp;mutexbalance );
}
.. deposit(100); / thread 1/
.. withdraw (50);/ thread 2/
.. withdraw(100); / thread 3/
 Scenar io: T1(read,wr ite),T2(read,wr ite),balance=550 
 Scenar io: T2(read),T1(read,wr ite),T2(wr ite),balance=550 
19</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>6.087 Lecture 12  January 27, 2010
Review 
Multithreaded prog ramming 
Concepts 
Pthread 
API 
Mute x 
Condition v ariables 
10</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Mute x
	Mute x (mutual exclusion) acts as a "lock" protecting access 
to the shared resource . 
	Only one thread can "o wn" the m utex at a time . Threads 
must tak e turns to loc k the m utex. 
int pthread_mutex_destroy ( pthread_mutex_t mutex ) ; 
int pthread_mutex_init ( pthread_mutex_t mutex ,  
const pthread_mutexattr_t attr );  
thread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 
	pthread_m utex_init() initializ es a m utex. If attr ibutes are NULL, 
default attr ibutes are used.
The macro PTHREAD_MUTEX_INITIALIZER can be used to initializ e
  
static m utexes.
pthread_m utex_destro y() destro ys the m utex.
  
	Both function return return 0 on success , non zero on error. 
16</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Condition variab les
Sometimes loc king or unloc king is based on a r un-time 
condition (e xamples?).Without condition v ariables, prog ram 
would ha ve to poll the v ariable/condition contin uously . 
Consumer : 
(a) lock mutex on global item v ariable 
(b) wait for (item&gt;0) signal from producer (m utex unloc ked 
automatically). 
(c) wake up when signalled (m utex locked again 
automatically), unloc k mutex and proceed. 
Producer : 
(1) produce something 
(2) Lock global item v ariable, update item 
(3) signal w aiting (threads) 
(4) unloc k mutex 
20</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Mute x
int pthread_mutex_lock ( pthread_mutex_t mutex ) ; 
int pthread_mutex_trylock ( pthread_mutex_t mutex ) ; 
int pthread_mutex_unlock ( pthread_mutex_t mutex ) ; 
	pthread_m utex_loc k() locks the giv en m utex. If the m utex is loc ked, 
the function is b locked until it becomes a vailab le. 
	pthread_m utex_trylock() is the non-b locking v ersion. If the m utex is 
currently loc ked the call will retur n immediately . 
pthread_m utex_unloc k() unloc ks the m utex.  
17</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Condition variab les
int pthread_cond_destroy ( pthread_cond_t cond ); 
int pthread _cond_init(pthread_cond_t cond, const pthread_condattr_t attr ); 	  
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 
	pthread_cond_init() initializ ed the condition v ariable. If attr is NULL, 
default attr ibutes are sed. 
	pthread_cond_destro y() will destro y (uninitializ e) the condition
variable.
	destro ying a condition v ariable upon which other threads 
are currently b locked results in undened beha vior. 
macro PTHREAD_COND_INITIALIZER can be used to initializ e condition  
variables. No error chec ks are perf ormed.
Both function retur n 0 on success and non-z ero otherwise .
  
21</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Example
int main () 
{ 
pthread_t cons_thread , prod_thread ; 
pthread_create(&amp;prod_thread ,NULL,produce ,NULL); 
pthread_create(&amp;cons_thread ,NULL,consume,NULL); 
pthread _join(cons_thread ,NULL); 
pthread _join(prod_thread ,NULL); 
return 0; 
} 
Output: 
produced (3077516144):1 
consumed(3069123440):1 
produced (3077516144):2 
consumed(3069123440):2 
produced (3077516144):3 
consumed(3069123440):3 
produced (3077516144):4 
consumed(3069123440):4 
produced (3077516144):5 
consumed(3069123440):5 
produced (3077516144):6 
consumed(3069123440):6 
produced (3077516144):7 
consumed(3069123440):7 
25</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Multithreaded concurrenc y
Serial execution: 
	All our prog rams so f ar has had a single thread of
execution: main thread.
 Prog ram e xits when the main thread e xits. 
Multithreaded: 
	Prog ram is organiz ed as m ultiple and concurrent threads 
of execution. 
	The main thread spa wns multiple threads . 
	The thread ma y comm unicate with one another . 
	Advantages: 
	Impro ves perf ormance 
	Impro ves responsiv eness 
	Impro ves utilization 
	less o verhead compared to m ultiple processes 
6</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Garba ge collection
 C does not ha ve any garbage collectors 
 Implementations a vailab le 
 Types: 
 Mark and s weep garbage collector (depth rst search) 
 Chene ys algor ithm (breadth rst search) 
 Copying garbage collector 
3</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: malloc()
	Mapping memor y: mmap(), munmap(). Useful f or 
demand paging. 
	Resizing heap: sbrk() 
	Designing malloc() 
	implicit link ed list,e xplicit link ed list 
 best t,rst t,ne xt t
Prob lems:
  
	fragmentation 
	memor y leaks 
	valgrind tool=memchec k, chec ks for memor y leaks . 
2</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Condition variab les
int pthread_cond_w ait(pthread_cond_t cond,pthread_m utex_t mutex); 
blocks on a condition v ariable.  
	must be called with the m utex already loc ked otherwise 
beha vior undened. 
	automatically releases m utex 
	upon successful retur n, the m utex will be automatically 
locked again. 
int pthread_cond_broadcast(pthread_cond_t cond); 
int pthread_cond_signal(pthread_cond_t cond); 
	unblocks threads w aiting on a condition v ariable. 
	pthread_cond_broadcast() unloc ks all threads that are w aiting. 
	pthread_cond_signal() unloc ks one of the threads that are w aiting. 
	both retur n 0 on success , non z ero otherwise . 
23</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Multithreaded programming
Even in C , multithread prog ramming ma y be accomplished in 
several ways 
 Pthreads: POSIX C libr ary. 
 OpenMP 
 Intel threading b uilding b locks 
 Cilk (from CSAIL!) 
 Grand centr al despatch 
 CUD A (GPU) 
 OpenCL (GPU/CPU) 
7</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Not all code can be made parallel
f l o a t params [ 1 0 ] ; 
f o r ( i n t i =0; i &lt;10; i ++) 
do_something ( params [ i ] ) ; f l o a t params [ 1 0 ] ; 
f l o a t prev =0; 
fo r ( i n t i =0; i &lt;10; i ++) 
{ 
prev=complicated ( params [ i ] , prev ) ; 
} 
paralleizab le not par allelizab le 
8</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 12  January 27, 2010
Review 
Multithreaded prog ramming 
Concepts 
Pthread 
API 
Mute x 
Condition v ariables 
4</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Example
#include &lt;pthread .h&gt;
pthread_cond_t cond_recv=PTHREAD_COND_INITIALIZER;
pthread_cond_t cond_send=PTHREAD_COND_INITIALIZER;
pthread_mutex_t cond_mutex=PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t count_mutex=PTHREAD_MUTEX_INITIALIZER;
int full =0;
int count =0;
void produce ( void ) void consume ( void ) 
{ {
while (1) while (1)
{ {
pthread_mutex_lock(&amp;cond_mutex); pthread_mutex_lock(&amp;cond_mutex); 
while ( full ) while (! full) 
{ { 
pthread_cond_wait(&amp;cond_recv, pthread_cond_wait(&amp;cond_send, 
&amp;cond_mutex ) ; &amp;cond_mutex ) ; 
} } 
pthread_mutex_unlock(&amp;cond_mutex); pthread_mutex_unlock(&amp;cond_mutex); 
pthread_mutex_lock(&amp;count_mutex); pthread_mutex_lock(&amp;count_mutex); 
count++;full=1; full=0; 
printf("produced(%d):%d\n", printf(" consumed(%ld):%d\n ", 
pthread_self(),count); pthread _self(),count); 
pthread_cond_broadcast(&amp;cond_send); pthread_cond_broadcast(&amp;cond_recv); 
pthread_mutex_unlock(&amp;count_mutex); pthread_mutex_unlock(&amp;count_mutex); 
if ( count &gt;=10) break ; if ( count &gt;=10)break ; 
} } 
24</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>6.087 Lecture 12  January 27, 2010
Review 
Multithreaded prog ramming 
Concepts 
Pthread 
API 
Mute x 
Condition v ariables 
2</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Condition variab les
int pthread_cond_destroy ( pthread_cond_t cond ); 
int pthread _cond_init(pthread_cond_t cond, const pthread_condattr_t attr ); 	  
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; 
	pthread_cond_init() initializ ed the condition v ariable. If attr is NULL, 
default attr ibutes are sed. 
	pthread_cond_destro y() will destro y (uninitializ e) the condition
variable.
	destro ying a condition v ariable upon which other threads 
are currently b locked results in undened beha vior. 
macro PTHREAD_COND_INITIALIZER can be used to initializ e condition  
variables. No error chec ks are perf ormed.
Both function retur n 0 on success and non-z ero otherwise .
  
22</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Example
#include &lt;pthread . h&gt; 
#include &lt; s t d i o . h&gt; 
#define NUM_THREADS 5 
void  P r i n t H e l l o ( void threadid ) 
{ 
long t i d ; 
t i d = ( long ) threadid ; 
p r i n t f ( " Hello World ! I t  s me, thread #%l d ! \ n " , t i d ) ; 
pthread _exit (NULL ) ; 
} 
i n t main ( i n t argc , char argv [ ] ) 
{ 
pthread_t threads [NUM_THREADS] ; 
i n t rc ; 
long t ; 
for ( t =0; t &lt;NUM_THREADS; t ++){ 
p r i n t f ( " In main : c reating thread %l d \ n " , t ) ;
rc = pthread_create (&amp; threads [ t ] , NULL, P ri n t H e ll o , ( void ) t ) ;
i f ( rc ) {
p r i n t f ( "ERROR; r e t u r n code from pthread_create ( ) i s %d \ n " , rc ) ; 
e x i t ( 1); 
}
}
pthread _exit (NULL ) ;
} 
code: https://computing.llnl.gov/tutorials/pthreads/ 
 Lawrence Livermore National Laboratory. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Example revisited
int balance =500; 
void deposit ( int sum ) { 
int currbalance=balance ; / read balance / 
... 
currbalance+=sum ; 
balance=currbalance ; / write balance / 
} 
void withdraw ( int sum ) { 
int currbalance=balance ; / read balance / 
if ( currbalance &gt;0) 
currbalance=sum ; 
balance=currbalance ; / write balance / 
} 
.. 
deposit (100); / thread 1/ 
.. 
withdraw (50);/ thread 2/ 
.. 
withdraw (100); / thread 3/ 
... 
 Scenar io: T1(read),T2(read,wr ite),T1(wr ite),balance=600 
 Scenar io: T2(read),T1(read,wr ite),T2(wr ite),balance=450 
18</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Process vs. Threads
	Process: An instance of a prog ram that is being e xecuted 
in its o wn address space . In POSIX systems , each 
process maintains its o wn heap , stac k, registers , le 
descr iptors etc. 
Comm unication: 
	Shared memor y
Netw ork
  
	Pipes , Queues 
	Thread: A light w eight process that shares its address 
space with others .In POSIX systems , each thread 
maintains the bare essentials: registers , stac k, signals . 
Comm unication: 
	shared address space . 
5</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Pthread
API: 
 Thread management: creating, joining, attr ibutes 
pthread_ 
 Mute xes: create , destro y mutexes 
pthread_m utex_ 
 Condition v ariables: create ,destro y,wait,signal 
pthread_cond_ 
 Synchronization: read/wr ite loc ks and barr iers 
pthread_rwloc k_, pthread_barr ier_ 
API: 
 #include &lt;pthread.h&gt; 
 gcc Wall O0 o &lt;output&gt; le.c pthread (no l prex) 
10</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Summar y
	Parallel prog ramming concepts 
	Multithreaded prog ramming 
Pthreads 
	Syncrhonization 
Mute x  
Condition v ariables  
26</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare 
http://ocw.mit.edu 
6.087  Practical Programming in C 
January (IAP) 2010 
 
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Control flow. Functions and modular programming. Variable scope. Static and global variables.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec03/</lecture_pdf_url>
      <lectureno>3</lectureno>
      <slides>
        <slide>
          <slideno>50</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Divide and conquer
	Break do wn prob lem into simpler sub-prob lems 
Consider iter ation and recursion  
 How can w e implement gcd(a,b) recursiv ely? 
Minimiz e transfer of state betw een functions  
	Writing pseudocode rst can help 
30</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
4</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Divide and conquer
	Conceptualiz e how a prog ram can be brok en into smaller 
parts 
	Lets design a prog ram to solv e linear Diophantine 
equation (ax + by = c,x, y: integers): 
get a, b, c from command line
compute g = gcd(a,b)
if (c is not a multiple of the gcd)
no solutions exist; exit
run Extended Euclidean algorithm on a, b
rescale x and y output by (c/g)
print solution 
	Extended Euclidean algor ithm: nds integers x, y s.t. 
ax + by = gcd(a, b). 
26</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Extended Euc lidean algorithm
Pseudocode f or Extended Euclidean algor ithm: 
Initialize state variables (x,y) 
if (a&lt;b) 
swap(a,b) 
while (b&gt;0){ 
compute quotient, remainder 
update state variables (x,y) 
} 
return gcd and state variables (x,y) 
[Menez es, A. J., et al. Handbook of Applied Cryptog raphy. CRC Press , 1996.] 
28  CRC Press. All rights reserved. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Using the Euc lid module
 Want to be ab le to call gcd() or ext_euclid() from the 
main le diophant.c
Need to include the header le euclid.h:
 
#include "euclid.h" (le in ., not search path) 
 Then, can call as an y other function: 
/  compute g = gcd(a,b)  / 
g = gcd(a,b); 
/  compute x and y using Extended Euclidean alg .  / 
g = ext _euclid(a,b); 
 Results in global v ariables x and y 
/  rescale so ax+by = c  / 
grow = c/g; 
x = grow ; 
y = grow ; 
36</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
31</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Returning m ultiple v alues
	Extended Euclidean algor ithm retur ns gcd, and tw o other 
state v ariables, x and y 
	Functions only retur n (up to) one v alue 
	Solution: use global variables 
	Declare v ariables for other outputs outside the function 
	variables declared outside of a function b lock are globals 
	persist throughout lif e of prog ram 
	can be accessed/modied in an y function 
29</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Programming modules in C
	C prog rams do not need to be monolithic 
	Module: interf ace and implementation 
interf ace: header les  
	implementation: auxilliar y source/object les 
	Same concept carr ies o ver to e xternal libr aries (ne xt 
week. . . ) 
31</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>The if statement
if (x% 2) 
y += x/2; 
Evaluate condition  
if	(x %2==0) 
	If true, evaluate inner statement 
y += x/2; 
	Otherwise , do nothing 
9</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>The extern keyword
	Need to inf orm other source les about functions/global 
variables in euclid.c 
	For functions: put function prototypes in a header le 
	For variables: re-declare the global v ariable using the 
extern keyword in header le 
	extern informs compiler that v ariable dened some where 
else 
	Enab les access/modifying of global v ariable from other 
source les 
34</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>The while loop
while (/  condition  /) 
/  loop body  / 
	Simplest loop str ucture  e valuate body as long as
condition is tr ue
	Condition e valuated rst, so body ma y never be e xecuted 
18</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Bloc ks
	Block can substitute f or simple statement 
	Compiled as a single unit 
Variables can be declared inside  
{
int temp = x+y;
z = foo(temp);
} 
	Block can be empty {} 
No semicolon at end  
5</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Nested b locks
Blocks nested inside each other  
{
int temp = x+y;
z = foo(temp);
{
float temp2 = xy;
z += bar(temp2);
}
}
6</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Multiple cases
	Compares v ariable to each case in order 
	When match f ound, star ts executing inner code until 
break; reached 
	Execution f alls through if break; not included 
switch (ch) { 
switch (ch) { case Y : 
case Y : /  do something i f 
case y : ch == Y  / 
/ 	do something i f case N : 
ch == Y or /  do something i f 
ch == y  / ch == Y or 
break ; ch == N  / 
} break ; 
} 
15</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Register v ariab les
	During e xecution, data processed in registers 
	Explicitly store commonly used data in registers  minimiz e 
load/store o verhead 
	Can e xplicitly declare cer tain v ariables as registers using 
register keyword 
 must be a simple type (implementation-dependent) 
 only local v ariables and function arguments eligib le 
	excess/unallo wed register declar ations ignored, compiled 
as regular v ariables 
	Registers do not reside in addressed memor y; pointer of a 
register v ariable illegal 
42</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
25</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>The break keyword
	Sometimes w ant to ter minate a loop ear ly 
	break; exits inner most loop or switch statement to e xit 
early 
	Consider the modication of the do-while example: 
char c;
do {
/  loop body  / 
puts ( "Keep going? (y/n) " );
c = getchar ( ) ;
if (c != y )
break ; 
/  other processing  /
} while (/  other conditions  / );
23</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>The for loop
int factorial ( int n) { 
int i, j=1; 
for (i =1; i&lt;= n; i++) 
j = i; 
return j; 
} 
 The counting loop 
 Inside parentheses , three e xpressions , separ ated b y 
semicolons:
Initialization: i=1
  
Condition: i &lt;= n  
Increment: i++  
 Expressions can be empty (cond ition assumed to be true) 
19</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Variab le scope
	scope  the region in which a v ariable is v alid 
	Many cases , corresponds to b lock with v ariables 
declar ation 
	Variables declared outside of a function ha ve global scope 
	Function denitions also ha ve scope 
38</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: Operator s
	Unar y, binar y, ternary (1-3 arguments) 
	Arithmetic oper ators , relational oper ators , binar y (bitwise 
and logical) oper ators , assignment oper ators , etc. 
	Conditional e xpressions 
	Order of e valuation (precedence , direction) 
3</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
38</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>An e xample
What is the scope of each v ariable in this e xample? 
int nmax = 20; 
/  The main() function  /
int main ( int argc , char argv) /  entry point  /
  
{ 
int a=0, b=1, c, n; 
printf ( "%3d: %d\n" ,1 ,a ); 
printf ( "%3d: %d\n" ,2 ,b ); 
for (n =3; n&lt;= nmax; n++) { 
c=a+b; a=b; b=c; 
printf ( "%3d: %d\n" ,n, c ); 
} 
return 0; /  success  / 
} 
39</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Static v ariab les
	static keyword has tw o meanings , depending on where 
the static v ariable is declared 
	Outside a function, static variables/functions only visib le 
within that le , not globally (cannot be externed) 
	Inside a function, static variables:
are still local to that function
 
	are initializ ed only dur ing prog ram initialization 
	do not get reinitializ ed with each function call 
static int somePersistentVar = 0; 
41</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Scope and nested dec larations
How man y lines are pr inted no w? 
int nmax = 20; 
/  The main() function  /
int main ( int argc , char argv) /  entry point  /
  
{ 
int a=0, b=1, c, n, nmax =25; 
printf ( "%3d: %d\n" ,1 ,a ); 
printf ( "%3d: %d\n" ,2 ,b ); 
for (n =3; n&lt;= nmax; n++) { 
c=a+b; a=b; b=c; 
printf ( "%3d: %d\n" ,n, c );
}
return 0; /  success  /
} 
40</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Nesting if statements
To associate else with outer if statement: use br aces 
if (x%4 == 0) { 
if (x%2 == 0) 
y= 2; 
} else 
y= 1; 
13</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Bloc ks and compound statements
	A simple statement ends in a semicolon: 
z = foo(x+y); 
	Consider the m ultiple statements: 
temp = x+y;
z = foo(temp);
	Curly braces  combine into compound statement/b lock 
4</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: Denitions
	Variable -name/ref erence to a stored v alue (usually in 
memor y) 
	Data type - deter mines the siz e of a v ariable in memor y, 
what v alues it can tak e on, what oper ations are allo wed 
	Oper ator - an oper ation perf ormed using 1-3 v ariables 
	Expression - combination of liter al values/v ariables and 
operators/functions 
1</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>The header: euclid.h
Header contains prototypes f or gcd() and ext_euclid(): 
/  ensure included only once  / 
#ifndef __EUCLID_H__ 
#define __EUCLID_H__ 
/  global variables (declared in euclid.c)  / 
extern int x, y; 
/  compute gcd  / 
int gcd ( int a, int b); 
/  compute g = gcd(a,b) and solve ax+by=g  / 
int ext _euclid ( int a, int b); 
#endif 
35</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Nesting if statements
if (x%4 == 0) 
if (x%2 == 0) 
y= 2; 
else 
y= 1; 
To which if statement does the else keyword belong? 
12</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>The do-while loop
char c; 
do { 
/  loop body  / 
puts ( "Keep going? (y/n) " );
c = getchar ( ) ;
/  other processing  / 
} while (c == y &amp;&amp; /  other conditions  / ); 
	Differs from while loop  condition e valuated after each 
iteration 
	Body e xecuted at least once
Note semicolon at end
 
22</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Computing the gcd
	Compute the gcd using the Euclidean algor ithm: 
int gcd ( int a, int b) { 
while (b) { /  if a &lt; b, performs swap  / 
int temp = b; 
b = a%b; 
a = temp ; 
}
return a;
}
	Algor ithm relies on gcd(a, b) = gcd(b, a mod b), for natur al 
numbers a &gt;b. 
[Knuth, D. E. The Art of Computer Programming, Volume 1: Fundamental 
Algorithms. 3rd ed. Addison-Wesley, 1997.] 
27  Addison Wesley. All rights reserved. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/fairuse.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>The for loop
Equiv alent to while loop: 
int factorial ( int n) { 
int j =1; 
int i=1; /  initialization  / 
while (i &lt;= n/  condition  /) { 
j = i; 
i ++; /  increment  /
}
return j;
} 
20</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>The Euc lid module
 Euclid s algor ithms useful in man y conte xts 
 Would lik e to include functionality in man y prog rams 
 Solution: make a module f or Euclid s algor ithms 
 Need to wr ite header le (.h) and source le (.c) 
32</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Compiling with the Euc lid module
	Just compiling diophant.c is insufcient 
	The functions gcd() and ext_euclid() are dened in 
euclid.c; this source le needs to be compiled, too 
	When compiling the source les , the outputs need to be 
linked together into a single output 
	One call to gcc can accomplish all this: 
athena% gcc -g -O0 -Wall diophant.c 
euclid.c -o diophant.o 
	diophant.o can be r un as usual 
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
37 1 1</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Data types
 Various siz es (char, shor t, long, oat, doub le) 
 Numer ic types - signed /unsigned 
 Implementation - little or big endian 
 Careful mixing and con verting (casting) types 
2</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
1</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>The switch statement
Contents of switch statement a b lock  
 Case labels: different entr y points into b lock 
 Similar to labels used with goto keyword (ne xt lecture. . . ) 
16</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>The switch statement
Alternativ e conditional statement  
 Integer (or char acter) v ariable as input 
Considers cases f or value of v ariable  
switch (ch) {
case Y :/  ch == Y  /
/  do something  /
break ; 
case N :/  ch == N  / 
/  do something else  / 
break ;
default :/  otherwise  /
/  do a third thing  /
break ;
}
14</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Summar y
Topics co vered: 
	Controlling prog ram o w using conditional statements and 
loops 
	Dividing a comple x prog ram into man y simpler 
sub-prog rams using functions and modular prog ramming 
techniques 
	Variable scope r ules and extern, static, and
register variables
44</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Loop statements
 The while loop 
 The for loop 
 The do-while loop 
 The break and continue keywords 
17</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>6.087 Lecture 3  Jan uary 13, 2010
Review 
Blocks and Compound Statements 
Control Flo w 
Conditional Statements 
Loops 
Functions 
Modular Prog ramming 
Variable Scope 
Static V ariables 
Register V ariables 
7</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Conditional statements
The if statement 
The switch statement 
8</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>The for loop
	Compound e xpressions separ ated b y commas 
int factorial ( int n) { 
int i, j; 
for (i =1, j=1; i&lt;= n; j = i , i++) 
;
return j;
}
	Comma: operator with lo west precedence , evaluated 
left-to-r ight; not same as betw een function arguments 
21</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>The else keyword
if (x%2 == 0) 
y += x/2; 
else 
y	+= (x+1)/2; 
	Optional 
Execute statement if condition is f alse  
y += (x+1)/2; 
 Either inner statement ma y be b lock 
10</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Contr ol conditions
 Unlik e C++ or J ava, no boolean type (in C89/C90) 
 in C99, bool type a vailab le (use stdbool.h) 
 Condition is an e xpression (or ser ies of e xpressions) 
e.g. n&lt;3 orx&lt;y || z&lt;y 
Expression is non-z ero condition tr ue   
 Expression m ust be n umer ic (or a pointer) 
const char str[] = "some text" ;
if (str) /  string is not null  /
return 0;
7</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>The sour ce: euclid.c
Implement gcd() in euclid.c: 
/  The gcd() function  / 
int gcd ( int a, int b) { 
while (b) { /  if a &lt; b, performs swap  / 
int temp = b; 
b = a%b; 
a = temp ; 
} 
return a; 
} 
Extended Euclidean algor ithm implemented as 
ext_euclid(), also in euclid.c 
33</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Functions
	Already seen some functions , including main(): 
int main ( void ){ 
/ 	do stuff  / 
return 0; /  success  / 
} 
	Basic syntax of functions e xplained in Lecture 1 
	How to wr ite a prog ram using functions? 
25</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Example
Variable scope e xample , revisited, with register variables: 
/  The main() function  / 
int main ( register int argc , register char argv )  
{ 
register int a=0, b=1, c, n, nmax =20; 
printf ( "%3d: %d\n" ,1 ,a ); 
printf ( "%3d: %d\n" ,2 ,b ); 
for (n =3; n&lt;= nmax; n++) { 
c=a+b; a=b; b=c; 
printf ( "%3d: %d\n" ,n, c );
}
return 0; /  success  /
} 
43</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>The else if keyword
if (x%2 == 0) 
y += x/2; 
else if (x%4 == 1) 
y+= 2 ((x+3)/4); 
else 
y	+= (x+1)/2; 
	Additional alter nativ e control paths 
	Conditions e valuated in order until one is met; inner 
statement then e xecuted 
	If multiple conditions tr ue, only rst e xecuted 
	Equiv alent to nested if statements 
11</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>The continue keyword
	Use to skip an iter ation 
	contin ue; skips rest of inner most loop body , jumping to loop 
condition 
	Example: 
#define min(a,b) ((a) &lt; (b) ? (a) : (b)) 
int gcd ( int a, int b) {
int i , ret = 1, minval = min(a,b);
for (i = 2; i &lt;= minval; i++) {
if (a%i) /  i not divisor of a  / 
continue ; 
if (b%i == 0) /  i is divisor of both a and b  / 
ret = i;
}
return ret ;
} 
24</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Linux inter process communication.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec14/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides>
        <slide>
          <slideno>1</slideno>
          <text>6.087 Lecture 14  January 29, 2010
Review 
Inter process comm unication 
Signals 
Fork 
Pipes 
FIFO 
Spotlights 
2</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&lt;signals.h&gt;
	Unix/Lin ux allo ws us to handle e xceptions that ar ise dur ing 
execution (e .g., interr upt, oating point error , segmentation 
fault etc.). 
	A process recie ves a signal when such a condition occurs . 
void (signal (int sig,void(handler)(int )))( int ) 
	deter mines ho w subsequent signals will be handled. 
	pre-dened beha vior: SIG_DFL (default), SIG_IGN (ignore) 
	returns the pre vious handler . 
5</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Example
#include &lt;stdio .h&gt; 
void sigproc () 
{ signal(SIGINT, sigproc); // 
printf("you have pressed ctrl c \n " ); 
} 
void quitproc ()
{ printf("ctrl \\ pressed to quit " );
exit (0); / normal exit status / 
} 
main () 
{ 
signal(SIGINT, sigproc);
signal (SIGQUIT, quitproc );
printf (   ctrl c disabled use ctrl \\ to quitn);
for (;;); / infinite loop /
} 
8</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>6.087 Lecture 14  January 29, 2010
Review 
Inter process comm unication 
Signals 
Fork 
Pipes 
FIFO 
Spotlights 
16</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&lt;signal.h&gt;
int raise( int sig) can be used to send signal sig to the prog ram. 
Notes: 
There can be r ace conditions .  
	signal handler itself can be interr upted.
use of non-reentr ant functions unsaf e.
  
	sigprocmask can be used to pre vent interr uptions .
handler is reset each time it is called.
  
7</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Project spotlights
	Face nding with openCV 
Barcode scanner  
	ImageIC 
	Image2DXF 
	Library database 
	Simple A udio Visualiz er 
Non-linear oscillator  
NoteDelux e  
CUD A  
Visual mouse  
	Wallpaper do wnloader 
16</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Example
#include &lt;stdlib .h&gt; 
#include &lt;stdio .h&gt; 
int	main() { 
/some code / 
pid _t pid=fork (); 
int	i;
if (pid) {
for ( i =0;i &lt;5; i ++){
sleep (2); 
printf("parent process:%d\n ",i); 
} 
} 
else { 
for ( i =0;i &lt;5; i ++){ 
sleep (1); 
printf("child process:%d\n ",i); 
} 
}/ end child / 
}/ end main / 
parent process :0 
child process:1 
child process:2 
parent process :1 
child process:3 
child process:4 
parent process :2 
parent process :3 
parent process :4 
10</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Pipes
Pipes are used in unix to redirect output of one command to 
another . Pipes also allo w parent processes to comm unicate 
with its children. Examples 
	ls | more -displa ys results of ls one screen at a time 
	cat file.txt | sort -displa ys contents of le .txt in 
sorted order 
int pipe(int FILEDES[2]) 
	A pipe can be thought of as a pair of le descr iptors 
 no ph ysical le is associated with the le descr iptor
 one end is opened in wr ite mode .
 other end is opened in read mode .
12</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Example
/ source: http://beej.us/guide /
#include &lt;stdio .h&gt;
#include &lt;stdlib .h&gt;
#include &lt;errno .h&gt;
#include &lt;sys / types .h&gt;
#include &lt;unistd .h&gt; / ipc /
int main ( void ) 
{ 
int pfds [2]; 
char buf [30]; 
pipe(pfds ); 
if (! fork ()) { 
printf(" CHILD : writing to the pipe\n ");
write(pfds[1], "test", 5);
printf(" CHILD : exiting\n");
exit (0);
} else { 
printf("PARENT: reading from pipe\n"); 
read(pfds[0], buf, 5); 
printf("PARENT: read \"%s\"\n ", buf); 
wait (NULL); 
} 
return 0; 
} 
13</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Fork
pid_t fork(void) 
	fork() is a system call to create a ne w process 
	In the child process , it retur ns 0 
	In the parent process , it retur ns the PID (process id) of the 
child. 
	The child PID can be used to send signals to the child 
process . 
	returns -1 on f ailure (in valid PID) 
9</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Example
/ source: http://beej.us/guide / 
#include &lt;stdio .h&gt; 
#include &lt;stdlib .h&gt; 
#include &lt;string .h&gt; 
#include &lt;sys/ stat .h&gt; 
#include &lt;unistd .h&gt; 
#define FIFO_NAME "fifo" 
int main ( void ){ 
char s[300]; 
int num, fd ; 
mkno d(FIFO_NAME, S_IFIFO | 0666, 0); 
printf("waiting for readers...\n "); 
fd = open(FIFO_NAME, O_WRONLY); 
printf("got a reader\n "); 
while (gets(s), !feof(stdin)) {
num = write(fd, s, strlen(s));
if (num == 1)
perror(" write " );
else 
printf("wrote %d bytes\n", num); 
} 
return 0; 
} #include &lt;stdio .h&gt; 
#include &lt;stdlib .h&gt; 
#include &lt;errno .h&gt; 
#include &lt;string .h&gt; 
#include &lt;fcntl .h&gt; 
#include &lt;sys / types .h&gt; 
#include &lt;sys/ stat .h&gt; 
#include &lt;unistd .h&gt; 
#define FIFO_NAME "fifo" 
int main ( void ){ 
char s[300]; 
int num, fd ; 
mkno d(FIFO_NAME, S_IFIFO | 0666, 0); 
printf("waiting for writers ...\n "); 
fd = open(FIFO_NAME, O_RDONLY); 
printf("got a writer\n "); 
do { 
num = read(fd, s, 300); 
if (num == 1) 
perror("read" ); 
else { 
s[num] = \0; 
printf("read %d bytes:\"%s\"\n", 
num, s); 
} 
} while (num &gt; 0); 
return 0; 
} 
15</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>FIFO
 FIFO queues ma y be thought of as named pipes . 
 Multiple processes can read and wr ite from a FIFO . 
 Unlik e pipes , the processes can be unrelated. 
 FIFOs can be created using mknod system call. 
int mknod (const char path,mode_t mode,de v_t de v) 
 &lt;sys/ stat.h&gt; contains the declar ation f or mknod. 
 mknod used to create special les - devices ,fos etc. 
 mode can ha ve special bits such as S_IFIFO | 0644 
 dev is inter preted based on the mode . 
Example: mknod("m yfo", S_IFIFO | 0644 , 0); 
14</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&lt;signal.h&gt;
Valid signals:
SIGABR T abnor mal ter mination 
SIGFPE oating point error 
SIGILL illegal instr uction 
SIGINT interr upt 
SIGSEGV segmentation f ault 
SIGTERM termination request 
SIGB US bus error 
SIGQ UIT quit 
The tw o signals SIGST OP,SIGKILL cannot be handled. 
6</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Outline
Review 
Inter process comm unication 
Signals 
Fork 
Pipes 
FIFO 
Spotlights 
1</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare 
http://ocw.mit.edu 
6.087  Practical Programming in C 
January (IAP) 2010 
 
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 14  January 29, 2010
Review 
Inter process comm unication 
Signals 
Fork 
Pipes 
FIFO 
Spotlights 
4</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Sockets
 &lt;sys/soc ket.h&gt; 
 enab les client-ser ver computing 
 Client: connect() 
 Server: bind(),listen(),accept() 
 I/O: write(),send(),read(),recv() 
3</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Preliminaries
	Each process has its o wn address space . Theref ore, 
individual processes cannot comm unicate unlik e threads . 
	Interprocess comm unication: Linux/Unix pro vides se veral 
ways to allo w comm unications 
	signal 
	pipes 
	FIFO queues 
	shared memor y 
	semaphores 
sockets  
4</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: multithreading
Race conditions  
non-deter minism in thread order .  
	can be pre vented b y synchronization 
	atomic oper ations necessar y for synchronization 
	Mute x: Allows a single thread to o wn it 
	Semaphores: Gener alization of m utex, allo ws N threads to 
acquire it at a time . 
	P(s) : acquires a loc k 
	V(s) : releases loc k 
	sem_init(),sem_destroy() 
	sem_wait(),sem_trywait(),sem_post() 
	Other prob lems: deadloc k, star vation 
2</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Fork
 fork() makes a full cop y of the parents address space . 
 pid_t getpid () returns PID of the current process . 
 pid_t getppid () returns PID of the parent process . 
 wait(int) is used to w ait for the child to nish. 
 waitpid () is used to w ait for a specic child. 
Zombies: 
 the child process can e xit bef ore the parent 
 stray process is mar ked as &lt;defunct&gt; 
 preap can be used to reap z ombie processes . 
11</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Introduction. Writing, compiling, and debugging C programs. Hello world.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec01/</lecture_pdf_url>
      <lectureno>1</lectureno>
      <slides>
        <slide>
          <slideno>20</slideno>
          <text>The #include macro
	Header les: constants, functions, other declarations 
#include &lt;stdio.h&gt;  read the contents of the header le  
stdio.h 
 stdio.h: standard I/O functions for console, les 
/  h e l l o . c  our f i r s t C program 
Created by Daniel Weller , 01/11/2010  / 
#include &lt; s t d i o . h&gt; /  basic I /O f a c i l i t i e s  / 
18</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>3. Evaluate addition
oat z = x+3.0;oat z = 5.0;
4. Perform initialization with assignment
Now, z= 5.0.
How do I insert parentheses to get z= 4.0?
oat z = (x+3x)/(y4);
Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
2. Evaluate multiplies and divides, from left-to-right 
oat z = x+3x/2.0; oat z = x+6.0/2.0; oat z = x+3.0;   
24</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
2. Evaluate multiplies and divides, from left-to-right 
oat z = x+3x/2.0; oat z = x+6.0/2.0; oat z = x+3.0;   
3. Evaluate addition
oat z = x+3.0; oat z = 5.0;
 
4. Perform initialization with assignment
Now, 
z = 5.0.
How do I insert parentheses to get z = 4.0? 
oat z = (x+3x)/(y4); 
24</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>oat z = (x+3x)/(y4);
Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
2. Evaluate multiplies and divides, from left-to-right 
oat z = x+3x/2.0; oat z = x+6.0/2.0; oat z = x+3.0;   
3. Evaluate addition
oat z = x+3.0; oat z = 5.0;
 
4. Perform initialization with assignment
Now, 
z = 5.0.
How do I insert parentheses to get z = 4.0? 
24</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>What is C used for?
Systems programming: 
	OSes, like Linux 
	microcontrollers: automobiles and airplanes 
	embedded processors: phones, portable electronics, etc. 
	DSP processors: digital audio and TV systems
. . .
 
4</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Features of C
C features: 
 Few keywords 
 Structures, unions  compound data types 
 Pointers  memory, arrays 
 External standard library  I/O, other facilities 
 Compiles to native code 
 Macro preprocessor 
2</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Versions of C
Evolved over the years: 
1972  C invented  
	1978  The C Programming Language published; rst 
specication of language 
	1989  C89 standard (known as ANSI C or Standard C) 
	1990  ANSI C adopted by ISO, known as C90
1999  C99 standard
 
	mostly backward-compatible 
 not completely implemented in many compilers 
2007  work on new C standard C1X announced  
In this course: ANSI/ISO C (C89/C90) 
3</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Dening expression macros
	#dene can take arguments and be treated like a function 
#dene add3(x,y,z) ((x)+(y)+(z)) 
	parentheses ensure order of operations 
	compiler performs inline replacement; not suitable for 
recursion 
34</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Alternative main() function
	Alternatively, store the string in a variable rst: 
i n t main ( void )/  entry p o in t  /
{
const char msg [ ] = "hello,
 6.087 students" ;
/  w r i t e message to console  / 
puts (msg ) ; 
	const keyword: qualies variable as constant 
	char: data type representing a single character; written in 
quotes: a, 3, n 
	const char msg[]: a constant array of characters 
30</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Editing C code
.c extension  
 Editable directly 
More later. . .  
7</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Warning: low-level language!
Inherently unsafe: 
	No range checking 
	Limited type safety at compile time 
	No type checking at runtime 
Handle with care. 
	Always run in a debugger like gdb (more later. . . ) 
Never run as root 
Never test code on the Athena servers  
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
6 11</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Function prototypes
Functions also must be declared before use  
	Declaration called function prototype 
	Function prototypes: 
int factorial ( int ); or int factorial ( int n); 
	Prototypes for many common functions in header les for 
C Standard Library 
25</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Comments
	Comments: / this is a simple comment / 
	Can span multiple lines 
/ 	This comment
spans
m u l t i p l e l i n e s  /
	Completely ignored by compiler 
	Can appear almost anywhere 
/ 	h e l l o . c  our f i r s t C program 
Created by Daniel Weller , 01/11/2010  / 
17</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 1  January 11, 2010
Introduction to C 
Writing C Programs 
Our First C Program 
1</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>More about header les
	stdio.h  part of the C Standard Library 
	other important header les: ctype.h, math.h, 
stdlib.h, string.h, time.h 
	For the ugly details: visit http: 
//www.unix.org/single_unix_specification/ 
(registration required) 
	Included les must be on include path 
	-Idirectory with gcc: specify additional include 
directories 
	standard include directories assumed by default 
	#include "stdio.h"  searches ./ for stdio.h rst 
19</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>6.087 Lecture 1  January 11, 2010
Introduction to C 
Writing C Programs 
Our First C Program 
15</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Function prototypes
General form:  
return_type function_name(arg1,arg2,...); 
	Arguments: local variables, values passed from caller 
	Return value: single value returned to caller when function 
exits 
	void  signies no return value/arguments 
int rand(void); 
26</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>More about strings
	Strings stored as character array 
	Null-terminated (last character in array is \0 null) 
	Not written explicitly in string literals 
	Special characters specied using \ (escape character): 
	\\  backslash, \  apostrophe, \  quotation mark 
	\b, \t, \r, \n  backspace, tab, carriage return, linefeed 
	\ooo, \xhh  octal and hexadecimal ASCII character 
codes, 
e.g. \x41  A, \060  0 
31</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Compiling our code
After we save our code, we run gcc: 
athena% gcc -g -O0 -Wall hello.c -o 
hello.o 
Assuming that we have made no errors, our compiling is 
complete. 
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
37 1
1</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>The IDE  all-in-one solution
	Popular IDEs: Eclipse (CDT), Microsoft Visual C++ 
(Express Edition), KDevelop, Xcode, . . . 
	Integrated editor with compiler, debugger 
	Very convenient for larger programs 
Courtesy of The Eclipse Foundation. Used with permission. 
13</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>More about gcc
 Run gcc: 
athena% gcc -Wall infilename.c -o 
outfilename.o 
 -Wall enables most compiler warnings 
 More complicated forms exist 
 multiple source les 
 auxiliary directories
 optimization, linking
 Embed debugging info and disable optimization: 
athena% gcc -g -O0 -Wall infilename.c -o 
outfilename.o 
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
9 11</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Order of operations
 Order of operations: 
Operator Evaluation direction 
+,-(sign) right-to-left 
*,/,%
 left-to-right 
+,- left-to-right 
=,+=,-=, *=,/=,%= right-to-left 
 Use parentheses to override order of evaluation 
23</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>2. Evaluate multiplies and divides, from left-to-right
oat z = x+3x/2.0;oat z = x+6.0/2.0;oat z = x+3.0;
3. Evaluate addition
oat z = x+3.0;oat z = 5.0;
4. Perform initialization with assignment
Now, z= 5.0.
How do I insert parentheses to get z= 4.0?
oat z = (x+3x)/(y4);
Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
24</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Our main() function
/  The main ( ) f u n c t i o n  / 
i n t main ( void )/  entry p oi n t  / 
{ 
/  w r i t e message to console  / 
puts ( "hello,  6.087 students" ) ; 
return 0; /  e x i t (0 =&gt; success )  / 
} 
	puts(): output text to console window (stdout) and end 
the line 
	String literal: written surrounded by double quotes 
	return 0;
exits the function, returning value 0 to caller
29</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Using gdb
Some useful commands: 
	break linenumber  create breakpoint at specied line 
	break file:linenumber  create breakpoint at line in 
le 
	run  run program
c  continue execution
 
next  execute next line  
	step  execute next line or step into function 
	quit  quit gdb 
	print expression  print current value of the specied 
expression 
	help command  in-program help 
11</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Structure of a .c le
/* Begin with comments about file contents */ 
Insert #include  statements and preprocessor 
definitions 
Function prototypes and variable declarations 
Define main() function 
{ 
Function body  
} 
Define other  function 
{ 
Function body  
} 
.
 . . 
16</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>6.087 Lecture 1  January 11, 2010
Introduction to C 
Writing C Programs 
Our First C Program 
7</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Memory debugging
Figure: valgrind: diagnose memory-related problems 
12</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Hello, 6.087 students
	In style of Hello, world! 
.c le structure  
	Syntax: comments, macros, basic declarations 
	The main() function and function structure 
	Expressions, order-of-operations 
	Basic console I/O (puts(), etc.) 
15</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Compiling a program
	gcc (included with most Linux distributions): compiler 
.o extension  
	omitted for common programs like gcc 
8</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>The main() function
	main(): entry point for C program 
	Simplest version: no inputs, outputs 0 when successful, 
and nonzero to signal some error 
int main(void); 
	Two-argument form of main(): access command-line 
arguments 
int main(int argc, char argv); 
	More on the char **argv notation later this week. . . 
27</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Conditional preprocessor macros
	#if, #ifdef , #ifndef , #else, #elif , #endif 
conditional preprocessor macros, can control which lines 
are compiled 
	evaluated before code itself is compiled, so conditions must 
be preprocessor denes or literals 
	the gcc option -Dname=value sets a preprocessor dene 
that can be used 
	Used in header les to ensure declarations happen only once 
35</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Running our code
Or, in gdb, 
athena% gdb hello.o
.
. . 
Reading
 symbols from hello.o...done. 
(gdb) run 
Starting program: hello.o 
hello, 6.087 students 
Program exited  normally.
(gdb) quit
athena%
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
38 1
1</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>4. Perform initialization with assignment
Now, z= 5.0.
How do I insert parentheses to get z= 4.0?
oat z = (x+3x)/(y4);
Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
2. Evaluate multiplies and divides, from left-to-right 
oat z = x+3x/2.0; oat z = x+6.0/2.0; oat z = x+3.0;   
3. Evaluate addition
oat z = x+3.0; oat z = 5.0;
 
24</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Arithmetic expressions
Suppose x and y are variables 
	x+y, x-y, x *y, x/y, x%y: binary arithmetic 
	A simple statement:
y = x+3x/(y4);
	Numeric literals like 3 or 4 valid in expressions 
	Semicolon ends statement (not newline) 
	x += y, x -= y, x *= y, x /= y, x %= y: arithmetic 
and assignment 
22</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Conditional preprocessor macros
	#pragma 
preprocessor directive 
	#error , #warning 
trigger a custom compiler error/warning 
	#undef msg 
remove the denition of msg at compile time 
36</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>C vs. related languages
	More recent derivatives: C++, Objective C, C# 
	Inuenced: Java, Perl, Python (quite different) 
C lacks:  
	exceptions 
	range-checking 
 garbage collection
 object-oriented programming
	polymorphism
. . .
 
Low-level language faster code (usually) 	  
5</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Function denitions
Function declaration 
{ 
declare
 variables; 
program statements; 
} 
	Must match prototype (if there is one)
variable names dont have to match
 
no semicolon at end  
 Curly braces dene a block  region of code 
 Variables declared in a block exist only in that block 
 Variable declarations before any other statements 
28</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>How do I insert parentheses to get z= 4.0?
oat z = (x+3x)/(y4);
Order of operations
Assume x = 2.0 and y = 6.0. Evaluate the statement 
oat z = x+3 x/(y4); 
1. Evaluate expression in parentheses
oat z = x+3x/(y4); oat z = x+3 x/2.0;
 
2. Evaluate multiplies and divides, from left-to-right 
oat z = x+3x/2.0; oat z = x+6.0/2.0; oat z = x+3.0;   
3. Evaluate addition
oat z = x+3.0; oat z = 5.0;
 
4. Perform initialization with assignment
Now, 
z = 5.0.
24</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Using Eclipse
	Need Eclipse CDT for C programs (see 
http://www.eclipse.org/cdt/) 
	Use New &gt; C Project 
	choose Hello World ANSI C Project for simple project 
	Linux GCC toolchain sets up gcc and gdb (must be 
installed separately) 
	Recommended for nal project 
14</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
IAP 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Console I/O
	stdout, stdin: console output and input streams 
	puts(string): print string to stdout 
	putchar(char): print character to stdout 
	char = getchar(): return character from stdin 
	string = gets(string): read line from stdin into 
string 
	Many others - later this week 
32</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Declaring variables
Must declare variables before use  
Variable declaration:  
int n;
oat phi;
 int - integer data type 
 float - oating-point data type 
 Many other types (more next lecture. . . ) 
20</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Debugging
Figure: gdb: command-line debugger 
10</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Initializing variables
	Uninitialized, variable assumes a default value 
	Variables initialized via assignment operator: 
n = 3;
Can also initialize at declaration:
 
oat phi = 1.6180339887; 
	Can declare/initialize multiple variables at once: 
int a, b, c = 0, d = 4; 
21</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Summary
Topics covered: 
 How to edit, compile, and debug C programs 
	C programming fundamentals:
comments
 
 preprocessor macros, including #include 
 the main() function 
 declaring and initializing variables, scope 
 using puts()  calling a function and passing an argument 
 returning from a function 
39</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Preprocessor macros
	Preprocessor macros begin with # character 
#include &lt;stdio.h&gt; 
	#dene msg "hello, 6.087 students" 
denes msg as hello, 6.087 students throughout 
source le 
	many constants specied this way 
33</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Multithreaded programming. Sockets and asynchronous I/O.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec13/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>21</slideno>
          <text>Deadloc k
20 Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 13.39, Progress graph for a program that can deadlock.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Deadloc k
	Deadloc k  happens when e very thread is w aiting on 
another thread to unb lock 
	Usually caused b y improper order ing of synchronization 
objects 
	Tricky bug to locate and reproduce , since 
schedule-dependent 
	Can visualiz e using a prog ress g raph  tr aces prog ress of 
threads in ter ms of synchronization objects 
19</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Creating a socket
	Create a soc ket, getting the le descr iptor f or that soc ket: 
int socket(int domain, int type, int protocol ); 
	domain  use constant AF_INET, so w ere using the 
internet; might also use AF_INET6 for IPv6 addresses 
	type  use constant SOCK_STREAM for connection-based 
protocols lik e TCP/IP; use SOCK_DGRAM for connectionless 
datag ram protocols lik e UDP (w ell concentr ate on the 
former) 
	protocol  specify 0 to use def ault protocol f or the soc ket 
type (e .g. TCP) 
	returns nonnegativ e integer f or le descr iptor, or 1 if 
couldnt create soc ket 
	Dont f orget to close the le descr iptor when y oure done! 
24</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>6.087 Lecture 13  January 28, 2010
Review 
Multithreaded Prog ramming 
Race Conditions 
Semaphores 
Thread Saf ety, Deadloc k, and Star vation 
Sockets and Asynchronous I/O 
Sockets 
Asynchronous I/O 
23</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Other challeng es
	Synchronization objects help solv e race conditions 
	Improper use can cause other prob lems 
Some common issues:  
	thread saf ety and reentr ant functions
deadloc k
  
starvation  
15</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Using semaphores
	Initializ e semaphore to value: 
int sem_init(sem_t sem, int pshared, unsigned int value); 
	Destro y semaphore: 
int sem_destro y(sem_t sem); 
	Wait to loc k, blocking: 
int sem_w ait(sem_t sem); 
	Try to loc k, retur ning immediately (0 if now loc ked, 1 
otherwise): 
int sem_tr ywait(sem_t sem); 
	Increment semaphore , unb locking a w aiting thread: 
int sem_post(sem_t sem); 
12</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Resour ce sharing
Access to shared resources need to be controlled to  
ensure deter ministic oper ation 
	Synchronization objects: mutexes, semaphores , read/wr ite 
locks, barr iers 
	Mute x: simple single loc k/unloc k mechanism 
	int pthread_m utex_init(pthread_m utex_t mutex, const pthread_m utexattr_t  attr); 
	int pthread_m utex_destro y(pthread_m utex_t mutex); 
	int pthread_m utex_loc k(pthread_m utex_t mutex); 
	int pthread_m utex_trylock(pthread_m utex_t mutex); 
	int pthread_m utex_unloc k(pthread_m utex_t mutex); 
2</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: Multithreaded programming
	Thread: abstr action of par allel processing with shared 
memor y 
	Prog ram organiz ed to e xecute m ultiple threads in par allel 
	Threads spa wned by main thread, comm unicate via 
shared resources and joining 
	pthread library implements m ultithreading 
int pthread_create ( pthread_t thread , const pthread _attr _t attr , 	  	
void ( start _routine )( void ), void  arg ); 
	void pthread_e xit(void value_ptr); 
	int pthread_join (pthread_t thread , void value_ptr); 
	pthread_t pthread_self (void); 
1</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Starvation and priority inversion
Starvation similar to deadloc k  
	Scheduler ne ver allocates resources (e .g. CPU time) f or a 
thread to complete its task 
	Happens dur ing pr iority inversion 
	example: highest pr iority thread T 1 waiting f or low priority 
thread T 2 to nish using a resource , while thread T 3, which 
has higher pr iority than T 2, is allo wed to r un indenitely 
	thread T 1 is considered to be in star vation 
22</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Listening for clients
	Using the bound soc ket, star t listening: 
int listen (int fd, int backlog); 
	fd  bound soc ket le descr iptor 
	backlog  length of queue f or pending TCP/IP 
connections; nor mally set to a large n umber , like 1024 
returns 0 if successful  
27</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Deadloc k
	Defeating deadloc k extremely difcult in gener al 
	When using only m utexes, can use the m utex lock
order ing rule to a void deadloc k scenar ios:
A program is deadloc k-free if, for each pair of mutexes (s, t) 
in the program, each thread that uses both s and t 
simultaneously locks them in the same order . 
[Bryant and OHallor an. Computer Systems: A Prog rammer s Perspectiv e 
Prentice Hall, 2003.] 
21</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Sockets
Socket  abstr action to enab le comm unication across a  
netw ork in a manner similar to le I/O 
	Uses header &lt;sys/socket.h&gt; (extension of C standard 
library) 
	Netw ork I/O, due to latency , usually implemented 
asynchronously , using m ultithreading 
	Sockets use client/ser ver model of estab lishing 
connections 
23</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare 
http://ocw.mit.edu 
6.087  Practical Programming in C 
January (IAP) 2010 
 
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 13  January 28, 2010
Review 
Multithreaded Prog ramming 
Race Conditions 
Semaphores 
Thread Saf ety, Deadloc k, and Star vation 
Sockets and Asynchronous I/O 
Sockets 
Asynchronous I/O 
4</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Thread safety
To mak e your code thread-saf e: 
 Use synchronization objects around shared v ariables 
Use reentr ant functions  
	Use synchronization around functions retur ning pointers to 
shared memor y (loc k-and-cop y): 
1. lock mutex for function 
2. call unsaf e function 
3. dynamically allocate memor y for result; (deep) cop y result 
into ne w memor y 
4. unloc k mutex 
18</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Semaphores
	Semaphore  special nonnegativ e integer v ariable s, 
initially 1, which implements tw o atomic oper ations: 
	P(s)  wait until s &gt; 0, decrement s and retur n 
	V(s)  increment s by 1, unb locking a w aiting thread 
	Mute x  loc king calls P(s) and unloc king calls V(s) 
	Implemented in &lt;semaphore.h&gt;, par t of libr ary rt, not 
pthread 
11</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>I/O multiple xing using poll()
	Similar to select(), b ut species le descr iptors 
differently: (include &lt;poll.h&gt;) 
int poll (struct pollfd fds [], nfds_t nfds, int timeout ); 
	fds  an arr ay of pollfd structures , whose members fd, 
events, and revents, are the le descr iptor, events to 
chec k (OR-ed combination of ags lik e POLLIN, POLLOUT, 
POLLERR, POLLHUP), and result of polling with that le 
descr iptor f or those e vents, respectiv ely 
	nfds  number of str uctures in the arr ay 
	timeout  number of milliseconds to w ait; use 0 to retur n 
immediately , or 1 to block indenitely 
33</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 13  January 28, 2010
Review 
Multithreaded Prog ramming 
Race Conditions 
Semaphores 
Thread Saf ety, Deadloc k, and Star vation 
Sockets and Asynchronous I/O 
Sockets 
Asynchronous I/O 
1</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Race conditions in assemb ly
Consider the f ollowing prog ram race.c: 
unsigned i n t cnt = 0; 
void count ( void arg) {/ thread body / 
int i; 
for ( i = 0; i &lt; 100000000; i ++) 
cnt++; 
return NULL ; 
} 
int main ( void ){ 
pthread_t tids [4]; 
int i; 
for (i =0; i&lt;4; i++) 
pthread_create(&amp;tids[i], NULL, count, NULL);
for (i =0; i&lt;4; i++)
pthread _join(tids[i], NULL);
printf ("cnt=%u\n " ,cnt );
return 0;
} 
What is the v alue of cnt? 
[Bryant and OHallor an. Computer Systems: A Prog rammer s Perspectiv e. 
Prentice Hall, 2003.] 
  Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license. 
For more information, see http://ocw.mit.edu/fairuse. 
6</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Connecting to a server
	Using created soc ket, w e connect to ser ver using: 
int connect(int fd, struct sockaddr addr, int addr_len); 
	fd  the soc kets le descr iptor 
	addr  the address and por t of the ser ver to connect to; f or 
internet addresses , cast data of type struct 
sockaddr_in, which has the f ollowing members: 
	sin_family  address f amily; alw ays AF_INET 
	sin_port  por t in netw ork byte order (use htons() to 
convert to netw ork byte order) 
	sin_addr.s_addr  IP address in netw ork byte order (use 
htonl() to con vert to netw ork byte order) 
	addr_len  size of sockaddr_in structure
returns 0 if successful
  
25</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Reading and writing with sockets
	Send data using the f ollowing functions: 
int write(int fd, const void buf, siz e_t len ); 
int send(int fd, const void buf, siz e_t len, int ags ); 
	Receiv e data using the f ollowing functions: 
int read( int fd, void buf, size_t len ); 
int recv(int fd, void buf, size_t len, int ags ); 
	fd  soc kets le descr iptor
buf  buffer of data to read or wr ite
  
	len  length of b uffer in b ytes 
	flags  special ags; w ell just use 0 
	all these retur n the n umber of b ytes read/wr itten (if 
successful) 
29</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Race conditions in assemb ly
	C not designed f or multithreading 
	No notion of atomic oper ations in C 
	Increment cnt++; maps to three assemb ly oper ations: 
1. load cnt into a register 
2. increment v alue in register 
3.	save new register v alue as ne w cnt 
	So what happens if thread interr upted in the middle? 
Race condition!  
8</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Race conditions
	Race conditions occur when m ultiple threads share a 
variable, without proper synchronization 
	Synchronization uses special v ariables, like a m utex, to 
ensure order of e xecution is correct 
	Example: thread T 1 needs to do something bef ore thread 
T2 
	condition v ariable forces thread T 2 to wait for thread T 1 
	producer-consumer model prog ram 
	Example: two threads both need to access a v ariable and 
modify it based on its v alue
surround access and modication with a m utex
  
	mutex groups oper ations together to mak e them atomic  
treated as one unit 
5</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Async hronous I/O
	Up to now, all I/O has been synchronous  functions do not 
return until oper ation has been perf ormed 
	Multithreading allo ws us to read/wr ite a le or soc ket 
without b locking our main prog ram code (just put I/O 
functions in a separ ate thread) 
	Multiple xed I/O  use select() or poll() with m ultiple 
le descr iptors 
30</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Race conditions in assemb ly
Ideally , should increment cnt 4  100000000 times , so 
cnt = 400000000. However, running our code giv es: 
athena% ./race.o 
cnt=137131900 
athena% ./race.o 
cnt=163688698 athena% ./race.o 
cnt=163409296 athena% ./race.o 
cnt=170865738 
athena% ./race.o 
cnt=169695163 
So, what happened? 
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
7 1
1</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: Condition variab les
 Lock/unloc k (with m utex) based on r un-time condition 
variable
Allows thread to w ait for condition to be tr ue
  
 Other thread signals w aiting thread(s), unb locking them 
 int pthread_cond_init(pthread_cond_t cond, const pthread_condattr_t attr); 
 int pthread_cond_destro y(pthread_cond_t cond); 
 int pthread_cond_w ait(pthread_cond_t cond, pthread_m utex_t mutex); 
 int pthread_cond_broadcast(pthread_cond_t cond); 
 int pthread_cond_signal(pthread_cond_t cond); 
3</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>I/O multiple xing with select()
	fd_set  a mask f or le descr iptors; bits are set (1) if in 
the set, or unset (0) otherwise 
	Use the f ollowing functions to set up the str ucture: 
	FD_ZER O(&amp;fdset)  initializ e the set to ha ve bits unset f or all le 
descr iptors 
	FD_SET(fd, &amp;fdset)  set the bit f or le descr iptor fd in the set 
	FD_CLR(fd, &amp;fdset)  clear the bit f or le descr iptor fd in the set 
	FD_ISSET(fd, &amp;fdset)  retur ns nonz ero if bit f or le descr iptor fd is 
set in the set 
32</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Multithreaded programming
	OS implements scheduler  deter mines which threads 
execute when 
	Scheduling ma y execute threads in arbitr ary order 
	Without proper synchronization, code can e xecute 
non-deter ministically 
	Suppose w e have two threads: 1 reads a v ariable, 2 
modies that v ariable 
	Scheduler ma y execute 1, then 2, or 2 then 1 
Non-deter minism creates a r ace condition  where the  
beha vior/result depends on the order of e xecution 
4</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Summar y
	Multithreaded prog ramming 
race conditions  
	semaphores 
	thread saf ety 
deadloc k and star vation  
	Sockets, asynchronous I/O 
	client/ser ver soc ket functions 
	select() and poll() 
34</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Thread safety
	Function is thread safe if it alw ays beha ves correctly when 
called from m ultiple concurrent threads 
	Unsaf e functions f al in se veral categor ies: 
	accesses/modies unsynchroniz ed shared v ariables 
	functions that maintain state using static v ariables  lik e 
rand(), strtok() 
	functions that retur n pointers to static memor y  lik e 
gethostbyname() 
	functions that call unsaf e functions ma y be unsaf e 
16</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Accepting a client s connection
	Wait for a client s connection request (ma y already be 
queued): 
int accept(int fd, struct sockaddr addr, int addr_len); 
	fd  soc kets le descr iptor 
	addr  pointer to str ucture to be lled with client address 
info (can be NULL) 
	addr_len  pointer to int that species length of str ucture 
pointed to b y addr; on output, species the length of the 
stored address (stored address ma y be tr uncated if bigger 
than supplied str ucture) 
	returns (nonnegativ e) le descr iptor f or connected client 
socket if successful 
28</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Race conditions in assemb ly
Lets x our code: 
pthread_mutex_t mutex; 
unsigned i n t cnt = 0; 
void count ( void arg) {/ thread body / 
int i; 
for ( i = 0; i &lt; 100000000; i ++) { 
pthread_mutex_lock(&amp;mutex );
cnt++;
pthread_mutex_unlock(&amp;mutex );
} 
return NULL ; 
} 
int main ( void ){ 
pthread_t tids [4]; 
int i; 
pthread_mutex_init(&amp;mutex, NULL); 
for (i =0; i&lt;4; i++) 
pthread_create(&amp;tids[i], NULL, count, NULL); 
for (i =0; i&lt;4; i++) 
pthread _join(tids[i], NULL);
pthread_mutex_destroy(&amp;mutex );
printf ("cnt=%u\n " ,cnt );
return 0;
} 
9</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Producer and consumer revisited
	Use a semaphore to tr ack availab le slots in shared b uffer 
	Use a semaphore to tr ack items in shared b uffer 
	Use a semaphore/m utex to mak e buffer oper ations 
synchronous 
13</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Reentrant functions
	Reentr ant function  does not ref erence an y shared data 
when used b y multiple threads 
	All reentr ant functions are thread-saf e (are all thread-saf e 
functions reentr ant?) 
	Reentr ant v ersions of man y unsaf e C standard libr ary 
functions e xist: 
Unsaf e function 
rand()
strtok()
asctime()
ctime()
gethostbyaddr()
gethostbyname()
inet_ntoa()
localtime()
Reentr ant v ersion
rand_r() strtok_r() asctime_r() ctime_r() gethostbyaddr_r() 
gethostbyname_r() 
(none) 
localtime_r() 
17</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Associate server socket with a port
	Using created soc ket, w e bind to the por t using: 
int bind(int fd, struct sockaddr addr, int addr_len); 
	fd, addr, addr_len  same as f or connect() 
note that address should be IP address of desired interf ace  
(e.g. eth0) on local machine 
	ensure that por t for ser ver is not tak en (or y ou ma y get 
address already in use errors) 
	return 0 if soc ket successfully bound to por t 
26</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Producer and consumer revisited
#include &lt;stdio .h&gt; for (i = 0; i &lt;ITEMS; i++) {
#include &lt;pthread.h&gt; sem_wait(&amp;items);
#include &lt;semaphore.h&gt; sem_wait(&amp;mutex);
printf (" consumed(%ld):%d\n " , 
sem_t mutex, slots , items; pthread_self(), i+1); 
sem_post(&amp;mutex ); 
#define SLOTS 2 sem_post(&amp;slots); 
#define ITEMS 10 } 
return NULL; 
void produce ( void arg) } 
{ 
int i; int main ()
for (i = 0; i &lt;ITEMS; i++) {
{ pthread_t tcons , tpro ;
sem_wait(&amp;slots );
sem_wait(&amp;mutex); sem_init(&amp;mutex, 0, 1);
printf("produced(%ld):%d\n ", sem_init(&amp;slots , 0, SLOTS);
pthread_self () , i +1); sem_init(&amp;items , 0, 0); 
sem_post(&amp;mutex ); 
sem_post(&amp;items ); pthread_create(&amp;tcons ,NULL,consume,NULL); 
} pthread_create(&amp;tpro,NULL,produce,NULL); 
return NULL; pthread_join(tcons,NULL); 
} pthread_join(tpro ,NULL); 
void consume ( void arg) sem_destroy(&amp;mutex); 
{ sem_destroy(&amp;slots); 
int i ; sem_destroy(&amp;items ); 
return 0; 
} 
[Bryant and OHallor an. Computer Systems: A Prog rammer s Perspectiv e. 
Prentice Hall, 2003.]  Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license. 
For more information, see http://ocw.mit.edu/fairuse. 14</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>I/O multiple xing with select()
	To chec k if m ultiple les/soc kets ha ve data to 
read/wr ite/etc: (include &lt;sys/select.h&gt;) 
int select (int nfds, fd_set readfds, fd_set writefds , fd_set errorfds , struct timeval timeout); 
	nfds  species the total r ange of le descr iptors to be 
tested (0 up to nfds 1) 
	readfds, writefds, errorfds  if not NULL, pointer to 
set of le descr iptors to be tested f or being ready to read, 
write, or ha ving an error ; on output, set will contain a list of 
only those le descr iptors that are ready 
	timeout  if no le descr iptors are ready immediately , 
maxim um time to w ait for a le descr iptor to be ready 
	returns the total n umber of set le descr iptor bits in all the 
sets 
	Note that select() is a b locking function 
31</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Race conditions
	Note that ne w code functions correctly , but is m uch slo wer 
	C statements not atomic  threads ma y be interr upted at 
assemb ly level, in the middle of a C statement 
	Atomic oper ations lik e mutex locking m ust be specied as 
atomic using special assemb ly instr uctions 
	Ensure that all statements accessing/modifying shared 
variables are synchroniz ed 
10</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Pointers to pointers, pointer and string arrays, multidimensional arrays. Stacks and queues.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec07/</lecture_pdf_url>
      <lectureno>7</lectureno>
      <slides>
        <slide>
          <slideno>15</slideno>
          <text>Pointer arra y example
Inser tion sor t (contin ued): 
/ 	iterate until outoforder element found ; 
shift the element , and continue iterating  / 
void insertion _sort ( void ){ 
unsigned i n t i, len = array_length(arr); 
for (i =1; i&lt;len; i++) 
if ( sorted_array [ i ] &lt;  sorted_array [ i 1]) 
shift _element(i ); 
} 
11</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>;Queue as linked list
	Add element using void enqueue(oat); 
void enqueue ( float elem) { 
struct s_listnode new_node = /  allocate new node  / 
( struct s_listnode  ) malloc ( sizeof ( struct s_listnode )) 
new_node&gt;element = elem ; 
new_node&gt;pnext = NULL; /  at rear  / 
if ( prear ) 
prear &gt;pnext = new_node; 
else /  empty  / 
queue_buffer = new_node;
prear = new_node;
}
	Adding an element doesnt aff ect the front if the queue is 
not empty 
29</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Queue as arra y
 Need to modify void enqueue(oat); and oat dequeue(v oid); 
 New void enqueue(oat); : 
void enqueue ( float elem) { 
if ( icount &lt; 100) { 
queue_buffer[(ifront+icount) % 100] = elem; 
icount ++; 
}
}
26</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Queue as arra y
	Again, store as arr ay buffer (static or dynamic allocation); 
oat queue_b uffer[100]; 
	Elements added to end (rear), remo ved from beginning 
(front) 
	Need to k eep tr ack of front and rear : 
int ifront = 0, irear = 0; 
	Alternativ ely, we can tr ack the front and n umber of 
elements: 
int ifront = 0, icount = 0; 
	Well use the second w ay (reason apparent later) 
22</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Queue as linked list
	Store as link ed list (dynamic allocation): 
struct	s_listnode {
float element ;
struct s_listnode pnext;
 
}; 
struct s_listnode queue_b uffer = NULL;  star t empty 
	Let front be at beginning  no need to tr ack front 
Rear is at end  w e should tr ack it:  
struct s_listnode prear = NULL; 
28</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>2bytes
4bytes,
4byte-aligned
bit fields
4bytes,
4byte-aligned
Review: Compound data types
 Consider this compound data str ucture: 
struct foo { 
short s; 
union { 
int i; 
char c;
} u;
unsigned int flag _s : 1;
unsigned int flag_u : 2;
unsigned int bar ;
}; 
	Assuming a 32-bit x86 processor , evaluate 
sizeof(struct foo) 
2</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: Compound data types
 Consider this compound data str ucture: 
struct foo { 
short s;  2 bytes 
union {  4 bytes, 
int i; 4 byte-aligned 
char c; 
} u; 
unsigned int flag _s : 1; bit fields 
unsigned int flag_u : 2;  
unsigned int bar ; 4 bytes,
};	 4 byte-aligned 
	Assuming a 32-bit x86 processor , evaluate 
sizeof(struct foo) 
2</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Stac k as linked list
	Store as link ed list (dynamic allocation): 
struct	s_listnode {
int element ;
struct s_listnode pnext;
 
}; 
struct s_listnode  stack_buffer = NULL;  star t empty 
	Top is no w at front of link ed list (no need to tr ack) 
18</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Evaluating postx
 Postx e valuation v ery easy with a stac k: 
1. dequeue a tok en from the postx queue 
2. if tok en is an oper and, push onto stac k 
3. if tok en is an oper ator, pop oper ands off stac k (2 for binar y 
operator); push result onto stac k 
4. repeat until queue is empty 
5. item remaining in stac k is nal result 
35</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Inx to postx
	"Shunting y ard algor ithm" - Dijkstr a (1961): input and 
output in queues , separ ate stac k for holding oper ators 
	Simplest v ersion (oper ands and binar y oper ators only): 
1. dequeue tok en from input 
2. if oper and (n umber), add to output queue 
3. if oper ator, then pop oper ators off stac k and add to output 
queue as long as 
 top oper ator on stac k has higher precedence , or 
 top oper ator on stac k has same precedence and is 
left-associativ e
and push ne w oper ator onto stac k
4. return to step 1 as long as tok ens remain in input 
5. pop remaining oper ators from stac k and add to output 
queue 
32</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>6.087 Lecture 7  Jan uary 20, 2010
Review 
More about P ointers 
Pointers to P ointers 
Pointer Arr ays 
Multidimensional Arr ays 
Data Str uctures 
Stacks 
Queues 
Application: Calculator 
5</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Postx e valuation e xample
 Postx e xpression: 3 4 + 5 1 - * 
Token
3
 3 
4
 34 
+
 7 
5
 75 
1
 751 
-
*
 28 
(end)
 answer = 28 Stack
74 
 Extends to e xpressions with functions , unar y oper ators 
 Performs e valuation in one pass , unlik e with prex notation 
36</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Queue as arra y
	Add element using void enqueue(oat); 
void enqueue ( float elem) { 
if ( icount &lt; 100) { 
queue_buffer[ifront+icount] = elem; 
icount ++; 
}
}
	Remo ve element using oat dequeue(v oid); 
float dequeue ( void ){ 
if ( icount &gt; 0) {
icount ;
return queue_buffer[ ifront++];
}	else 
return 0.; /  or other special value  / 
} 
23</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>String arra ys
	An arr ay of str ings, each stored as a pointer to an arr ay of 
chars 
	Each str ing ma y be of diff erent length 
char str1 [] = "hello" ;/  length = 6  /
char str2 [] = "goodbye" ;/  length = 8  /
char str3 [] = "ciao" ;/  length = 5  /
char strArray[] = {str1, str2, str3};
  
	Note that strArr ay contains only pointers , not the char acters 
themselv es! 
12</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Pointer arra y example
	Have an arr ay int arr [100]; that contains some n umbers 
	Want to ha ve a sor ted v ersion of the arr ay, but not modify 
arr 
	Can declare a pointer array int  sorted_arr ay[100]; containing 
pointers to elements of arr and sor t the pointers instead 
of the n umbers themselv es 
	Good approach f or sor ting arr ays whose elements are v ery 
large (lik e strings) 
9</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Pointer re view
	Pointer represents address to v ariable in memor y 
	Examples: 
int pn;  pointer to int 
struct div_t  pdiv;  pointer to str ucture div_t 
	Addressing and indirection: 
double pi = 3.14159;
double  ppi = &amp;pi;
printf ( "pi = %g\n" ,  ppi );
	Today: pointers to pointers , arrays of pointers , 
multidimensional arr ays 
5</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Stac k as arra y
	Store as arr ay buffer (static allocation or dynamic 
allocation): 
int stack_buffer[100]; 
	Elements added and remo ved from end of arr ay; need to 
track end: 
int itop =0; / end at zero =&gt; initializ ed for empty stac k / 
16</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Answer:order from largest tosmallest:
structfoo{
union{
inti;
charc;
}u;
unsignedintbar;
shorts;
unsignedintflag_s:1;
unsignedintflag_u:2;
};
sizeof(struct foo)=12
Review: Compound data types
 How can w e rearr ange the elds to minimiz e the siz e of 
struct foo? 
3</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Review: Compound data types
	How can w e rearr ange the elds to minimiz e the siz e of 
struct foo? 
	Answer: order from largest to smallest: 
struct foo { 
union {
int i;
char c;
} u;
unsigned i n t bar ;
short s;
unsigned i n t flag _s : 1;
unsigned i n t flag _u : 2;
}; 
sizeof(struct foo) = 12 
3</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>6.087 Lecture 7  Jan uary 20, 2010
Review 
More about P ointers 
Pointers to P ointers 
Pointer Arr ays 
Multidimensional Arr ays 
Data Str uctures 
Stacks 
Queues 
Application: Calculator 
14</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>More data structures
Last time: linked lists  
 Today: stack, queue 
 Can be implemented using link ed list or arr ay stor age 
14</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Queue as arra y
Dequeue a: 
cb d 
front rear 
Enqueue e to the rear : where should it go?  
Solution: use a circular (or r ing) b uffer  
e would go in the beginning of the arr ay  
25</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>;Stac k as linked list
 Add element using void push(int ); 
void push ( int elem) { 
struct s_listnode new_node = /  allocate new node  / 
( struct s_listnode  ) malloc ( sizeof ( struct s_listnode )) 
new_node&gt;pnext = stack _buffer ; 
new_node&gt;element = elem ; 
stack _buffer = new_node; 
} 
 Adding an element pushes bac k the rest of the stac k 
19</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Pointer pointer s example
What does this function do?  
void swap( int a, int b) {
int temp = a;
a= b;
b = temp ;
} 
 How does it compare to the f amiliar v ersion of s wap? 
void swap( int a, int b) {
int temp = a;
a= b;
b = temp ;
} 
7</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>A simple calculator
	Stacks and queues allo w us to design a simple e xpression 
evaluator 
	Prex, inx, postx notation: operator before, betw een, and 
after oper ands , respectiv ely
Inx
A+B
A*B-C
( A + B ) * ( C - D)
Prex
+AB 
-*ABC 
*+AB-CD Postx
AB+
AB*C
AB+CD-*
 Inx more natur al to wr ite, postx easier to e valuate 
31</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Pointer s to pointer s
	Address stored b y pointer also data in memor y 
	Can address location of address in memor y  pointer to 
that pointer 
int n= 3;
int pn =&amp;n; /  pointer to n  /
int ppn =&amp;pn; /  pointer to address of n  /
	Many uses in C: pointer arr ays, string arr ays 
6</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Stac k as linked list
	Remo ve element using int pop(v oid); 
int pop ( void ){ 
if (stack _buffer) { 
struct s_listnode pelem = stack _buffer ; 
int elem = stack_buffer &gt;element ; 
stack _buffer = pelem&gt;pnext ; 
free(pelem); /  remove node from memory  / 
return elem ; 
}	else
return 0; /  or other special value  /
}
	Some implementations pro vide int top(void); to read last 
(top) element without remo ving it 
20</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Multidimensional arra ys
	C also permits multidimensional arrays specied using [] 
brackets notation: 
int world [20][30]; is a 20x30 2-D arr ay of int s 
	Higher dimensions possib le: 
char bigchar matrix [15][7][35][4];  what are the dimensions of 
this? 
	Multidimensional arr ays are rectangular ; pointer arr ays can 
be arbitr ary shaped 
13</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Stac k as arra y
	Add element using void push(int ); 
void	push ( int elem) {
stack _buffer[itop++] = elem;
}
	Remo ve element using int pop(v oid); 
int	pop ( void ){
if ( itop &gt; 0)
return stack _buffer[ itop ];
else
return 0; /  or other special value  /
}
	Some implementations pro vide int top(void); to read last 
(top) element without remo ving it 
17</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: Compound data types
	struct -structure containing one or multiple elds , each with 
its own type (or compound type) 
	size is combined siz e of all the elds , padded f or byte 
alignment 
	anon ymous or named 
	union -structure containing one of se veral elds , each with 
its own type (or compound type) 
	size is siz e of largest eld 
 anon ymous or named
Bit elds - structure elds with width in bits
  
	aligned and ordered in architecture-dependent manner 
can result in inefcient code  
1</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Inx to postx e xample
 Inx e xpression: A + B * C - D 
Token
A 
+ 
B 
* 
C 
-
D 
(end) Output queue
A 
A 
AB 
AB 
ABC 
ABC*+ 
ABC*+D 
ABC*+D-Oper ator stac k
+ + 
+* 
+* 
--
 Postx e xpression: A B C * + D 
 What if e xpression includes parentheses? 
33</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Queue as arra y
This w ould mak e for a v ery poor queue! Obser ve a queue  
of capacity 4: 
a cb 
front rear 
Enqueue d to the rear of the queue:  
a cb d 
front rear
The queue is no w full.
24</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Example with parentheses
 Inx e xpression: ( A + B ) * ( C - D ) 
Token
( 
A 
+ 
B 
) 
* 
( 
C 
-
D 
) 
(end) Output queue
A 
A AB 
AB+ 
AB+ 
AB+ 
AB+C 
AB+C 
AB+CD 
AB+CD
AB+CD-* Oper ator stac k
( ( (+ 
(+ 
* 
*( 
*( 
*(
*(
* 
 Postx e xpression: A B + C D - * 
34</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>The stac k
	Special type of list - last element in (push) is rst out (pop) 
Read and wr ite from same end of list  
	The stac k (where local v ariables are stored) is 
implemented as a *gasp* stac k 
15</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>The queue
	Opposite of stac k -rst in (enqueue), rst out (dequeue) 
	Read and wr ite from opposite ends of list 
	Impor tant for UIs (event/message queues), netw orking (Tx, 
Rx pac ket queues) 
	Imposes an order ing on elements 
21</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Pointer arra ys
	Pointer arr ay  arr ay of pointers 
int arr [20];  an arr ay of pointers to int s 
char arr[10];  an arr ay of pointers to char s 
	Pointers in arr ay can point to arr ays themselv es 
char strs [10];  an arr ay of char arrays (or str ings) 
8</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 7  Jan uary 20, 2010
Review 
More about P ointers 
Pointers to P ointers 
Pointer Arr ays 
Multidimensional Arr ays 
Data Str uctures 
Stacks 
Queues 
Application: Calculator 
1</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Summar y
Topics co vered: 
 Pointers to pointers 
 pointer and str ing arr ays 
 multidimensional arr ays
Data str uctures
  
 stack and queue 
 implemented as arr ays and link ed lists 
 writing a calculator 
37</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Queue as linked list
	Remo ve element using oat dequeue(v oid); 
float	dequeue ( void ){ 
if ( queue_buffer ) { 
struct s_listnode pelem = queue_buffer ; 
float elem = queue_buffer &gt;element ; 
queue_buffer = pelem&gt;pnext ; 
if (pelem == prear ) /  at end  / 
prear = NULL; 
free(pelem); /  remove node from memory  / 
return elem ; 
} else
return 0.; /  or other special value  /
}
	Remo ving element doesnt aff ect rear unless resulting 
queue is empty 
30</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Howdoes itcompare tothefamiliar version ofswap?
voidswap(inta,intb){
inttemp=a;
a=b;
b=temp;
}
Pointer pointer s example
What does this function do?  
void swap( int a, int b) { 
int temp = a; 
a= b; 
b = temp ; 
} 
7</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Queue as arra y
	New oat dequeue(v oid);: 
float dequeue ( void ){ 
if ( icount &gt; 0) { 
float elem = queue_buffer[ ifront ]; 
icount ; 
ifront ++; 
if ( ifront == 100) 
ifront = 0; 
return elem ; 
}	else 
return 0.; /  or other special value  / 
} 
	Why would using front and rear counters instead mak e 
this harder? 
27</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Pointer arra y example
Inser tion sor t: 
/  move previous elements down until 
insertion point reached  / 
void shift _element ( unsigned int i) { 
int  pvalue ; 
/  guard against going outside array  / 
for ( pvalue = sorted_array [ i ] ; i &amp;&amp; 
 sorted_array [ i 1] &gt;  pvalue ; i ){ 
/  move pointer down  / 
sorted_array [ i ] = sorted_array [ i 1]; 
} 
sorted_array [ i ] = pvalue ; /  insert pointer  / 
} 
10</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Review: Linked lists and trees
	Linked list and tree dynamically g row as data is 
added/remo ved 
	Node in list or tree usually implemented as a struct 
	Use malloc(), free(), etc. to allocate/free memor y 
dynamically 
	Unlik e arrays, do not pro vide f ast random access b y inde x 
(need to iter ate) 
4</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Dynamic memory allocation, malloc and valgrind, garbage collection.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec11/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>34</slideno>
          <text>Chene ys (not Dicks) algorithm
	Method f or cop ying garbage collector using 
breadth-rst-search of memor y graph 
	Start with empty to-space 
	Examine stac k; mo ve pointers to to-space and update 
pointers to to-space ref erences 
	Items in from-space replaced with pointers to cop y in 
to-space 
	Starting at beginning of to-space , iterate through memor y, 
doing the same as pointers are encountered 
	Can accomplish in one pass 
30</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Freeing data
1. Mark block as free (bit ag in header/f ooter) 
2. If pre vious b lock free , coalesce with pre vious b lock (update 
size of pre vious) 
3. If next block free , coalesce with ne xt block (update siz e) 
18</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Using malloc()
	Minimiz e overhead  use f ewer, larger allocations 
	Minimiz e fragmentation  reuse memor y allocations as 
much as possib le 
	Growing memor y  using realloc() can reduce 
fragmentation 
	Repeated allocation and freeing of v ariables can lead to 
poor perf ormance from unnecessar y splitting/coalescing 
(depending on implementation of malloc()) 
21</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>6.087 Lecture 11  January 26, 2010
Review 
Dynamic Memor y Allocation 
Designing the malloc() Function 
A Simple Implementation of malloc() 
A Real-W orld Implementation of malloc() 
Using malloc() 
Using valgrind 
Garbage Collection 
21</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: C standar d librar y
	Conversion functions: atoi(), atol(), atof(), 
strtol(), strtoul(), strtod() 
	Utility functions: rand(), srand(), abort(), exit(), 
atexit(), system(), bsearch(), qsort() 
	Diagnostics: assert() function, __FILE__, __LINE__ 
macros 
2</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 11  January 26, 2010
Review 
Dynamic Memor y Allocation 
Designing the malloc() Function 
A Simple Implementation of malloc() 
A Real-W orld Implementation of malloc() 
Using malloc() 
Using valgrind 
Garbage Collection 
1</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: C standar d librar y
	I/O functions: fopen(), freopen(), fflush(), 
remove(), rename(), tmpfile(), tmpnam(), 
fread(), fwrite(), fseek(), ftell(), rewind(), clearerr(), feof(), ferror() 
	Char acter testing functions: isalpha(), isdigit(), 
isalnum(), iscntrl(), islower(), isprint(), ispunct(), isspace(), isupper() 
	Memor y functions: memcpy(), memmove(), memcmp(), 
memset() 
1</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Initialization
1. Allocate 16 bytes f or padding, prologue , epilogue 
2. Inser t 4 byte padding and prologue b lock (header + f ooter 
only, no pa yload) at beginning 
3. Add an epilogue b lock (header only , no pa yload) 
4. Inser t a ne w free chunk (e xtend the heap) 
16</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Bloc k structures
12  Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.50, Format of heap blocks that use doubly-linked free lists.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Mark and sweep garba ge collector
	Simple tr acing garbage collector 
	Starts with list of kno wn in-use memor y (e.g. the stac k) 
	Mark: trace all pointers , mar king data on the heap as it 
goes 
	Sweep: traverse entire heap , freeing unmar ked data 
	Requires tw o complete tr aversals of memor y, takes a lot of 
time 
	Implementation a vailab le at http: 
//www.hpl.hp.com/personal/Hans_Boehm/gc/ 
26</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Copying garba ge collector
	Uses a duplicate heap; copies liv e objects dur ing tr aversal 
to the duplicate heap (the to-space) 
	Updates pointers to point to ne w object locations in 
duplicate heap 
	After cop ying phase , entire old heap (the from-space) is 
freed 
	Code can only use half the heap 
29</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Mapping memor y
	Mapping memor y: 
void	mmap( void  start , size _t length , int prot , 
int flags , int fd , off _t offset ); 
	asks OS to map vir tual memor y of specied length, using 
specied ph ysical memor y (le or demand-z ero) 
	fd is le descr iptor (integer ref erring to a le , not a le 
stream) f or ph ysical memor y (i.e . le) to load into memor y 
	for demand-z ero, including the heap , use MMAP_ANON ag 
	start  suggested star ting address of mapped memor y, 
usually NULL 
	Unmap memor y: 
int munmap(v oid start, size_t length); 
5</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>malloc() for the real world
	Used in GNU libc v ersion of malloc() 
	Details ha ve changed, b ut nice gener al discussion can be 
found at 
http://g.oswego.edu/dl/html/malloc.html 
	Chunks implemented as in seg regated free list, with 
pointers to pre vious/ne xt chunks in free list in pa yload of 
free b locks 
	Lists seg regated into bins according to siz e; bin siz es 
spaced logar ithmically 
Placement done in best-t order  
	Deferred coalescing and splitting perf ormed to minimiz e 
overhead 
20</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Garba ge collection and memor y allocation
	Prog ram relies on garbage collector to free memor y 
	Garbage collector calls free() 
	malloc() may call garbage collector if memor y allocation 
above a threshold 
25 
 Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.52, Integrating a conservative garbage collector and a C malloc package.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Mark and sweep garba ge collector
27  Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.51, A garbage collector's view of memory as a directed graph.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Allocating data
1. Compute total b lock size (header+pa yload+f ooter) 
2. Locate free b lock large enough to hold data (using rst or 
next t f or speed) 
3. If block found, add data to b lock and split if padding  16 
bytes 
4. Otherwise , inser t a ne w free chunk (e xtending the heap), 
and add data to that 
5. If could not add large enough free chunk, out of memor y 
17</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: C standar d librar y
	Variable argument lists: 
	Declar ation with ... for variable argument list (ma y be of 
any type): 
int printf (const char  fmt, ...); 
	Access using data str ucture va_list ap, initializ ed using 
va_start(), accessed using va_arg(), destro yed at 
end using va_end() 
	Time functions: clock(), time(), difftime(), 
mktime(), asctime(), localtime(), ctime(), 
strftime() 
3</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 11  January 26, 2010
Review 
Dynamic Memor y Allocation 
Designing the malloc() Function 
A Simple Implementation of malloc() 
A Real-W orld Implementation of malloc() 
Using malloc() 
Using valgrind 
Garbage Collection 
4</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Dynamic memor y allocation
	Memor y allocated dur ing runtime 
	Request to map memor y using mmap() function (in 
&lt;sys/mman.h&gt;) 
	Virtual memor y can be retur ned to OS using munmap() 
	Virtual memor y either bac ked by a le/de vice or b y 
demand-z ero memor y:
all bits initializ ed to z ero
  
not stored on disk  
	used f or stac k, heap , uninitializ ed (at compile time) globals 
4</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>The heap
	Heap  pr ivate section of vir tual memor y (demand-z ero) 
used f or dynamic allocation 
	Starts empty , zero-siz ed 
	brk  OS pointer to top of heap , moves upw ards as heap 
grows 
	To resiz e heap , can use sbrk() function: 
void sbrk(int inc); / returns old value of brk_ptr / 
	Functions lik e malloc() and new (in C++) manage heap , 
mapping memor y as needed 
	Dynamic memor y allocators divide heap into b locks 
6</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Splitting and joining blocks
	At allocation, can use entire free block, or part of it, splitting 
the b lock in tw o 
	Splitting reduces inter nal fr agmentation, b ut more 
complicated to implement 
	Similar ly, can join adjacent free b locks dur ing (or after) 
freeing to reduce e xternal fr agmentation 
	To join (coalesce) b locks, need to kno w address of 
adjacent b locks 
	Footer with pointer to head of b lock  enab le successiv e 
block to nd address of pre vious b lock 
14</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Design choices
Data str ucture to tr ack blocks  
 Algor ithm f or positioning a ne w allocation 
 Splitting/joining free b locks 
9</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Explicit free list
	Maintain pointer to head, tail of free list (not in address 
order) 
	When freeing, add free b lock to end of list; set pointer to 
next, pre vious b lock in free list at beginning of pa yload 
section of b lock 
	When allocating, iter ate through free list, remo ve from list 
when allocating b lock 
	For seg regated free lists , allocator maintains arr ay of lists 
for diff erent siz ed free b locks 
19</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Positioning allocations
	Block must be large enough f or allocation 
	First t: start at beginning of list, use rst b lock 
	Next t: start at end of last search, use ne xt block 
	Best t: examines entire free list, uses smallest b lock 
	First t and ne xt t can fr agment beginning of heap , but 
relativ ely fast 
	Best t can ha ve best memor y utilization, b ut at cost of 
examining entire list 
13</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Pointer(s) tomemor ynolonger exist
Trickywhen pointers onheap orreferences arecircular
(think ofcircular linkedlists)
Pointers canbemask edasdata inmemor y;garbage
collector mayfreedata thatisstillreferenced (ornotfree
unref erenced data)
Garba ge collection
	C implements no garbage collector 
	Memor y not freed remains in vir tual memor y until prog ram 
terminates 
	Other languages lik e Java implement garbage collectors to 
free unref erenced memor y 
	When is memor y unref erenced? 
24</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Bloc k structures
11  Figure removed due to copyright restrictions. Please see 
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.37, Format of a simple heap block.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Garba ge collection
	C implements no garbage collector 
	Memor y not freed remains in vir tual memor y until prog ram 
terminates 
	Other languages lik e Java implement garbage collectors to 
free unref erenced memor y 
	When is memor y unref erenced? 
	Pointer(s) to memor y no longer e xist 
	Tricky when pointers on heap or ref erences are circular 
(think of circular link ed lists) 
	Pointers can be mask ed as data in memor y; garbage 
collector ma y free data that is still ref erenced (or not free 
unref erenced data) 
24</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Tracking blocks
	Implicit free list: no data str ucture required 
	Explicit free list: heap divided into x ed-siz e blocks; 
maintain a link ed list of free b locks 
	allocating memor y: remo ve allocated b lock from list 
	freeing memor y: add b lock bac k to free list 
Linked list iter ation in linear time  
	Segregated free list: multiple link ed lists f or blocks of 
different siz es 
	Explicit lists stored within b locks (pointers in pa yload 
section of free b locks) 
10</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Requirements
 Must be ab le to allocate , free memor y in an y order 
 Auxiliar y data str ucture m ust be on heap 
 Allocated memor y cannot be mo ved 
 Attempt to minimiz e fragmentation 
7</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>A simple memor y allocator
	Code in Computer Systems: A Prog rammer s Perspectiv e 
	Payload 8 byte alignment; 16 byte minim um b lock size 
	Implicit free list 
	Coalescence with boundar y tags; only split if remaining 
block space  16 bytes 
15 
 Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.44, Invariant form of the implicit free list.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Mark and sweep garba ge collector
28  Figure removed due to copyright restrictions. Please see
http://csapp.cs.cmu.edu/public/1e/public/figures.html,Figure 10.54, Mark and sweep example.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Other valgrind tools
	Can use to prole code to measure memor y usage , 
identify e xecution bottlenec ks 
	valgrind tools (use name in -tool= ag): 
	cachegrind  counts cache misses f or each line of code 
	callgrind  counts function calls and costs in prog ram 
	massif  tracks overall heap usage 
23</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Fragmentation
	Two types  inter nal and e xternal 
	Internal  b lock size larger than allocated v ariable in b lock 
	Exter nal  free b locks spread out on heap 
	Minimiz e external fr agmentation b y pref erring fewer larger 
free b locks 
8</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Summar y
Topics co vered: 
 Dynamic memor y allocation 
	the heap 
	designing a memor y allocator 
a real w orld allocator  
	Using malloc() 
	Using valgrind 
	Garbage collection 
	mark-and-s weep collector 
	copying collector 
31</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Using valgrind to detect memor y leaks
	A simple tutor ial: http://cs.ecs.baylor.edu/ 
~donahoo/tools/valgrind/ 
	valgrind program pro vides se veral perf ormance tools , 
including memcheck: 
athena% valgrind --tool=memcheck
--leak-check=yes program.o
	memcheck runs prog ram using vir tual machine and tr acks 
memor y leaks 
	Does not tr igger on out-of-bounds inde x errors f or arr ays 
on the stac k 
Athena is MIT's UNIX-based computing environment. OCW does not provide access to it. 
22 11</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>6.087 Lecture 11  January 26, 2010
Review 
Dynamic Memor y Allocation 
Designing the malloc() Function 
A Simple Implementation of malloc() 
A Real-W orld Implementation of malloc() 
Using malloc() 
Using valgrind 
Garbage Collection 
24</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Variables and datatypes, operators.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec02/</lecture_pdf_url>
      <lectureno>2</lectureno>
      <slides>
        <slide>
          <slideno>18</slideno>
          <text>Relational Operator s
Relational oper ators compare tw o oper ands to produce a 
boolean result. In C an y non-z ero v alue (1 b y con vention) is 
considered to be tr ue and 0 is considered to be f alse. 
operator meaning examples 
&gt; greater than 3&gt;2; /evaluates to 1 / 
2.99&gt;3 /e valuates to 0 / 
&gt;= greater than or 
equal to 3&gt;=3; /e valuates to 1 / 
2.99&gt;=3 /e valuates to 0 / 
&lt; lesser than 3&lt;3; /evaluates to 0 / 
A&lt;B/e valuates to 1/ 
&lt;= lesser than or equal 
to 3&lt;=3; /e valuates to 1 / 
3.99&lt;3 /e valuates to 0 / 
16</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Denitions
Datatypes: 
	The datatype of an object in memor y deter mines the set 
of values it can ha ve and what oper ations that can be 
performed on it. 
	Cis a weakly typed language . It allows implicit conversions 
as well as f orced (potentially dangerous) casting. 
Oper ators: 
	Operator s specify ho w an object can be manipulated
(e.g.,, n umer ic vs. string oper ations).
	operators can be unar y(e.g., -,++),binar y (e.g.,
+,-,*,/),ter nary (?:)
3</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Assignment Operator s
Another common e xpression type f ound while prog ramming in 
C is of the type var = var (op) expr 
x=x+1 
 x=x10 
 x=x/2 
C pro vides compact assignment oper ators that can be used 
instead. 
 x+=1 / is the same as x=x+1 / 
 x=1 /is the same as x=x 1/ 
 x=10 / is the same as x=x 10 / 
 x/=2 / is the same as x=x/2 
 x%=2 / is the same as x=x%2 
22</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Increment and decrement operator s
Prex: 
++x is a shor t cut f or x=x+1  
	x is a shor t cut f or x=x1 
	y=++x is a shor t cut f or x=x+1;y=x; . x is evaluate after it is 
incremented. 
	y=x is a shor t cut f or x=x1;y=x; . x is evaluate after it is 
decremented. 
20</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
IAP 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Pop quiz II
 int x=017;int y=12; /is x&gt;y?/ 
 shor t int s=0xFFFF12; / correct? / 
 char c= 1;unsigned c har uc= 1; /correct? / 
 puts("hel"+"lo");puts("hel""lo");/ which is correct? / 
 enum sz{S=0,L=3,XL}; / what is the v alue of XL? / 
 enum sz{S=0,L= 3,XL}; / what is the v alue of XL? / 
13</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Bitwise Operator s
operator meaning examples 
&amp; AND 0x77 &amp; 0x3; /e valuates to 0x3 / 
0x77 &amp; 0x0; /e valuates to 0 / 
| OR 0x700 | 0x33; /evaluates to 0x733 / 
0x070 | 0 /evaluates to 0x070 / 
 XOR 0x770 ^ 0x773; /e valuates to 0x3 / 
0x33 ^ 0x33; /evaluates to 0 / 
 left shift 0x01&lt;&lt;4; /e valuates to 0x10 / 
1&lt;&lt;2; /e valuates to 4 / 
 right shift 0x010&gt;&gt;4; /e valuates to 0x01 / 
4&gt;&gt;1 /e valuates to 2 / 
Notes: 
 AND is tr ue only if both oper ands are tr ue. 
 OR is tr ue if an y oper and is tr ue. 
 XOR is tr ue if onl y one of the oper and is tr ue. 
21</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Big endian vs. little endian
The individual siz es are machine/compiler dependent. 
However, the f ollowing is guar anteed: 
sizeof(c har)&lt;siz eof(shor t)&lt;=siz eof(int)&lt;=siz eof(long) and 
sizeof(c har)&lt;siz eof(shor t)&lt;=siz eof(oat)&lt;=siz eof(doub le) 
"NUXI" prob lem: For numer ic data types that span m ultiple 
bytes, the order of arr angement of the individual b ytes is 
impor tant. Depending on the de vice architecture , we have "big 
endian" and "little endian" f ormats . 
8</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Denitions (contd.)
Expressions: 
	An expression in a prog ramming language is a 
combination of v alues , variables, oper ators , and functions 
Variables: 
	A variable is as named link/ref erence to a v alue stored in 
the system s memor y or an e xpression that can be 
evaluated. 
Consider : int x=0,y=0; y=x+2; . 
	x, y are v ariables 
 y = x +2 is an e xpression
 + is an oper ator.
4</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 2  Jan uary 12, 2010
Review 
Variables and data types 
Oper ators 
Epilogue 
1</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Relational Operator s
Testing eq uality is one of the most commonly used relational
operator 
== operator. 
!= 
Gotchas: meaning 
equal to 
not equal to examples
3==3; / evaluates to 1 /
A==a/ evaluates to 0 /
3!=3; /evaluates to 0 /
2.99!=3 /evaluates to 1 /
Note that the "==" equality oper ator is diff erent from the  
"=", assignment oper ator.
Note that the "==" oper ator on oat v ariables is tr icky
  
because of nite precision. 
17</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Variab le names
Naming r ules: 
	Variable names can contain letters ,digits and _
Variable names should star t with letters .
  
	Keywords (e .g., for,while etc.) cannot be used as v ariable 
names 
	Variable names are case sensitiv e. int x; int X declares 
two diff erent v ariables. 
Pop quiz (correct/incorrect): 
	int mone y$owed; (incorrect: cannot contain $) 
	int total_count (correct) 
	int score2 (correct) 
	int 2ndscore (incorrect: must star t with a letter) 
	int long (incorrect: cannot use k eyword) 
5</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Increment and decrement operator s
Increment and decrement are common ar ithmetic oper ation. C 
provides tw o shor t cuts f or the same . 
Postx 
x++ is a shor t cut f or x=x+1  
	x is a shor t cut f or x=x1 
	y=x++ is a shor t cut f or y=x;x=x+1 . x is evaluated bef ore it is 
incremented. 
	y=x is a short cut for y=x;x=x 1. x is evaluated before it is 
decremented. 
19</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>6.087 Lecture 2  Jan uary 12, 2010
Review 
Variables and data types 
Oper ators 
Epilogue 
14</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>6.087 Lecture 2  Jan uary 12, 2010
Review 
Variables and data types 
Oper ators 
Epilogue 
24</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Constants
Constants are liter al/xed values assigned to v ariables or used 
directly in e xpressions . 
Datatype example meaning 
int i=3; integer 
long l=3; long integer 
integer unsigned long ul= 3UL; unsigned long 
int i=0xA; hexadecimal 
int i=012; octal n umber 
oat pi=3.14159 oat 
oating point oat pi=3.141F oat 
doub le pi=3.1415926535897932384L doub le 
10</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Precedence and Or der of Ev aluation
 ++,,(cast),siz eof ha ve the highest pr iority
 *,/,% ha ve higher pr iority than +,
 ==,!= ha ve higher pr iority than &amp;&amp;,|| 
 assignment oper ators ha ve very low priority 
Use () generously to a void ambiguities or side eff ects 
associated with precendence of oper ators . 
 y=x3+2 / same as y=(x 3)+2/ 
 x!=0 &amp;&amp; y==0 / same as (x!=0) &amp;&amp; (y==0) / 
 d= c&gt;=0&amp;&amp; c&lt;=9/ same as d=(c&gt;=0) &amp;&amp; (c&lt;=9) / 
25</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Numeric data types
Depending on the precision and r ange required, y ou can use 
one of the f ollowing datatypes . 
signed unsigned 
short shor t int x;shor t y; unsigned shor t x;unsigned shor t int y; 
default int x; unsigned int x; 
long long x; unsigned long x; 
oat oat x; N/A 
doub le doub le x; N/A 
char char x; signed c har x; unsigned c har x; 
	The unsigned v ersion has roughly doub le the r ange of its 
signed counter parts. 
	Signed and unsigned char acters diff er only when used in 
arithmetic e xpressions . 
	Titbit: Flickr changed from unsigned long (232  1) to str ing 
two years ago . 
7</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Basics
 Variable declar ations: int i; oat f; 
 Intialization: char c=A; int x=y=10; 
 Oper ators: +,,,/,% 
 Expressions: int x,y,z; x=y2+z3; 
 Function: int factor ial (int n); /function takes int , returns int / 
2</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>6.087 Lecture 2  Jan uary 12, 2010
Review 
Variables and data types 
Oper ators 
Epilogue 
3</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Data types and siz es
C has a small f amily of datatypes . 
 Numer ic (int,oat,doub le) 
 Char acter (char) 
 User dened (str uct,union) 
6</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Big endian vs. little endian (cont.)
	Big endian: the most signicant bits (MSBs) occup y the 
lower address . This representation is used in the po werpc 
processor . Netw orks gener ally use big-endian order , and 
thus it is called netw ork or der. 
	Little endian : the least signcant bits (LSBs) occup y the 
lower address . This representation is used on all x86 
compatib le processors . 
Figure: (from http://en.wikipedia.org/wiki/Little_endian) 
9</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Arithmetic operator s
operator meaning examples 
+ addition x=3+2; /constants/ 
y+z; /variables/ 
x+y+2; /both/ 
- subtr action 32; /constants/ 
int x=yz; /v ariables/ 
y2z; /both/ 
* multiplication int x=32; /constants/ 
int x=yz; /variables/ 
xy2; /both/ 
14</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Arithmetic operator s (contd.)
operator meaning examples 
/ division oat x=3/2; /produces x=1 (int /) / 
oat x=3.0/2 /produces x=1.5 ( oat /) / 
int x=3.0/2; /produces x=1 (int conversion)/ 
% modulus 
(remainder) int x=3%2; /produces x=1/ 
int y=7;int x=y%4; /produces 3/ 
int y=7;int x=y%10; /produces 7/ 
15</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Logical operator s
operator meaning examples 
&amp;&amp; AND ((9/3)==3) &amp;&amp; (23==6); /e valuates to 1 / 
(A==a) &amp;&amp; (3==3) /e valuates to 0 / 
|| OR 2==3 || A==A; /e valuates to 1 / 
2.99&gt;=3 || 0 /evaluates to 0 / 
! NOT !(3==3); /evaluates to 0 / 
!(2.99&gt;=3) /evaluates to 1 / 
Shor t circuit: The e valuation of an e xpression is discontin ued if
the v alue of a conditional e xpression can be deter mined ear ly.
Be careful of an y side eff ects in the code .
Examples:
	(3==3) || ((c=getchar())==y) . The second e xpression is not 
evaluated. 
	(0) &amp;&amp; ((x=x+1)&gt;0) . The second e xpression is not e valuated. 
18</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Conditional Expression
A common patter n in C (and in most prog ramming) languages 
is the f ollowing: 
if ( cond ) 
x=&lt;expra &gt;; 
else 
x=&lt;exprb &gt;; 
C pro vides syntactic sugar to express the same using the 
ternary oper ator ?: 
sign=x&gt;0?1:1; isodd=x%2==1?1:0; 
if (x&gt;0) if ( x%2==1) 
sign =1 isodd=1 
else else 
sign=1 isodd=0 
Notice ho w the ter nary oper ator mak es the code shor ter and 
easier to understand (syntactic sugar). 
23</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: C Programming langua ge
	C is a f ast, small,gener al-pur pose ,platf orm independent 
programming language . 
	C is used f or systems prog ramming (e .g., compilers and 
interpreters , oper ating systems , database systems , 
microcontrollers etc.) 
	C is static (compiled), typed, str uctured and imper ative. 
	"C is quir ky, awed, and an enor mous success ."Ritchie 
1</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Constants (contd.)
Datatype example meaning 
character A 
\x41 
\0101 character 
specied in he x 
specied in octal 
string "hello world" 
"hello""world" string liter al 
same as "hello w orld" 
enumer ation enum BOOL {NO,YES} 
enum COLOR {R=1,G,B,Y=10} NO=0,YES=1 
G=2,B=3 
11</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Declarations
The gener al format f or a declar ation is
type variable-name [=value] .
Examples:
 char x; / uninitializ ed / 
 char x=A; / intializ ed to A/ 
 char x=A,y=B; /multiple v ariables initialized / 
 char x=y=Z;/ multiple initializations / 
12</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Type Con versions
When v ariables are promoted to higher precision, data is 
preser ved. This is automatically done b y the compiler f or mix ed 
data type e xpressions . 
int i;
float f;
f=i +3.14159; /  i is promoted to float , f=(float)i+3.14159  /
Another con version done automatically b y the compiler is char 
int. This allo ws compar isons as w ell as man upilations of 
character v ariables. 
isupper =(c&gt;=A &amp;&amp; c&lt;=Z )?1:0; /  c and literal constants 
are converted to int  / 
if (! isupper ) 
c=ca+A ;/  subtraction is possible 
because of integer conversion  / 
As a r ule (with e xceptions), the compiler promotes each ter m in 
an binar y expression to the highest precision oper and. 
24</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Void and function pointers. Hash tables.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec08/</lecture_pdf_url>
      <lectureno>8</lectureno>
      <slides>
        <slide>
          <slideno>14</slideno>
          <text>Array of function pointer s
The same can be done using an arr ay of function pointers 
instead. 
void ( fp [4])( struct shape ps)=
{&amp;draw_square,&amp;draw_rec,&amp;draw_circle ,&amp;draw_poly };
typedef void ( fp )( struct shape ps) drawfn;
drawfn fp[4] =
{&amp;draw_square,&amp;draw_rec,&amp;draw_circle ,&amp;draw_poly };
void draw ( struct shape ps )
{
( fp [ps&gt;type])(ps); /  call the correct function  / 
} 
13</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Callbac k (cont.) 
Counting nodes: 
void dototal ( void p, void arg ) 
{ 
struct node np=( struct node  )p; 
int  ptotal =( int  )arg ; 
 ptotal += np&gt;data ; 
} 
int total =0; 
apply(phead,dototal ,&amp;total ); 
11</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Callbac k (cont.)
Consider a link ed list with nodes dened as f ollows: 
struct node { 
int data ; 
struct node next ; 
}; 
Also consider the function apply dened as f ollows: 
void apply ( struct node phead , 
void ( fp )( void  , void ), 
void arg) /  only fp has to be named  / 
{ 
struct node p=phead ; 
while ( p !=NULL) 
{ 
fp(p,arg); /  can also use ( fp )(p,arg)  / 
p=p&gt;next ; 
} 
} 
9</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Hash tab le
Hash tab les (hashmaps) combine link ed list and arr ays to 
provide an efcient data str ucture f or stor ing dynamic data. 
Hash tab les are commonly implemented as an arr ay of link ed 
lists (hash tab les with chaining). 
keys
John Smith
Lisa Smith
Sam Doe
Sandra Dee
Ted Baker
buckets
000
001
002
:
:
151
152
153
154
:
:
253
254
255
entries
Lisa Smith
521-8976
John Smith
521-1234
Sandra Dee
521-9655
Ted Baker
418-4165
Sam Doe
521-5030
Figure: Example of a hash tab le with chaining (source: wikipedia) 
14</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Array of function pointer s
Example:Consider the case where diff erent functions are called 
based on a v alue. 
enum TYPE{SQUARE,RECT,CIRCILE ,POLYGON}; 
struct shape { 
float params[MAX] ; 
enum TYPE type ; 
};
void draw ( struct shape ps )
{
switch ( ps&gt;type ) 
{ 
case SQUARE: 
draw_square(ps ); break ; 
case RECT: 
draw_rect (ps ); break ; 
... 
} 
} 
12</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Review: Expressions
 Inx: (A+B) *(C-D) 
 prex: *+AB-CD 
 postx: AB+CD-* 
4</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Callbac ks
Denition: Callbac k is a piece of e xecutab le code passed to
functions . In C, callbac ks are implemented b y passing function
pointers .
Example:
void qsor t(void arr, int num,int siz e,int (fp )(void pa,voidpb))
	qsort() function from the standard libr ary can be sor t an 
array of an y datatype . 
	Question: How does it do that? callbac ks. 
	qsort() calls a function whene ver a compar ison needs to 
be done . 
	The function tak es tw o arguments and retur ns (&lt;0,0,&gt;0) 
depending on the relativ e order of the tw o items . 
7</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Hash tab le: example
struct wordrec  lookup ( const char str , int create ) 
{ 
struct wordrec curr =NULL; 
unsigned long hash= hashstring(str ); 
struct wordrec wp= table [hash]; 
for (curr =wp;curr!=NULL ;curr =curr &gt;next ) 
/  search  /; 
notfound : 
if ( create ) 
/  add to front  / 
return curr ; 
} 
19</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Callbac k (cont.)
int arr [] ={10 ,9 ,8 ,1 ,2 ,3 ,5}; 
/  callback  / 
int asc ( void pa , void pb ) 
{ 
return ( ( int  ) pa  ( int  )pb ); 
} 
/  callback  / 
int desc ( void pa , void pb ) 
{ 
return ( ( int  ) pb  ( int  )pa ); 
} 
/  sort in ascending order  / 
qsort ( arr , sizeof ( arr )/ sizeof ( int ), sizeof ( int ) ,asc); 
/  sort in descending order  / 
qsort ( arr , sizeof ( arr )/ sizeof ( int ), sizeof ( int ) ,desc); 
8</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 8  Jan uary 21, 2010
Review 
Pointers 
Void pointers 
Function pointers 
Hash tab le 
1</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Hash tab le
	Each data item is associated with a k ey that deter mines its 
location. 
	Hash functions are used to gener ate an e venly distr ibuted 
hash v alue.
A hash collision is said to occur when tw o items ha ve the
  
same hash v alue. 
	Items with the same hash k eys are chained 
	Retrieving an item is O (1) operation. 
15</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: Stac ks
LIFO: last in rst out data str ucture .  
items are inser ted and remo ved from the same end. 
 operations: push(),pop(),top()
 can be implemented using arr ays, linked list 
2</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Hash tab le: example
unsigned long hashstring ( const char str ) 
{ 
unsigned long hash =0; 
while ( str ) 
{ 
hash= hashMULTIPLIER+ str ; 
str ++; 
} 
return hash%MAX_BUCKETS; 
} 
18</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: Queues
FIFO: rst in rst out  
items are inser ted at the rear and remo ved from the front. 
 operations: queue(),dequeue()
 can be implemented using arr ays, linked list 
3</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Callbac k (cont.)
Iterating: 
struct node phead ; 
/  populate somewhere  / 
void print ( void p, void arg ) 
{ 
struct node np =( struct node  )p; 
printf ( "%d " ,np&gt;data ); 
} 
apply(phead,print ,NULL); 
10</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>6.087 Lecture 8  Jan uary 21, 2010
Review 
Pointers 
Void pointers 
Function pointers 
Hash tab le 
14</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Hash tab le: example
#define MAX_BUCKETS 1000 
#define MULTIPLIER 31 
struct wordrec 
{ 
char word ;
unsigned long count ;
struct wordrec next ;
}; 
/  hash bucket  / 
struct wordrec  table [MAX_LEN]; 
17</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6.087 Lecture 8  Jan uary 21, 2010
Review 
Pointers 
Void pointers 
Function pointers 
Hash tab le 
5</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Void pointer s
C does not allo w us to declare and use v oid v ariab les.  
	void can be used only as retur n type or par ameter of a 
function. 
	C allo ws void pointer s 
	Question: What are some scenar ios where y ou w ant to 
pass v oid pointers? 
	void pointers can be used to point to an y data type 
	int x; void p=&amp;x; / points to int / 
	oat f;void p=&amp;f; /points to oat / 
	void pointers cannot be deref erenced. The pointers should 
always be cast bef ore deref erencing. 
void p; printf ("%d", p); / invalid / 
void p; int px=(int )p; printf ("%d", px); /valid / 
5</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review:Pointer s
 pointers: int x; int p=&amp;x; 
 pointers to pointer : int x; int p=&amp;x;int  pp=&amp;p; 
 Array of pointers: char names[]={"abba","u2"}; 
 Multidimensional arr ays: int x [20][20]; 
1</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Function pointer s
	In some prog ramming languages , functions are rst class 
variables (can be passed to functions , retur ned from 
functions etc.). 
	In C, function itself is not a v ariable. But it is possib le to 
declare pointer to functions . 
	Question: What are some scenar ios where y ou w ant to 
pass pointers to functions? 
	Declar ation e xamples: 
	int (fp )( int )/notice the () / 
	int (fp )(void,void) 
	Function pointers can be assigned, pass to and from 
functions , placed in arr ays etc. 
6</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Hash tab les
Hash functions: 
	A hash function maps its input into a nite r ange: hash 
value, hash code . 
	The hash v alue should ideally ha ve unif orm distr ibution. 
why? 
	Other uses of hash functions: cryptog raphy, caches 
(computers/inter net), b loom lters etc. 
	Hash function types: 
	Division type 
	Multiplication type 
	Other w ays to a void collision: linear probing, doub le 
hashing. 
16</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>Pointers and memory addressing. Arrays and pointer arithmetic. Strings. Searching and sorting algorithms.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec05/</lecture_pdf_url>
      <lectureno>5</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>6.087 Lecture 5  January 15, 2010
Review 
Pointers and Memor y Addresses 
Physical and Vir tual Memor y 
Addressing and Indirection 
Functions with Multiple Outputs 
Arrays and P ointer Ar ithmetic 
Strings 
String Utility Functions 
Searching and Sor ting Algor ithms 
Linear Search 
A Simple Sor t 
Faster Sor ting 
Binar y Search 
5</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Sear ching and sorting
 Basic algor ithms 
 Can mak e good use of pointers 
 Just a f ew examples; not a course in algor ithms 
 Big-O notation 
21</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Sear ching an array
	Suppose w e have an arr ay of int s 
int arr [100]; / array to search / 
	Lets write a simple search function: 
int linear _search ( int val) {  
int parr, parrend = arr + array _length(arr);   
for (parr = arr; parr &lt; parrend; parr++) { 
if ( parr == val ) 
return parr ;
}
return NULL;
} 
22</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>More string utility functions
	Concatenation functions: strcat(), strncat() 
char  strcat (strto,strfrom ); add strfrom to end of strto 
char  strncat(strto,strfrom ,n); add n chars from strfrom to 
end of strto 
	Search functions: strchr(), strrchr() 
char  strchr (str,c);  nd char c in str, retur n pointer to 
rst occurrence , or NULL if not f ound 
char  strrchr (str,c); ndchar c in str, retur n pointer to 
last occurrence , or NULL if not f ound 
	Many other utility functions e xist. . . 
20</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Pointer arithmetic
	Suppose int pa = arr; 
	Pointer not an int, b ut can add or subtr act an int from a 
pointer : 
pa + i points to arr[i] 
	Address v alue increments b y i times siz e of data type 
Suppose arr[0] has address 100. Then arr[3] has 
address 112. 
	Suppose char  pc= (char )pa; What v alue of i satises 
(int )(pc+i) == pa + 3 ? 
i = 12  
17</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Quic ksor t
	Many faster sor ts availab le (shellsor t, mergesor t, 
quicksort, . . . ) 
	Quicksort: O(n log n) average; O (n2) worst case 
	choose a piv ot element 
	move all elements less than piv ot to one side , all elements 
greater than piv ot to other 
	sort sides individually (recursiv e algor ithm) 
	Implemented in C standard libr ary as qsort() in 
stdlib.h 
26</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: Unconditional jumps
 goto keyword: jump some where else in the same function 
 Position identied using labels 
 Example ( for loop) using goto: 
{
int i=0, n=20; /  initialization  /
goto loop_cond ;
loop_body : 
/  body of loop here  / 
i ++;
loop_cond :
if (i &lt;n) /  loop condition  /
goto loop_body ;
}
 Excessiv e use of goto results in spaghetti code 
1</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 5  January 15, 2010
Review 
Pointers and Memor y Addresses 
Physical and Vir tual Memor y 
Addressing and Indirection 
Functions with Multiple Outputs 
Arrays and P ointer Ar ithmetic 
Strings 
String Utility Functions 
Searching and Sor ting Algor ithms 
Linear Search 
A Simple Sor t 
Faster Sor ting 
Binar y Search 
1</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Virtual memor y
	How much ph ysical memor y do I ha ve? 
Answer: 2 MB (cache) + 2 GB (RAM) + 100 GB (hard 
drive) + . .. 
	How much vir tual memor y do I ha ve? 
Answer: &lt;4 GB (32-bit OS), typically 2 GB f or Windo ws, 
3-4 GB f or lin ux 
	Virtual memor y maps to diff erent par ts of ph ysical memor y 
	Usab le par ts of vir tual memor y: stack and heap 
	stack: where declared v ariables go 
	heap: where dynamic memor y goes 
8</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Summar y
Topics co vered: 
 Pointers: addresses to memor y 
 physical and vir tual memor y 
 arrays and str ings 
 pointer ar ithmetic 
 Algor ithms 
 searching: linear , binar y 
 sorting: inser tion, quic k 
33</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Pointer s and addresses
	Pointer : memor y address of a v ariable 
	Address can be used to access/modify a v ariable from 
anywhere 
	Extremely useful, especially f or data str uctures 
	Well kno wn for obfuscating code 
5</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>6.087 Lecture 5  January 15, 2010
Review 
Pointers and Memor y Addresses 
Physical and Vir tual Memor y 
Addressing and Indirection 
Functions with Multiple Outputs 
Arrays and P ointer Ar ithmetic 
Strings 
String Utility Functions 
Searching and Sor ting Algor ithms 
Linear Search 
A Simple Sor t 
Faster Sor ting 
Binar y Search 
15</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Binar y search
	Binar y search: O(log n) average, worst case: 
int binary_search ( int val) {  
unsigned i n t L = 0, R = array _length(arr), M; 
while (L &lt;R) { 
M = (L+R 1)/2; 
if (val == arr [M]) 
return arr+M; /  found  / 
else if (val &lt; arr [M]) 
R=M; /  in first half  / 
else 
L	= M+1; /  in second half  / 
} 
return NULL; /  not found  / 
} 
31</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Functions with multiple outputs
	Consider the Extended Euclidean algor ithm 
ext_euclid(a,b) function from W ednesda ys lecture 
	Retur ns gcd(a, b), x and y s.t. ax + by = gcd(a, b) 
	Used global v ariables for x and y 
	Can use pointers to pass bac k multiple outputs: 
int ext_euclid (int a, int b, int x, int y); 
	Calling ext_euclid(), pass pointers to v ariables to 
receiv e x and y:
int x, y, g;
/  assume a, b declared previously  / 
g	= ext _euclid(a,b,&amp;x,&amp;y); 
	Warning about x and y being used bef ore initializ ed 
12</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Shifting out-of-or der elements
 Code f or shifting the element 
/  move previous elements down until
insertion point reached  /
void shift _element ( unsigned i n t i) {
int ivalue ;
/  guard against going outside array  / 
for (ivalue = arr[i]; i &amp;&amp; arr[i 1] &gt; ivalue; i ) 
arr[i] = arr[i 1]; /  move element down  / 
arr[i] = ivalue; /  insert element  / 
} 
24</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Addressing variab les
	Every variable residing in memor y has an address! 
What doesnt ha ve an address?  
	register v ariables 
	constants/liter als/preprocessor denes 
	expressions (unless result is a v ariable) 
	How to nd an address of a v ariable? The &amp; operator 
int n= 4;
double pi = 3.14159;
int pn =&amp;n; /  address of integer n  /
double  ppi =&amp;pi; /  address of double pi  /
	Address of a v ariable of type t has type t * 
9</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Accessing caller s variab les
 Want to wr ite function to s wap tw o integers 
 Need to modify v ariables in caller to s wap them 
 Pointers to v ariables as arguments 
void swap( int x, int y) {
int temp = x;
x= y;
y = temp ;
} 
 Calling swap() function: 
int a= 5, b= 7;
swap(&amp;a, &amp;b);
/  now, a=7, b=5  / 
13</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>6.087 Lecture 5  January 15, 2010
Review 
Pointers and Memor y Addresses 
Physical and Vir tual Memor y 
Addressing and Indirection 
Functions with Multiple Outputs 
Arrays and P ointer Ar ithmetic 
Strings 
String Utility Functions 
Searching and Sor ting Algor ithms 
Linear Search 
A Simple Sor t 
Faster Sor ting 
Binar y Search 
21</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Quic ksor t implementation
	Restore the piv ot; sor t the sides separ ately: 
/  restore pivot position  / 
swap(arr+left , arr+mid); 
/  sort two sides  / 
if (mid &gt; left) 
quick _sort(left , mid 1); 
if (mid &lt; right ) 
quick _sort(mid+1,right ); 
} 
	Starting the recursion:
quick_sor t(0, array_length( arr)  1);
[Kernighan and Ritchie . The C Prog ramming Language . 2nd ed. Prentice 
Hall, 1988.] 
 Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license. 
For more information, see http://ocw.mit.edu/fairuse. 
28</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>i=12
Pointer arithmetic
	Suppose int pa = arr; 
	Pointer not an int, b ut can add or subtr act an int from a 
pointer : 
pa + i points to arr[i] 
	Address v alue increments b y i times siz e of data type 
Suppose arr[0] has address 100. Then arr[3] has 
address 112. 
	Suppose char  pc= (char )pa; What v alue of i satises 
(int )(pc+i) == pa + 3 ? 
17</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Pointer invalidafter variablepasses outofscope
Variab les passing out of scope
	What is wrong with this code? 
#include &lt;stdio .h&gt; 
char get_message ( ) {  
char msg[] = "Arent pointers fun?" ; 
return msg; 
} 
int main ( void ){
char string = get_message();
  
puts(string );
return 0;
}
14</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Discussion of quicksor t
	Not stab le (equal-v alued elements can get s witched) in 
present f orm 
	Can sor t in-place  especially desir able for low-memor y 
environments 
	Choice of piv ot inuences perf ormance; can use r andom 
pivot 
	Divide and conquer algor ithm; easily par alleliz eable 
	Recursiv e; in w orst case , can cause stac k overow on 
large arr ay 
29</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>The sizeof() operator
	For primitiv e types/v ariables, size of type in b ytes: 
int s= sizeof(c har); / == 1 / 
doub le f; / sizeof(f) ==8 /(64-bit OS) 
	For primitiv e arrays, size of arr ay in b ytes: 
int arr [8]; / sizeof(arr) == 32 /(64-bit OS) 
long arr [5]; / sizeof(arr) == 40 /(64-bit OS) 
	Array length: 
/  needs to be on one line when implemented  / 
#define array _length(arr) ( sizeof (arr) == 0? 
0	: sizeof ( arr )/ sizeof ((arr )[0])) 
	More about sizeof() next week. . . 
16</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Review: Strings and character arrays
	Strings represented in C as an arr ay of char acters ( char []) 
	String m ust be n ull-ter minated (\0 at end) 
Declar ation:  
char str[] = "I am a string."; or
char str[20] = "I am a string.";
	strcpy() -function f or cop ying one str ing to another 
	More about str ings and str ing functions toda y. . . 
4</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>6.087 Lecture 5  January 15, 2010
Review 
Pointers and Memor y Addresses 
Physical and Vir tual Memor y 
Addressing and Indirection 
Functions with Multiple Outputs 
Arrays and P ointer Ar ithmetic 
Strings 
String Utility Functions 
Searching and Sor ting Algor ithms 
Linear Search 
A Simple Sor t 
Faster Sor ting 
Binar y Search 
18</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>String utility functions
	String functions in standard header string.h 
	Copy functions: strcpy(), strncpy() 
char  strcp y(strto,strfrom ); copy strfrom to strto 
char  strncpy(strto,strfrom ,n); copy n chars from strfrom 
to strto 
	Compar ison functions: strcmp(), strncmp() 
int strcmp(str1 ,str2);  compare str1, str2; retur n 0 if 
equal, positiv e if str1&gt;str2, negativ e if str1&lt;str2 
int strncmp(str1, str2,n);  compare rst n chars of str1 and 
str2 
	String length: strlen() 
int strlen ( str );  get length of str 
19</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Sear ching a sorted array
	Searching an arbitr ary list requires visiting half the 
elements on a verage 
	Suppose list is sor ted; can mak e use of sor ting 
information: 
	if desired v alue g reater than v alue and current inde x, only 
need to search after inde x 
	each compar ison can split list into tw o pieces 
	solution: compare against middle of current piece; then 
new piece guar anteed to be half the siz e 
	divide and conquer! 
	More searching ne xt week. . . 
30</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Variab les passing out of scope
 What is wrong with this code? 
#include &lt;stdio .h&gt;
char get_message ( ) {
  
char msg[] = "Arent pointers fun?" ; 
return msg; 
} 
int main ( void ){
char string = get_message();
  
puts(string );
return 0;
} 
 Pointer in valid after v ariable passes out of scope 
14</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Arrays and pointer s
	Primitiv e arrays implemented in C using pointer to b lock of 
contiguous memor y 
	Consider arr ay of 8 ints: 
int arr [8]; 
	Accessing arr using arr ay entr y oper ator: 
int a = arr [0]; 
	arr is like a pointer to element 0 of the arr ay: 
int pa = arr; int pa = &amp;arr [0];  
	Not modiab le/reassignab le like a pointer 
15</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Binar y search
	Worst case: logar ithmic time 
	Requires r andom access to arr ay memor y 
 on sequential data, lik e hard dr ive, can be slo w 
	seeking bac k and f orth in sequential memor y is w asteful 
	better off doing linear search in some cases 
	Implemented in C standard libr ary as bsearch() in 
stdlib.h 
32</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>A simple sort
	A simple inser tion sor t: O(n2) 
	iterate through arr ay until an out-of-order element f ound 
inser t out-of-order element into correct location  
	repeat until end of arr ay reached 
	Split into tw o functions f or ease-of-use 
int arr [100]; /  array to sort  / 
void shift _element ( unsigned i n t i) { 
/  do insertion of outoforder element  / 
} 
void insertion _sort () { 
/  main insertion sort loop  /
/  call shift _element () for
each outoforder element  /
} 
23</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: I/O Functions
	I/O pro vided b y stdio.h, not language itself 
	Char acter I/O: putchar(), getchar(), getc(), 
putc(), etc. 
	String I/O: puts(), gets(), fgets(), fputs(), etc. 
	Formatted I/O: fprintf(), fscanf(), etc. 
	Open and close les: fopen(), fclose() 
	File read/wr ite position: feof(), fseek(), ftell(), etc. 
...  
2</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Physical and virtual memor y
	Physical memor y: physical resources where data can be 
stored and accessed b y your computer
cache
 
RAM 
hard disk  
	remo vable stor age 
	Virtual memor y: abstr action b y OS , addressab le space 
accessib le by your code 
6</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Deref erencing pointer s
	I have a pointer  no w what? 
	Accessing/modifying addressed v ariable: 
deref erencing/indirection oper ator * 
/  prints "pi = 3.14159\n "  / 
printf ( "pi = %g\n" , ppi ); 
/  pi now equals 7.14159  / 
 ppi =  ppi + pn ; 
	Deref erenced pointer lik e any other v ariable 
	null pointer , i.e. 0(NULL): pointer that does not ref erence 
anything 
10</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Casting pointer s
	Can e xplicitly cast an y pointer type to an y other pointer 
type 
ppi =(doub le )pn; / pn originally of type ( int ) / 
	Implicit cast to/from void * also possib le (more ne xt 
week. . . ) 
	Deref erenced pointer has ne w type , regardless of real type 
of data 
	Possib le to cause segmentation f aults , other 
difcult-to-identify errors 
	What happens if w e deref erence ppi now? 
11</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Inser tion sort
	Main inser tion sor t loop 
/ 	iterate until outoforder element found ; 
shift the element , and continue iterating  / 
void insertion _sort ( void ){
unsigned i n t i, len = array _length(arr);
for (i =1; i&lt;len; i++)
if (arr[i] &lt; arr[i 1])
shift _element(i );
}
	Can y ou re write using pointer ar ithmetic instead of 
indexing? 
25</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Quic ksor t implementation
 Select the piv ot; separ ate the sides: 
void quick_sort ( unsigned i n t left , 
unsigned i n t right ) {
unsigned i n t i , mid;
int pivot ;
if (left &gt;= right)
return ;/  nothing to sort  /
/  pivot is midpoint; move to left side  /
swap(arr+left ,arr + (left+right)/2);
pivot = arr[mid = left ];
/ 	separate into side &lt; pivot (left+1 to mid) 
and side &gt;= pivot (mid+1 to right )  / 
for (i = left+1; i &lt;= right; i++)
if (arr[i] &lt; pivot)
swap(arr + ++mid,arr + i);
[Kernighan and Ritchie . The C Prog ramming Language . 2nd ed. Prentice 
Hall, 1988.]	 Prentice Hall. All rights reserved. This content is excluded from our Creative Commons license. 
For more information, see http://ocw.mit.edu/fairuse. 
27</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Strings as arrays
	Strings stored as n ull-ter minated char acter arr ays (last 
character == \0) 
	Suppose char str[] = "This is a string."; and 
char  pc= str; 
	Manipulate str ing as y ou w ould an arr ay 
(pc+10) = S; 
puts(str ); / prints "This is a String ." / 
18</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Physical memor y considerations
	Different siz es and access speeds 
	Memor y management  major function of OS 
	Optimization  to ensure y our code mak es the best use of 
physical memor y availab le 
	OS mo ves around data in ph ysical memor y dur ing 
execution 
	Embedded processors  ma y be v ery limited 
7</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Review: printf() and scanf()
	Formatted output: 
int printf (char format[], arg1, arg2, ...) 
	Takes variable number of arguments 
	Format specication: 
%[flags][width][.precision][length]&lt;type&gt; 
	types: d, i (int), u, o , x, X (unsigned int), e , E, f, F, g, G 
(doub le), c (char), s (str ing) 
	ags , width, precision, length -modify meaning and number 
of char acters pr inted 
	Formatted input: scanf() -similar f orm, tak es pointers to 
arguments (e xcept str ings), ignores whitespace in input 
3</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
    <lecture>
      <lecture_title>User-defined datatypes, structs, unions, bitfields. Memory allocation. Linked lists, binary trees.</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-087-practical-programming-in-c-january-iap-2010/resources/mit6_087iap10_lec06/</lecture_pdf_url>
      <lectureno>6</lectureno>
      <slides>
        <slide>
          <slideno>5</slideno>
          <text>Structure
Denition: A structure is a collection of related v ariables (of
possib ly diff erent types) g rouped together under a single name .
This is a an e xample of compositionb uilding comple x
structures out of simple ones .
Examples:
struct employee 
struct p o i n t { 
{ char fname [ 1 0 0 ] ; 
i n t x ; char lname [ 1 0 0 ] ; 
i n t y ; i n t age ; 
} ; } ; 
/  n o t i c e the ; at the end  / /  members of d i f f e r e n t 
type  / 
4</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Structure
	struct denes a ne w datatype . 
	The name of the str ucture is optional. 
struct {...} x,y,z;
The v ariables declared within a str ucture are called its
  
members 
	Variables can be declared lik e any other b uilt in data-type . 
struct point ptA; 
	Initialization is done b y specifying v alues of e very member . 
struct point ptA={10,20}; 
	Assignment oper ator copies e very member of the str ucture 
(be careful with pointers). 
5</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Binary tree (cont.) 
Add node: 
struct tnode  addnode ( struct tnode  root , int data ) 
{ 
struct tnode  p=NULL; 
/  termination condition  / 
if ( root ==NULL) 
{ 
/  allocate node  / 
/  return new root  / 
} 
/  recursive call  / 
else if (data&lt; root &gt;data ) 
root &gt;le f t =addnode( root &gt;left ,data) 
else 
root &gt;right =addnode( root &gt;right ,data) 
} 
22</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Size of structures
	The siz e of a str ucture is g reater than or equal to the sum 
of the siz es of its members . 
	Alignment 
struct {
char c;
/  padding  / 
int i; 
	Why is this an impor tant issue? libraries, precompiled les , 
SIMD instr uctions . 
	Members can be e xplicitly aligned using compiler 
extensions . 
__attr ibute__ ((aligned (x))) /gcc/ 
__declspec((aligned(x ))) /MSVC / 
10</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Sear ching and sor ting
Searching 
 Linear search: O(n) 
 Binar y search: O(logn). The arr ay has to be sor ted rst. 
Sorting 
 Inser tion sor t: O(n2) 
 Quick sor t: O(n log n) 
3</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Review: string.h
 String cop y: strcpy(),strncpy() 
 Compar ison: strcmp(),strncmp() 
 Length: strlen() 
 Concatenation: strcat() 
 Search: strchr(),strstr() 
2</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Linked list
Denition: A dynamic data str ucture that consists of a 
sequence of records where each element contains a link to the 
next record in the sequence . 
	Linked lists can be singly linked, doub ly linked or circular. 
For no w, we will f ocus on singly linked list. 
	Every node has a pa yload and a link to the ne xt node in 
the list. 
	The star t (head) of the list is maintained in a separ ate
variable.
	End of the list is indicated b y NULL (sentinel). 
12
99
37
15</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Linked list
struct node 
{ 
int data; /  payload  / 
struct node next ; 
};
struct node head; /  beginning  /
Linked list vs . arrays 
linked-list array 
size dynamic xed 
indexing O(n) O(1) 
inser ting O(1) O(n) 
deleting O(1) O(n) 
16</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Bit elds
Denition: A bit-eld is a set of adjacent bits within a single 
word. Example: 
struct flag {
unsigned i n t is _color :1;
unsigned i n t has_sound : 1 ;
unsigned i n t is _ntsc :1;
};
 the n umber after the colons species the width in bits . 
 each v ariables should be declared as unsigned int 
Bit elds vs. masks 
CLR=0x1,SND=0x2,NTSC=0x4; struct ag f; 
x|= CLR; x|=SND; x|=NTSC f.has_sound=1;f.is_color=1; 
x&amp;= ~CLR; x&amp;=~SND; f.has_sound=0;f.is_color=0; 
if (x &amp; CLR || x&amp; NTSC) if (f.is_color || f.has_sound) 
13</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Arrays of structures
	Declar ing arr ays of int: int x[10]; 
	Declar ing arr ays of str ucture: struct point p[10]; 
	Initializing arr ays of int: int x [4]={0,20,10,2}; 
	Initializing arr ays of str ucture: 
struct point p[3]={0,1,10,20,30,12}; 
struct point p [3]={{0,1},{10,20},{30,12}}; 
9</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms. 
MIT OpenCourseWare
http://ocw.mit.edu  
6.087 Practical Programming in C
January (IAP) 2010
For information about citing these materials or our Terms of Use,visit: http://ocw.mit.edu/terms.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.087 Lecture 6  Jan uary 19, 2010
Review 
User dened datatype 
Structures 
Unions 
Bitelds 
Data str ucture 
Memor y allocation 
Linked lists 
Binar y trees 
1</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Unions (cont.)
	The siz e of the union v ariable is equal to the siz e of its 
largest element. 
	Impor tant: The compiler does not test if the data is being 
read in the correct f ormat. 
union data d; d .idata =10; oat f=d.fdata ; / will give junk/ 
	A common solution is to maintain a separ ate v ariable. 
enum dtype {INT ,FLOAT,CHAR};
struct variant
{
union data d;
enum dtype t ;
};
12</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Binar y tree (cont.)
struct tnode 
{ 
int data; /  payload  / 
struct tnode  left ; 
struct tnode  right ; 
}; 
The oper ation on trees can be fr amed as recursiv e oper ations . 
Traversal (printing, 
searching): 
	pre-order : root, left
subtree , right subtree
	Inorder : left subtree , root,
right subtree
	post-order : right subtree ,
right subtree , root
3
1 8
0 2 6 9
5
21</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Union
A union is a v ariable that ma y hold objects of diff erent 
types/siz es in the same memor y location. Example: 
union data 
{ 
int idata ; 
float fdata ; 
char sdata ; 
} d1,d2,d3; 
d1. idata=10; 
d1. fdata=3.14F; 
d1. sdata="hello world" ; 
11</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Review: pointer s
	Pointers: memor y address of v ariables 
	&amp; (address of) oper ator. 
	Declar ing: int x=10; int  px= &amp;x; 
	Deref erencing: px=20; 
Pointer ar ithmetic:  
	sizeof() 
	incrementing/decrementing 
	absolute value after operation depends on pointer datatype . 
1</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Linked list
Iterating:
for ( p=head ; p!=NULL; p=p&gt;next )
/  do something  / 
for ( p=head ; p&gt;next !=NULL;p=p&gt;next ) 
/  do something  / 
19</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Digression: dynamic memor y allocation
void malloc(siz e_t n) 
	malloc() allocates b locks of memor y 
	returns a pointer to unitializ ed block of memor y on 
success
returns NULL on f ailure .
  
	the returned value should be cast to appropr iate type using 
(). int ip=(int)malloc(siz eof(int)100) 
void calloc (size_t n,size_t size) 
	allocates an arr ay of n elements each of which is  size
bytes.
 initializ es memor y to 0 
void free(void) 
	Frees memor y allocated m y malloc() 
	Common error : accessing memor y after calling free 
14</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Binar y trees
	A binar y tree is a dynamic data str ucture where each node 
has at most tw o children. A binar y sear ch tree is a binar y 
tree with order ing among its children. 
	Usually , all elements in the left subtree are assumed to be 
less than the root element and all elements in the r ight 
subtree are assumed to be "g reater" than the root element. 
3
1 8
0 2 6 9
5
20</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>6.087 Lecture 6  Jan uary 19, 2010
Review 
User dened datatype 
Structures 
Unions 
Bitelds 
Data str ucture 
Memor y allocation 
Linked lists 
Binar y trees 
4</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Structure pointer s
	Structures are copied element wise . 
	For large str uctures it is more efcient to pass pointers . 
void foo(struct point  pp); struct point pt; foo(&amp;pt ) 
	Members can be accesses from str ucture pointers using 
-&gt; oper ator. 
struct point p={10,20};
struct point  pp=&amp;p ;
pp&gt;x =10; /  changes p . x  /
int y= pp&gt;y; /  same as y=p.y  /
Other w ays to access str ucture members? 
struct point p={10,20}; 
struct point  pp=&amp;p ; 
( pp).x = 10; /  changes p . x  / 
int y= ( pp).y; /  same as y=p.y  / 
why is the () required? 
8</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>;Structure (cont.)
More e xamples: 
struct triangle struct chain_element
{
 {
struct point ptA;
 int data ;
struct point ptB;
 struct chain_element  next 
struct point ptC; };
};
 /  members can be
/  members can be structures  / self referential  /
6</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Linked list
Adding elements to front: 
struct node addfront ( struct node head , int data ) 
{ 
struct node p= nalloc (data ); 
if ( p==NULL) return head ; 
p&gt;next=head ; 
return p; 
18</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>6.087 Lecture 6  Jan uary 19, 2010
Review 
User dened datatype 
Structures 
Unions 
Bitelds 
Data str ucture 
Memor y allocation 
Linked lists 
Binar y trees 
14</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Linked list
Creating ne w element: 
struct node nalloc ( int data ) 
{ 
struct node p=( struct node  ) malloc ( sizeof (node )) ; 
if ( p!=NULL) 
{ 
p&gt;data=data ; 
p&gt;next=NULL;
}
return p;
} 
17</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Structure (cont.)
	Individual members can be accessed using .  operator. 
struct point pt={10,20}; int x=pt.x; int y=pt.y; 
	If structure is nested, m ultiple .  are required 
struct rectangle 
{
struct point tl; /  top left  /
struct point br; /  bot right  /
};
struct rectangle rect ;
int tlx= rect.tl.x; /  nested  /
int tly= rect. tl .y;
7</text>
        </slide>
      </slides>
      <videos/>
    </lecture>
  </lectures>
</doc>
