<doc>
  <source>MIT</source>
  <date>28/01/2023</date>
  <course>
    <course_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/</course_url>
    <course_title>Computer Graphics</course_title>
    <course_tags>
      <list>Engineering </list>
      <list>Computer Science </list>
      <list>Programming Languages </list>
    </course_tags>
  </course>
  <lectures>
    <lecture>
      <lecture_title>Implicit Integration, Collision Detection (PDF - 1.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec09/</lecture_pdf_url>
      <lectureno>09</lectureno>
      <slides>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; So far, we have seen explicit Euler 
&#8211;X(t+h) = X(t) + h X&#8217;(t) 
 
&#8226; We also saw midpoint and trapezoid methods 
&#8211; They took small Euler steps, re-evaluated X&#8217; there, and 
used some combination of these to step away from the 
original X(t). 
&#8211; Yields higher accuracy, but not impervious to stiffness 
(twice the speed limit of Euler) 
22 Explicit Integration </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Remember our model problem:  x&#8217; = -kx 
&#8211; Exact solution was a decaying exponential x0 e-kt 
 
&#8226; Explicit Euler: x(t+h) = (1- hk) x(t) 
&#8211; Here we got the bounds on h  to avoid oscillation/explosion 
26 Simple Closed Form Case </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226;x&#8217;=-kx 
&#8226; First half Euler step: xm=x-0.5 hkx = x(1-0.5 hk) 
&#8226; Read derivative at xm: fm=-kxm=-k(1-0.5 hk)x 
&#8226; Apply derivative at origin:  
x(t+h)=x+hfm = x-hk(1-0.5hk)x =x(1-hk+0.5 h2k2) 
&#8226; Looks a lot like Taylor... 
&#8226; We want 0&lt;x(t+h )/x(t)&lt;1 
-hk+0.5 h2k2 &lt; 0 
hk(-1+0.5 hk)&lt;0 
For positive values of h &amp; k =&gt;  h &lt;2/k 
&#8226; Twice the speed limit of Euler
 
19 Midpoint Speed Limit </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>&#8226; Axis Aligned Bounding Boxes 
&#8211;&#8220;R-Trees&#8221; 
 
&#8226; Oriented bounding boxes 
&#8211;  S. Gottschalk, M. Lin, and D. Manocha . &#8220;OBBTree: A hierarchical Structure 
for rapid interference detection,&#8221; Proc. Siggraph 96. ACM Press, 1996 
 
&#8226; Binary space partitioning trees; kd-trees  
88 Other Options </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Forward Euler Implementation 
  class ForwardEuler : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   newPositions = positions + h*velocities 
   newVelocities = velocities  + h*accelerations 
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  } 
 </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Trapezoid 
&#8211; take &#8220;fake&#8221; Euler step 
&#8211; read derivative at &#8220;fake&#8221; destination 
&#8226; Implicit Euler 
&#8211; take derivative at the real destination 
&#8211; harder because the derivative depends on the destination 
and the destination depends on the derivative 
24 Difference with Trapezoid </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; The Jacobian matrix Jf  is usually sparse 
&#8211; Only few non-zero entries per row 
&#8211; E.g. the derivative of a spring force only depends on the 
adjacent masses&#8217; positions 
&#8226; Makes the system cheaper to solve 
&#8211; Don&#8217;t invert the Jacobian! 
&#8211; Use iterative matrix solvers like 
conjugate gradient, perhaps with 
preconditioning, etc.  
57 Good News 
&#169; David Baraff and Andrew Witkin . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Implicit Integration 
Collision Detection 
Philippe Halsman : Dali Atomicus MIT EECS 6.837 &#8211; Matusik 
This image is in the public domain. Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Particle System Class 
  class ParticleSystem 
  { 
        virtual int getDimension() 
        virtual setDimension(int n) 
        virtual float* getStatePositions() 
        virtual setStatePositions(float* positions) 
        virtual float* getStateVelocities() 
        virtual setStateVelocities(float* velocities) 
        virtual float* getForces(float* positions, float* velocities) 
                        virtual setMasses(float* masses) 
                        virtual float* getMasses() 
 
        float* m_currentState  
  } </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Detection 
&#8226; Response 
&#8226; Overshooting problem  
(when we enter the solid) 
64 Collisions </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; So far, we have seen explicit Euler 
&#8211;X(t+h) = X(t) + h X&#8217;(t) 
 
&#8226; Implicit Euler uses the derivative at the destination! 
&#8211;X(t+h) = X(t) + h X&#8217;(t+h) 
&#8211;It is implicit because we do not have X&#8217;(t+h ), 
it depends on where we go (HUH?) 
 
&#8211; aka backward Euler 
23 Implicit Integration </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>&#8226; Hierarchy of bounding spheres 
&#8211; Organized in a tree 
&#8226; Recursive test with early pruning Hierarchical Collision Test 
Root encloses 
whole object 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
78 </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Remember our model problem:  x&#8217; = -kx 
&#8211; Exact solution was a decaying exponential x0 e-kt 
 
&#8226; Explicit Euler: x(t+h) = (1- hk) x(t) 
 
&#8226; Implicit Euler: x(t+h ) = x(t) + h x&#8217;(t+h )  
                        x(t+h) = x(t) - h k x(t+h) 
                               = x(t) / (1+ hk) 
&#8211;It is a hyperbola! 
29 Implicit Euler is 
unconditionally stable! 
1/(1+hk ) &lt; 1, 
when h,k &gt; 0 Simple Closed Form Case </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Mid-Point Implementation 
  class MidPoint : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   midPositions = positions + 0.5*h*velocities 
   midVelocities = velocities  + 0.5*h*accelerations 
   midForces = ps-&gt;getForces(midPositions, midVelocities) 
   midAccelerations = midForces / masses 
   newPositions = positions + 0.5*h* midVelocities 
   newVelocities = velocities  + 0.5*h* midAccelerations      
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  } 
 </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>&#8226; Pong: &#949; =? 
&#8226;http://www.youtube.com/watch?v=sWY0Q_lMFfw  
&#8226;http://www.xnet.se/javaTest/jPong/jPong.html  
72 Questions? 
http://en.wikipedia.org/wiki/Pong  
Animation removed due to 
copyright restrictions. 
This image is in the public domain.
Source: Wikimedia Commons.Image courtesy of Chris Rand on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; Imagine we have n objects. Can we test all pairwise 
intersections? 
&#8211; Quadratic cost O(n2)! 
 
&#8226; Simple optimization: separate static objects 
&#8211; But still O(static &#215; dynamic+ dynamic2) 
73 Collision Detection in Big Scenes </text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>&#8226; Take longest scene dimension 
&#8226; Cut in two in the middle 
&#8211; assign each object or triangle to one side 
&#8211; build sphere around it 
94 Top-Down Construction 
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.This image is in the public domain.
Source: Wikimedia Commons.&#169; Sara McMains . All rights reserved. This content is excluded
from our Creative Commons license. Fo
r more information,
see http://ocw.mit.edu/help/faq-fair-use /.&#169; Gareth Bradshaw. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>&#8226; Iterate until convergence 
 
&#8211; Initial guess                            (or result of explicit method) 
 
&#8211; For each step, solve 
 
 
 
&#8211; Then set 
52 Putting It All Together 
</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 Newton, Visually 
We are here Let&#8217;s approximate f 
by its tangent at 
point ( xn, f(xn)) 
Then we&#8217;ll see 
where the tangent 
line crosses zero 
and take that as 
next guess 
f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>76 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Implicit Euler with Newton, Visually 
Xi=Y0 Y1 Y2 
Y3 Y=Xi+1 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>62 Efficient Simulation of Inextensible Cloth  
Rony  Goldenthal, David Harmon, Raanan Fattal, Michel Bercovier, Eitan Grinspun 
Animation removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226; To simplify, consider only 1D time-invariant systems 
&#8211; This means x&#8217; = f( x,t) = f(x) is independent of t 
&#8211; Our spring equations satisfy this already 
 
&#8226;x(t+h)=x(t)+dx = x(t)+h f(x(t+h )) 
&#8226;f can be approximated it by 1st order Taylor: 
f(x+dx)=f(x)+dxf&#8217;(x)+O(dx2) 
&#8226;x(t+h)=x(t)+h [f(x) + dx f&#8217;(x)] 
&#8226;dx=h [f(x) +dx f&#8217;(x)] 
&#8226;dx=hf(x)/[1-
hf&#8217;(x)] 
&#8226; Pretty much Newton solution 34 Implicit Euler in 1D 
</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Easy with implicit equations of surfaces: 
 
H(x,y,z) = 0     on the surface 
H(x,y,z) &lt; 0      inside surface 
 
&#8226; So just compute H and you know that 
you are inside if it is negative 
 
&#8226; More complex with other surface 
definitions like meshes 
&#8211; A mesh is not necessarily even closed, what is inside? 
65 Detecting Collisions </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>&#8226; Use simpler conservative proxies  
(e.g. bounding spheres) 
 
&#8226; Recursive (hierarchical) test 
&#8211; Spend time only for parts of the scene that are close 
 
&#8226; Many different versions, we will cover only one 
 
 
74 Hierarchical Collision Detection </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>54 Implicit Euler with Newton, Visually 
What is the location 
Xi+1=X(t+h) such that the 
derivative there, multiplied 
by -h, points back to 
Xi=X(t) where we are 
starting from? 
Xi=Y0 -hf(X,t) 
Y=Xi+1 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226; Usually, we detect collision when it is too late: 
we are already inside 
&#8226; Solution: Back up 
&#8226; Compute intersection point 
&#8226; Ray-object 
intersection! 
&#8226; Compute response there 
&#8226; Advance for remaining  
fractional time step 
&#8226; Other solution: 
Quick and dirty hack  
&#8226; Just project back to object closest point 
71 Collisions &#8211; Overshooting 
fixing backtracking xi 
xi+1 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>boolean intersect(node1, node2) 
   // no overlap? ==&gt; no intersection!  
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
 
   // recurse down the larger 
of the two nodes  
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
      for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
 
   // no intersection in the subtrees? ==&gt; no intersection!  
   return false 
80 Pseudocode (simplistic version) </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Newton, Visually 
 Questions? 
Image courtesy of Ralf Pfeifer on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226; Implicit Euler uses the derivative at the destination! 
&#8211;X(t+h) = X(t) + h X&#8217;(t+h) 
&#8211; It is implicit because we do not have X&#8217;(t+h), 
it depends on where we go (HUH?) 
&#8211; Two situations 
&#8226;X&#8217; is known analytically and everything 
is closed form ( doesn&#8217;t happen in practice ) 
&#8226;We need some form of iterative non-linear solver. 
25 Implicit Integration </text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; Now locations Xi, Xi+1 and F are N-D 
&#8226; Newton solution of F(Xi+1) = 0 is just like 1D: 
 
 
 
 
 
&#8226; Must solve a linear system at each 
step of Newton iteration 
&#8211; Note that also Jacobian changes for each step 
46 Newton&#8217;s Method &#8211; N Dimensions 
NxN Jacobian 
matrix 
unknown N- D 
step from 
current to next 
guess </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; Iterative method for solving non-linear equations 
 
 
&#8226; Start from initial guess x0, then iterate 
37 Newton&#8217;s Method (1D) 
one step  
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; We have N point masses  
&#8211; Let&#8217;s just stack all xs and vs in a big vector of length 6N 
&#8211;Fi denotes the force on particle i 
&#8226; When particles do not interact , Fi only depends on xi and vi. 
6 Many Particles 
f gives d/dt X, 
remember! </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226;h &gt; 1/k: oscillate. h &gt; 2/k: explode! 
17 Euler Has a Speed Limit! 
From the SIGGRAPH PBM notes &#8217; 
Image removed due to copyright restrictions -- please see slide 5 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse/.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1 ) 
 
&#8226; Let&#8217;s rewrite this as                          with 
48 Implicit Euler &#8211; N Dimensions 
</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; Iterative method for solving non-linear equations 
 
 
&#8226; Start from initial guess x0, then iterate 
 
 
 
 
&#8226; Also called Newton-Raphson iteration 
36 Newton&#8217;s Method (1D) 
</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Newton, Visually 
We are here f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Time Stepper Class 
  class TimeStepper 
  { 
        virtual takeStep(ParticleSystem* ps, float h) 
  } 
 
 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 
Xi Xi+1  Implicit Euler, Visually 
Xi+1 = Xi + h f( Xi+1, t+h ) 
Xi+1 - h f( Xi+1, t+h ) = Xi 
 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 A Mass Spring Model for Hair Simulation  
Selle, A., Lentine, M., G., and Fedkiw 
Animation removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59 Reference 
&#8226;Large steps in cloth simulation   
&#8226;David Baraff    Andrew Witkin    
&#8226;http://portal.acm.org/citation.cfm?id=280821  
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>97 Reference 
An image of the book, &#8220;Real Time Collision Detection&#8221; by Christer Ericson, 
has been removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>&#8226; Trivial given center C 
&#8211; radius = max i ||C-Pi|| 
91 Bounding Sphere of a Set of Points 
C 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; To simplify, consider only time-invariant systems 
&#8211; This means X&#8217; = f( X,t) = f(X) is independent of t 
&#8211; Our spring equations satisfy this already 
 
&#8226; Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1) 
 
&#8226; Non-linear equation, 
unknown Xi+1 on both the LHS and the RHS 
44 Implicit Euler and Large Systems </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Usually, we detect collision when it is too late: 
we are already inside 
&#8226; Solution: Back up 
&#8226; Compute intersection poin
t 
&#8226; Ray-object 
intersection! 
&#8226; Compute response there 
&#8226; Advance for remaining  
fractional time step 
70 Collisions &#8211; Overshooting 
backtracking xi 
xi+1 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; 1D:  
 
&#8226; Now locations Xi, Xi+1 and F are N-D 
&#8226; N-D Newton step is just like 1D: 
45 Newton&#8217;s Method &#8211; N Dimensions 
NxN Jacobian 
matrix replaces 
f&#8217; 
unknown N- D 
step from 
current to next 
guess 
</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>58 Implicit Euler Pros &amp; Cons 
&#8226; Pro: Stability! 
 
&#8226; Cons:  
&#8211; Need to solve a linear system at each step  
&#8211; Stability comes at the cost of &#8220;numerical viscosity&#8221;, but 
then again, you do not have to worry about explosions. 
&#8226; Recall exp vs. hyperbola 
 
&#8226; Note that accuracy is not improved 
&#8211; error still O(h) 
&#8211; There are lots and lots of implicit methods out there! 
 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41 Newton, Visually 
Image courtesy of Ralf Pfeifer on  Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; To simplify, consider only time-invariant systems 
&#8211; This means X&#8217; = f( X,t) = f(X) is independent of t 
&#8211; Our spring equations satisfy this already 
 
&#8226; Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1) 
43 Implicit Euler and Large Systems </text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>84 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
      
for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>101 
That&#8217;s All for Today! 
Bungie / ign.com 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; Tangential velocity vt  
often unchanged  
&#8226; Normal velocity vn reflects: 
 
 
 
&#8226; Coefficient of restitution &#949; 
 
&#8226; When &#949; = 1 , mirror reflection 
68 Collision Response for Particles 
N v 
vn vt 
N v vnew 
N v vnew &#949;=1 
&#949;&lt;1 </text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>&#8226; Using axis-aligned bounding box 
&#8211;center=  
((xmin+xmax)/2, (y min+ymax)/2, (z min, zmax)/2) 
&#8211; Better than the average of the vertices because does not 
suffer from non-uniform tessellation  
92 Bounding Sphere of a Set of Points 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Midpoint : 
&#8211; &#189; Euler step 
&#8211; evaluate fm 
&#8211; full step using fm 
&#8226; Trapezoid: 
&#8211; Euler step (a) 
&#8211; evaluate f1 
&#8211; full step using f1 (b)  
&#8211; average (a) and (b) 
&#8226; Better than Euler but still a speed limit 
18 Integrator Comparison f1 a 
 
fm f1 a 
b 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>31 Implicit vs. Explicit 
From the Siggraph PBM notes Questions? 
Image removed due to copyright restrictions -- please see slide 12 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse /.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
node 1  
node 2 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Implementing Particle Systems 
&#8226; Implicit Integration 
&#8226; Collision detection and response 
&#8211; Point-object and object-object detection 
&#8211; Only point-object response 
3 Plan </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text> 
 
&#8226; Given a function f(X,t) compute X(t) 
&#8226; Typically, initial value problems : 
&#8211; Given values X(t0)=X0 
&#8211; Find values X(t) for t &gt; t0 
 
&#8226; We can use lots of standard tools 
4 ODEs and Numerical Integration 
</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>&#8226;http://www.youtube.com/watch?v=b_cGXtc-nMg  
&#8226;http://www.youtube.com/watch?v=nFd9BIcpHX4&amp;f
eature=related  
&#8226;http://www.youtube.com/watch?v=2SXixK7yCGU  
89 Questions? 
http://www.youtube.com/watch?v=b_cGXtc-nMg</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>83 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text> 
 
 
&#8226; Then iterate 
&#8211; Initial guess                            (or result of explicit method) 
 
&#8211; For each step, solve 
 
&#8211; Then set 
50 
Y is variable Xi is fixed 
Implicit Euler &#8211; N Dimensions </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new ForwardEuler() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render  
 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Implicit Euler, Visually 
Xi+1 = Xi + h f( Xi+1, t+h ) 
Xi+1 - h f( Xi+1, t+h ) = Xi 
 
 What is the location 
Xi+1=X(t+h)  such that the 
derivative there, multiplied 
by -h, points back to 
Xi=X(t) where we are 
starting from? 
Xi+1 -hf(X,t) 
i X
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text> 
 
&#8226; Simple partial differentiation... 
 
 
 
 
&#8226; Where 
51 What is the Jacobian? 
The Jacobian of 
the Force function 
f </text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>&#8226; Keyframing mostly 
&#8226; Articulated figures, inverse kinematics 
&#8226; Skinning  
&#8211; Complex deformable skin, muscle, skin motion 
&#8226; Hierarchical controls 
&#8211; Smile control, eye blinking, etc.  
&#8211; Keyframes for these higher-level controls 
&#8226; A huge time is spent building the 3D models,  
its skeleton and its controls (rigging) 
&#8226; Physical simulation for secondary motion 
&#8211; Hair, cloths, water 
&#8211; Particle systems for &#8220;fuzzy&#8221; objects 
How Do They Animate Movies? 
Images from the Maya tutorial 100 &#169; Maya tutorial. All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>&#8226; Top down 
&#8211; Divide and conquer  
 
&#8226; Bottom up 
&#8211; Cluster nearby objects 
 
&#8226; Incremental 
&#8211; Add objects one by one, binary-tree style.  
90 Hierarchy Construction </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39 Newton, Visually 
We are here Let&#8217;s approximate f 
by its tangent at 
point (x n, f(x n)) 
f(x) 
Wikipedia users Olegalexandrov, Pbroks13 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Tuesday, October 16th  2:30pm &#8211; 4:00pm 
&#8226; In class 
&#8226; Two-pages of notes (double sided) allowed 
2 Midterm </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; Remember our model problem:  x&#8217; = -kx 
&#8211; Exact solution was a decaying exponential x0e-kt 
 
&#8226; Explicit Euler: x(t+h) = (1- hk) x(t) 
 
&#8226; Implicit Euler: x(t+h ) = x(t) + h x&#8217;(t+h )  
                        x(t+h) = x(t) - hk x(t+h) 
       x(t+h) +hkx(t+h) = x(t) 
                   x(t+h)  = x(t) / (1+hk) 
&#8211;It is a hyperbola! 
28 Simple Closed Form Case </text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>&#8226; Using axis-aligned bounding box 
&#8211;center=  
((xmin+xmax)/2, (y min+ymax)/2, (z min, zmax)/2) 
&#8211; Better than the average of the vertices because does not 
suffer from non-uniform tessellation  
93 Bounding Sphere of a Set of Points 
Questions? 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new MidPoint() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render  
 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; Implicit Euler with N-D phase space: 
Xi+1 = Xi + h f( Xi+1 ) 
 
&#8226; Let&#8217;s rewrite this as                          with 
 
 
 
&#8226; Then the Y that solves F(Y)=0 is Xi+1 
49 Implicit Euler &#8211; N Dimensions 
</text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>99 Robust Treatment of Simultaneous Collisions  
David Harmon, Etienne Vouga, Rasmus Tamstorf, Eitan Grinspun 
Animation removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&#8226; Basic idea 
&#8211; &#8220;Particle System&#8221; tells &#8220;Time Stepper&#8221; how many 
dimensions (N) the phase space has 
&#8211; &#8220;Particle System&#8221; has a function to write its state to an N-
vector of floating point numbers (and read state from it) 
&#8211; &#8220;Particle System&#8221; has a function that evaluates f( X,t), 
given a state vector X and time t 
 
&#8211; &#8220;Time Stepper&#8221; takes a &#8220;Particle System&#8221; as input and 
advances its state 
8 Implementation Notes </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Collision Response for Particles 
N v </text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
 
   // if there is nowhere to go, test everythin
g 
   if (node1-&gt;isLeaf() &amp;&amp; node2-&gt;isLeaf()) 
      perform full test between all primitives within nodes 
 
   // otherwise go down the tree in the non-leaf path 
   if ( !node2-&gt;isLeaf() &amp;&amp; !node1-&gt;isLeaf() ) 
      // pick the larger node to subdivide, then recurse 
   else 
      // recurse down the node that is not a leaf 
 
   return false 
87 Pseudocode (with leaf case) </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; Now locations Xi, Xi+1 and F are N-D 
&#8226; Newton solution of F(Xi+1) = 0 is just like 1D: 
 
 
 
 
 
&#8226; Must solve a linear system at each 
step of Newton iteration 
&#8211; Note that also Jacobian changes for each step 
47 Newton&#8217;s Method &#8211; N Dimensions 
NxN Jacobian 
matrix 
unknown N- D 
step from 
current to next 
guess 
Questions? </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; It pays off to abstract (as usual) 
&#8211; It&#8217;s easy to design your &#8220;Particle System&#8221; and &#8220;Time 
Stepper&#8221; to be unaware of each other 
 
&#8226; Basic idea 
&#8211; &#8220;Particle system&#8221; and &#8220;Time Stepper&#8221; communicate via 
floating-point vectors X and a function that computes 
f(X,t) 
&#8226; &#8220;Time Stepper&#8221; does not need to know anything else! 
7 Implementation Notes </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>&#8226; Iterative method for solving non-linear equations 
 
 
&#8226; Start from initial guess x0, then iterate 
35 Newton&#8217;s Method (1D) 
</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 ODE: Path Through a Vector Field 
&#8220;When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ?&#8221; 
&#8226;X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
&#8226;f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction.   Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; In more complex systems, 
step size is limited by the largest k. 
&#8211; One stiff spring can ruin things for everyone else! 
 
&#8226; Systems that have some big k values 
are called stiff systems . 
 
&#8226; In the general case, k values are eigenvalues of the 
local Jacobian! 
21 Stiffness 
From the siggraph PBM notes Questions? 
&#169; David Baraff and Andrew Witkin . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>&#8226; Place spheres around objects  
&#8226; If spheres do not intersect, neither do the objects! 
&#8226; Sphere-sphere collision test is easy. 
75 Bounding Spheres 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Simulating Knitted Cloth at the Yarn Level  
Jonathan Kaldor, Doug L. James, and Steve Marschner 
Animation removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>&#8226;http://isg.cs.tcd.ie/spheretree/  
79 Examples of Hierarchy 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>&#8226; A cloth has many points of contact 
&#8226; Stays in contact 
&#8226; Requires 
&#8211; Efficient collision detection 
&#8211; Efficient numerical treatment (stability) 
98 The Cloth Collision Problem 
Image from Bridson et al.   
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
95Top-Down Construction - Recurse 
&#169; Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, seehttp://ocw.mit.edu/help/faq-fair-use/.
&#169; Gareth Bradshaw. All rights reserved.This content is excluded from our CreativeCommons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.
This image is in the public domain.Source: Wikimedia Commons .
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; Often, the 1st Newton step may suffice 
&#8211; People often implement Implicit Euler using only one 
step. 
&#8211; This amounts to solving the system 
 
 
 
 
where the Jacobian and f are evaluated at Xi, and we are 
using Xi as an initial guess. 
56 One-Step Cheat 
 Questions? </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Collision Response for Particles 
N v 
vn vt 
v=vn+vt 
normal component  
tangential component </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; In more complex systems, 
step size is limited by the largest k. 
&#8211; One stiff spring can ruin things for everyone else! 
 
&#8226; Systems that have some big k values 
are called stiff systems . 
 
&#8226; In the general case, k values are eigenvalues of the 
local Jacobian! 
20 Stiffness 
From the siggraph PBM notes 
&#169; David Baraff and Andrew Witkin . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; When computing the forces, initialize the force 
vector to zero, then sum over all forces for each 
particle 
&#8211; Gravity is a constant acceleration 
&#8211; Springs connect two particles, affects both 
&#8211;dvi/dt = Fi(X, t) is the vector sum of all forces on particle i 
&#8211; For 2nd order Fi=miai system, 
dxi/dt is just the current vi 
15 Computing Forces 
</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226; Usually, we detect collision when it is too late: 
we are already inside 
69 Collisions &#8211; Overshooting 
xi 
xi+1 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Implicit vs. Explicit 
From the Siggraph PBM notes Image removed due to copyright restrictions -- please see slide 12 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse /.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 Questions? </text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
96Top-Down Construction - Recurse 
Questions? 
&#169; Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
&#169; Gareth Bradshaw. All rights reserved.
This content is excluded from our Creative
Commons license. For more information, 
see http://ocw.mit.edu/help/faq-fair-use/. 
This image is in the public domain.Source: Wikimedia Commons .
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>&#8226; Two spheres, centers C1 and C2, radii r1 and r2 
&#8226; Intersect only if | |C1C2||&lt;r1+r2 
77 Sphere-Sphere Collision Test 
C1 C2 r1 r2 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; Remember our model problem:  x&#8217; = -kx 
&#8211; Exact solution was a decaying exponential x0 e-kt 
 
&#8226; Explicit Euler: x(t+h) = (1- hk) x(t) 
 
&#8226; Implicit Euler : x(t+h ) = x(t) + h x&#8217;(t+h ) 
27 Simple Closed Form Case </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; Often, the 1st Newton step may suffice 
&#8211; People often implement Implicit Euler using only one 
step. 
&#8211; This amounts to solving the system 
 
 
 
 
where the Jacobian and f are evaluated at Xi, and we are 
using Xi as an initial guess. 
55 One-Step Cheat 
</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>82 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1-&gt;radius()&gt;node2-&gt;radius()) 
     
 for each child c of node1 
         if intersect(c, node2) return true 
   else 
      for each child c f node2 
        if intersect(c, node1) return true 
   return false 
85 &#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Sampling, Aliasing, and Mipmaps (PDF - 1.6MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec17/</lecture_pdf_url>
      <lectureno>17</lectureno>
      <slides>
        <slide>
          <slideno>24</slideno>
          <text>Choosing the parameters 
&#8226; Empirical tests determined usable parameters 
&#8211; Mitchell, Don and Arun Netravali, "Reconstruction Filters in 
Computer Gra
phics", SIGGRAPH 88.  
         http ://www.mentallandscape.com/Papers_siggraph88.pdf  
         http://dl.acm.org/citation.cfm?id=378514  
 
25 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Jittering 
&#8226; Uniform sample + random perturbation 
&#8226; Sampling is now non-uniform 
&#8226; Signal processing gets more complex 
&#8226; In practice, adds noise to image 
&#8226; But noise is better than aliasing Moir&#233; patterns 
37 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Gaussian 
32  
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Piecewise-cubic 
&#8226; General formula 
 
 
   where P, Q, R, S, T, U, V, W are parameters 
&#8226; But we want the derivatives to be zero at the 
boundary and constant signals to be well 
reconstructed. Reduces to 2 parameters 
24 
</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Gauss 
27 
 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html  &#169; Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Uniform supersampling 
&#8226; Advantage:  
&#8211; The first (super)sampling captures more high 
frequencies that are not aliased 
&#8211; Downsampling can use a good filter 
&#8226; Issues 
&#8211; Frequencies above the (super)sampling limit are still 
aliased 
&#8226; Works well for edges, since  
spectrum replication is less an issue 
&#8226; Not as well for repetitive textures 
&#8211; But solution soon 
34 </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Box 
26 
 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html  &#169; Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>What is a Pixel? 
&#8226; A pixel is not: 
&#8211; a box 
&#8211; a disk 
&#8211; a teeny tiny little light 
&#8226; A pixel &#8220;looks different&#8221; on 
different display devices 
&#8226; A pixel is a sample 
&#8211; it has no dimension 
&#8211; it occupies no area 
&#8211; it cannot be seen 
&#8211; it has a coordinate 
&#8211; it has a value 
8 &#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Box 
29 
http://rise.sourceforge.net/cgi-bin/makepage.cgi?Filtering&#169; Aravind Krishnaswamy. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>In photos too 
See also http://vimeo.com/26299355  
 
6 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Sampling &amp; reconstruction 
The visual array of light is a continuous function 
1/ we sample it  
&#8211; with a digital camera, or with our ray tracer 
&#8211; This gives us a finite set of numbers,  
not really something we can see 
&#8211; We are now inside the discrete computer world 
2/ we need to get this back to the physical world:  
we reconstruct a continuous function 
&#8211; for example, the point spread of a pixel on a CRT or LCD 
&#8226; Both steps can create problems 
&#8211; pre-aliasing caused by sampling 
&#8211; post-aliasing caused by reconstruction 
&#8211; We focus on the former 
11 Questions? </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Your intuitive solution is to 
compute multiple color values per 
pixel and average them In practice: Supersampling 
jaggies w/ antialiasing 
18 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Sampling Density 
&#8226; If we&#8217;re lucky, sampling density is enough 
Input Reconstructed 
12 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Image Quality Comparison 
&#8226; Trilinear mipmapping 
EWA trilinear mipmapping 
58 </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text> 1 sample / pixel 
 
 
 
 
 
 
 
 
 
 
 
 
 
         0 jittering                               jittering by 0.5                        jittering by 1        
Jittered supersampling 
38 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Box 
31 
 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>MIP Indices 
 
Actually, you have a choice of ways to translate this derivative value into a MIP 
level. 
 
Because we have two derivatives, for u and for v (anisotropy) 
         
This also brings up one of the shortcomings of MIP mapping. MIP mapping assumes 
that both the u and v components of the texture index are undergoing a uniform 
scaling, while in fact the terms du/dt and dv/dt are relatively independent. Thus, we 
must make some sort of compromise. Two of the most common approaches are 
given below: 
55 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Uniform supersampling 
&#8226; Advantage:  
&#8211; The first (super)sampling captures more high 
frequencies that are not aliased 
&#8211; Downsampling can use a good filter 
&#8226; Issues 
&#8211; Frequencies above the (super)sampling limit are still 
aliased 
&#8226; Works well for edges, since  
spectrum replication is less an issue 
&#8226; Not as well for repetitive textures 
&#8211; But solution soon 
35 Questions? </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>FELINE results 
60 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Mitchell bicubic 
28 http://www.willsmith.org/maya_gi_tutorial_1/Wills_Maya_GI_Tweaking_Guide_1.html  
&#169; Will Smith. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Mitchell-Netravali cubic (1/3. 1/3) 
30 http://rise.sourceforge.net/cgi-bin/makepage.cgi?Filtering 
&#169; Aravind Krishnaswamy. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>MIP Mapping 
&#8226; Construct a pyramid  
of images that are  
pre-filtered and  
re-sampled at  
1/2, 1/4, 1/8, etc.,  
of the original  
image's sampling 
&#8226; During rasterization  
we compute the index of the decimated image that is sampled at 
a rate closest to the density of our desired sampling rate 
&#8226; MIP stands for multum in parvo  which means  
many in a small place   
49 </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Questions? 
61 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Examples of Aliasing 
Texture Errors 
point sampling 
5 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Solution? 
&#8226; How do we avoid that high-frequency patterns 
mess up our image? 
&#8226; We blur! 
&#8211; In the case of audio, people first include an analog low-
pass filter before sampling 
&#8211; For ray tracing/rasterization: compute at higher 
resolution, blur, resample at lower resolution 
&#8211; For textures, we can also blur the texture image before 
doing the lookup 
&#8226; To understand what really happens, we need 
serious math 
17 Questions? </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Minification: Examples of Aliasing 
point sampling 
47 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&#8226; In signal processing, the process of mapping a continuous 
function to a discrete one is called sampling 
&#8226; The process of mapping a continuous variable to a discrete one 
is called quantization 
&#8211; Gamma helps quantization 
&#8226; To represent or render an image using a computer,  
we must both sample and quantize  
&#8211; Today we focus on the effects of sampling and how to fight them More on Samples 
discrete position discrete 
value 
9 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 
 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Jittering 
&#8226; Displaced by a vector a fraction of the size of the 
subpixel distance 
&#8226; Low-frequency Moire (aliasing) pattern replaced 
by noise 
&#8226; Extremely effective 
&#8226; Patented by Pixar! 
&#8226; When jittering amount is 1, equivalent to 
stratified sampling (cf. later) 
40 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Discussion 
&#8226; Types of aliasing 
&#8211; Edges 
&#8226; mostly directional 
aliasing 
(vertical and horizontal 
edges rather than actual 
slope)  
&#8211; Repetitive textures 
&#8226; Paradigm of aliasing 
&#8226; Harder to solve right 
&#8226; Motivates fun  
mathematics 
14 &#169; Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights
reserved. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Uniform supersampling 
&#8226; Compute image at resolution k*width, k*height 
&#8226; Downsample using low-pass filter  
(e.g. Gaussian, sinc, bicubic) 
19 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Solution? 
&#8226; How do we avoid that high-frequency patterns 
mess up our image? 
15 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>MIP Mapping Example 
&#8226; Small details may "pop" in and out of view 
MIP Mapped (Bi-Linear) Nearest Neighbor 
51 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Examples of Aliasing 
4 &#169; Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text> 1 sample / pixel 
 
 
 
 
 
 
   2 sample / pixel 
 
 
 
 
 
 
         0 jittering                               jittering by 0.5                        jittering by 1        Jittered supersampling 
39 </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Linear Interpolation 
&#8226; Tell OpenGL to use a tent filter instead of a box filter. 
&#8226; Magnification looks better, but blurry 
&#8211; (texture is under-sampled for this resolution) 
&#8211; Oh well.  
46 Questions? </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Examples of Aliasing 
3 &#169; Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text> 
 
 
 
 
 
 
&#8226; How to map the texture area seen through the pixel 
window to a single pixel value? Sampling Texture Maps 
image plane textured surface 
(texture map) 
circular pixel window 
43 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Low pass / convolution 
&#8226; Each output (low-res) pixel is a weighted average 
of input subsamples 
&#8226; Weight depends on relative spatial position 
&#8226; For example: 
&#8211; Gaussian as a function of distance 
&#8211; 1 inside a square, zero outside (box) 
 
20 
 http://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm  &#169; 2003 R. Fisher, S. Perkins, A. Walker and E. Wolfart . All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Philosophical perspective 
&#8226; The physical world is continuous, inside the 
computer things need to be discrete 
&#8226; Lots of computer graphics is about translating 
continuous problems into discrete solutions  
&#8211; e.g. ODEs for physically-based animation, global 
illumination, meshes to represent smooth surfaces, 
rasterization, antialiasing 
&#8226; Careful mathematical understanding helps do the 
right thing 
7 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Sampling,  
Aliasing,  
&amp; Mipmaps 
1 
MIT EECS 6.837 Computer Graphics 
Wojciech Matusik, MIT EECS </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Sampling Texture Maps 
&#8226; When texture mapping it is rare that the screen-space 
sampling density matches the sampling density of the 
texture.  
Original Texture Minification for Display Magnification for Display 
64x64 pixels 
44 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Recommended filter 
&#8226; Bicubic 
&#8211;http://www.mentallandscape.com/Papers_siggraph88.
pdf 
&#8226; Good tradeoff between sharpness and aliasing 
23 
http://de.wikipedia.org/wiki/Datei:Mitchell_Filter.svg  </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Sampling &amp; reconstruction 
The visual array of light is a continuous function 
1/ we sample it  
&#8211; with a digital camera, or with our ray tracer 
&#8211; This gives us a finite set of numbers,  
not really something we can see 
&#8211; We are now inside the discrete computer world 
2/ we need to get this back to the physical world:  
we reconstruct a continuous function 
&#8211; for example, the point spread of a pixel on a CRT or LCD 
&#8226; Both steps can create problems 
&#8211; pre-aliasing caused by sampling 
&#8211; post-aliasing caused by reconstruction 
&#8211; We focus on the former 
10 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Sampling Density 
&#8226; If we insufficiently sample the signal, it may be 
mistaken for something simpler during reconstruction 
(that's aliasing!) 
&#8226; This is why it&#8217;s called aliasing: the new low-frequency 
sine wave is an alias/ghost of the high-frequency one 
13 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>In practice: Supersampling 
&#8226; Your intuitive solution is to 
compute multiple color values per 
pixel and average them 
&#8226; A better interpretation of the 
same idea is that 
&#8211; You first create a higher resolution 
image 
&#8211; You blur it (low pass, prefilter) 
&#8211; You resample it at a lower resolution 
21 Images removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Recap: image antialiasing 
&#8226; Render multiple samples per pixel 
&#8226; Jitter the sample locations 
&#8226; Use appropriate filter to reconstruct final image 
&#8211; Bicubic for example 
42 Questions? </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Examples of Aliasing 
2 &#169; Rosalee Nerheim-Wolfe, Toby Howard, Stephen Spencer. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Recap: image antialiasing 
&#8226; Render multiple samples per pixel 
&#8226; Jitter the sample locations 
&#8226; Use appropriate filter to reconstruct final image 
&#8211; Bicubic for example 
41 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Linear Interpolation 
&#8226; Tell OpenGL to use a tent filter instead of a box filter. 
&#8226; Magnification looks better, but blurry 
&#8211; (texture is under-sampled for this resolution) 
&#8211; Oh well.  
45 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Spatial Filtering 
&#8226; Remove the high frequencies 
which cause artifacts in texture 
minification. 
&#8226; Compute a spatial integration 
over the extent of the pixel 
&#8226; This is equivalent to 
convolving the texture with a 
filter kernel centered at the 
sample (i.e., pixel center)! 
&#8226; Expensive to do during 
rasterization, but an 
approximation it can be 
precomputed 
projected texture in image plane 
pixels projected in texture plane 
48 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>MIP Mapping Example 
MIP Mapped (Bi-Linear) Nearest Neighbor 
50 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Examples of Aliasing 
Texture Errors 
nearest neighbor/ point 
sampling 
mipmaps &amp; linear interpolation 
52 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Approximation of anisotropic 
&#8226; Feline: Fast Elliptical Lines for Anisotropic Texture Mapping Joel 
McCormack, Ronald Perry, Keith I. Farkas, and Norman P. Jouppi 
SIGGRAPH 1999 
&#8226; Andreas Schilling, Gunter Knittel &amp; Wolfgang Strasser . Texram: A Smart 
Memory for Texturing. IEEE Computer Graphics and Applications, 16(3): 32-
41, May 1996.  
&#8226; Approximate Anisotropic Gaussian by a set of 
isotropic &#8220;probes&#8221; 
59 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Mitchell-Netravali cubic 
33  
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; Isotropic filter wrt screen space 
&#8226; Becomes anisotropic in texture 
space 
&#8226; e.g. use anisotropic Gaussian 
&#8226; Called Elliptical Weighted 
Average (EWA) 
Elliptical weighted average 
57 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Finding the mip level 
&#8226; Square MIP-map area is a bad approximation 
image plane textured surface 
(texture map) 
circular pixel window area pre- 
filtered in MIP-
map 
53 </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text> 
How does a screen-space change dt relates to a texture-space change du,dv.  
=&gt; derivatives, ( du/dt, dv/dt ).  
e.g. computed by hardware during rasterization 
often: finite difference (pixels are handled by quads) Finding the MIP level 
dt du, dv 
54 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Uniform supersampling 
&#8226; Problem: supersampling only pushes the problem 
further: The signal is still not bandlimited 
&#8226; Aliasing happens 
&#8226; Especially if the signal and the sampling are 
regular 
36 
</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Anisotropy &amp; MIP-Mapping 
&#8226; What happens when the surface is tilted? 
MIP Mapped (Bi-Linear) Nearest Neighbor 
56 </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Solution? 
&#8226; How do we avoid that high-frequency patterns 
mess up our image? 
&#8226; We blur! 
&#8211; In the case of audio, people first include an analog low-
pass filter before sampling 
&#8211; For ray tracing/rasterization: compute at higher 
resolution, blur, resample at lower resolution 
&#8211; For textures, we can also blur the texture image before 
doing the lookup 
&#8226; To understand what really happens, we need 
serious math 
16 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Hierarchical Modeling (PDF - 2.1MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec04/</lecture_pdf_url>
      <lectureno>04</lectureno>
      <slides>
        <slide>
          <slideno>23</slideno>
          <text>Hierarchical models  
24 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Recall frames  
&#8226;An object frame has coordinates O in the world  
(of course O is also our 4x4 matrix)  
 
 
&#8226;Then we are given coordinates c in the object frame  
 
 
 
&#8226;Indeed we need to apply matrix O to all objects  
40 </text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Inverse Kinematics  
skeleton parameter vector p &#7805;w 
86 &#8226;Given the position of the point in local coordinates vs and 
the desired position      in world coordinates, what are the 
skeleton parameters p? 
 
 
 
 
 
&#8226;Requires solving for p, given vs and  
&#8226;Non-linear and &#8230;  
</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Hierarchical Modeling  
&#8226;Triangles, parametric curves and surfaces 
are the building blocks from which more 
complex real -world objects are modeled.  
 
&#8226;Hierarchical modeling creates complex real -
world objects by combining simple primitive 
shapes into more complex aggregate 
objects.  
21 
Image courtesy of Nostalgic dave on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>More Normal Visualizations  
Incorrect Normal Transformation  Correct Normal Transformation  
13 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Recap  
&#8226;Vectors can be expressed in a basis  
&#8226;Keep track of basis with left notation  
&#8226;Change basis  
&#8226;Points can be expressed in a frame  
(origin+basis)  
&#8226;Keep track of frame with left notation  
&#8226;adds a dummy 4th coordinate always 1 
2 
</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Hierarchical models  
26 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Frames &amp; transformations  
&#8226;Transformation S wrt car frame f  
 
&#8226;how is the world frame a affected by this?  
&#8226;we have  
&#8226;which gives  
 
&#8226;i.e. the transformation in a is A -1SA 
&#8226;i.e., from right to left, A takes us from a to f, then 
we apply S, then we go back to a with A -1 
3 
</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
43 </text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>That&#8217;s All for Today!  
Further reading 
&#61550;OpenGL Matrix Stack and 
hierarchical model/view transforms 
&#61550;http://www.glprogramming.com/red/c
hapter 03.html 
Image courtesy of BrokenSphere  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.91 </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>When You Encounter a Transform Node  
&#8226;Push the current transform using glPushMatrix()  
&#8226;Multiply current transform by node&#8217;s transformation  
&#8226;Use glMultMatrix(), glTranslate(), glRotate(), glScale(), etc.  
&#8226;Traverse the subtree  
&#8226;Issue draw calls for geometry nodes  
&#8226;Use glPopMatrix() when done.  
 
 
&#8226;Simple as that!  
 
68 </text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Questions?  
82 </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
57 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Hierarchical models  
23 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Scene Graph Traversal  
&#8226;How to handle transformations?  
&#8226;Traversal algorithm keeps a transformation state S (a 4x4 matrix)  
&#8226;from world coordinates  
&#8226;Initialized to identity in the beginning  
&#8226;Geometry nodes always drawn using current S  
&#8226;When visiting a transformation node T: 
multiply current state S with T, 
then visit child nodes  
&#8226;Has the effect that nodes below  
will have new transformation  
&#8226;When all children have been  
visited, undo the effect of T!  
39 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Hierarchical models  
25 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Questions?  
&#8226;Further reading on OpenGL  
Matrix Stack and hierarchical model/view transforms  
&#8226;http://www.glprogramming.com/red/chapter 03.html 
 
&#8226;It can be a little confusing if you don&#8217;t think the previous 
through, but it&#8217;s really quite simple in the end.  
&#8226;I know very capable people who after 15 years of experience still 
resort to brute force (trying all the combinations) for getting their 
transformations right, but it&#8217;s such a waste :)  
71 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Why is the Normal important?  
&#8226;It's used for shading &#8212; makes things look 3D! 
object color only  Diffuse Shading  
7 </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>More Specifically...  
&#8226;An OpenGL transformation call corresponds to a matrix T 
&#8226;The call multiplies current modelview matrix C by T from the 
right, i.e. C&#8217; = C * T. 
&#8226;This also works for projection, but you often set it up only once.  
 
&#8226;This means that the transformation for the subsequent 
vertices will be p&#8217; = C * T * p 
&#8226;Vertices are column vectors on the right in OpenGL  
&#8226;This implements hierarchical transformation directly!  
69 </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Hierarchical Modeling in OpenGL  
&#8226;The OpenGL Matrix Stack implements what we just did!  
 
&#8226;Commands to change current transformation  
&#8226;glTranslate, glScale, etc.  
&#8226;Current transformation is part of the OpenGL state, i.e., all 
following draw calls will undergo the new transformation  
&#8226;Remember, a transform affects the whole subtree  
&#8226;Functions to maintain a matrix stack  
&#8226;glPushMatrix, glPopMatrix  
&#8226;Separate stacks for modelview (object -to-view)  
and projection matrices  
67 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
60 At each node, the current object -to-world transformation is the 
matrix product of all transformations found on the way from the 
node to the root.  
S = T1R1 </text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Inverse Kinematics  
vs 
&#7805;w 
85 &#8226;Forward Kinematics  
&#8226;Given the skeleton parameters p (position of the root and the joint 
angles) and the position of the point in local coordinates vs, what is 
the position of the point in the world coordinates vw? 
&#8226;Not too hard, just apply transform accumulated from the root.  
 
 
&#8226;Inverse Kinematics  
&#8226;Given the current position of the point                                             
and the desired new position      in                                                     
world coordinates, what are the skeleton                                          
parameters p that take the point to the                                        
desired position?  
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Comment  
&#8226;So the correct way to transform normals is:  
 
&#8226;But why did  nWS = M nOS work for similitudes?  
&#8226;Because for similitude / similarity transforms,  
(M&#175;&#185;)&#7488; =&#955; M 
&#8226;e.g. for orthonormal basis:  
 
                   M&#175;&#185; = M &#7488;     i.e.  ( M&#175;&#185;)&#7488; = M 
  nWS = (M&#175;&#185;)&#7488; nOS Sometimes denoted M &#175;&#7488; 
17 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>How do we transform normals?  
Object Space  World Space  nOS nWS 
9 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Traversal State  
&#8226;The state is updated during traversal  
&#8226;Transformations  
&#8226;But also other properties (color, etc.)  
&#8226;Apply when entering node, &#8220;undo&#8221; when leaving  
 
&#8226;How to implement?  
&#8226;Bad idea to undo transformation by inverse matrix  
&#8226;Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix &#8211; you accumulate error  
&#8226;Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane &#8211; no way to undo, inverse doesn&#8217;t exist!  
62 </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Digression  
 
 
&#8226;The previous proof is not quite rigorous; first 
you&#8217;d need to prove that tangents indeed 
transform with M. 
-Turns out they do, but we&#8217;ll take it on faith here.  
-If you believe that, then the above formula follows .  nWS = (M&#175;&#185;)&#7488; nOS 
16 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Frames and hierarchy  
&#8226;Matrix M1 to go from world to torso  
&#8226;Matrix M2 to go from torso to arm  
 
&#8226;How do you go from arm coordinates to world?  
 
 
 
 
&#8226;We can concatenate the matrices  
&#8226;Matrices for the lower hierarchy nodes go to the right  
41 </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Plan 
&#8226;Hierarchical Modeling, Scene Graph  
&#8226;OpenGL matrix stack  
&#8226;Hierarchical modeling and animation of characters  
&#8226;Forward and inverse kinematics  
72 </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Forward Kinematics  
vs vs Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
79 </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Traversal State  
&#8226;The state is updated during traversal  
&#8226;Transformations  
&#8226;But also other properties (color, etc.)  
&#8226;Apply when entering node, &#8220;undo&#8221; when leaving  
 
&#8226;How to implement?  
&#8226;Bad idea to undo transformation by inverse matrix  
&#8226;Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix &#8211; you accumulate error  
&#8226;Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane &#8211; no way to undo, inverse doesn&#8217;t exist!  
Can you think of a data structure suited for this?  
63 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Some slides from BarbCutler &amp; 
Jaakko Lehtinen  Wojciech Matusik, MIT EECS  
1 6.837 Computer Graphics  
Hierarchical Modeling  
Image courtesy of BrokenSphere  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = I 
44 </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Traversal State  
&#8226;The state is updated during traversal  
&#8226;Transformations  
&#8226;But also other properties (color, etc.)  
&#8226;Apply when entering node, &#8220;undo&#8221; when leaving  
 
&#8226;How to implement?  
&#8226;Bad idea to undo transformation by inverse matrix (Why?)  
61 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
51 </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>More Specifically...  
&#8226;An OpenGL transformation call corresponds to a matrix T 
&#8226;The call multiplies current modelview matrix C by T from the 
right, i.e. C&#8217; = C * T. 
&#8226;This also works for projection, but you often set it up only once.  
 
&#8226;This means that the transformation for the subsequent 
vertices will be p&#8217; = C * T * p 
&#8226;Vertices are column vectors on the right in OpenGL  
&#8226;This implements hierarchical transformation directly!  
 
&#8226;At the beginning of the frame, initialize the current matrix by 
the viewing transform that maps from world space to view 
space.  
&#8226;For instance, glLoadIdentity() followed by gluLookAt()  
70 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Text format is fictitious, better to use XML in real applications  
33 Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }  </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Forward Kinematics  
vs vs 
This product is S Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
Note that the angles have a non -linear effect.  
80 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
49 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Homogeneous Visualization  
&#8226;Divide by w to normalize (project)  
&#8226;w = 0?   
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) = &#8230; 
(7, 1, 1) = (14, 2, 2) = &#8230; 
(4, 5, 1) = (8, 10, 2) = &#8230; (0,0,0) 
4 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
47 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
55 </text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Draw by Traversing a Tree  
 
 
 
 
 
 
 
 
&#8226;Assumes drawing procedures 
for thigh, calf, and foot use 
joint positions as the origin for 
a drawing coordinate frame  hips 
r-thigh 
r-calf 
r-foot left-leg ... glLoadIdentity();  
glPushMatrix();  
  glTranslatef(&#8230;);  
  glRotate(&#8230;);  
  drawHips();  
  glPushMatrix();  
    glTranslate(&#8230;);  
 glRotate(&#8230;);  
 drawThigh();  
 glTranslate(&#8230;);  
 glRotate(&#8230;);  
 drawCalf();  
 glTranslate(&#8230;);  
 glRotate(&#8230;);  
 drawFoot();  
  glPopMatrix();  
      left-leg 
77 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
53 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Visualization of Surface Normal  
   &#177; x = Red  
&#177; y = Green  
&#177; z = Blue  
8 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Plan 
&#8226;Hierarchical Modeling, Scene Graph  
&#8226;OpenGL matrix stack  
&#8226;Hierarchical modeling and animation of characters  
&#8226;Forward and inverse kinematics  
66 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Transform tangent vector v 
v is perpendicular to normal n: 
nOS&#703;&#7488; vOS  =  0 
 nOS&#7488;  (M &#772; &#185;  M)  vOS  =  0 
 nWS&#7488; =  nOS&#7488; (M &#772; &#185;)  (nOS&#7488;  M &#772; &#185;)  (M    vOS)  =  0 
 (nOS&#7488;  M &#772; &#185;)  vWS  =  0 
 nWS&#7488; vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M &#772; &#185;)&#7488; nOS nOS 
vWS nWS vOS Dot product  
15 </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = I 
56 </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Recap: Scene Graph Traversal  
&#8226;How to handle transformations?  
&#8226;Traversal algorithm keeps a transformation state S (a 4x4 matrix)  
&#8226;from world coordinates  
&#8226;Initialized to identity in the beginning  
&#8226;Geometry nodes always drawn using current S  
&#8226;When visiting a transformation node T: 
multiply current state S with T, 
then visit child nodes  
&#8226;Has the effect that nodes below  
will have new transformation  
&#8226;When all children have been  
visited, undo the effect of T!  
42 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
58 </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>How to tackle these problems?  
&#8226;Deal with non -linearity:  
Iterative solution (steepest descent)  
&#8226;Compute Jacobian matrix of world position w.r.t. angles  
&#8226;Jacobian: &#8220;If the parameters p change by tiny amounts, what is the resulting 
change in the world position vWS?&#8221; 
&#8226;Then invert Jacobian.  
&#8226;This says &#8220;if vWS changes by a tiny amount, what is the change in the 
parameters p?&#8221; 
&#8226;But wait! The Jacobian is non -invertible ( 3xN) 
&#8226;Deal with ill -posedness: Pseudo -inverse  
&#8226;Solution that displaces things the least  
&#8226;See http://en.wikipedia.org/wiki/Moore -Penrose_pseudoinverse  
&#8226;Deal with ill -posedness: Prior on &#8220;good pose&#8221; (more advanced)  
&#8226;Additional potential issues: bounds on joint angles, etc.  
&#8226;Do not want elbows to bend past 90 degrees, etc.  
 
88 
</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Scene Graph Traversal  
&#8226;Depth first recursion  
&#8226;Visit node, then visit subtrees (top to bottom, left to right)  
&#8226;When visiting a geometry node: Draw it!  
 
&#8226;How to handle transformations?  
&#8226;Remember, transformations are always specified  
in coordinate system of the parent  
38 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }  
Here we have only simple shapes, but easy to add a &#8220;Mesh&#8221; 
node whose parameters specify an .OBJ to load (say)  
34 </text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Mesh-Based Inverse Kinematics 
&#8226;Video 
 
&#8226;Doesn&#8217;t even need a hierarchy or skeleton: Figure proper 
transformations out based on a few example deformations! 
 
&#8226;Link to paper: 
Sumner, Zwicker, Gotsman, Popovic: Mesh-Based Inverse Kinematics, 
ACM SIGGRAPH 2005 
90 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Question?  
20 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Scene Graph Representation  
30 &#8226;Basic idea: Tree  
&#8226;Comprised of several node types  
&#8226;Shape: 3D geometric objects  
&#8226;Transform: Affect current transformation  
&#8226;Property: Color, texture  
&#8226;Group: Collection of subgraphs  
 
 
&#8226;C++ implementation  
&#8226;base class Object  
&#8226;children, parent  
&#8226;derived classes for each                                
node type (group, transform)  </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
54 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 T2 
48 </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
46 </text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Example: Style -Based IK  
&#8226;Video  
 
&#8226;Prior on &#8220;good pose&#8221;  
 
&#8226;Link to paper: Grochow, Martin, Hertzmann, Popovic: Style -Based 
Inverse Kinematics, ACM SIGGRAPH 2004 
89 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226;Think about transforming the tangent plane   
to the normal, not the normal vector  So how do we do it right?  
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane,  
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS 
14 </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Hierarchical Grouping of Objects  
&#8226;The &#8220;scene graph&#8221; represents  
the logical organization of scene  
6.837 -  Durand  
chair table 
table fruits ground  scene  
28 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>6.837 -  Durand  
Simple Example with Groups  
Text format is fictitious, better to use XML in real applications  
32 Group {   
    numObjects 3 
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
    Plane { &lt;PLANE PARAMS&gt; } }  </text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Joints and bones  
&#8226;Describes the positions of the  
body parts as a function of joint angles.  
&#8226;Body parts are usually called &#8220;bones&#8221;  
 
&#8226;Each joint is characterized by its degrees of freedom (dof)  
&#8226;Usually rotation for articulated bodies  
1 DOF: knee  2 DOF: wrist  3 DOF: arm  
75 </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Animation  
&#8226;Hierarchical structure is essential for 
animation  
&#8226;Eyes move with head  
&#8226;Hands move with arms  
&#8226;Feet move with legs  
&#8226;&#8230; 
 
&#8226;Without such structure the model falls apart.  
73 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226;Further Reading  
&#8211;Buss, Chapter 2 
 
&#8226;Other Cool Stuff  
&#8211;Algebraic Groups  
&#8211;http://phototour.cs.washington.edu / 
&#8211;http://phototour.cs.washington.edu/findingpaths/  
&#8211;Free-form deformation of solid objects  
&#8211;Harmonic coordinates for character articulation  
19 </text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>It&#8217;s Underconstrained  
&#8226;Count degrees of freedom:  
&#8226;We specify one 3D point ( 3 equations)  
&#8226;We usually need more than 3 angles  
&#8226;p usually has tens of dimensions  
 
&#8226;Simple geometric example (in 3D): 
specify hand position, need elbow &amp; shoulder  
&#8226;The set of possible elbow location is a circle in 3D  vs vs 
87 </text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Inverse Kinematics  
&#8226;Forward Kinematics  
&#8226;Given the skeleton parameters p (position of the root and the joint 
angles) and the position of the point in local coordinates vs, what is 
the position of the point in the world coordinates vw? 
&#8226;Not too hard, just apply transform accumulated from the root.  
vs 
84 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Hierarchical models  
22 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Transformation for shear and scale  
Incorrect 
Normal 
Transformation  
Correct 
Normal 
Transformation  
12 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Skeleton Hierarchy  
&#8226;Each bone position/orientation described 
relative to the parent in the hierarchy:  
hips 
r-thigh 
r-calf 
r-foot left-leg ... 
vs y 
x 
z For the root, the 
parameters 
include a position 
as well  
Joints are 
specified by 
angles.  
76 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Questions?  
65 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Normal  
&#8226;Surface Normal:  unit vector that is locally 
perpendicular to the surface  
6 </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Forward Kinematics  
vs vs 
How to determine the world -space 
position for point vs? 
78 </text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
 
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Scene Graph Representation  
Group  Trsfrm  Trsfrm  Trsfrm  Trsfrm  Group  
31 &#8226;In fact, generalization of a tree: Directed Acyclic Graph (DAG)  
&#8226;Means a node can have multiple parents, but cycles are not allowed  
&#8226;Why? Allows multiple instantiations  
&#8226;Reuse complex hierarchies many times in the scene using different 
transformations (example: a tree)  
&#8226;Of course, if you only want to reuse meshes, just load the mesh once and make 
several geometry nodes point to the same data  
</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Connections  
&#8226;Not part of class, but cool  
&#8226;&#8220;Covariant&#8221;: transformed by the matrix  
&#8226;e.g., tangent  
&#8226;&#8220;Contravariant&#8221;: transformed by the inverse transpose  
&#8226;e.g., the normal  
&#8226;a normal is a &#8220;co -vector&#8221;  
 
&#8226;Google &#8220;differential geometry&#8221; to find out more  
18 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 R1 
52 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
50 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Transform Normal like Object?  
&#8226;translation?  
&#8226;rotation?  
&#8226;isotropic scale?  
&#8226;scale?  
&#8226;reflection?  
&#8226;shear?  
&#8226;perspective?  
11 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = T1 
45 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Adding Transformations  
36 </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Traversal State &#8211; Stack  
&#8226;The state is updated during traversal  
&#8226;Transformations  
&#8226;But also other properties (color, etc.)  
&#8226;Apply when entering node, &#8220;undo&#8221; when leaving  
 
&#8226;How to implement?  
&#8226;Bad idea to undo transformation by inverse matrix  
&#8226;Why I? T*T-1 = I does not necessarily hold in floating point even 
when T is an invertible matrix &#8211; you accumulate error  
&#8226;Why II? T might be singular, e.g., could flatten a 3D object onto a 
plane &#8211; no way to undo, inverse doesn&#8217;t exist!  
 
&#8226;Solution: Keep state variables in a stack  
&#8226;Push current state when entering node, update current state 
&#8226;Pop stack when leaving state -changing node  
&#8226;See what the stack looks like in the previous example!  64 </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Hierarchical models  
27 
Image courtesy of David Ba&#345;ina, Kamil Dudka, Jakub Fil&#225;k, Luk&#225;&#353; Hefka  on Wikimedia Commons. License: CC- BY-SA. This
content is excluded from our  Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Adding Attributes (Material, etc.)  
Group {   
    numObjects 3 
    Material { &lt;BLUE&gt; }  
    Group { 
        numObjects 3 
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; }  
        Box { &lt;BOX PARAMS&gt; } }  
    Group { 
        numObjects 2 
        Material { &lt;BROWN&gt; }  
        Group { 
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Box { &lt;BOX PARAMS&gt; } }  
        Group { 
            Material { &lt;GREEN&gt; }  
            Box { &lt;BOX PARAMS&gt; }  
            Material { &lt;RED&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; }  
            Material { &lt;ORANGE&gt; }  
            Sphere { &lt;SPHERE PARAMS&gt; } } }  
            Material { &lt;BLACK&gt; }  
    Plane { &lt;PLANE PARAMS&gt; } }  
35 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Transform Normal like Object?  
&#8226;translation?  
&#8226;rotation?  
&#8226;isotropic scale?  
&#8226;scale?  
&#8226;reflection?  
&#8226;shear?  
&#8226;perspective?  
10 </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Questions?  
37 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Different objects  
&#8226;Points  
&#8226;represent locations  
&#8226;Vectors  
&#8226;represent movement, force, displacement from A to B  
&#8226;Normals  
&#8226;represent orientation, unit length  
&#8226;Coordinates  
&#8226;numerical representation of the above objects  
in a given coordinate system  
5 </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Articulated Models  
&#8226;Articulated models  are rigid parts connected by joints  
&#8226;each joint has some angular degrees of freedom  
 
&#8226;Articulated models can be animated by specifying the joint 
angles as functions of time.  
74 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Traversal Example  
Group  
(table, fruits)  
Translate T2 
Group  
(tabletop, legs)  Group  
(basket, fruit)  Group  
(chair, legs)  Root  
Translate T1 
Rotate R1 Rotate R2 
S = R2 
59 ..... </text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Inverse Kinematics  
&#8226;Context: an animator wants to &#8220;pose&#8221; a character  
&#8226;Specifying every single angle is tedious and not intuitive  
&#8226;Simpler interface:  
directly manipulate position of e.g. hands and feet  
&#8226;That is, specify vw, infer joint transformations  
vs 
83 </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>6.837 -  Durand  Forward Kinematics  
vs vs 
parameter vector p This product is S Transformation matrix S for a point vs is a matrix 
composition of all joint transformations between 
the point and the root of the hierarchy. S is a 
function of all the joint angles between here and 
root. 
Note that the angles have a non -linear effect.  
81 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Real-time Shadows (PDF - 2.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec23/</lecture_pdf_url>
      <lectureno>23</lectureno>
      <slides>
        <slide>
          <slideno>9</slideno>
          <text>Shadow Map Look Up 
&#8226; We have a 3D point (x,y,z)WS 
&#8226; How do we look up  
the depth from the  
shadow map? 
 
&#8226; Use the 4x4  
perspective projection  
matrix from the light  
source to get (x',y',z')LS 
&#8226; ShadowMap(x',y') &lt; z'? 
Foley et al. &#8220;Computer Graphics Principles and 
Practice&#8221; (x,y,z)WS (x',y',z')LS 
10 &#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Tag pixels in one rendering pass to 
control their update in subsequent 
rendering passes 
&#8211; "For all pixels in the frame buffer" &#8594; 
"For all tagged pixels in the frame buffer" 
&#8226; Can specify different rendering 
operations for each case: 
&#8211; stencil test fails 
&#8211; stencil test passes &amp; depth test fails 
&#8211; stencil test passes &amp; depth test passes 
stencil buffer Stencil Buffer 
frame buffer 
depth buffer 
29 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Shadows as a Depth Cue 
3 &#169; source unknown. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>3. Percentage Closer Filtering 
&#8226; 5x5 samples 
&#8226; Nice antialiased 
shadow 
&#8226; Using a bigger 
filter produces 
fake soft shadows 
&#8226; Setting bias  
is tricky 
20 Questions? </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Further Reading on Shadows 
&#8226; Some recent techniques allow filtering the shadow 
map instead of just the tests (percentage closer) 
&#8211; Works pretty well in some situations, although not general 
&#8211;Variance Shadow Maps (Donnelly, Lauritzen I3D 2006)  
&#8211; Convolution Shadow Maps 
&#8226;Annen et al., SIGGRAPH 2008  
&#8226;Annen et al., EGSR 2007  
&#8226; An interesting hybrid between 
shadow maps and ray tracing 
&#8211;Aila and Laine, Alias-Free  
Shadow Maps, EGSR 200 4 
Annen et al. 2008 
43 &#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Today 
&#8226; Shadow Maps 
&#8226; Shadow Volumes 
&#8211; (The Stencil Buffer) 
&#8226; Deep Shadow Maps 
&#8226; Alias-free Shadow Maps 
54 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Enables motion blur in shadows 
53 
Questions? &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Content removed due to copyright restrictions -- please see slide 4,6-14 from Timo Aila and Samuli Laine's talk slides on "Alias-
Free Shadow Maps." available at https://research.nvidia.com/publication/alias-free-shadow-maps for further details.
56 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Shadow in Ray Tracing 
5 &#8226; Trace secondary (shadow) rays towards each 
light source 
&#8226; If the closest hit point is smaller than the 
distance to the light then the point is in shadow  </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>2. Bias (Epsilon) for Shadow Maps 
ShadowMap(x&#8217;,y&#8217;) + bias &lt; z&#8217; 
Choosing a good bias value can be very tricky 
Correct image Not enough bias 
(&#8220;surface acne&#8221;) Way too much bias 
15 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>2. Clip the Shadow Volumes 
&#8226; Clip the shadow volumes to the view frustum 
and include these new polygons   
&#8226;Messy CSG 
35 </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Instead we need to filter the result of the shadow test 
(weighted average of comparison results) 3. Percentage Closer Filtering 
18 50.2 50.0 50.0
50.1 1.2 1.1
1.3 1.4 1.2XSurface at z = 49.8
Sample transform step&lt;49.8?
0.550 0 0
0 1 1
1 1 1Compare Filter
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>That&#8217;s All For Today! 
58 
Image: Laine  and Aila, EG 2005  Image removed due to cop
yright restrictions --  please see Fig. 4 in S. Laine and T. Aila, &#8221;Hierarchical
Penumbra Casting.&#8221; Computer Graphics Forum 24(3) ( Eurographics  2005) for further details.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Limitations of Shadow Maps 
1.Field of View 
2.Bias (Epsilon) 
3.Aliasing 
12 &#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Shadow Maps Are Important 
&#8226; Both in high-end production software... 
&#8211; Pixar&#8217;s RenderMan 
&#8226; ... and in real-time rendering (e.g. games) 
7 &#169; Pixar. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Comm
ons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Shadows in Production 
&#8226; Often use 
shadow maps 
&#8226; Ray casting as 
fallback in case 
of robustness 
issues 
21 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; It is possible to implement shadow volumes rather 
efficiently using the stencil buffer 
&#8211; John Carmack&#8217;s Doom 3 engine did this very well 
&#8211; Shadow volumes had their 15 minutes of popularity around that 
ti
me 
&#8211; NVIDIA even came up with 
hardware acceleration 
(&#8220;UltraShadow &#8221;) 
&#8226; Further info 
&#8211;Wikipedia  
&#8211;Aila &amp; Akenine-M&#246;ller: 
Hierarchical Shadow Volumes,  
Proc. Graphics Hardware 20 04 Shadow Volumes Are Sort of Pass&#233; 
Id Software 
40 Screenshot from video game Doom 4 removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Shadow Map Look Up 
&#8226; We have a 3D point (x,y,z)WS 
&#8226; How do we look up  
the depth from the  
shadow map? 
 
&#8226; Use the 4x4  
perspective projection  
matrix from the light  
source to get (x',y',z')LS 
&#8226; ShadowMap(x',y') &lt; z'? 
Foley et al. &#8220;Computer Graphics Principles and 
Practice&#8221; (x,y,z)WS (x',y',z')LS 
11 Questions? 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative 
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>3. Shadow Map Aliasing 
&#8226; Under-sampling of the shadow map 
&#8211; Jagged shadow edges 
16 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Shadows as the Origin of Painting 
4 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.This image is in the public domain. Author: David Allan (!744- 1796).</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Optimizing Shadow Volumes 
&#8226; Use silhouette edges only  (edge where  
a back-facing &amp; front-facing polygon meet) 
39 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; Can be done with hardware texture mapping 
&#8211; Texture coordinates u,v,w generated using 4x4 matrix 
&#8211; Modern hardware permits tests on texture values 
Hardware Shadow Maps 
23 Questions? </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Visibility function along depth 
&#8226; Fraction of a pixel occluded, as a function of depth 
&#8226; Due to  
&#8211; small occluders, semi-transparent objects, smoke &amp; 
volumetric effects 
46 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; Clear frame, depth &amp; stencil buffers 
&#8226; Draw all non-mirror geometry to 
frame &amp; depth buffers 
&#8226; Draw mirror to stencil buffer, where 
depth buffer passes 
&#8226; Set depth to infinity, where stencil 
buffer passes 
&#8226; Draw reflected geometry to  
frame &amp; depth buffer, where  
stencil buffer passes 
See NVIDIA's stencil buffer tutorial 
http://developer.nvidia.com 
also discusses blending, multiple  
mirrors, objects behind mirror, etc&#8230; Stencil Buffer &#8211; Real-time Mirror 
without  
stencil  
buffer: reflected 
geometry 
30 &#169; NVIDIA. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Deep shadow map results 
49 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Shadow Mapping 
&#8226; Texture mapping with 
depth information 
&#8226; 2 passes 
&#8211; Compute shadow  
map == depth from  
light source 
&#8226; You can think of 
it as a z-buffer as 
seen from the light 
&#8211; Render final image, 
check shadow map  
to see if points are  
in shadow 
Foley et al. &#8220;Computer Graphics Principles and 
Practice&#8221; 
9 &#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
Start at infinity 
 
... 
 
Draw front-facing shadow polygons 
If z-fail, decrement counter 
Draw back-facing shadow polygons 
If z-fail, increment counter 
 
...   
0 
+1 0 
36 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Deep shadow maps 
&#8226; Preprocess: 
Compute dense visibility function for each pixel of 
shadow map 
&#8211; send lots of rays or rasterize at a high resolution 
&#8211; compress visibility function at each pixel 
&#8226; to reduce memory cost 
&#8226; At render time, shadow query 
&#8211; Transform visible point into light coordinates 
&#8226; just like shadow maps 
&#8211; Read visibility value from compressed function 
47 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Deep shadow map results 
&#8226; Advantage of deep shadow map over higher-
resolution normal shadow map:  
Pre-filtering for shadow antialiasing 
51 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Today 
&#8226; Shadow Maps 
&#8226; Shadow Volumes 
&#8211; (The Stencil Buffer) 
&#8226; Deep Shadow Maps 
&#8226; Alias-free Shadow Maps 
 
24 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Compression algorithm 
&#8226; Approximation:  
Piecewise linear  
&#8226; Set an error bound 
&#8226; Decide which vertices  
to keep 
&#8226; Greedy from zero do far 
48 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
0 
+1 0  
 
&#8226; Introduces problems  
with far clipping plane 
&#8226; Solved by clamping the  
depth during clipping 
38 Questions? </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Irregular z buffer results 
57 A video clip demonstrating the irregular z buffer results has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>3. Percentage Closer Filtering 
&#8226; 5x5 samples 
&#8226; Nice antialiased 
shadow 
&#8226; Using a bigger 
filter produces 
fake soft shadows 
&#8226; Setting bias  
is tricky 
19 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Today 
&#8226; Shadow Maps 
&#8211; Shadow/View Duality  
&#8211; Texture Mapping 
&#8226; Shadow Volumes 
&#8226; Deep Shadow Maps 
&#8226; Alias-free Shadow Maps 
 
6 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Initialize stencil buffer to 0 
Draw scene with ambient light only 
Turn off frame buffer &amp; z-buffer updates 
Draw front-facing shadow polygons 
If z-pass &#8594; increment counter 
Draw back-facing shadow polygons 
If z-pass &#8594; decrement counter 
Turn on frame buffer updates 
Turn on lighting and  
redraw pixels with  
counter = 0 Shadow Volumes w/ the Stencil Buffer  
0 
+2 +1 
31 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Why are Shadows Important? 
&#8226; Depth cue 
&#8226; Scene 
Lighting 
&#8226; Realism 
&#8226; Contact  
points Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Shadow Volumes 
&#8226; If a point is inside a shadow  
volume cast by a particular light,  
the point does not receive any  
illumination from that light 
 
&#8226; Cost of naive  
implementation: 
 #polygons * #lights 
26 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>2. The Bias (Epsilon) Nightmare 
&#8226; For a point visible 
from the light source 
 ShadowMap(x&#8217;,y &#8217;) &#61627; z&#8217; 
&#8211; But due to rounding 
errors the depths 
never agree exactly 
&#8226; How can we  
avoid erroneous  
self-shadowing? 
&#8211; Add bias (epsilon)  
14 &#169; Addison-Wesley
. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Shadow Volumes Are Sort of Pass&#233; 
&#8226; The need to extract 
silhouette edges and 
rasterize the resulting 
shadow polygons is just 
too much work when 
scene complexities and 
image resolutions grow 
&#8226; Still, such use of the 
stencil buffer can be 
useful for other tricks ??? 
41 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>1. Field of View Problem 
&#8226; What if point to 
shadow is outside 
field of view of 
shadow map? 
&#8211; Use 6 shadow maps 
on the faces of a cube 
&#8211; ... or use only  
spot lights  
13 &#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Enables motion blur in shadows 
52 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226; Should we filter the depth?   
(weighted average of neighboring depth values) 
&#8226; No...  filtering depth is not meaningful 3. Shadow Map Filtering 
17 50.2 50.0 50.0
50.1 1.2 1.122.9
1.3 1.4 1.2XSurface at z = 49.8
Ordinary texture map filtering. Does not work for depth maps.&lt;49.8?
1 Filter Compare
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>3. "Z-Fail" Shadow Volumes 
0 
+1 0  
 
&#8226; Introduces problems  
with far clipping plane 
&#8226; Solved by clamping the  
depth during clipping 
37 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Can be done with hardware texture mapping 
&#8211; Texture coordinates u,v,w generated using 4x4 matrix 
&#8211; Modern hardware permits tests on texture values 
Hardware Shadow Maps 
22 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Shadow Volumes 
&#8226; Explicitly represent the volume  
of space in shadow 
&#8226; For each polygon 
&#8211; Pyramid with point  
light as apex 
&#8211; Include polygon to cap 
 
25 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Deep shadow maps 
&#8226; Lokovic &amp; Veach, Pixar  
&#8226; Shadows in participating media like smoke, inside 
hair, etc. 
&#8211; They represent not 
just depth of the 
first occluding 
surface, but the 
attenuation 
along the light rays 
&#8226; Note: shadowing  
only, no scattering 
45 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 &#8211; Durand  Real-Time 
Shadows MIT EECS 6.837 
Computer Graphics 
 
Wojciech Matusik 
1 A cartoon has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>1. Test Eye with Respect to Volumes 
&#8226; Adjust initial  
counter value 
 
 Expensive 
0 
+1 0 
+1 
34 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Initialize stencil buffer to 0 
Draw scene with ambient light only 
Turn off frame buffer &amp; z-buffer updates 
Draw front-facing shadow polygons 
If z-pass &#8594; increment counter 
Draw back-facing shadow polygons 
If z-pass &#8594; decrement counter 
Turn on frame buffer updates 
Turn on lighting and  
redraw pixels with  
counter = 0 Shadow Volumes w/ the Stencil Buffer  
0 
+2 +1 
32 Questions? </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Better Shadow Volumes 
&#8226; Shoot a ray from the eye to 
the visible point 
&#8226; Increment/decrement a 
counter each time we 
intersect a shadow  
volume polygon  
  
&#8226; If the counter &#8800; 0, 
the point is  
in shadow +1 -1 
+1 
28 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Shadow/View Duality 
&#8226; A point is lit if it 
is visible from the 
light source 
 
 
&#8226; Shadow 
computation 
similar to view 
computation 
8 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>If the Eye is in Shadow... 
&#8226; ... then a counter of 0 does 
not necessarily mean lit 
&#8226; 3 Possible Solutions: 
1.  Explicitly test eye  
point with respect  
to all shadow volumes 
2.  Clip the shadow  
volumes to the  
view frustum 
3.  "Z-Fail" shadow  
volumes -1 
0 -1 
33 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Alias-free shadow maps 
&#8226; Aila and Laine,  
http://www.tml.tkk.fi/~timo/  
&#8226; aka Irregular z-buffer by Johnson et al. 
http://pl887.pairlitesite.com/papers/tog05-izb/ 
 
&#8226; Following slides by Aila and Laine 
55 </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Today 
&#8226; Shadow Maps 
&#8226; Shadow Volumes 
&#8211; (The Stencil Buffer) 
&#8226; Deep Shadow Maps 
&#8226; Alias-free Shadow Maps 
44 </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Shadow Volumes 
&#8226; If a point is inside a shadow  
volume cast by a particular light,  
the point does not receive any  
illumination from that light 
 
&#8226; Cost of naive  
implementation: 
 #polygons * #lights 
27 Questions? </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Shadow Volumes Are Sort of Pass&#233; 
&#8226; The need to extract 
silhouette edges and 
rasterize the resulting 
shadow polygons is just 
too much work when 
scene complexities and 
image resolutions grow 
&#8226; Shadow maps are bad, 
but they&#8217;re the best 
we&#8217;ve got! ??? 
42 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Deep shadow map results 
50 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Collision Detection and Response (PDF - 1.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec10/</lecture_pdf_url>
      <lectureno>10</lectureno>
      <slides>
        <slide>
          <slideno>3</slideno>
          <text>4 Collision Response for Particles 
N v 
vn vt 
v=vn+vt 
normal component 
tangential component </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226;Tangential velocity vt  
often unchanged 
&#8226;Normal velocity vn reflects: 
 
  
&#8226;Coefficient of restitution &#949; 
 
&#8226;When &#949; = 1, mirror reflection 
5 Collision Response for Particles 
N v 
vn vt 
N v vnew 
N v vnew &#949;=1 
&#949;&lt;1 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226;Detection 
&#8226;Response 
&#8226;Overshooting problem  
(when we enter the solid) 
2 Collisions  </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226;Top down 
&#8211;Divide and conquer  
 
&#8226;Bottom up 
&#8211;Cluster nearby objects 
 
&#8226;Incremental 
&#8211;Add objects one by one, binary-tree style.  
26 Hierarchy Construction </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3Top-Down Construction - Recurse 
Questions? 
&#169; Sara McMains. All righ ts reserved. This content
is excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
&#169; Gareth Bradshaw. All rights reserved.
This content is excluded from our Creative
Commons license. For more information, 
see http://ocw.mit.edu/help/faq-fair-use/. 
This image is in the public domain.Source: Wikimedia Commons .
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.
32</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226;Usually, we detect collision when it is too late: 
we are already inside 
&#8226;Solution: Back up 
&#8226;Compute intersection point  
&#8226;Ray- object intersection!  
&#8226;Compute response there  
&#8226;Advance for remaining  
fractional time step  
7 Collisions &#8211; Overshooting 
backtracking xi 
xi+1 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>/g135 /g55/g68/g78/g72/g3/g79/g82/g81/g74/g72/g86/g87/g3/g86/g70/g72/g81/g72/g3/g71/g76/g80/g72/g81/g86/g76/g82/g81/g3
/g135 /g38/g88/g87/g3/g76/g81/g3/g87/g90/g82/g3/g76/g81/g3/g87/g75/g72/g3/g80/g76/g71/g71/g79/g72/g3
/g177 /g68/g86/g86/g76/g74/g81/g3/g72/g68/g70/g75/g3/g82/g69/g77/g72/g70/g87/g3 /g82/g85/g3/g87/g85/g76/g68/g81/g74/g79/g72/g3/g87/g82/g3/g82/g81/g72/g3/g86/g76/g71/g72/g3
/g177 /g69/g88/g76/g79/g71/g3/g86/g83/g75/g72/g85/g72/g18/g69/g82/g91/g3/g68/g85/g82/g88/g81/g71/g3/g76/g87/g3
&#169; Sara McMains. All righ ts reserved. This contentTop-Down Construction - Recurse 
is excluded from our Creative Commons license.
For more information, seehttp://ocw.mit.edu/help/faq-fair-use/.
&#169; Gareth Bradshaw. All rights reserved.This content is excluded from our CreativeCommons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.
This image is in the public domain.Source: Wikimedia Commons .
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights/g3reserved. This content is
excluded from our/g3Creative Commons license. For more information, Courtesy of Patrick Laug. Used with permission.
see http://ocw.mit.edu/help/faq-fair-use/.
31 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&#8226;Two spheres, centers C1 and C2, radii r1 and r2 
&#8226;Intersect only if ||C 1C2||&lt;r1+r2 
13 Sphere-Sphere Collision Test  
C1 C2 r1 r2 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226;Using axis -aligned bounding box 
&#8211;center=  
((xmin+xmax)/2, (ymin+ymax)/2, (zmin, zmax)/2) 
&#8211;Better than the average of the vertices because does not suffer from non -uniform tessellation  
28 Bounding Sphere of a Set of Points 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226;Using axis -aligned bounding box 
&#8211;center=  
((xmin+xmax)/2, (ymin+ymax)/2, (zmin, zmax)/2) 
&#8211;Better than the average of the vertices because does not suffer from non -uniform tessellation  
29 Bounding Sphere of a Set of Points 
Questions?  
&#169; Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/. Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837 &#8211; D
urand  
MIT EECS 6.837 Computer Graphics 
Collision Detection  
and Response 
Philippe Halsman : Dali Atomicus  MIT EECS 6.837 &#8211; Matusik 
This image is in the public domain. Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226;http://www.youtube.com/watch?v=b_cGXtc-nMg 
&#8226;http://www.youtube.com/watch?v=nFd9BIcpHX4&amp;f
eature=related 
&#8226;http://www.youtube.com/watch?v=2SXixK7yCGU 
25 Questions? </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false  
   // if there is nowhere to go, test everything 
   if (node1- &gt;isLeaf() &amp;&amp; node2-&gt;isLeaf()) 
      perform full test between all primitives within nodes 
    // otherwise go down the tree in the non- leaf path 
   if ( !node2- &gt;isLeaf() &amp;&amp; !node1- &gt;isLeaf() ) 
      // pick the larger node to subdivide, then recurse 
   else       // recurse down the node that is not a leaf     return false 
23 Pseudocode (with leaf case) </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226;Use simpler conservative proxies  
(e.g. bounding spheres) 
 
&#8226;Recursive (hierarchical) test 
&#8211;Spend time only for parts of the scene that are close  
 
&#8226;Many different versions, we will cover only one 
 
 
11 Hierarchical Collision Detection </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226;http://isg.cs.tcd.ie/spheretree/ 
15 Examples of Hierarchy 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226;Place spheres around objects  
&#8226;If spheres do not intersect, neither do the objects!  
&#8226;Sphere-sphere collision test is easy. 
12 Bounding Spheres 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Reference 
Image of the cover of the book, "Real Time Collision Detection," by Christer Ericson has been removed
due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226;Axis Aligned Bounding Boxes  
&#8211;&#8220;R-Trees&#8221; 
 
&#8226;Oriented bounding boxes  
&#8211; S. Gottschalk, M. Lin, and D. Manocha. &#8220;OBBTree: A hierarchical Structure 
for rapid interference detection,&#8221; Proc. Siggraph 96. ACM Press, 1996 
 
&#8226;Binary space partitioning trees; kd-trees  
24 Other Options </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&#8226;Usually, we detect collision when it is too late: 
we are already inside 
&#8226;Solution: Back up 
&#8226;Compute intersection point  
&#8226;Ray- object intersection!  
&#8226;Compute response there  
&#8226;Advance for remaining  
fractional time step  
&#8226;Other solution: 
Quick and dirty hack 
&#8226;Just project back to object closest point 
8 Collisions &#8211; Overshooting 
fixing backtracking xi 
xi+1 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; Take longest scene dimension 
&#8226; Cut in two in the middle 
&#8211; assign each object or triangle to one side 
&#8211; build sphere around it 
30 Top-Down Construction 
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Patrick Laug . Used with permission.This image is in the public domain.
Source: Wikimedia Commons .&#169; Sara McMains . All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.&#169; Gareth Bradshaw. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
21 &#169; G
areth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226;A cloth has many points of contact 
&#8226;Stays in contact 
&#8226;Requires 
&#8211;Efficient collision detection  
&#8211;Efficient numerical treatment (stability)  
34 The Cloth Collision Problem 
Image from Bridson et al.   
&#169; AC
M. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226;Trivial given center C 
&#8211;radius = max i ||C-Pi|| 
27 Bounding Sphere of a Set of Points 
C 
&#169; Gareth Bradsha
w. All rights reserved. This content is excluded  from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Collision Response for Particles 
N v </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&#8226;Pong: &#949; =? 
&#8226;http://www.youtube.com/watch?v=sWY0Q_lMFfw  
&#8226;http://www.xnet.se/javaTest/jPong/jPong.html  
9 Questions? 
 
Animation removed due to copyright restrictions.
Image courtesy of Chris Rand  on Wikimedia Commons. License:  CC-BY-SA.
This content is excluded from our Creative Commons license. For more info
rmation, see http://ocw.mit
.edu/help/faq-fair-use/ . This image is in the public domain.
Source: Wikimedia Commons . 
 
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>&#8226;Imagine we have n objects. Can we test all pairwise 
intersections? 
&#8211;Quadratic cost O(n2)! 
 
&#8226;Simple optimization: separate static objects  
&#8211;But still O(static &#215; dynamic+ dynamic2) 
10 Collision Detection in Big Scenes </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>boolean intersect(node1, node2) 
   // no overlap? ==&gt; no intersection! 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false 
    // recurse down the larger of the two nodes 
   if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true 
 
   // no intersection in the subtrees? ==&gt; no intersection!    return false 
16 Pseudocode (simplistic version) </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226;Hierarchy of bounding spheres 
&#8211;Organized in a tree  
&#8226;Recursive test with early pruning 
14 Hierarchical Collision Test  
Root encloses 
whole object 
&#169; Gareth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Robust Treatment of Simultaneous Collisions  
David Harmon, Etienne Vouga, Rasmus Tamstorf, Eitan  Grinspun  
Animation removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 boolean intersect(node1, node2) 
   if (!overlap(node1-&gt;sphere, node2-&gt;sphere)  
      return false    if (node1- &gt;radius()&gt;node2- &gt;radius()) 
      for each child c of node1          if intersect(c, node2) return true    else       for each child c f node2         if intersect(c, node1) return true    return false 
node 1 
node 2 
&#169; G
areth Bradshaw. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.Courtesy of Patrick Laug. Used with permission.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226;Usually, we detect collision when it is too late: 
we are already inside 
6 Collisions &#8211; Overshooting 
xi 
xi+1 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Particle Systems and ODEs (PDF - 1.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec07/</lecture_pdf_url>
      <lectureno>07</lectureno>
      <slides>
        <slide>
          <slideno>90</slideno>
          <text>91 Image from Sameboat
 Image courtesy of Sameboat on Wikimedia Commons. License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Euler, Visually 
X(t) 
f(X,t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; We have N point masses 
&#8211; Let&#8217;s just stack all xs and vs in a big vector of length 6N 
40 Now, Many Particles 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; That was Brute Force 
&#8211; Meaning all O( n2) pairs of particles 
were considered when computing forces 
&#8211; Yes, computers are fast these days, but this gets 
prohibitively expensive soon. (The square in n2 wins.) 
 
&#8226;Hierarchical techniques  approximate forces caused 
by many distant attractors by one force, yields O( n)! 
&#8211;&#8220;Fast Multipole Method&#8221;, Greengard and Rokhlin, J 
Comput Phys 73, p. 325 (1987)  
&#8211; This inspired very cool hierarchical illumination rendering 
algorithms in graphics (hierarchical radiosity, etc.) 
61 An Aside on Gravity </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>80 Battle of the Helm&#8217;s deep, LOTR 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
    For each particle p in PL  
        p-&gt;position+=p-&gt;velocity*dt;  //dt: time step   
        p-&gt;velocity-=g*dt;  //g: gravitation constant   
        glColor(p.color);  
        glVertex(p.position); 
29 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions .</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; Midpoint, Trapezoid, Runge-Kutta 
&#8211; Also, &#8220;implicit methods&#8221; (next week) 
 
 
 
 
 
 
&#8226; Extremely valuable resource: SIGGRAPH 2001 
course notes on physically based modeling  
56 More Accurate Alternatives 
More on this during next 
class </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; Current state X 
&#8226; Examine f(X ,t) at (or near) current state 
&#8226; Take a step to new value of X 
46 Intuitive Solution: Take Steps 
f = d/d t X is a vector 
that sits at each 
point in phase 
space, pointing the 
direction. 
&#8220;            &#8221; 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more i n
formation, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; Numerical solution is called &#8220;integration of the 
ODE&#8221; 
&#8226; Many techniques 
&#8211; Today, the simplest one 
&#8211; Thursday and next week we&#8217;ll look at some more 
advanced techniques 
45 Numerics of ODEs </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21 EA Fight Night 4 Physics Trailer 
</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
     
27 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>89 
Rendering and Motion Blur 
Metal Gear Solid by Konami &#169; Konami Digital Entertainment, Inc..  All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Keyframing 
&#8226; Procedural 
&#8226; Physically-based 
&#8211; Particle Systems: TODAY 
&#8226; Smoke, water, fire, sparks, etc. 
&#8226; Usually heuristic as opposed to simulation, but not always 
&#8226; Mass-Spring Models (Cloth) NEXT CLASS 
&#8211; Continuum Mechanics (fluids, etc.), finite elements 
&#8226; Not in this class 
&#8211; Rigid body simulation 
&#8226; Not in this class Types of Animation 
2 CERN </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; Gravity depends on all other particles 
&#8226; Opposite for pairs of particles 
&#8226; Force in the direction of pi-pj with magnitude 
inversely proportional to square distance 
 
 
 
&#8226; Testing all pairs is O(n2)! 
59 Forces: Gravity (N-body problem) 
Pi 
Pj where G=6.67&#215; 10-11 Nm2/kg2 
Particles are not 
independent! 
Pk </text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text> 
 
 
 
 
 
 
&#8226; Often use texture maps (fire, clouds, smoke puffs) 
&#8211; Called &#8220;billboards&#8221; or &#8220;sprites&#8221; 
&#8211; Always parallel to image plane 
90 Rendering and Motion Blur 
90 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text> 
 
 
 
&#8226; Why reduce? 
37 Reduction to 1st Order 
2 variables ( x, v) 
instead of just one </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Losasso, F., Talton, J., Kwatra, N. and Fedkiw, R., 
"Two-way Coupled SPH and Particle Level Set Fluid 
Simulation", IEEE TVCG 14, 797-804 (2008).  These Stanford folks use SPH for resolving the 
small-scale spray and mist that would otherwise 
be too much for the grid solver to handle. 
&#169; IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 Euler, Visually 
X(t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; Point 
 
&#8226; Rigid body 
5 Types of Dynamics 
Animation by Mark Carlson </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226;http://processing.org/learning/topics/simpleparticlesy
stem.html  
 
31 Demo with Processing </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Particle-based methods can range from pure 
heuristics (hacks that happen to look good) to 
&#8220;real&#8221; simulation 
 
&#8226; Basics are the same: 
Things always boil 
down to integrating ODEs!  
&#8211; Also in the case of 
grids/computational meshes Take-Home Message 
22 
Andrew Selle et al . 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86 Unreal Engine 
&#169; Epic Games, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
 
28 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>&#8226; Often created by generators  or emitters 
&#8211; Can be attached to objects in the model 
&#8226; Given rate of creation: particles/second 
&#8211; record tlast of last particle created 
 
 
&#8211; create n particles.  
update tlast if n &gt; 0 
&#8226; Create with (random) distribution  
of initial x and v 
&#8211;if creating n &gt; 1 particles at once, spread out on path 
82 Where do particles come from? 
http://www.particlesystems.org / Image removed due to 
copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 Euler, Visually 
 X(t) 
f(X,t) h f(X,t) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Moves along tangent; can leave solution curve, e.g.: 
 
 
&#8226; Exact solution is circle: 
54 Euler&#8217;s method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>79 Processing demo 
&#8226;http://processing.org/learning/topics/flocking.html  
 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>PL: linked list of particle = empty; 
 
25 Simple Particle System: Sprinkler 
Image Jeff Lander Image by  Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 Reduction to 1st Order 
2 unknowns ( x, v) 
instead of just x 
or 
&#8226; Point mass: 2nd order ODE 
 
 
 
&#8226; Corresponds to system of 
    first order ODEs 
This image is in the public domain.
Source: Wikimedia Commons .</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>&#8226; Let&#8217;s stack the pair ( x, v) into a bigger state vector X 
39 Notation 
For a particle in 
3D, state vector X 
has 6 numbers </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 Path through a Vector Field 
&#8220;When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ?&#8221; 
&#8226;X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
&#8226;f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction. 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; Simplest and most intuitive 
&#8226; Pick a step size h 
&#8226; Given X0=X(t0), take step: 
 
 
 
 
&#8226; Piecewise-linear approximation to the path 
&#8226;Basically, just replace d t by a 
small but finite number 
47 Euler&#8217;s Method 
</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Basic particle systems are simple hacks 
&#8226; Extend to physical simulations, e.g., clothes 
&#8226; For this, we need to understand numerical integration 
&#8226; This lecture: point particles 
&#8226; Next lecture: mass-spring and clothes  
 
33 Path forward </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Effect of Step Size 
&#8226; Step size controls accuracy  
&#8226; Smaller steps more closely follow curve 
&#8211; May need to take many small steps per frame 
&#8211; Properties of f(X, t) determine this (more later) 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; A force changes the motion of the system 
&#8211; Newton says: When there are no forces, motion continues 
uniformly in a straight line (good enough for us) 
 
&#8226; Forces can depend on location, time, velocity 
&#8211; Gravity, spring, viscosity, wind, etc. 
 
&#8226; For point masses, forces are vectors 
&#8211;Ie., to get total force, take vector 
sum of everything 
57 What is a Force?  
Wikipedia 
Image courtesy of BillC on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from ou
r Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>&#8226; Again, reuse splines! 
84 Emitter Controls 
 Controls from ParticleFX by Remedy Entertainment &#169; Remedy Entertainment Ltd. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>87 Unreal Engine 
&#169; Epic Games, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Path through a Vector Field 
&#8220;When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ?&#8221; 
&#8226;X(t): path in multidimensional phase space 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Newtonian Mechanics 
or 
&#8226; Point mass: 2nd order ODE 
 
 
 
 
&#8226; Position x and force F are vector quantities 
&#8211; We know F and m, want to solve for x 
 
&#8226; You have all seen this a million times before 
This image is in the public domain.
Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text> 
66 
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Sprinkler 
 
 
 
&#8226;http://www.youtube.com/watch?v=rhvH12nC6_Q 
 
13 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 MIT EECS 6.837 &#8211; Durand  Particle Systems Overview 
&#8226;Emitters generate tons of &#8220;particles&#8221; 
&#8226; Describe the external forces with a force field 
&#8226;Integrate  the laws of mechanics (ODEs) 
&#8226; In the simplest case, each particle is independent  
&#8226; If there is enough randomness  (in particular at the 
emitter) you get nice effects 
&#8211; sand, dust, smoke, sparks, flame, water, &#8230; 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/  </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1; //how random the colors are  
For each time step 
    Generate k particles 
        p=new particle();  
        p-&gt;position=(0,0,0);  
        p-&gt;velocity=(0,0,1)+spread*(rnd(), rnd(), rnd());  
        p.color=(0,0,1)+colorSpread*(rnd(), rnd(),rnd());  
        PL-&gt;add(p); 
    For each particle p in PL  
        p-&gt;position+=p-&gt;velocity*dt; //dt: time step   
        p-&gt;velocity-=g*dt; //g: gravitation constant   
        glColor(p.color);  
        glVertex(p.position); 
30 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text> 
 
 
 
 
&#8226; (&#8220;Boid" was an 
abbreviation of 
"birdoid". His rules 
applied equally to 
simulated flocking 
birds, and shoaling 
fish.) 
75 Flocks (&#8220;Boids&#8221;) 
Courtesy of Craig W. Reynolds. Used with permission.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 MIT EECS 6.837 &#8211; Durand  Particle Systems Overview 
&#8226;Emitters generate tons of &#8220;particles&#8221; 
&#8226; Describe the external forces with a force field 
&#8211; E.g., gravity, wind 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/  </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 http://www.youtube.com/watch?v=nl7maklgYnI&amp;feature=related  
 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Fire 
 
 
 
 
&#8226; http://www.youtube.com/watch?v=6hG00etwRBU 
 
14 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226;Curl noise for procedural fluid flow , R. Bridson, J. 
Hourihan, and M. Nordenstam, Proc. ACM 
SIGGRAPH 2007. 
65 Example: Procedural Spatial Field 
Plausible, 
conrollable force 
fields &#8211; just 
advecting particles 
along the flow gives 
cool results! 
 
And it&#8217;s simple, too!  
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; Externally specified force (or velocity) fields in 
space 
&#8226; Force on particle i depends only on its position 
&#8226; Arbitrary functions 
&#8211; wind 
&#8211; attractors, repulsors 
&#8211; vortices 
&#8226; Can depend on time 
&#8226; Note: these add energy, may need damping 
63 Forces: Spatial Fields 
Bridson et al.  </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text> 
 
 
 
 
 
 
http://www.youtube.com/watch?v=uhTuJZiAG64  
 
60 Real-Time Gravity Demo 
NVIDIA </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 MIT EECS 6.837 &#8211; Durand  Particle Systems Overview 
&#8226;Emitters generate tons of &#8220;particles&#8221; 
&#8226; Describe the external forces with a force field 
&#8226;Integrate  the laws of mechanics (ODEs) 
&#8226; In the simplest case, each particle is independent 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/  </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 MIT EECS 6.837 &#8211; Durand  More Eyecandy from NVIDIA 
&#8226; Fluid flow solved using a regular grid solver 
&#8211; This gives a velocity field 
&#8226; 0.5M smoke particles advected using the field 
&#8211; That means particle velocity is given by field 
&#8226; Particles are 
for rendering, 
motion solved 
using other 
methods 
&#8226;Link to 
video NVIDIA 
72 Image removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Assign physical properties to objects 
&#8211; Masses, forces, etc. 
&#8226; Also procedural forces (like wind) 
&#8226; Simulate physics by solving equations of motion 
&#8211; Rigid bodies, fluids, plastic deformation, etc. 
&#8226; Realistic but difficult to control 
3 Types of Animation: Physically-Based 
v0 
m g 
3 3 </text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>94 Questions? 
Early particle fun by Karl Sims Courtesy of Karl Sims . Used with permission.</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; Flocking birds, fish shoals 
&#8211; http://www.red3d.com/cwr/boids/ 
&#8226; Crowds (www.massivesoftware.com ) 
 
73 More Advanced &#8220;Forces&#8221; </text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>&#8226; Further reading 
&#8211;Witkin, Baraff, Kass: Physically-based Modeling Course 
Notes, SIGGRAPH 2001  
&#8226;Extremely good, easy-to -read resource. Highly 
recommended! 
 
&#8211;William Reeves: Particle systems&#8212;a technique for 
modeling a class of fuzzy objects, Proc. SIGGRAPH 1983  
&#8226; The original paper on particle systems 
 
&#8211;particlesystems.org  
95 That&#8217;s All for Today! </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226; Mass-spring and deformable surface dynamics 
&#8211; surface represented as a set of points 
&#8211; forces between neighbors keep the surface coherent 
16 Generalizations &#8211; Next Class 
Image Michael Kass 
Image Witkin &amp; Baraff &#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>&#8226; The grass is made of particles 
&#8211; The entire lifetime of the particle is drawn at once. 
&#8211; This can be done procedurally on the GPU these days! 
93 Particle Modeling [Reeves 1983] 
William Reeves &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; Moves along tangent; can leave solution curve, e.g.: 
 
 
&#8226; Exact solution is circle: 
 
 
&#8226; Euler spirals outward 
no matter how small h is 
&#8211; will just diverge more slowly 
55 Euler&#8217;s method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text> 
 
&#8226; Damping force on particle i determined its velocity 
&#8211; Opposes motion 
&#8211; E.g. wind resistance 
&#8226; Removes energy, so system can settle 
&#8226; Small amount of damping can stabilize solver 
&#8226; Too much damping makes motion like in glue 
62 Forces: Viscous Damping 
</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; More advanced versions of behavior  
&#8211; flocks, crowds 
&#8226; Forces between particles 
&#8211; Not independent any more  
15 Generalizations 
http://www.blendernation.com/2008/01/05/simulat
ing-flocks-herds- and-swarms-using-
experimental-blender-boids-particles/  
See http://www.red3d.com/cwr/boids/  
for discussion on how to do flocking.  
 
We&#8217;ll come back to this a little later. &#169; Animate Projects Limited 2013. All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; We have N point masses 
&#8211; Let&#8217;s just stack all xs and vs in a big vector of length 6N 
&#8211;Fi denotes the force on particle i 
&#8226; When particles don&#8217;t interact, Fi only depends on xi and vi. 
41 Now, Many Particles 
f gives d/dt X, 
remember! </text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>&#8226; Again, reuse splines! 
85 Emitter Controls 
 Controls from ParticleFX by Remedy Entertainment 
&#169; Remedy Entertainment Ltd. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Lennard-Jones forces 
http://www.youtube.com/watch?v=XfjYlKxKIWQ&amp;feature=autoplay&amp;list=PL0
605C44C6E8D5EDB&amp;lf=autoplay&amp;playnext=2  
69 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Cloth Video 
Selle. A, Su, J., Irving, G. and Fedkiw, R., "Robust High-
Resolution Cloth Using Parallelism, History-Based Collisions, 
and Accurate Friction," IEEE TVCG 15, 339-350 (2009).  </text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Point 
4 Types of Dynamics </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>&#8226; Often not shaded (just emission, think sparks) 
&#8211; But realistic non-emissive particles needs shadows, etc. 
&#8226; Most often, particles don&#8217;t contribute to the z-buffer, 
i.e., they do not fully occlude stuff that&#8217;s behind 
&#8211; Rendered with z testing on 
(particles get occluded by solid stuff) 
&#8226; Draw a line for 
motion blur  
&#8211;( x, x+v dt ) 
&#8211; Or an elongated 
quad with texture 
88 
Rendering and Motion Blur 
Metal Gear Solid by Konami &#169; Konami Digital Entertainment, Inc..  All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; Point 
 
&#8226; Rigid body 
 
&#8226; Deformable body  
(include clothes, fluids, smoke, etc.) 
6 Types of Dynamics 
Mark Carlson &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Today We Focus on Point Dynamics 
&#8226; Lots of points! 
&#8226; Particles systems 
&#8211; Borderline between 
procedural and physically-
based 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Flocks (&#8220;Boids&#8221;) 
Craig Reynolds 
76 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Real-time particles in games 
&#8226;http://www.youtube.com/watch?v=6DicVajK2xQ  
 
 </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44 Questions? 
http://vimeo.com/14597952  </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226;http://processing.org/learning/topics/smokeparticlesy
stem.html  
 
64 Processing demo </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text> 
 
&#8226; E.g., approximate fluid using Lennard-Jones force: 
 
 
&#8226; Repulsive + attractive force 
&#8226; Again, O(N2) to test all pairs 
&#8211; usually only local 
&#8211; Use buckets to optimize. Cf. 6.839 
67 Forces: Other Spatial Interaction 
distance force 
Particles are not 
independent! </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Questions? 
http://www.cs.columbia.edu/cg/ESIC/esic.html  
 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text> 
 
 
&#8226; Given a function f(X,t) compute X(t) 
&#8226; Typically, initial value problems : 
&#8211; Given values X(t0)=X0 
&#8211; Find values X(t) for t &gt; t0 
 
&#8226; We can use lots of standard tools 
34 Ordinary Differential Equations 
</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Massive software 
&#8226;http://www.massivesoftware.com/  
&#8226; Used for battle scenes in the Lord of The Rings </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 MIT EECS 6.837 &#8211; Durand  Particle Systems Overview 
&#8226;Emitters generate tons of &#8220;particles&#8221; 
&#8226; Describe the external forces with a force field 
&#8226;Integrate  the laws of mechanics (ODEs) 
&#8211; Makes the particles move 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/  </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>&#8226; One of the earliest 
particle systems (from 1982) 
&#8226; Also, fractal landscapes  
 
 
 
 
 
&#8226; Described in [ Reeves, 1983 ] 
92 Star Trek 2 &#8211; The Wrath of Khan 
Paramount Pictures 92 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 MIT EECS 6.837 &#8211; Durand  Particle Systems Overview 
&#8226;Emitters generate tons of &#8220;particles&#8221; 
&#8211; Sprinkler, waterfall, chimney, 
gun muzzle, exhaust pipe, etc. 
Images of particle systems removed due to copyright restrictions.
http://www.particlesystems.org/  </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 Flocks (&#8220;Boids&#8221;) 
&#8226; From Craig Reynolds 
&#8226; Each bird modeled as a complex particle (&#8220;boid&#8221;) 
&#8226; A set of forces control its behavior 
&#8226; Based on location of other birds and control forces 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/. Courtesy of Craig W. Reynolds. Used with permission.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text> 
 
 
 
&#8226; Why reduce? 
&#8211; Numerical solvers grow more complicated with increasing 
order, can just write one 1st order solver and use it 
&#8211; Note that this doesn&#8217;t mean it would always be easy :-) 
38 Reduction to 1st Order 
2 variables ( x, v) 
instead of just one </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; Depends only on particle mass 
&#8226;f(X,t) = constant 
&#8226; Hack for smoke, etc: make gravity point up! 
&#8211; Well, you can call this buoyancy, too. 
58 Forces: Gravity on Earth 
v0 
mi g 
Image courtesy of MichaelMaggs on Wikimedia Commons. License: CC- BY-
SA. This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>PL: linked list of particle = empty; 
spread=0.1; //how random the initial velocity is 
colorSpread=0.1;  //how random the colors are  
 
26 Image Jeff Lander Simple Particle System: Sprinkler 
Image by Jeff Lander removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837 &#8211; Matusik 
MIT EECS 6.837 Computer Graphics 
 
Particle Systems and ODEs 
 
 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; It&#8217;s not all hacks: 
Smoothed Particle Hydrodynamics 
(SPH) 
&#8211; A family of &#8220;real&#8221; particle-based 
fluid simulation techniques. 
 
&#8211; Fluid flow is described by the 
Navier-Stokes Equations , a nonlinear 
partial differential equation (PDE) 
&#8226; SPH discretizes the fluid as small packets 
(particles!), and evaluates pressures and 
forces based on them. 
18 Generalizations 
Jos Stam M&#252;ller et al. 2005  
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>&#8226; In production tools, all these variables are time-
varying and controllable by the user (artist) 
&#8211; Emission rate, color, velocity distribution, 
direction spread, textures, etc. etc. 
&#8226; All as a function of time! 
&#8211; Example: ParticleFX 
(Max Payne Particle Editor) 
&#8226; Custom editor software 
&#8226; You can download it  (for Windows) 
and easily create your own particle 
systems. Comes with examples! 
&#8226; This is what we used for all the 
particles in the game! 
83 Particle Controls </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Collection of many small simple pointlike things 
&#8211; Described by their current state: position, velocity, age, color, 
etc. 
&#8226; Particle motion influenced by external force fields and 
internal forces between particles 
&#8226; Particles created by generators  or emitters  
&#8211; With some randomness 
&#8226; Particles often have lifetimes  
&#8226; Particles are often independent 
&#8226; Treat as points for dynamics, but 
rendered as anything you want 
24 What is a Particle System? 
Image courtesy of Halixi72  on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Questions? 
http://www.youtube.com/watch?v=dHWCT7RPjPo  
 
70 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226; Detection 
&#8226; Response 
 
&#8226; Covered later Collisions 
71 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 Euler, Visually 
X(t) 
f(X,t) h f(X,t) 
X(t+h) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>77 Predator-Prey 
&#8226; http://www.youtube.com/watch?v=rN8DzlgMt3M </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Bezier Curves and Splines (PDF)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec01/</lecture_pdf_url>
      <lectureno>01</lectureno>
      <slides>
        <slide>
          <slideno>7</slideno>
          <text>8 How Many Dimensions? 
This curve lies on the 2D plane, 
but is itself 1D. 
</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; For B&#233;zier curves, the  
    basis polynomials/vectors 
    are Bernstein polynomials 
 
&#8226; For cubic Bezier curve: 
    B1(t)=(1- t)&#179; B2(t)=3t(1- t)&#178; 
    B3(t)=3t&#178;(1- t) B4(t)=t&#179; 
    (careful with indices, many authors start at 0) 
&#8226; Defined for any degree 
45 Bernstein Polynomials </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226; Bezier curves: piecewise polynomials 
&#8226; Bernstein polynomials 
&#8226; Linear combination of basis functions 
&#8211; Basis: control points  weights: polynomials 
&#8211; Basis: polynomials  weights: control points  
&#8226; Subdivision by de Casteljau algorithm 
&#8226; All linear, matrix algebra 
 
69 Recap </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; User specifies 4 control points P1 ... P4 
&#8226; Curve goes through (interpolates) the ends P1, P4 
&#8226; Approximates the two other ones 
&#8226; Cubic polynomial 
23 Cubic B&#233;zier Curve 
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Smooth curves in 2D 
&#8211; Useful in their own right 
&#8211; Provides basis for surface 
editing 
3 Today 
This image is in the public domain
Source: Wikimedia Commons</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837 &#8211; Matusik 6.837 Computer Graphics 
 
B&#233;zier Curves and Splines 
Wojciech Matusik 
MIT CSAIL 
vectorportal.com  </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>&#8226; In 3D, each vector has three components x, y, z 
&#8226; But geometrically, each vector is actually the sum 
 
 
&#8226;i, j, k  are basis vectors 
 
&#8226; Vector addition: just add components 
&#8226; Scalar multiplication: just multiply components 
35 Usual Vector Spaces 
i j 
k </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; Polynomials 
&#8226; Can be added: just add the coefficients 
 
 
 
&#8226; Can be multiplied by a scalar: multiply the 
coefficients 
36 Polynomials as a Vector Space 
</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; Can we split a Bezier curve in the middle into 
two B&#233;zier curves? 
&#8211; This is useful for adding detail  
&#8211; It avoids using nasty higher-order curves 
63 Subdivision of a Bezier Curve 
? </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; Do we actually get the middle point? 
&#8226; B1(t)=(1-t) &#179; 
&#8226; B2(t)=3t(1- t)&#178; 
&#8226; B3(t)=3t&#178;(1 -t) 
&#8226; B4(t)=t&#179; 
67 Sanity Check 
&#10004; P&#8217;1 P&#8217;2 
P&#8217;&#8217;1 
P&#8217;&#8217;&#8217; P&#8217;3 P&#8217;&#8217;2 </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>More precisely: 
What&#8217;s a basis? 
 
&#8226; A set of &#8220;atomic&#8221; vectors 
&#8211; Called basis vectors 
&#8211; Linear combinations of basis vectors span the space 
&#8226; i.e. any cubic polynomial is a sum of those basis cubics 
&#8226; Linearly independent 
&#8211; Means that no basis vector can be obtained from the 
others by linear combination 
&#8226; Example: i, j, i+j is not a basis (missing k direction!) 
40 Basis for Cubic Polynomials 
i j 
k In 3D 
</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; Interpolation 
&#8211; Goes through all specified points 
&#8211; Sounds more logical 
 
&#8226; Approximation 
&#8211; Does not go through all points 
20 Interpolation vs. Approximation 
Interpolation 
Approximation </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 How Many Dimensions? 
This curve lies on 
the 2D plane, 
but is itself 1D. You can just as well 
define 1D curves in 
3D space. 
</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 
Properties of Bernstein Polynomials 
&#8226;          for all  0    t     1 
&#8226; Sum to 1 for every t 
&#8211; called partition of unity 
&#8226; These two together are the 
reason why B&#233;zier curves  
lie within convex hull 
&#8226; B1(0) =1 
&#8211; Bezier curve interpolates P1 
&#8226; B4(1) =1 
&#8211; Bezier curve interpolates P4 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>55 Questions? </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226;P(t) = P1B1( t) + P2B2( t) + P3B3( t) + P4B4( t) 
&#8211; Pi are 2D points ( xi, yi) 
&#8226;P(t) is a linear combination of the control points 
with weights equal to Bernstein polynomials at t 
&#8226; But at the same time, the control points  
(P1, P2, P3, P4) are the &#8220;coordinates&#8221; of the 
curve in the Bernstein basis 
&#8211; In this sense, specifying a B&#233;zier curve with control 
points is exactly like specifying a 2D point with its x 
and y coordinates. 
47 B&#233;zier Curves in Bernstein Basis </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56 More Matrix-Vector Notation 
matrix of 
control points (2 x 4) Bernstein polynomials 
(4x1 vector) 
point on curve 
(2x1 vector) 
</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>58 Cubic B&#233;zier in Matrix Notation 
point on curve 
(2x1 vector) 
&#8220;Geometry matrix&#8221; 
of control points P1..P4 
(2 x 4) &#8220;Spline matrix&#8221; 
(Bernstein) Canonical 
monomial basis </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; P2 and P3 never have full 
influence 
&#8211; Not interpolated! 
31 Weights 
P(t) =  (1-t)&#179;  P1 
 + 3t(1- t)&#178;   P2  
 + 3t&#178;(1 -t)  P3 
 + t&#179;  P4  </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Polylines 
&#8211; Sequence of vertices connected 
by straight line segments 
&#8211; Useful, but not for smooth curves 
&#8211; This is the representation 
that usually gets drawn in the end 
(a curve is converted into a polyline) 
&#8226;Smooth curves 
&#8211; How do we specify them? 
&#8211; A little harder (but not too much) 
4 Modeling 1D Curves in 2D 
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226; User specifies control points 
&#8226; We will interpolate the control points 
by a smooth curve 
&#8211; The curve is completely 
determined by the control points. 
11 General Principle of Splines 
</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Questions? </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Questions? </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Questions? </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; Specified by a few control points 
&#8211; Good for UI 
&#8211; Good for storage 
 
&#8226; Results in a smooth parametric curve P( t) 
&#8211; Just means that we specify x(t) and y(t) 
&#8211; In practice: low-order polynomials, chained together 
&#8211; Convenient for animation, where t is time 
&#8211; Convenient for tessellation because we can discretize 
t and approximate the curve with a polyline 
15 Splines </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; &gt; 4 control points 
&#8226; Bernstein Polynomials as the basis functions 
&#8211; For polynomial of order n, the ith basis function is  
 
 
 
&#8226; Every control point affects the entire curve  
&#8211; Not simply a local effect  
&#8211; More difficult to control for modeling 
&#8226;You will not need this in this class 
62 Higher-Order B&#233;zier Curves 
Courtesy of Seth Teller.  Used with 
permission. </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 6.837 &#8211; Durand Tessellation 
&#8226; It is easy to rasterize mathematical line segments 
into pixels 
&#8211; OpenGL and the graphics hardware can do it for you 
&#8226; But polynomials and other parametric functions 
are harder  
Image courtesy of Phrood on Wikimedia Commons. License: CC- BY-SA.This content is excluded from our
Creative Commons license. For moreinformation, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Tessellation 
t0 t1 t2 tn 
 
To display P(t),  
discretize it at discrete ts  </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text> 
 
 
&#8226; Any cubic polynomial is a 
linear combination of these: 
a0+a1t+a2t2+a3t3 = a0*1+ a1*t+a2*t2+a3*t3 
 
&#8226; They are linearly independent 
&#8211; Means you cannot write any of the four monomials as 
a linear combination of the others. (You can try.) 
41 Canonical Basis for Cubics 
1 
t 
t2 
t3 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; Geometry: control points coordinates assembled 
into a matrix (P1, P2, &#8230;, Pn+1) 
&#8226; Spline matrix: defines the type of spline 
&#8211; Bernstein for B&#233;zier  
&#8226; Power basis:  the monomials (1, t, ..., tn) 
&#8226; Advantage of general formulation 
&#8211; Compact expression 
&#8211; Easy to convert between types of splines 
&#8211; Dimensionality (plane or space) does not really matter 
59 General Spline Formulation 
</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Cubic polynomials form a 4D vector space. 
&#8226; Bernstein basis is canonical for B&#233;zier. 
&#8211; Can be seen as influence function of data points 
&#8211; Or data points are coordinates of the curve in the 
Bernstein basis 
&#8226; We can change between basis with matrices. 
54 Recap </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Take the middle point of each of the 3 segments 
&#8226; Construct the two segments joining them 
&#8226; Take the middle of those two new segments 
&#8226; Join them  
&#8226; Take the middle point P&#8217;&#8217;&#8217; 
65 De Casteljau Construction 
P&#8217;1 P&#8217;2 
P&#8217;&#8217;1 
P&#8217;&#8217;&#8217; P&#8217;3 P&#8217;&#8217;2 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; P(t) is a weighted 
combination of the 4 
control points with 
weights: 
&#8211; B1(t)=(1- t)&#179; 
&#8211; B2(t)=3t(1- t)&#178; 
&#8211; B3(t)=3t&#178;(1- t) 
&#8211; B4(t)=t&#179; 
&#8226; First, P1 is the most 
influential point, 
then P2, P3, and P4 
 30 Weights  
P(t) =  (1-t)&#179;  P1 
 + 3t(1- t)&#178;   P2  
 + 3t&#178;(1 -t)  P3 
 + t&#179;  P4  </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Questions? </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>57 Flashback 
</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Anything on your mind 
concerning Assignment 0? 
&#8226; Any questions about the course? 
 
&#8226; Assignment 1 (Curves &amp; Surfaces)  
&#8226; Linear algebra review session 
2 Before We Begin </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Explanation 1: 
&#8211; Magic! 
&#8226; Explanation 2:  
&#8211; These are smart weights that describe the influence of 
each control point 
&#8226; Explanation 3: 
&#8211; It is a linear combination of  basis polynomials. 
29 Why Does the Formula Work? </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; A type of smooth curve 
in 2D/3D 
&#8226; Many different uses 
&#8211; 2D illustration (e.g., Adobe Illustrator) 
&#8211; Fonts (e.g., PostScript, TrueType) 
&#8211; 3D modeling 
&#8211; Animation: trajectories 
&#8226; In general: interpolation 
and approximation 
5 Splines 
ACM &#169; 1987 &#8220;Principles of 
traditional animation applied to 3D 
computer animation&#8221; 
&#169; ACM. All rights reserved. This content is excluded from our
Creativ e
 Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Two Definitions of a Curve 
&#8226; A continuous 1D set of points in 2D (or 3D) 
&#8226; A mapping from an interval S onto the plane  
&#8211; That is, P(t) is the point of the curve at parameter t 
 
 
 
&#8226; Big differences 
&#8211; It is easy to generate points on the curve from the 2nd 
&#8211; The second definition can describe trajectories, the 
speed at which we move on the curve 
</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Cubic B&#233;zier Curve 
Verify what happens  
for t=0 and t=1 &#8226; P(t) =  (1-t)&#179;  P1 
  + 3t(1- t)&#178;     P2  
  + 3t&#178; (1-t)      P3 
  + t&#179;          P4  </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; 4 control points 
&#8226; Curve passes through first &amp; last control point 
&#8226; Curve is tangent at P1 to (P1-P2) and at P4 to (P4-P3) 
27 Cubic B&#233;zier Curve 
A B&#233;zier curve is 
bounded by the 
convex hull  of its 
control points.  </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; For example: 
&#8211; {1,  1+t,  1+t+t2 , 1+t-t2+t3 } 
&#8211; {t3,  t3+t2 ,  t3+t,  t3+1} 
 
 
&#8226; These can all be obtained from 
by linear combination 
&#8226; Infinite number of possibilities, just like you have 
an infinite number of bases to span R2 
42 Different Basis  
2D examples </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 How Many Dimensions? 
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12Physical Splines 
See http://en.wikipedia.org/wiki/Flat_spline  Courtesy of The Antique Boat Museum.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; 4 control points 
&#8226; Curve passes through first &amp; last control point 
26 Cubic B&#233;zier Curve 
Courtesy of Seth Teller. 
Used with permission. </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; For example: 
1,  1+t,  1+t+t2, 1+t-t2+t3 
t3,  t3+t2,  t3+t,  t3+1 
44 Matrix-Vector Notation 
Change-of-basis 
matrix &#8220;Canonical&#8221; 
monomial 
basis 
Not any matrix will do! 
If it&#8217;s singular, the basis 
set will be linearly 
dependent, i.e., 
redundant and 
incomplete.  </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; The plane where the curve lies, a 2D vector space  
&#8226; The space of cubic polynomials, a 4D space 
&#8226; Don&#8217;t be confused! 
&#8226; The 2D control points can be replaced by 3D 
points &#8211; this yields space curves. 
&#8211; The math stays the same, just add z(t). 
&#8226; The cubic basis can be extended to higher-order 
polynomials 
&#8211; Higher-dimensional vector space 
&#8211; More control points 
48 Two Different Vector Spaces!!! </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Questions? </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>&#8226; How do we go from Bernstein basis  
to the canonical monomial basis  
1, t, t&#178;, t&#179; and back? 
&#8211; With a matrix! 
50 Change of Basis 
New basis vectors 
&#8226; B1(t)=(1-t) &#179; 
&#8226; B2(t)=3t(1- t)&#178; 
&#8226; B3(t)=3t&#178; (1-t) 
&#8226; B4(t)=t&#179; 
 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Explanation 1: 
&#8211; Magic! 
&#8226; Explanation 2:  
&#8211; These are smart weights that describe the influence of 
each control point 
&#8226; Explanation 3: 
&#8211; It is a linear combination of  basis polynomials. 
&#8211;The opposite perspective:  
control points are the weights of polynomials!!! 
 
33 Why Does the Formula Work? </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Cubic Bernstein: 
&#8226; B1(t)=(1- t)&#179; 
&#8226; B2(t)=3t(1- t)&#178; 
&#8226; B3(t)=3t&#178;(1 -t) 
&#8226; B4(t)=t&#179; 
51 How You Get the Matrix 
Expand these out 
and collect powers of t. 
The coefficients are the entries 
in the matrix B! 
</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text> 
 
&#8226; Given B1...B4, how to get back 
to canonical 1, t, t&#178;, t&#179; ? 
52 Change of Basis, Other Direction 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; What if you want more control? 
61 A Cubic Only Gets You So Far </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; The two new curves are defined by 
&#8211;P1, P&#8217;1, P&#8217;&#8217;1, and P&#8217;&#8217;&#8217; 
&#8211;P&#8217;&#8217;&#8217;, P&#8217;&#8217;2, P&#8217;3, and P4 
&#8226; Together they exactly replicate the original 
curve! 
&#8211; Originally 4 control points, now 7 (more control) 
66 Result of Split in Middle 
P&#8217;1 P&#8217;2 
P&#8217;&#8217;1 
P&#8217;&#8217;&#8217; P&#8217;3 P&#8217;&#8217;2 
P4 
P1 </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Questions? </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Tessellation 
t0 t1 t2 tn 
It&#8217;s clear that adding 
more points will get 
us closer to the 
curve. </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Interpolation 
&#8211; Goes through all specified points 
&#8211; Sounds more logical 
&#8211; But can be more unstable 
&#8226; Approximation 
&#8211; Does not go through all points 
&#8211; Turns out to be convenient 
 
&#8226; We will do something  
in between. 
21 Interpolation vs. Approximation 
Interpolation 
Approximation 
</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text> 
 
&#8226; Given B1...B4, how to get back 
to canonical 1, t, t&#178;, t&#179; ? 
53 
Change of Basis, Other Direction 
That&#8217;s right, with the inverse matrix! </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; Polynomials 
  
 
 
&#8226; In the polynomial vector space, {1, t, ..., tn} are 
the basis vectors, a0, a1, ..., an are the 
components 
37 Polynomials as a Vector Space 
</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 Tessellation 
t0 t1 t2 tn 
It&#8217;s clear that adding 
more points will get 
us closer to the 
curve. </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226; Understand relationships between types of splines 
&#8211; Conversion 
&#8226; Express what happens when a spline curve is 
transformed by an affine transform  
(rotation, translation, etc.)  
&#8226; Cool simple example of non-trivial vector space 
&#8226; Important to understand for advanced methods 
such as finite elements 
34 Why Study Splines as Vector Space? </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text> 
 
&#8226; Closed under addition &amp; scalar multiplication 
&#8211; Means the result is still a cubic polynomial (verify!) 
&#8226; Cubic polynomials also compose a vector space 
&#8211; A 4D subspace  of the full space of polynomials 
&#8226; The x and y coordinates of cubic B&#233;zier curves 
belong to this subspace as functions of t. 
39 Subset of Polynomials: Cubic 
</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Demo </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Bezier curves: piecewise polynomials 
&#8226; Bernstein polynomials 
&#8226; Linear combination of basis functions 
&#8211; Basis: control points  weights: polynomials 
&#8211; Basis: polynomials  weights: control points  
&#8226; Subdivision by de Casteljau algorithm 
&#8226; All linear, matrix algebra 
 
70 Recap </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 
Cubic B&#233;zier Curve 
That is, 
&#8226; P(t) =  (1-t)&#179;  P1 
  + 3t(1- t)&#178;     P2  
  + 3t&#178; (1-t)      P3 
  + t&#179;          P4  </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions? </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; Actually works to construct a point at any t, not just 
0.5 
&#8226; Just subdivide the segments with ratio (1- t), t 
(not in the middle) 
68 De Casteljau Construction 
t 
t t t t 
t </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Can we split a Bezier curve in the middle into 
two B&#233;zier curves? 
&#8211; The resulting curves are again a cubic 
(Why? A cubic in t is also a cubic in 2 t) 
&#8211; Hence it must be representable using the Bernstein 
basis. So yes, we can! 
64 Subdivision of a Bezier Curve 
? 
t=1 t=0.5 t=0 t2=2t-0.5 t1=2t 
cubic </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; For example: 
1,  1+t,  1+t+t&#178;, 1+t-t&#178;+t &#179; 
t&#179;,  t&#179;+t&#178;,  t&#179;+t,  t&#179;+1 
43Matrix-Vector Notation 
Change-of-basis 
matrix &#8220;Canonical&#8221; 
monomial 
basis 
These 
relationships 
hold for each 
value of t </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Texture Mapping and Shaders (PDF - 2.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec16/</lecture_pdf_url>
      <lectureno>16</lectureno>
      <slides>
        <slide>
          <slideno>8</slideno>
          <text>9 Texture Mapping 
Texture 
mapped model Image: Praun et al.  
Texture map (2D image) 
We need a function 
that associates each 
surface point with a 
2D coordinate in the 
texture map 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Slide from Epic Games 
3D Model UV Mapping 
&#169; Epic Games Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; All materials seen so far are the same everywhere 
&#8211; In other words, we are assuming the BRDF is independent 
of the surface point x 
&#8211; No real reason to make that assumption 
3 Spatial Variation 
&#169; ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission.&#169; source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26 Questions? </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Texture mapping can be used to alter some or all 
of the constants in the illumination equation 
&#8211; Diffuse color kd, specular exponent q, specular color ks... 
&#8211; Any parameter in any BRDF model! 
 
 
 
&#8211;kd in particular is often read from a  texture map 
29 Texture Mapping &amp; Illumination 
Constant Diffuse Color 
 Diffuse Texture Color 
 Texture used as Label 
 Texture used as Diffuse Color 
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Texture Mapping 
Texture 
mapped model Image: Praun et al.  
Texture map (2D image) 
For each point 
rendered, look up 
color in texture map 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; That is, each octave f has weight 1/ f 
57 Sum 1/f noise 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Questions? </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Questions? 
Image removed due to copyright restrictions.  Please the image of &#8220;blueglass.gif&#8221; from 
http://mrl.nyu.edu/~perlin/imgs/imgs.html. </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; Marble 
&#8211; recall sin (x[0] + sum 1/ f |noise|)  
&#8211;BoringMarble  = colormap  (sin(x[0]) 
&#8211;Marble = colormap  (sin(x[0]+turbulence)) 
&#8211;http://legakis.net/justin/MarbleApplet/   
&#8226; Wood 
&#8211;replace x (or parallel plane)  
by radius 
&#8211;Wood = colormap  (sin(r+turbulence)) 
&#8211; http://www.connectedpixel.com/blog/texture/wood 
62 Noise For Solid Textures 
&#169; Ken Perlin . All rights reserved. This content is excluded
from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 
Normal Map Example 
Simplified mesh, 
500 triangles Simplified mesh + 
normal mapping Paolo Cignoni 
Image courtesy of Maksim on Wikimedia Commons. License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; 0 at integer locations 
&#8226; Pseudo-random derivative (1D gradient)  
at integer locations 
&#8211; define local linear functions 
&#8226; Interpolate at location P 1D Noise 
49 noise 
value 
x P </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; Critical component of  
procedural textures 
&#8226; Pseudo-random function 
&#8211; But continuous 
&#8211; band pass (single scale) 
&#8226; Useful to add lots of visual detail 
http://www.noisemachine.com/talk1/index.html  
http://mrl.nyu.edu/~perlin/doc/oscar.html  
http://mrl.nyu.edu/~perlin/noise/  
http://en.wikipedia.org/wiki/Perlin_noise 
http://freespace.virgin.net/hugo.elias/models/m_perlin.htm   
 (not really Perlin noise but very good) 
http://portal.acm.org/citation.cfm?id=325247  
46 Perlin Noise 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Questions? </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 
P &#8226;dx: fractional x coordinate 
&#8226; Gradients G1 and G2 at neighboring vertices 
&#8211; Scalars in 1D. They are 3D vectors in 3D 
&#8226; We know that noise is zero at vertices </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Effect of Textures 
Courtesy of Jeremy Birn.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39 Questions? Epic Games 
Image from Epic Games has been removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; What of non-triangular geometry? 
&#8211; Spheres, etc. 
 
&#8226; No vertices, cannot specify UVs that way! 
 
&#8226; Solution: Parametric Texturing 
&#8211; Deduce (u, v) from (x, y, z) 
&#8211; Various mappings are possible.... 
20 Mathematical Mapping </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; Pseudo random 
&#8226; For arbitrary dimension 
&#8211; 4D is common for animation 
&#8226; Smooth 
&#8226; Band pass (single scale) 
&#8226; Little memory usage 
 
&#8226; How would you do it? 
47 Requirements </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; A scale is also called an octave in noise parlance 
&#8226; But multiple octaves 
are usually used,  
where the scale  
between two octaves 
is multiplied by 2 
&#8211; hence the name 
octave 
56 Noise At Multiple Scales 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; A scale is also called an octave in noise parlance 
 
55 Noise At One Scale 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Texture Mapping 
Image of a cartoon of a man applying wall paper has been removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Texture Mapping 
3D model 
 Texture mapped model 
Image: Praun et al.  ? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. &#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; From data : texture mapping  
&#8211; read color and other information  
from 2D images 
 
 
 
&#8226; Procedural : shader 
&#8211; write little programs that compute 
color/info as a function of location 
5 
Two Approaches 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; Cubic lattice  
&#8226; Zero at vertices 
&#8211; To avoid low frequencies 
&#8226; Pseudo-random gradient  
at vertices 
&#8211; define local linear functions 
&#8226; Splines to interpolate the values  
to arbitrary 3D points 
48 Perlin Noise 
</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Questions? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Video removed due to copyright restrictions.  Please see  
http://www.youtube.com/watch?v=RPhGEiM_6lM  for further details. </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 Normal Map Example 
Diffuse texture kd Normal Map 
Final render Models and images: Trevor Taylor 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Modeling from photographs 
&#8226; Using input photos as textures 
24 Projective Texture Example 
Figure from Debevec, Taylor &amp; Malik 
http://www.debevec.org/Research  &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226; Given an input point P 
&#8226; For each of its neighboring grid points:  
&#8211; Get the "pseudo-random" gradient vector G 
&#8211; Compute linear function (dot product G&#183;dP)  
&#8226; Take weighted sum,  
using separable cubic  
weights  
&#8211;[demo in 2D]  
53 Algorithm in 3D 
</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 n2 
n1 P &#8226; Compute the values from the two neighboring 
linear functions: n1 = dx*G1; n2=(dx-1)*G2 
&#8211; dot product in 3D. </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; Initially for production (slow) rendering 
&#8211; Renderman in particular 
&#8226; Now used for real-time (Games) 
&#8211; Evaluated by graphics hardware 
&#8211; More later in the course 
 
&#8226; Often makes heavy use of texture mapping 
41 Shader </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Gloss Mapping Example 
Spatially varying kd and ks Ron Frazier 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; Per-vertex (u, v) &#8220;texture coordinates&#8221; are specified: 
&#8211; Manually, provided by user (tedious!) 
&#8211; Automatically using parameterization optimization 
&#8211; Mathematical mapping (independent of vertices) 
14 UV Coordinates? 
(u0, v0) 
(u1, v1) (u2, v2) u v 
&#10004; </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; Advantages: 
&#8211; easy to implement in ray tracer  
&#8211; more compact than texture maps 
(especially for solid textures)  
&#8211; infinite resolution 
 
&#8226; Disadvantages 
&#8211;non-intuitive  
&#8211; difficult to match existing texture 
44 Procedural Textures 
</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; Functions executed when light interacts with a 
surface 
&#8226; Constructor: 
&#8211; set shader parameters  
&#8226; Inputs: 
&#8211; Incident radiance 
&#8211; Incident and reflected light directions 
&#8211; Surface tangent basis (anisotropic shaders only) 
&#8226; Output: 
&#8211; Reflected radiance 
40 Shaders ( Material  class) </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&#8226; Ray cast pixel (x, y), get visible point and &#945;, &#946;, &#947; 
&#8226; Get texture coordinates (u, v) at that point 
&#8211; Interpolate from vertices using barycentrics 
&#8226; Look up texture color 
using UV coordinates 
13 Pseudocode &#8211; Ray Casting 
Scene 
Texture map 
Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; Absolute value introduces C1 discontinuities 
58 sum 1/f |noise| 
 
&#8226; a.k.a. turbulence 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; Looks like marble! 
59 sin (x + sum 1/ f |noise|) 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 Questions? </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Precompute (1D) table of n gradients G[n] 
&#8226; Precompute (1D) permutation P[n]  
&#8226; For 3D grid point i, j, k :  
G(i,j,k) = G[ ( i + P[ (j + P[k]) mod n ] ) mod n ]  
 
 
&#8226; In practice only n gradients are stored! 
&#8211; But optimized so that they are well distributed 
54 Computing Pseudo-random Gradients </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; Specify texture coordinates (u,v) at each vertex 
&#8226; Canonical texture coordinates (0,0) &#8594; (1,1) 
&#8211; Wrap around when coordinates are outside (0, 1) Texture Tiling 
seamless tiling (repeating) tiles with visible seams 
(0,0) (3,0) (0,3) 
(0,0) (3,0) (0,3) 
(0,0) (1,1) 
(0,0) (1,1) Note the range (0,1) unlike 
normalized screen coordinates! </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>34 Normal Map Example 
Original Mesh 
4M triangles Paolo Cignoni 
Image courtesy of Maksim on Wikimedia Commons. License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 Procedural Textures 
Image by Turner Whitted 
&#8226; Alternative to 
texture mapping 
&#8226; Little program that 
computes color as a 
function of x,y,z: 
f(x,y,z) &#61614;color 
&#169; Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 
BRDF in Matrix II &amp; III 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; Goal : &#8220;flatten&#8221; 3D object onto 2D UV coordinates 
&#8226; For each vertex, find coordinates U,V such that 
distortion is minimized 
&#8211; distances in UV correspond to distances on mesh 
&#8211; angle of 3D triangle same as angle of triangle in UV plane 
&#8226; Cuts are usually required (discontinuities) 
15 Texture UV Optimization 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226;For this course, assume UV given per vertex 
&#8226;Mesh Parameterization: Theory and Practice&#8221; 
&#8211;Kai Hormann, Bruno L&#233;vy and Alla Sheffer
 ACM SIGGRAPH Course Notes, 2007 
&#8226;http://alice.loria.fr/index.php/publications.html?redir
ect=0&amp;Paper=SigCourseParam@2007&amp;Author=Lev
y 
 
 
16 To Learn More </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Generating Normal Maps 
&#8226; Model a detailed mesh 
&#8226; Generate a UV parameterization for the mesh 
&#8211; A UV mapping such that each 3D point has unique 
image coordinates in the 2D texture map 
&#8211; This is a difficult problem, but tools are available 
&#8226; E.g., the DirectX SDK  has functionality to do this 
&#8226; Simplify the mesh (again, see DirectX SDK) 
&#8226; Overlay simplified and original model 
&#8226; For each point P on the simplified mesh, find 
closest point P&#8217; on original model (ray casting) 
&#8226; Store the normal at P&#8217; in the normal map. Done! </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; For each shaded point, normal is given by a 2D 
image normalMap  that stores the 3D normal 
 For a visible point 
interpolate UV using barycentric  
       // same as texture mapping 
Normal = normalMap[U,V] 
compute shading (BRDF) using this normal 
33 Normal Mapping 
</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64 Other Cool Usage: Displacement, Fur 
&#169; Ken Perlin . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; The corona was made as follows:  
&#8211; Create a smooth gradient function the drops off 
radially from bright yellow to dark red.  
&#8211; Phase shift this function by adding a turbulence 
texture to its domain.  
&#8211; Place a black cutout disk over the image.  
&#8226; Animation 
&#8211; Scale up over time 
&#8211; Use higher dim noise (for time) 
&#8211;http://www.noisemachine.com/talk1/imgs/flame500.html   
63 Corona 
Slides by Ken Perlin Image of corona removed due to copyright restrictions.  
Please see the link below for further details. </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; Programmable shader provide great flexibility 
&#8226; Shaders can be extremely complex 
&#8211; 10,000 lines of code! 
&#8226; Writing shaders is a black art 
67 Bottom Line </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Questions? </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>31 Questions? </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>&#8226; You can store an object-space normal 
&#8211; Convenient if you have a 
unique parameterization 
&#8226; ....but if you want to use a tiling 
 normal map, this will not work 
&#8211; Must account for the curvature 
of the object! 
&#8211; Think of mapping this diffuse+normal 
map combination on a cylindrical tower 
&#8226; Solution: Tangent space normal map 
&#8211; Encode a &#8220;difference&#8221; from the 
geometric normal in a local coord. system 38 Normal Map Details 
</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Projective Mappings 
&#8226; A slide projector 
&#8211; Analogous to a camera! 
&#8211; Usually perspective 
projection tells us where 
points project to in our 
image plane 
&#8211; This time we will use 
these coordinates as UVs 
&#8226; No need to specify  
texture coordinates  
explicitly Image removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Projective Mappings 
&#8226; We are given the 
camera matrix H of the 
slide projector 
&#8226; For a given 3D point P 
&#8226; Project onto 2D space 
of slide projector: HP 
&#8211; results in 2D texture 
coordinates Image removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics  
 1 
MIT EECS 6.837 &#8211; Matusik  Texture Mapping &amp; Shaders 
&#169; Remedy Enterainment. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226; The normal vector is really important in conveying 
the small-scale surface detail 
&#8211; Remember cosine dependence 
&#8211; The human eye is really good at 
picking up shape cues from lighting! 
 
&#8226; We can exploit this and look up also the normal 
vector from a texture map 
&#8211; This is called &#8220;normal mapping&#8221; or &#8220;bump mapping&#8221; 
&#8211; A coarse mesh combined with detailed normal maps can 
convey the shape very well! 
32 We Can Go Even Further... 
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226; Each vertex P stores 2D (u, v) &#8220;texture coordinates&#8221; 
&#8211; UVs determine the 2D location in the texture for the vertex  
&#8211; We will see how to specify them later 
&#8226; Then we interpolate using barycentrics 
12 UV Coordinates 
(u0, v0) 
(u1, v1) (u2, v2) u v 
&#10004; </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 1D Noise: Reconstruct at P 
noise 
value 
x 
dx G1 G2 w1 w2 
n2 
n1 P &#8226; Compute the values from the two neighboring 
linear functions: n1 = dx*G1; n2=(dx-1)*G2 
&#8211; dot product in 3D 
&#8226; Weight w1=3dx2&#8211;2dx3 and w2=3(1&#8211;dx)2&#8211;2(1&#8211;dx)3
 
&#8211;ie: noise=w1 G1 dx + w2 G2 (dx- 1) </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; Noise: one ingredient of shaders 
&#8226; Can also use textures 
&#8226; Shaders control diffuse color, but also specular 
components, maybe even roughness (exponent), 
transparency, etc. 
&#8226; Shaders can be layered (e.g. a layer of dust, 
peeling paint, mortar between bricks).  
&#8226; Notion of shade tree  
&#8211; Pretty much algebraic tree 
&#8226; Assignment 5:  
checkerboard shader based on two shaders 
66 Shaders </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 That&#8217;s All For Today! 
Justin Legakis Justin Legakis 
Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226; Each vertex P stores 2D (u, v) &#8220;texture coordinates&#8221; 
&#8211; UVs determine the 2D location in the texture for the vertex  
&#8211; We will see how to specify them later 
&#8226; Then we interpolate using barycentrics 
11 UV Coordinates 
(u0, v0) 
(u1, v1) (u2, v2) u v (&#945;u0+&#946;u1+&#947;u2, 
&#945;v0+&#946;v1+&#947;v2) </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; We will allow BRDF parameters to vary over space 
&#8211; This will give us much more complex surface appearance 
&#8211; e.g. diffuse color kd vary with x  
&#8211; Other parameters/info can vary too: ks, exponent, normal 
4 Spatial Variation 
&#169; ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission. &#169; source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>sum 1/ f(noise ) sum 1/f( |noise | ) 
60 Comparison 
&#8226;noise                               sin (x + sum 1/f(  |noise | ))  
&#169; Ken Perlin . All rights reserved. 
This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Information we need: 
&#8226; Per vertex 
&#8211; 3D coordinates 
&#8211; Normal 
&#8211; 2D UV coordinates 
&#8226; Other information 
&#8211; BRDF (often same for the whole object, but could vary) 
&#8211; 2D Image for the texture map 
18 3D Model </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Planar 
&#8211; Vertex UVs and 
linear interpolation 
is a special case! 
&#8226; Cylindrical 
&#8226; Spherical  
&#8226; Perspective  
Projection 
21 Common Texture Coordinate Mappings 
Planar 
Spherical Spherical Images removed due to copyright restrictions. </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Ray Tracing (PDF - 2.9MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec13/</lecture_pdf_url>
      <lectureno>13</lectureno>
      <slides>
        <slide>
          <slideno>39</slideno>
          <text>What&#8217;s Wrong then? 
&#8226; No surface is a perfect mirror, 
no material interface is perfectly smooth 
40 &#169; Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Today &#8211; Ray Tracing 
(Indirect illumination) 
Shadows Reflections Refractions 
(Caustics) Henrik Wann Jensen 
4 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Stopping criteria: 
&#8226; Recursion depth 
&#8211; Stop after a 
number  
of bounces 
&#8226; Ray contribution 
&#8211; Stop if reflected /  
transmitted 
contribution  
becomes too small trace ray  
   Intersect all objects  
   color = ambient term  
   For every light  
      cast shadow ray  
      color += local shading term  
   If mirror 
      color += colorrefl *  
                trace reflected ray  
   If transparent  
      color += colortrans *  
               trace transmitted ray  
 
&#8226;   Does it ever end? 
Recap: Ray Tracing 
54 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Shadow Optimization 
&#8226; We only want to know whether there is an intersection, 
not which one is closest 
&#8226; Special routine Object3D::intersectShadowRay()  
&#8211; Stops at first intersection 
13 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Qualitative Refraction 
22 &#169; Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Recursion For Reflection: None 
55 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Total Internal Reflection 
No transmission 
26 Image courtesy of Frazzydee  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Total Internal Reflection 
27 &#169; Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Mirror Reflection 
&#8226; Cast ray symmetric with  
respect to the normal 
&#8226; Multiply by reflection  
coefficient ks (color) 
&#8226; Don&#8217;t forget to add epsilon  
to the ray! 
Without epsilon 
With epsilon 
16 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Transparency (Refraction) 
&#8226; Cast ray in refracted direction 
&#8226; Multiply by transparency coefficient kt (color) 
21 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Refraction 
I    = N cos &#1256;i  &#8211; M sin &#1256;i 
M  = (N cos &#1256;i  &#8211; I) / sin &#1256;i 
 
T  = &#8211; N cos &#1256;T  + M sin &#1256;T 
     = &#8211; N cos &#1256;T + (N cos &#1256;i &#8211; I) sin &#1256;T / sin &#1256;i 
     = &#8211; N cos &#1256;T + (N cos &#1256;i &#8211; I) &#951;r 
     = [  &#951;r cos &#1256;i &#8211; cos &#1256;T ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; sin2 &#1256;T ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; &#951;r2 sin2 &#1256;i ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; &#951;r2 (1 &#8211; cos2 &#1256;i ) ] N &#8211; &#951;r I 
     = [ &#951;r (N &#183; I)  &#8211; &#8730;1 &#8211; &#951;r2 (1 &#8211; ( N &#183; I)2 ) ] N &#8211; &#951;r I I 
T &#1256;i 
&#1256;T N 
-N M &#951;T &#951;i 
Snell-Descartes Law: 
 N cos &#1256;i &#8211; M sin &#1256;i 
let&#8217;s get rid of  
the cos &amp; sin Plug M 
&#8226;Total internal reflection when  
the square root is imaginary 
(no refraction, just reflection)  
 
 
25 &#119899;&#119894;sin &#120579; &#119894;= &#119899; &#119879;sin &#120579; &#119879; 
sin &#120579; &#119879;
sin &#120579; &#119894;=  &#119899;&#119894;
&#119899;&#119879;= &#119899; &#119903; </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade  
2 
Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Camera definitions 
&#8211; Perspective and orthographic 
&#8211; View coordinate system [-1,1] 
&#8211; field of view, aspect ratio, etc. 
&#8226; Ray representation 
&#8211; origin + t * direction 
&#8211; Generating rays based in image coordinates 
&#8226; Ray-geometry intersection 
&#8211; Planes, spheres, triangles (barycentric coordinates) 
&#8211; CSG 
&#8211; Transformations Earlier 
NVIDIA 
3 &#169; NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>   color = ambient*hit-&gt;getMaterial()-&gt;getDiffuseColor() 
   for every light  
      Ray ray2(hitPoint, directionTo
Light) 
      Hit hit2(distanceToLight, NULL, NULL) 
      For every object 
         object-&gt;intersect(ray2, hit2, 0) 
      if (hit2-&gt;getT() = distanceToLight) 
         color += hit-&gt;getMaterial()-&gt;Shade 
                  (ray, hit, directionToLight, lightCo
lor) 
   return color Problem: Self-Shadowing 
Without epsilon With epsilon epsilon) 
Bad Good 
8 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Let&#8217;s Think About Shadow Rays 
Ro Rd P 
9 &#8226; What&#8217;s special about                                                    
shadow rays compared to eye rays? </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Questions? 
Henrik Wann Jensen 
52 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>The Ray Tree 
R2 
R1 R3 
L2 
L1 L3 N1 N2 
N3 T1 T3 
Ni surface normal 
Ri reflected ray 
Li shadow ray 
Ti transmitted (refracted) ray Eye 
L1 
T3 R3 L3 L2 T1 R1 
R2 Eye 
Complexity? 
58 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>How Can We Add Shadows? 
6 For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade  </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Recursion For Reflection: 1 
56 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Wavelength 
Pittoni, 1725, Allegory to Newton 
Pink Floyd, The Dark Side of the Moon &#8226; Refraction is wavelength-
dependent (dispersion) 
&#8211; Refraction increases as the 
wavelength of light decreases 
&#8211; violet and blue experience more 
bending than orange and red  
&#8226;Newton&#8217;s  prism experiment 
&#8226;Usually ignored in graphics 
32 &#169; source unknown. All right
s reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; The Fitzwilliam Museum. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; Multiple rays per pixel: 
sample lens aperture 
MIT EECS 6.837 &#8211; Durand 
  Depth of Field 
Justin Legakis focal length film out-of-focus blur 
out-of-focus blur 
51 Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Shadows 
&#8226; One shadow ray per 
intersection per point 
light source 
no shadow rays 
one shadow ray 
46 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>What&#8217;s Wrong then? 
&#8226; No surface is a perfect mirror, 
no material interface is perfectly smooth 
Adapted from blender.org 
Perfectly specular 
(mirror) reflection Perfectly specular 
refraction 1 ray in 1 ray out 1 ray in 
1 ray out 
1 ray out 
41 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Ray tree 
&#8226; Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray This gets pretty complicated 
pretty fast! 
60 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Overview of Today 
&#8226; Shadows 
 
 
&#8226; Reflection 
 
 
&#8226; Refraction 
 
 
&#8226; Recursive Ray Tracing 
20 </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Cool Refraction Demo 
&#8226;Enright, D., 
Marschner, S. 
and Fedkiw, 
R., 
SIGGRAPH 
2002  
29 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Soft Shadows 
&#8226; Multiple shadow rays 
to sample area light 
source 
one shadow ray  
(to random location) 
lots of shadow rays 
48 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Rainbow 
&#8226; Rainbow is caused by  
refraction + internal reflection + refraction 
&#8226; Maximum for angle around 42 degrees 
&#8226; Refraction depends on wavelength (dispersion) 
&#8220;Color and Light in Nature&#8221;  
by Lynch and Livingstone The outgoing 
angle is different 
for each 
wavelength 
33 &#169; Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Let&#8217;s Think About Shadow Rays 
Ro Rd P 
10 &#8226; What&#8217;s special about                                                    
shadow rays compared to eye rays? </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Refracted direction T? Refraction 
I 
T &#1256;i 
&#1256;T N 
-N M &#951;T &#951;i 
Snell-Descartes Law: 
 
23 Relative index of refraction Material 1, index of refraction &#951; i 
Material 2, index of refraction &#951; T 
&#119899;&#119894;sin &#120579; &#119894;= &#119899; &#119879;sin &#120579; &#119879; 
sin &#120579; &#119879;
sin &#120579; &#119894;=  &#119899;&#119894;
&#119899;&#119879;= &#119899; &#119903; </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; Has revolutionized lens design 
&#8211; E.g. zoom lenses are good now 
Application: CAD for lenses 
From Hecht's Optics 
37 &#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; One reflection ray per intersection 
perfect mirror Reflection 
&#952; &#952; 
44 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Questions? 
Henrik Wann Jensen &#8220;Sphereflake&#8221; fractal 
19 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Motion Blur 
&#8226; Sample objects 
temporally over 
time interval 
Rob Cook 
50 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Non-Ideal Reflection/Refraction 
Non-ideal glossy 
reflection Non-ideal refraction &#8226; No surface is a perfect mirror, 
no material interface is perfectly smooth 
Adapted from blender.org 1 ray in 1 ray in 
many 
rays out many 
rays out 
42 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Refraction and the Lifeguard Problem 
&#8226; Running is faster than swimming  
Beach 
Person  
in trouble Lifeguard 
Water 
Run 
Swim 
30 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Let&#8217;s Pause for a Moment... 
&#8226; Do these pictures look real? 
39 &#169; Turner Whitted, Bell Laboratories. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Perfect Mirror Reflection 
&#8226; Reflection angle = view angle 
&#8211; Normal component is negated 
&#8211; Remember particle collisions? 
&#8226;R = V &#8211; 2 (V &#183; N) N 
R V 
&#61553; V &#61553; R N 
V N N V N N 
V 
17 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>How Does a Rainbow Work? 
&#8226; From &#8220;Color and Light in Nature&#8221; 
by Lynch and Livingstone 
31 &#169; Cambridge University Press. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Stack Studios, Rendered using Maxwell 
That&#8217;s All for Today 
 
Further reading: 
- Shirley: Realistic Ray Tracing  
- Dutre et al.: Advanced 
Global Illumination 
61 &#169; Next Limit S.L. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>   color = ambient*hit-&gt;getMaterial()-&gt;getDiffuseColor() 
   for every light  
      Ray ray2(hitPoint, directionToLi
ght) 
      Hit hit2(distanceToLight, NULL, NULL) 
      For every object 
         object-&gt;intersect(ray2, hit2, 0) 
      if (hit2-&gt;getT() = distanceToLight) 
         color += hit-&gt;getMaterial()-&gt;Shade 
                  (ray, hit, directionToLight, lightCo
lor) 
   return color How Can We Add Shadows? 
ambient = k a 
diffuseColor = k d 
7 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Dispersion  
&#8226; Image by Henrik Wann Jensen using Photon Mapping 
35 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics 
Ray Tracing 
 
 
 
 
 
 
 
 
 
 
 
 
Wojciech Matusik, MIT EECS 
Many slides from Jaakko Lehtinen and Fredo Durand 
Henrik Wann Jensen  
1 Courtesy of Henrik Wann Jensen.
 Used with permission.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Non-Ideal Reflection/Refraction 
images from blender.org Glossy (as opposed to mirror) reflection 
Glossy (as opposed to perfect) refraction 
43 Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Overview of Today 
&#8226; Shadows 
 
 
&#8226; Reflection 
 
 
&#8226; Refraction 
 
 
&#8226; Recursive Ray Tracing 
15 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Overview of Today 
&#8226; Shadows 
 
 
&#8226; Reflection 
 
 
&#8226; Refraction 
 
 
&#8226; Recursive Ray Tracing 
53 </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Refraction 
I    = N cos &#1256;i  &#8211; M sin &#1256;i 
M  = (N cos &#1256;i  &#8211; I) / sin &#1256;i 
 
T  = &#8211; N cos &#1256;T  + M sin &#1256;T 
     = &#8211; N cos &#1256;T + (N cos &#1256;i &#8211; I) sin &#1256;T / sin &#1256;i 
     = &#8211; N cos &#1256;T + (N cos &#1256;i &#8211; I) &#951;r 
     = [  &#951;r cos &#1256;i &#8211; cos &#1256;T ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; sin2 &#1256;T ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; &#951;r2 sin2 &#1256;i ] N &#8211; &#951;r I 
     = [ &#951;r cos &#1256;i &#8211; &#8730;1 &#8211; &#951;r2 (1 &#8211; cos2 &#1256;i ) ] N &#8211; &#951;r I 
     = [ &#951;r (N &#183; I)  &#8211; &#8730;1 &#8211; &#951;r2 (1 &#8211; ( N &#183; I)2 ) ] N &#8211; &#951;r I I 
T &#1256;i 
&#1256;T N 
-N M &#951;T &#951;i 
Snell-Descartes Law: 
 N cos &#1256;i &#8211; M sin &#1256;i 
let&#8217;s get rid of  
the cos &amp; sin Plug M 
24 sin &#120579; &#119879;
sin &#120579; &#119894;=  &#119899;&#119894;
&#119899;&#119879;= &#119899; &#119903; &#119899;&#119894;sin &#120579; &#119894;= &#119899; &#119879;sin &#120579; &#119879; </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Questions? 
36 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Let&#8217;s Think About Shadow Rays 
Ro Rd P 
11 &#8226; What&#8217;s special about                                                    
shadow rays compared to eye rays? </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; Make sure you know whether you&#8217;re entering or leaving 
the transmissive material: 
 
 
 
 
 
 
 
&#8226; Note: We won&#8217;t ask you to trace rays through 
intersecting transparent objects :-) Refraction &amp; Sidedness of Objects 
T &#951;T = material  
        index &#951;i=1 
N 
T &#951;T= 1 &#951;i = material  
       index 
N I 
I 
28 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Rainbow 
&#8226; Rainbow is caused by  
refraction + internal 
reflection + refraction 
&#8226; Maximum for angle 
around 42 degrees 
&#8226; Refraction depends on 
wavelength 
(dispersion) 
34 This image is in the public domain. Source:  Wikipedia.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Glossy Reflection 
&#8226; Multiple reflection rays 
polished surface &#952; &#952; 
Justin Legakis 
45 Courtesy of Justin Legakis.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Antialiasing &#8211; Supersampling 
&#8226; Multiple rays per pixel 
jaggies w/ antialiasing 
49 </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Recursion For Reflection: 2 
57 Images removed due to copyright restrictions -- please see the images of "Scene with no reflection
rays." "Scene with one layer of reflection." "Scene with two layers of reflection." available at
http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace1.htm for further details.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Questions? 
Henrik Wann Jensen 
14 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Ray tree 
&#8226; Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray 
59 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Shadows &amp; Light Sources 
http://www.pa.uky.edu/~sciworks/light/preview/bulb2.htm 
clear bulb frosted bulb 
http://3media.initialized.org/photos/2000-10-18/index_gall.htm http://www.davidfay.com/index.php  
47 Image remov
ed due to copyright restrictions.  
&#169; David Fay Custom Furniture. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Joseph Straley and Sally Shafer Kovash. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Overview of Today 
&#8226; Shadows 
 
 
&#8226; Reflection 
 
 
&#8226; Refraction 
 
 
&#8226; Recursive Ray Tracing 
&#8211; &#8220;Hall of mirrors&#8221; 
5 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Let&#8217;s Think About Shadow Rays 
Ro Rd P 
12 &#8226; What&#8217;s special about                                                    
shadow rays compared to eye rays? 
&#8211; We do not need to find the closest                                       
intersection, any will do! </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Lens design by Ray Tracing 
&#8226; Used to be done 
manually, by rooms 
full of engineers who 
would trace rays. 
&#8226; Now software, e.g. 
Zemax 
&#8226; More in 6.815/6.865 
Computational 
Photography 
source: canon red book 
38 &#169; BBG Photographica. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Amount of Reflection 
&#8226; Traditional ray tracing (hack)  
&#8211; Constant ks 
&#8226; More realistic (we&#8217;ll do this later): 
&#8211; Fresnel reflection term (more reflection at grazing angle) 
&#8211; Schlick&#8217;s approximation: R( &#61553;)=R0+(1-R0)(1-cos &#61553;)5 
&#8226; Fresnel makes a big difference! 
metal 
 18 Dielectric (glass) </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Coordinates and Transformations (PDF - 1.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec03/</lecture_pdf_url>
      <lectureno>03</lectureno>
      <slides>
        <slide>
          <slideno>39</slideno>
          <text>Linear component  
&#8226;Note how we leave the fourth component alone  
40 </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Questions?  
44 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Matrix notation  
&#8226;Linearity implies  
 
 
 
&#8226;i.e. we only need to know the basis 
transformation  
&#8226;or in algebra notation  
19 
</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Full affine expression  
Which tells us both how to get a new frame ftM  
or how to get the coordinates Mc after transformation  
43 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Goals for today  
&#8226;Make it very explicit what coordinate system is 
used  
&#8226;Understand how to change coordinate systems  
&#8226;Understand how to transform objects  
&#8226;Understand difference between points, vectors, 
normals and their coordinates  
8 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Points &amp; vectors are different  
&#8226;Moving car  
&#8226;points describe location of car elements  
&#8226;vectors describe velocity, distance between pairs of 
points  
&#8226;If I translate  the moving car to a different road  
&#8226;The points (location) change  
&#8226;The vectors (speed, distance between points) don&#8217;t  
6 
Image courtesy of Gunnar A. Sj&#246;gren  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Plan 
&#8226;Vectors  
 
&#8226;Points  
 
&#8226;Homogenous coordinates  
 
&#8226;Normals  
57 
</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>How do we transform normals?  
Object Space  World Space  nOS nWS 
78 </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Perspective in 2D  
Projectively 
equivalent  
64 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .
</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Change of basis  
&#8226;We have                               &amp;  
&#8226;Given the coordinate of    in   :  
 
&#8226;What are the coordinates in    ?  
27 
</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Transform tangent vector v 
v is perpendicular to normal n: 
nOS&#7488; vOS  =  0 
 nOS &#7488;  (M&#713;&#185;  M)  vOS  =  0 
 nWS&#7488; =  nOS&#7488; (M&#713;&#185;)  (nOS&#7488;  M&#713;&#185;)  (M    vOS)  =  0 
 (nOS&#7488;  M&#713;&#185;)  vWS  =  0 
 nWS&#7488; vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M&#713;&#185;)&#7488; nOS nOS 
vWS nWS vOS Dot product  
84 </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Questions?  
69 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>TS  =  2 
0 
0 0 
2 
0 0 
0 
1 1 
0 
0 0 
1 
0 3 
1 
1 
ST  =  2 
0 0 
2 0 
0 1 
0 0 
1 3 
1 Non-commutative Composition  
Scale then Translate:   p'  =  T ( S p )  =  TS p  
2 
0 
0 0 
2 
0 3 
1 
1 
2 
0 0 
2 6 
2 = 
= Translate then Scale:   p'  =  S ( T p )  =  ST p  
 
 
0  
 
0  
 
1  
 
0  
 
0  
 
1  
 
0  
 
0  
 
1 
55 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Plan 
&#8226;Vectors  
 
&#8226;Points 
 
&#8226;Homogenous coordinates  
 
&#8226;Normals  
31 
</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Algebra notation  
&#8226;The          are also vectors of the space  
&#8226;They can be expressed in the basis  
for example:  
 
 
 
&#8226;which gives us  
21 
</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226;L(p + q) = L(p) + L(q)  
&#8226;L(ap) = a L(p)  Linear Transformations  
Translation  
Rotation Rigid / Euclidean  Linear  Similitudes  
Isotropic Scaling  Scaling 
Shear Reflection  Identity 
Translation  is not linear : 
f(p) = p+t  
f(ap) = ap+t &#8800; a(p+t) = a f(p)  
f(p+q) = p+q+t &#8800; (p+t)+(q+t) = f(p) + f(q)  
30 </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Non-commutative Composition  
Scale then Translate:   p'  =  T ( S p )  =  TS p  
Translate then Scale:   p'  =  S ( T p )  =  ST p  
(0,0) (1,1) (4,2) 
(3,1) (8,4) 
(6,2) (0,0) (1,1) (2,2) 
(0,0) (5,3) 
(3,1) Scale(2,2)  Translate(3,1)  
Translate(3,1)  Scale(2,2)  
54 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Perspective in 2D  
We&#8217;ll just copy z to w, 
and get the projected 
point after 
homogenization!  
65 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .
</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Connections  
&#8226;Not part of class, but cool  
&#8226;&#8220;Covariant&#8221;: transformed by the matrix  
&#8226;e.g., tangent  
&#8226;&#8220;Contravariant&#8221;: transformed by the inverse transpose  
&#8226;e.g., the normal  
&#8226;a normal is a &#8220;co -vector&#8221;  
 
&#8226;Google &#8220;differential geometry&#8221; to find out more  
87 </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Eye candy: photo tourism  
&#8226;Application of homogenous coordinates  
&#8226;Goal: given N photos of a scene  
&#8226;find where they were taken  
&#8226;get 3D geometry for points in the scene  
70 
From Photo Tourism::  Exploring Photo Collections in 3D , used with permission from ACM, Inc.  &#169;ACM. All rights reserved. This content is excluded from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>And that&#8217;s it for today  
&#8226;The rest on Thursday  
74 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Forward reference and eye  
&#8226;The fourth coordinate is useful for perspective 
projection  
&#8226;Called homogenous coordinates  
58 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Translation component  
&#8226;Express translation vector t in the basis  
41 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Vectors (linear space)  
&#8226;We can use a basis  to produce all the vectors in 
the space:  
&#8226;Given n basis vectors  
any vector       can be written as  
here:  
13 
</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Perspective in 2D  
63 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .
The projected point in 
homogeneous 
coordinates  
(we just added w=1):  </text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>That&#8217;s All for Today  
&#8226;Further Reading  
&#8211;Buss, Chapter 2  
 
&#8226;Other Cool Stuff  
&#8211;Algebraic Groups  
&#8211;http://phototour.cs.washington.edu/ 
&#8211;http://phototour.cs.washington.edu/findingpaths/ 
&#8211;Free-form deformation of solid objects 
&#8211;Harmonic coordinates for character articulation 
89 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Recap, matrix notation  
 
&#8226;Given the coordinates c in basis  
the transformed vector has coordinates Mc in  
22 
</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 How are transforms combined?  
(0,0) (1,1) (2,2) 
(0,0) (5,3) 
(3,1) Scale(2,2)  Translate(3,1)  
TS  =  2 
0 0 
2 0 
0 1 
0 0 
1 3 
1 2 
0 0 
2 3 
1 = Scale then Translate  
Use matrix multiplication:   p'  =  T ( S p )  =  TS p  
Caution: matrix multiplication is NOT commutative!   
 
0  
 
0  
 
1  
 
0  
 
0  
 
1  
 
0  
 
0  
 
1 
53 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Why is the Normal important?  
&#8226;It's used for shading &#8212; makes things look 3D!  
object color only  Diffuse Shading  
76 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Affine space  
&#8226;Points are elements of an affine space  
&#8226;We denote them with a tilde  
 
&#8226;Affine spaces are an extension of vector spaces  
33 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Why bother with extra coord?  
w = 1 
w = 2 &#8226;This picture gives away almost  
the whole story.  
61 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>More notation properties  
&#8226;If the fourth coordinate is zero, we get a vector  
&#8226;Subtracting two points:  
 
 
 
 
&#8226;Gives us  
 
a vector (last coordinate = 0)  
45 </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>More notation properties  
&#8226;Adding a point  
 
 
                                to a vector  
 
&#8226;Gives us  
 
 
 
a point (4th coordinate=1)  
46 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>More notation properties  
&#8226;vectors are not affected by the translation part  
 
 
 
 
&#8226;because their 4th coordinate is 0  
&#8226;If I rotate my moving car in the world, I want its 
motion to rotate  
&#8226;If I translate it, motion should be unaffected  
47 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226;Camera at origin, looking along z, 90 degree 
f.o.v., &#8220;image plane&#8221; at z=1 Perspective in 2D  
62 
This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Comment  
&#8226;So the correct way to transform normals is:  
 
&#8226;But why did  nWS = M nOS work for similitudes?  
&#8226;Because for similitude / similarity transforms,  
                              (M&#713;&#185;)&#7488; =&#955; M 
&#8226;e.g. for orthonormal basis:  
 
                   M&#713;&#185; = M &#7488;     i.e.  (M&#713;&#185;)&#7488; = M 
  nWS = (M&#713;&#185;)&#7488; nOS Sometimes denoted M &#713;&#7488; 
86 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Vectors (linear space)  
&#8226;Formally, a set of elements equipped with 
addition and scalar multiplication  
&#8226;plus other nice properties  
&#8226;There is a special element, the zero vector  
&#8226;no displacement, no force  
12 </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Questions?  
88 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Questions?  
9 </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Projective Equivalence &#8211; Why? 
&#8226;For affine transformations,  
adding w=1 in the end proved to be convenient.  
&#8226;The real showpiece is perspective.  
68 This image is in the public domain.
Source: http://openclipart.org/detail/34051/digicam- by-thesaurus .&#169; source unknown. All rights reserved. This content is excluded from our Creative  
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-us  e/.  
</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Algebra notation  
&#8226;The          are also vectors of the space  
&#8226;They can be expressed in the basis  
for example:  
 
 
 
&#8226;which gives us  
... 
20 </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Eye candy: photo tourism  
QuickTime&#8482; and a
MPEG-4 Video decompressor
are needed to see this picture.
73 
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Linear transformation  
&#8226;Transformation       of the vector space so that  
 
 
&#8226;Note that it implies  
&#8226;Notation                for transformations  
17 
Courtesy of Prof. Fredo Durand. Used with permission.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Linear transformation  
&#8226;Transformation       of the vector space  
16 
Courtesy of Prof. Fredo Durand. Used with permission.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Plan 
&#8226;Vectors  
 
&#8226;Points  
 
&#8226;Homogeneous coordinates  
 
&#8226;Normals (in the next lecture)  
11 
</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
 
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Coordinates  
&#8226;We are used to represent points with tuples of 
coordinates such as  
&#8226;But the tuples are meaningless without a clear 
coordinate system  
could be this point                
in the blue 
coordinate system  could be this point 
in the red 
coordinate system  
3 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Frames &amp; hierarchical modeling  
&#8226;Many coordinate systems (frames):  
&#8226;Camera  
&#8226;Static scene  
&#8226;car 
&#8226;driver  
&#8226;arm 
&#8226;hand  
&#8226;... 
 
&#8226;Need to understand nested transformations  
49 
Image courtesy of Gunnar A. Sj&#246;gren on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Normal 
&#8226;Surface Normal:  unit vector that is locally 
perpendicular to the surface  
75 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Reference  
&#8226;This lecture follows the new book by 
Steven (Shlomo) Gortler from Harvard:  
Foundations of 3D Computer Graphics  
10 </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Structure from motion  
&#8226;Given point correspondences  
&#8226;Unknowns: 3D point  location, camera poses  
&#8226;For each point in each image, write perspective 
equations  
72 Camera 1 R1,t1  Camera 2 R2,t2  Camera 3  
R3,t3  p1 Minimize f(R,T,P)  </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Questions?  
56 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Coordinates and 
Transformations  
MIT ECCS 6.837  
Wojciech Matusik  
 
many slides follow Steven Gortler&#8217;s book  
1 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226;All non-zero scalar multiples of a point are considered 
identical 
&#8226;to get the equivalent Euclidean point, divide by w 
 Projective Equivalence  
x 
y 
z 
w ax 
ay 
az 
aw 
a  != 0  = x/w 
y/w 
z/w 
1 = w !=0  
60 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Frames &amp; transformations  
&#8226;Transformation S wrt car frame f  
 
&#8226;how is the world frame a affected by this?  
&#8226;we have  
&#8226;which gives  
 
&#8226;i.e. the transformation in a is A -1SA 
&#8226;i.e., from right to left, A takes us from a to f, then 
we apply S, then we go back to a with A -1 
51 
</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Why do we care  
&#8226;We like linear algebra  
&#8226;It&#8217;s always good to get back to an abstraction 
that we know and for which smarter people have 
developed a lot of tools  
&#8226;But we also need to keep track of what 
basis/coordinate system we use  
23 </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Recap 
&#8226;Vectors can be expressed in a basis  
&#8226;Keep track of basis with left notation  
&#8226;Change basis  
&#8226;Points can be expressed in a frame  
(origin+basis)  
&#8226;Keep track of frame with left notation  
&#8226;adds a dummy 4th coordinate always 1  
37 
</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Questions?  
24 </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Matrix notation  
&#8226;We know how to transform the vector basis  
 
 
 
&#8226;We will soon add translation by a vector  
39 
</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Affine transformations  
&#8226;Include all linear transformations  
&#8226;Applied to the vector basis  
&#8226;Plus translation  
38 Courtesy of Prof. Fredo Durand . Used with permission.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Questions?  
29 </text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Digression  
 
 
&#8226;The previous proof is not quite rigorous; first 
you&#8217;d need to prove that tangents indeed 
transform with M. 
&#8226;Turns out they do, but we&#8217;ll take it on faith here.  
&#8226;If you believe that, then the above formula follows.   nWS = (M&#713;&#185;)&#7488; nOS 
85 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Step 1: point correspondences  
&#8226;Extract salient points (corners) from images  
&#8226;Find the same scene point in other images  
&#8226;To learn how it&#8217;s done, take 6.815  
71 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Change of basis  
&#8226;Critical in computer graphics  
&#8226;From world to car to arm to hand coordinate system  
&#8226;From Bezier splines to B splines and back  
 
&#8226;problem with basis change:  
you never remember which is M or M &#175;&#185; 
it&#8217;s hard to keep track of where you are  
25 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Linear algebra notation  
&#8226;can be written as  
 
 
&#8226;Nice because it makes the basis  
(coordinate system) explicit  
&#8226;Shorthand:  
 
&#8226;where bold means triplet, t is transpose  
14 
</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>&#8226;Think about transforming the tangent plane   
to the normal, not the normal vector  So how do we do it right?  
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane,  
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS 
83 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Points &amp; vectors are different  
&#8226;The 0 vector has a fundamental meaning:  
no movement, no force  
&#8226;Why would there be a special 0 point?  
 
&#8226;It&#8217;s meaningful to add vectors, not points  
&#8226;Boston location + NYC location =?  
+ =? 
5 
</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Point-vector operations  
&#8226;Subtracting points gives a vector  
 
&#8226;Adding a vector to a point gives a point  
34 
</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Translation  
42 </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Matrix notation  
&#8226;Linearity implies  
 
? 
18 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Transform Normal like Object?  
&#8226;translation?  
&#8226;rotation?  
&#8226;isotropic scale?  
&#8226;scale?  
&#8226;reflection?  
&#8226;shear?  
&#8226;perspective?  
80 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Different objects  
&#8226;Points 
&#8226;represent locations  
&#8226;Vectors 
&#8226;represent movement, force, displacement from A to B  
&#8226;Normals  
&#8226;represent orientation, unit length  
&#8226;Coordinates  
&#8226;numerical representation of the above objects  
in a given coordinate system  
4 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Algebra notation  
&#8226;We like matrix -vector expressions  
&#8226;We want to keep track of the frame  
&#8226;We&#8217;re going to cheat a little for elegance  
and decide that 1 times a point is the point  
 
 
 
&#8226;   is represented in   by 4 coordinate, where the 
extra dummy coordinate is always 1 (for now)  
36 
</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>More Normal Visualizations  
Incorrect Normal Transformation  Correct Normal Transformation  
82 </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Homogeneous Visualization  
&#8226;Divide by w to normalize (project)  
&#8226;w = 0?   
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) = &#8230;  
(7, 1, 1) = (14, 2, 2) = &#8230;  
(4, 5, 1) = (8, 10, 2) = &#8230;  Points at infinity (directions)  
(0,0,0)  
67 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Homogeneous Coordinates  
&#8226;Add an extra dimension (same as frames)  
&#8226;in 2D, we use 3 -vectors and 3 x 3 matrices  
&#8226;In 3D, we use 4 -vectors and 4 x 4 matrices  
&#8226;The extra coordinate is now an arbitrary  value, w 
&#8226;You can think of it as &#8220;scale,&#8221; or &#8220;weight&#8221;  
&#8226;For all transformations  
except perspective, you can  
just set w=1 and not worry  
about it  x' 
y&#8216; 
1 a    b  
d    e  
0  0 c 
f 
1 = x 
y 
1 
59 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Frames &amp; hierarchical modeling  
&#8226;Example: what if I rotate the wheel of the moving 
car:  
&#8226;frame 1: world  
&#8226;frame 2: car  
&#8226;transformation: rotation  
50 
Image courtesy of Gunnar A. Sj&#246;gren  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Change of basis  
&#8226;We have                               &amp;  
&#8226;Given the coordinate of    in   :  
 
&#8226;Replace    by its expression in  
 
 
&#8226;   has coordinates               in  
&#8226;Note how we keep track of the coordinate 
system by having the basis on the left  
28 
</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Questions?  
48 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Points vs. Vectors  
&#8226;A point is a location  
&#8226;A vector is a motion between two points  
&#8226;Adding vectors is meaningful  
&#8226;going 3km North + 4km East = going 5km North -East 
&#8226;Adding points is not meaningful  
&#8226;Boston location + New York location = ?  
&#8226;Multiplying a point by a scalar?  
&#8226;The zero vector is meaningful (no movement)  
&#8226;Zero point ?  
32 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Hierarchical modeling  
&#8226;Many coordinate systems:  
&#8226;Camera  
&#8226;Static scene  
&#8226;car 
&#8226;driver  
&#8226;arm 
&#8226;hand  
&#8226;... 
&#8226;Makes it important to understand coordinate 
systems  2 
  
Image courtesy of Gunnar A. Sj&#246;gren on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Matrices have two purposes  
&#8226;(At least for geometry)  
&#8226;Transform things  
&#8226;e.g. rotate the car from facing 
North to facing East  
&#8226;Express coordinate system 
changes  
&#8226;e.g. given the driver's location 
in the coordinate system of the 
car, express it in the coordinate 
system of the world  
7 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Questions?  
52 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Homogeneous Visualization  
&#8226;Divide by w to normalize (project)  
w = 1 
w = 2 (0, 0, 1) = (0, 0, 2) = &#8230;  
(7, 1, 1) = (14, 2, 2) = &#8230;  
(4, 5, 1) = (8, 10, 2) = &#8230;  (0,0,0)  
66 </text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Visualization of Surface Normal  
&#177; x = Red  
&#177; y = Green  
&#177; z = Blue  
77 </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Transformation for shear and scale  
Incorrect 
Normal 
Transformation  
Correct 
Normal 
Transformation  
81 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Frames 
&#8226;A frame is an origin      plus a basis  
&#8226;We can obtain any point in the space by adding 
a vector to the origin  
 
 
&#8226;using the coordinates c of the vector in  
35 
</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Change of basis  
&#8226;Assume we have two bases        and  
&#8226;And we have the coordinates of       in  
&#8226;e.g.  
 
&#8226;i.e. 
 
&#8226;which implies  
26 
</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Transform Normal like Object?  
&#8226;translation?  
&#8226;rotation?  
&#8226;isotropic scale?  
&#8226;scale?  
&#8226;reflection?  
&#8226;shear?  
&#8226;perspective?  
79 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Questions?  
15 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Ray Casting and Rendering (PDF - 3.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec11/</lecture_pdf_url>
      <lectureno>11</lectureno>
      <slides>
        <slide>
          <slideno>43</slideno>
          <text>44 
field of view &#945; 
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
eye point e p p is point on image 
plane at coordinate x, 
we want to know the 
direction of the ray r 
r? Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 Questions? 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; &#8220;Rendering&#8221; refers to the entire 
process that produces color values for pixels 
&#8226; Pixels correspond to rays; need to figure out the 
visible scene point along each ray 
&#8211; Called &#8220;hidden surface problem&#8221; in older texts 
&#8211; &#8220;Visibility&#8221; is a more modern term 
&#8211; Also, we assume (for now) a single ray per pixel 
&#8226; Major algorithms: Ray casting and rasterization 
 
&#8226; Note: We are assuming a pinhole camera (for now) 
15 Rendering </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 
field of view &#945; image plane 
-1 &lt; x &lt; 1 1 
right u view direction w Ray Generation in 2D 
What is the distance 
D to the screen so 
that the normalized 
coordinates go to 1? 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Ray Casting Basics 
 
&#8226; Camera and Ray Generation 
 
&#8226; Ray-Plane Intersection 
 
&#8226; Ray-Sphere Intersection 
54 Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; Ray equation is explicit       P(t) = Ro + t * Rd 
&#8211; Parametric 
&#8211; Generates points 
&#8211; Hard to verify that a point is on the ray  
&#8226; Plane equation is implicit    H(P) = n&#183;P + D = 0 
&#8211; Solution of an equation 
&#8211; Does not generate points 
&#8211; Verifies that a point is on the plane 
 
&#8226; Exercise: Explicit plane and implicit ray? 
61 Explicit vs. Implicit? </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Cool Artifacts from Assignment 1 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 
Scene Image 
Pixels Rendering 
What&#8217;s the 
color you put 
in each pixel? &#169; source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content is excluded from our Creative Commons
license. For more  
information, see 
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; (Infinite) plane defined by  
&#8211; Po = (x0, y0, z0) 
&#8211; n = (A,B,C)  
&#8226; Implicit plane equation 
&#8211; H(P) = Ax+By+Cz+D = 0 
         = n&#183;P + D = 0 
58 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0 </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Verify that intersection is closer than previous 
 
&#8226; Verify that it is not out of range (behind eye) 
64 Additional Bookkeeping 
t &gt; tmin t &lt; tcurrent 
P(t) </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Pinhole Camera 
&#8226; Box with a tiny hole 
&#8226; Inverted image 
&#8226; Similar triangles &#8226; Perfect image if hole 
infinitely small 
&#8226; Pure geometric optics 
&#8226; No depth of field issue 
(everything in focus) 
</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Also Called &#8220;Camera Obscura&#8221; 
Image courtesy of Wellcome Library, London. License: CC- BY-NC. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Camera Obscura Today 
Abelardo Morell    
www.abelardomorell.net Images removed due to copyright restrictions -- please see
http://www.abelardomorell.net/photography/cameraobsc_01/cameraobsc_17.html
http://www.abelardomorell.net/posts/camera-obscura/
http://www.abelardomorell.net/photography/cameraobsc_49/cameraobsc_63.html 
for further details.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Origin &#8211; Point 
&#8226; Direction &#8211; Vector  
&#8211; normal
ized is bette
r 
&#8226; Parametric line 
&#8211; P(t) = origin + t * direction 
29 Ray Representation 
origin direction P(t) How would you 
represent a ray? </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 
Scene Camera 
Image 
plane Pixels &#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights  reserved.
This content is excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/hel p
/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 
Ray Generation in 2D 
field of view &#945; 
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
D 
eye point e r p then we just 
normalize r to get 
the ray r = p-e = (x* u, D*w) 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 
Camera Description? 
Object 
coordinates 
World 
coordinates 
View 
coordinates 
Image 
coordinates u w v &#8226; Eye point e (center) 
&#8226; Orthobasis u, v, w (horizontal, up, direction) 
&#8226; Field of view angle 
&#8226; Image rectangle aspect ratio </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Questions? 
Even Funkier 
Multiperspective 
Imaging 
Courtesy of Paul Rademacher. Used with permission.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; Origin &#8211; Point 
&#8226; Direction &#8211; Vector  
&#8211; normal
ized is bette
r 
&#8226; Parametric line 
&#8211; P(t) = origin + t * direction 
30 Ray Representation 
origin direction P(t) Another way to put 
the ray casting 
problem statement: 
Find smallest t &gt; 0 
such that P(t) lies 
on a surface in the 
scene </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>43 
Camera Image 
plane Image Coordinates 
-1 &#8804; x &#8804; 1  -1 &#8804; y &#8804; 1  
Convenient to define 
&#8220;normalized image 
coordinates&#8221; such 
that the x, y 
coordinates run 
from -1 to 1 
regardless of the 
dimensions and 
aspect ratio of the 
image rectangle. 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; Simply Q/||Q||  
&#8211; Q = P(t), intersection point 
&#8211; (for spheres centered at origin) 
73 Sphere Normal 
Q 
normal Ro O 
Rd 
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 
Scene Image 
Pixels Rendering 
Pixel Color 
Determined by 
Lighting/Shading &#169; source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content is excluded from our Creative Commons
license. For more information, see 
http://ocw.mit .
edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; Surface/Scene Properties 
&#8211; surface normal 
&#8211; direction to light 
&#8211; viewpoint 
&#8226; Material Properties 
&#8211; Diffuse (matte) 
&#8211; Specular (shiny) 
&#8211; &#8230; 
&#8226; Light properties 
&#8211; Position 
&#8211; Intensity, ... 
&#8226; Much more! 
20 
Shading = What Surfaces Look Like 
Diffuse sphere Specular spheres N 
L 
V </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 
Scene Camera 
Image 
plane Image 
Pixels Rendering = Scene to Image 
&#169; source unknown. All rights reserved. This
content is excluded from our Creative
Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia- P
astor, Daniel Rypl . All rights  reserved.
This content i
s excluded from our Creative Commons
license. For  more information, see
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Secondary Rays 
Indirect illumination 
Shadows Reflections Refractions 
Caustics Henrik Wann Jensen 25 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Also need surface normal for shading 
&#8211; (Diffuse: dot product between light 
direction and normal, clamp to zero) 
&#8226; Normal is constant over the plane 
65 Normal  
normal </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; Eye point e (center) 
&#8226; Orthobasis u, v, w (horizontal, up, direction) 
41 
Camera Description? 
Object 
coordinates 
World 
coordinates 
View 
coordinates 
Image 
coordinates u w v </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226; Insert explicit equation of ray into  
implicit equation of sphere &amp; solve for t  
    P(t) = Ro + t*Rd ;     H(P) = P&#183;P - r2  =  0 
         ( Ro + tRd) &#183; (Ro + tRd) - r2  =  0 
                  Rd&#183;Rdt2 + 2Rd&#183;Rot + Ro&#183;Ro - r2  = 0 
69 
Ray-Sphere Intersection 
Rd Ro </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>For every pixel  
Construct a ray from the eye  
For every object in the scene  
Find intersection with the ray  
Keep if closest  
First we will study ray-plane intersection 
55 
Ray Casting </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Questions? </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>&#8226; E.g. fish eye, omnimax, parabolic 
52 Other Weird Cameras 
CAVE Columbia University  
&#169; source unknown. All rights reserved. This content is excluded
from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.&#169; CAVE Lab, Columbia University. All rights reserved. This
content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>47 
field of view &#945; 
right u view direction w image plane 
-1 &lt; x &lt; 1 x 
D r = p-e = (x* u, D*w) 
eye point e r p Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 
field of view &#945; image plane 
-1 &lt; x &lt; 1 
D 1 
right u view direction w Ray Generation in 2D 
This image is in the public domain. Source: openclipart</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; (Infinite) plane defined by  
&#8211; Po = (x0, y0, z0) 
&#8211; n = (A,B,C)  
57 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226; 3 cases, depending on the sign of  b2 &#8211; 4ac 
&#8226; What do these cases correspond to? 
&#8226; Which root (t+ or t-) should you choose? 
&#8211; Closest positive! 
71 Ray-Sphere Intersection 
</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; From Gemma Frisius, 1545 
36 Oldest Illustration  
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Ray-Sphere Intersection 
&#8226; It's so easy  
that all  
ray-tracing  
images  
have  
spheres! 
:-) 
Turner Whitted &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Ray Casting Basics 
 
&#8226; Camera and Ray Generation 
 
&#8226; Ray-Plane Intersection 
 
&#8226; Ray-Sphere Intersection 
33 Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>For every pixel  
  Construct a ray from the eye  
  For every object in the scene  
    Find intersection with ray  
      Keep if closest  
34 Cameras 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; &#8220;Rendering&#8221; refers to the entire 
process that produces color values for pixels,  
given a 3D representation of the scene 
&#8226; Pixels correspond to rays; need to figure out the 
visible scene point along each ray 
&#8211; Called &#8220;hidden surface problem&#8221; in older texts 
&#8211; &#8220;Visibility&#8221; is a more modern term 
&#8211; Also, we assume (for now) a single ray per pixel 
14 Rendering </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226; Ray Casting Basics 
 
&#8226; Camera and Ray Generation 
 
&#8226; Ray-Plane Intersection 
 
&#8226; Ray-Sphere Intersection 
17 Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 
&#8220;camera rays&#8221; 
are rays from the 
camera to the 
scene ? Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade  
19 
Shading 
</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Quadratic: at2 + bt + c = 0 
&#8211; a = 1  (remember, ||Rd|| = 1) 
&#8211; b = 2Rd&#183;Ro 
&#8211; c = Ro&#183;Ro &#8211; r2 
 
&#8226; with discriminant 
 
&#8226; and solutions 
70 Ray-Sphere Intersection 
</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>26 Ray Tracing 
Reflections, refractions 
Caustics Reflections 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Henrik Wann Jensen. Used with permission.
&#169; Turner Whitted, Bell Laboratories. All rights reserved. This content is
excluded from our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; What does rendering  mean? 
 
&#8226; Basics of ray casting 
6 Today </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Ray casting = eye rays only, tracing = also secondary 
 
24 
X Secondary rays are used for 
testing shadows, doing 
reflections, refractions, etc. 
We&#8217;ll do all this a little 
later! Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 
X ray from light to hit 
point is blocked, i.e., 
point is in shadow Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>For every pixel  
Construct a ray from the eye  
For every object in the scene  
Find intersection  with the ray   
Keep if closest  
Shade depending on light and normal vector 
28 
Ray Casting 
N Finding the 
intersection point  
and normal  is the 
central part of ray 
casting </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Cool Artifacts from Assignment 1 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226; Albrecht D&#252;rer, 16th century 
32 D&#252;rer&#8217;s Ray Casting Machine 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; Ray Generation? 
&#8211; Origin = e + x*size* u + y*size* v 
&#8211; Direction is constant: w 
51 
Orthographic Camera </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; Ray Casting Basics 
 
&#8226; Camera and Ray Generation 
 
&#8226; Ray-Plane Intersection 
 
&#8226; Ray-Sphere Intersection 
67 Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 Perspective vs. Orthographic 
&#8226; Parallel projection 
&#8226; No foreshortening 
&#8226; No vanishing point 
perspective orthographic </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Modeling 
&#8211; splines, hierarchies, transformations, meshes, etc. 
 
&#8226; Animation 
&#8211; skinning, ODEs, masses and springs 
 
&#8226;Now we&#8217;ll to see how to generate  
an image given a scene description! 
4 The Story So Far </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Scene 
7 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more  information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>&#8226; Eye-image pyramid (view frustum) 
&#8226; Note that the distance/size of image are arbitrary 
39 Simplified Pinhole Camera 
same image 
will result on 
this image plane </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 
Camera Description? </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
 MIT EECS 6.837 &#8211; Matusik MIT EECS 6.837 Computer Graphics 
Part 2 &#8211; Rendering 
NVIDIA Today: Intro to Rendering, Ray Casting 
&#169; NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 
Scene Image 
Each pixel corresponds to 
one ray. We need to figure 
out which scene point each 
one hits. Pixels Rendering &#8211; Pinhole Camera 
&#169; source unknown. All rights reserved. This
content is excluded from our Creative 
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved.
This content  
is excluded from our Creative Commons
license. For more information, see 
http://ocw.mit.edu/help/faq-fair-use /.
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Let&#8217;s think about shadows... 
21 Ray Casting vs. Ray Tracing 
This image is in the public domain.
Source: openclipart</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; Ray Casting and Ray Tracing 
&#8226; Intro to Global Illumination 
&#8211; Monte Carlo techniques, photon mapping, etc. 
&#8226; Shading, texture mapping 
&#8211; What makes materials look like they do? 
&#8226; Image-based Rendering 
&#8226; Sampling and antialiasing 
&#8226; Rasterization, z-buffering 
&#8226; Shadow t
echniques 
&#8226; Graphics Hardware 
5 The Remainder of the Term 
[Lehtinen et al. 2008] &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; Parametric line  
&#8226; P(t) = Ro + t * Rd 
&#8226; Explicit representation 
56 Recall: Ray Representation 
Rd Ro 
origin direction P(t) </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226; (Infinite) plane defined by  
&#8211; Po = (x0, y0, z0) 
&#8211; n = (A,B,C)  
&#8226; Implicit plane equation 
&#8211; H(P) = Ax+By+Cz+D = 0 
         = n&#183;P + D = 0 
&#8226; Point-Plane distance? 
&#8211; If n is normalized,  
distance to plane is
 H(P) 
&#8211; it is a signed  distance! 
60 3D Plane Representation? 
H Po normal P 
P' 
H(p) &lt; 0 H(p) &gt; 0 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Image by Henrik Wann Jensen 
66 Questions? 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226;Albrecht D&#252;rer , 16th century 
31 D&#252;rer&#8217;s Ray Casting Machine 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; Intersection means both are satisfied 
&#8226; So, insert explicit equation of ray into  
implicit equation of plane &amp; solve for t 
      P(t) = Ro + t * Rd 
      H(P) = n&#183; P + D = 0 
      n&#183;(Ro + t * Rd) + D = 0 
      t = -(D + n&#183;Ro) / n&#183;Rd  
63 Ray-Plane Intersection 
P(t) 
Done! 
What&#8217;s the deal 
when n&#183;R d = 0? </text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>MIT EECS 6.837 &#8211; Durand  That&#8217;s All for Today 
NVIDIA  
&#8226; But before we talk about the quiz, let&#8217;s watch a  cool 
video! 
&#8226; Next time: Ray-triangle intersection, ray tracing 
75 &#169; NVIDIA Inc. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Questions? </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; Intersection means both are satisfied 
&#8226; So, insert explicit equation of ray into  
implicit equation of plane &amp; solve for t 
      P(t) = Ro + t * Rd 
      H(P) = n&#183; P + D = 0 
      n&#183;(Ro + t * Rd) + D = 0 
      t = -(D + n&#183;Ro) / n&#183;Rd  
62 Ray-Plane Intersection 
P(t) 
Done! </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; (Infinite) plane defined by  
&#8211; Po = (x0, y0, z0) 
&#8211; n = (A,B,C)  
&#8226; Implicit plane equation 
&#8211; H(P) = Ax+By+Cz+D = 0 
         = n&#183;P + D = 0 
&#8211; What is D? 
59 3D Plane Representation? 
H Po normal P 
P' 
H(p) = d &lt; 0 H(p) = d &gt; 0 
(Point P 0 must lie on plane) </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226;y coordinate is treated just like x, 
except accounting for aspect ratio 
&#8211;r = (x* u, aspect*y* v, D*w) 
&#8211; Again, u, v, w are the basis vectors 
of the view coordinate system 
&#8211; Aspect ratio handles non-square viewports 
&#8226; Think of your 16:9 widescreen TV 
 
&#8226; The point of the exercise with computing D was to 
allow us to use the [-1,1] image coordinate system 
regardless of field of view. 
49 That was 2D, 3D is just as simple </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
18 
Ray Casting </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 
Scene Camera This image is in the public domain.
Source: openclipart&#169; source unknown. All rights reserved. This content is  excluded from our Creative
Commons license. For more  information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Oscar Meruvia-Pastor, Daniel Rypl . All rights reserved. This  content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.
</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; Implicit sphere equation  
&#8211; Assume centered at origin (easy to translate) 
&#8211; H(P) = ||P||2 - r2 = P&#183;P - r2  = 0 
68 Sphere Representation? 
Rd Ro </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Ray Casting II (PDF - 2.0MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec12/</lecture_pdf_url>
      <lectureno>12</lectureno>
      <slides>
        <slide>
          <slideno>40</slideno>
          <text>41 Implementing CSG 
1.Test "inside" intersections: 
&#8226; Find intersections with A,  
test if they are inside/outside B 
&#8226; Find intersections with B, 
test if they are inside/outside A 
 
2.Overlapping intervals: 
&#8226; Find the intervals of "inside" 
along the ray for A and B 
&#8226; How? Just keep an &#8220;entry&#8221; / &#8220;exit&#8221; bit 
for each intersection 
&#8226; Easy to determine from intersection 
normal and ray direction 
&#8226; Compute 
union/intersection/subtraction of the 
intervals 
Problem reduces to 1D for each ray </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; Or write it as a 2 &#61620;2 linear system 
&#8226;P(&#61538;, &#61543; ) = a + &#61538;e1 + &#61543;e2 
e1 = (b- a), e2 = (c-a) 
20 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P This should be zero 
Something&#8217;s wrong... This 
is a linear system of 3 
equations and 2 
unknowns! </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>80 That&#8217;s All for Today! 
Yu et al. 2009 &#8226; Further reading 
&#8211;Realistic Ray Tracing, 2nd ed.  
(Shirley, Morley) 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Questions? 
Image by Henrik Wann Jensen 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; We have seen that transformations such as affine 
transforms are useful for modeling &amp; animation 
&#8226; How do we incorporate them into ray casting? 
66 Transformations and Ray Casting </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; ...but very hard  if you actually try to compute an 
explicit representation of the resulting surface as a 
triangle mesh 
&#8226; In principle very simple, 
but floating point numbers are not exact  
&#8211; E.g., points do not lie exactly on planes... 
&#8211; Computing the intersection A vs B is not necessarily the 
same as B vs A... 
&#8211; The line that results from intersecting two planes does not 
necessarily lie on either plane... 
&#8211; etc., etc. 
42 CSG is Easy with Ray Casting... </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Ray Casting then Intersection 
52 Reference 1 Reference 2 Desired 
</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&#8226; Since &#61537;+&#61538;+&#61543; =1, we can write &#61537; = 1&#8211; &#61538;&#8211;&#61543;  
 P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c 
  P(&#61538;,&#61543;)      = (1&#8211;&#61538;&#8211;&#61543;)a + &#61538;b + &#61543;c 
                   = a + &#61538;(b-a) + &#61543;(c-a) 
13 Barycentric Coordinates 
c 
a b P Non-orthogonal  
coordinate 
system 
on the plane! rewrite 
Vectors that lie on 
the triangle plane 
{ 
{ </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Edges in triangle meshes 
&#8211; Must report intersection (otherwise not watertight) 
&#8211; Hard to get right 
64 The Evil &#61541; 
</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226;If M includes scaling, directionOS ends up  
NOT be normalized after transformation  
 
&#8226; Two solutions 
&#8211; Normalize the direction  
&#8211; Do not normalize the direction 
71 What About t ? </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Barycentric Definition of a Plane 
[M&#246;bius, 1827] c 
a b P Why? How? 
Ro Rd &#8226; A (non-degenerate) triangle ( a,b,c) defines a plane 
&#8226; Any point P on this plane can be written as 
    P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c, 
    with &#61537;+&#61538;+&#61543; = 1 </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 
The Evil &#61541; 
reflection 
refraction shadow &#8226; In ray tracing, do NOT report intersection for rays 
starting on surfaces 
&#8211; Secondary rays start on surfaces 
&#8211; Requires epsilons 
&#8211; Best to nudge the starting 
point off the surface 
e.g., along normal </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Ray Casting then Intersection 
56 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>CSG then Ray Casting 
47 
Reference 1 Reference 2 Desired 
</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text> 
 
What is a Visual Hull? 
43 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Ray Casting II 
 
 
 
 
 
 
 
 
 
 
 
 
 
Henrik Wann Jensen  
MIT EECS 6.837 &#8211; Matusik Courtesy 
of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Peter Shirley et al.: 
Fundamentals of  
Computer Graphic s 
AK Peters 
 
&#8226; Ray Tracing 
&#8211;Jensen 
&#8211;Shirley 
&#8211;Glassner 
33 Books 
Remember the ones at 
books24x7 mentioned 
in the beginning! 
Images of three book covers have been removed due to copyright restrictions.  Please see the 
following books for more details: 
-Shirley P., M. Ashikhmin and S. Marschner , Fundamentals of Computer Graphics 
-Shirley P. and R.K. Morley, Realistic Ray Tracing 
-Jensen H.W., Realistic Image Synthesis Using Photon Mapping </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Or write it as a 2 &#61620;2 linear system 
&#8226;P(&#61538;, &#61543; ) = a + &#61538;e1 + &#61543;e2 
e1 = (b- a), e2 = (c-a) 
22 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P 
where 
and &lt;a,b&gt; is the dot product. </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; Or write it as a 2 &#61620;2 linear system 
&#8226;P(&#61538;, &#61543; ) = a + &#61538;e1 + &#61543;e2 
e1 = (b- a), e2 = (c-a) 
23 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P 
where 
and &lt;a,b&gt; is the dot product. Questions? </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Reference 1 
Reference 2 Desired Image Based (2D) Intersection 
59 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; 3 ways to pass arguments to a function 
&#8211; by value, e.g. float f(float x) 
&#8211; by reference, e.g. float f(float &amp;x) 
&#8226; f can modify the value of x 
&#8211; by pointer, e.g. float f(float *x) 
&#8226; x here is a just a memory address 
&#8226; motivations:  
less memory than a full data structure if x has a complex type 
dirty hacks (pointer arithmetic),but just do not do it 
&#8226; clean languages do not use pointers 
&#8226; kind of redundant with reference 
&#8226; arrays are pointers 
2 C++  </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Ratio of opposite sub-triangle area to total area 
&#8211;  &#61537; = Aa/A      &#61538; = Ab/A      &#61543; = Ac/A 
&#8226; Use signed areas for points outside the triangle 
    
18 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P Aa A </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>1.Make each primitive handle any applied 
transformations and produce a camera space 
description of its geometry 
 
 
 
 
 
 
2....Or Transform the Rays 
67 Incorporating Transforms 
Transform { 
    Translate { 1 0.5 0 } 
    Scale { 2 2 2 } 
    Sphere {  
        center 0 0 0  
        radius 1  
    }  
}  </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; Complicated for many primitives 
68 Primitives Handle Transforms 
r 
major r 
minor 
(x,y) Sphere {  
    center 3 2 0   
    z_rotation 30 
    r_major 2 
    r_minor 1  
}   </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; Display as much information as you can 
&#8211; image maps (e.g. per-pixel depth, normal) 
&#8211; OpenGL 3D display (e.g. vectors, etc.) 
&#8211; cerr&lt;&lt; or cout&lt;&lt; (with intermediate values, a message 
when you hit a given if statement, etc.) 
&#8226; Doubt everything 
&#8211; Yes, you are sure this part of the code works, but test it 
nonetheless 
&#8226; Use simple cases 
&#8211; e.g. plane z=0, ray with direction (1, 0, 0) 
&#8211; and display all intermediate computation 
7 Debugging </text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>&#8226; Think about transforming the tangent plane   
to the normal, not the normal vector 
77 So How Do We Do It Right? 
Original Incorrect Correct nOS 
Pick any vector vOS in the tangent plane, 
how is it transformed by matrix M? vOS vWS nWS 
vWS   =   M  vOS </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>69 MIT EECS 6.837 &#8211; Durand  (0,0) Transform Ray 
&#8226; Move the ray from World Space  to Object Space 
Object Space World Space r = 1 r 
major r 
minor 
(x,y) 
pWS  =  M    pOS 
pOS  =  M-1  pWS </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text> 
 
 
 
 
&#8226; A neat way to build complex objects from simple 
parts using Boolean operations 
&#8211; Very easy when ray tracing 
&#8226; Remedy used this in the Max Payne games for 
modeling the environments 
&#8211; Not so easy when not ray tracing :) 
34 Constructive Solid Geometry (CSG) 
&#169; Rockstar Games. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226; Or write it as a 2 &#61620;2 linear system 
&#8226;P(&#61538;, &#61543; ) = a + &#61538;e1 + &#61543;e2 
e1 = (b- a), e2 = (c-a) 
19 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P This should be zero 
</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40 Implementing CSG 
1.Test "inside" intersections: 
&#8226; Find intersections with A,  
test if they are inside/outside B 
&#8226; Find intersections with B, 
test if they are inside/outside A 
 
2.Overlapping intervals: 
&#8226; Find the intervals of "inside" 
along the ray for A and B 
&#8226; How? Just keep an &#8220;entry&#8221; / &#8220;exit&#8221; bit 
for each intersection 
&#8226; Easy to determine from intersection 
normal and ray direction 
&#8226; Compute 
union/intersection/subtraction of the 
intervals 
</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Implementing CSG 
1.Test "inside" intersections: 
&#8226; Find intersections with A,  
test if they are inside/outside B 
&#8226; Find intersections with B, 
test if they are inside/outside A 
This would 
certainly work, but 
would need to 
determine if points 
are inside solids... :-( 
39 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226;P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c 
with &#61537;+&#61538;+&#61543; =1 parameterizes the entire plane 
15 Barycentric Definition of a Triangle 
c 
a b P </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Why Use a Visual Hull? 
&#8226; Can be computed robustly 
&#8226; Can be computed efficiently 
44 
- = 
background  
+  
foreground 
background   
 foreground  
</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>36 
Constructive Solid Geometry (CSG) 
Should only 
&#8220;count&#8221; overlap 
region once! Given overlapping shapes A and B: 
 
 
 
     
  Union                   Intersection            Subtraction </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 MIT EECS 6.837 &#8211; Durand  CSG Examples 
&#169; David Kurlander. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Ray Casting then Intersection 
57 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>CSG then Ray Casting 
46 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>How Can We Implement CSG? 
 
 
 
 
 
 
      Union               Intersection            Subtraction Points on A, 
Outside of B Points on B, 
Outside of A 
Points on B, 
Inside of A Points on A, 
Inside of B 4 cases  
37 </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; New origin: 
 
&#8226; New direction: 
70 originOS  = M-1 originWS 
directionOS  = M-1 (originWS + 1 * directionWS)   -   M-1 originWS 
originOS originWS 
directionOS directionWS 
Object Space World Space  qWS = originWS + tWS * directionWS 
 qOS  = originOS + tOS * directionOS directionOS  = M-1  directionWS Transform Ray 
Note that the w 
component of 
direction is 0  </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226;P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c 
with &#61537;+&#61538;+&#61543; =1 
&#8226; Is it explicit or implicit? 
14 Barycentric Definition of a Plane 
[M&#246;bius, 1827] 
c 
a b P Fun to know: 
P is the barycenter , 
the single point upon which  
the triangle would balance if  
weights of size &#61537;, &#61538;, &amp; &#61543; are  
placed on points a, b &amp; c. </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Ray Casting then Intersection 
58 Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Questions? </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226;P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c 
with &#61537;+&#61538;+&#61543; =1 parameterizes the entire plane 
&#8226; If we require in addition that 
&#61537;, &#61538;, &#61543; &gt;= 0, we get just the triangle! 
&#8211; Note that with  &#61537;+&#61538;+&#61543; =1 this implies 
0 &#61603; &#61537; &#61603; 1   &amp;   0 &#61603; &#61538; &#61603; 1   &amp;   0 &#61603; &#61543; &#61603; 1  
&#8211; Verify: 
&#8226;&#61537; =0  =&gt;  P lies on line b-c 
&#8226;&#61537;, &#61538; =0  =&gt;  P = c 
&#8226; etc. 
 
16 Barycentric Definition of a Triangle 
c 
a b P </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Ray Casting then Intersection 
51 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226;Ro + t * Rd = a + &#61538;(b-a) + &#61543;(c-a) 
    
 Rox + tRdx = ax + &#61538;(bx-ax) + &#61543;(cx-ax) 
 Roy + tRdy = ay + &#61538;(by-ay) + &#61543;(cy-ay) 
 Roz + tRdz = az + &#61538;(bz-az)  + &#61543;(cz-az) 
 
&#8226; Regroup &amp; write in matrix form Ax=b 
25 Intersection with Barycentric Triangle 
3 equations,  
3 unknowns 
</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Again, set ray equation equal to barycentric equation 
                            P(t) = P(&#61538;, &#61543;)  
                Ro + t * Rd = a + &#61538;(b-a) + &#61543;(c-a)  
&#8226; Intersection if &#61538; + &#61543; &#61603; 1   &amp; &#61538; &#61619; 0   &amp; &#61543; &#61619; 0 
     (and t &gt; tmin &#8230; ) 
24 Intersection with Barycentric Triangle 
Ro Rd c 
a b P </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>CSG then Ray Casting 
50 Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>76 Transformation for Shear and Scale 
Incorrect 
Normal 
Transformation 
Correct 
Normal 
Transformation 
</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Rendering Visual Hulls 
45 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Or write it as a 2 &#61620;2 linear system 
&#8226;P(&#61538;, &#61543; ) = a + &#61538;e1 + &#61543;e2 
e1 = (b- a), e2 = (c-a) 
21 How Do We Compute &#61537;, &#61538;, &#61543; ? 
c 
a b P These should be zero 
Ha! We&#8217;ll take inner products of 
this equation with e1 &amp; e2 
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226; Use ray-plane intersection followed by in-triangle test 
&#8226; Or try to be smarter 
&#8211; Use barycentric coordinates 
11 Ray-Triangle Intersection 
Ro Rd c 
a b P </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 
Barycentric Intersection Pros 
Ro Rd c 
a b P &#8226; Efficient 
&#8226; Stores no plane equation 
&#8226; Get the barycentric coordinates for free 
&#8211; Useful for interpolation, texture mapping </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>&#8226;tOS &#8800;  tWS    
and must be rescaled after intersection 
==&gt; One more possible failure case... 
72 1. Normalize Direction 
Object Space World Space tWS tOS </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>&#8226; Position  
&#8211; transformed by the full homogeneous matrix M 
&#8226; Direction 
&#8211; transformed by M except the translation component 
&#8226; Normal  
&#8211; transformed by M-T, no translation component 
79 Position, Direction, Normal </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
30 
Ray Casting: Object Oriented Design </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; What happens when  
&#8211; Ray Origin lies on an object? 
&#8211; Grazing rays? 
&#8226; Problem with floating-point approximation 
62 Precision 
</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Image Based Visual Hulls 
</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; We want to be able to add primitives easily 
&#8211; Inheritance and virtual methods 
&#8226; Even the scene is derived from Object3D! 
 
 
 
 
 
&#8226; Also cameras are abstracted (perspective/ortho) 
&#8211; Methods for generating rays for given image coordinates 
31 Object-Oriented Design 
Object3D 
bool intersect(Ray, Hit, tmin) 
Plane 
bool intersect(Ray, Hit, 
tmin) Sphere 
bool intersect(Ray, Hit,  
tmin) Triangle Mesh 
bool intersect(Ray, Hit, 
 tmin) Group 
bool intersect(Ray, Hit,  
tmin) </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Questions? 
&#8226; Image computed using 
the RADIANCE 
system by Greg Ward 
&#169; Martin Moeck . All rights reserved. This content is excluded from our Creative Commons 
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /. </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>CSG then Ray Casting 
48 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 Recap: How to Transform Normals? 
Object Space World Space nOS nWS </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61 Questions? </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>&#8226; Transform point 
 
 
 
&#8226; Transform direction 
74 Transforming Points &amp; Directions 
Homogeneous Coordinates:  
(x,y,z,w) 
w = 0  is a point at infinity (direction) 
&#8226; If you do not store w you need different routines to apply M to a 
point and to a direction ==&gt; Store everything in 4D! </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226; Write a basic ray caster 
&#8211; Orthographic and 
perspective cameras 
&#8211; Spheres and triangles 
&#8211; 2 Display modes: color and distance 
&#8226; We provide classes for 
&#8211; Ray: origin, direction  
&#8211; Hit: t, Material, ( normal) 
&#8211; Scene Parsing 
&#8226; You write ray generation, 
hit testing, simple shading 
32 Assignment 4 &amp; 5: Ray Casting/Tracing 
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; TERRIBLE thing about segfault: the program does 
not necessarily crash where you caused the problem 
&#8226; You might write at an address that is inappropriate 
but that exists 
&#8226; You corrupt data or code at that location 
&#8226; Next time you get there, crash 
 
&#8226; When a segmentation fault occurs, always look for 
pointer or array operations before the crash, but not 
necessarily at the crash 
6 Segmentation Fault </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Questions? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Can get it from a variable using &amp; 
&#8211; often a BAD idea. see next slide 
&#8226; Can be dereferenced with * 
&#8211; float *px=new float; // px is a memory address to a float 
&#8211; *px=5.0; //modify the value at the address px 
&#8226; Should be instantiated with new. See next slide 
3 Pointers </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Transform Tangent Vector v 
v is perpendicular to normal n: 
nOST vOS  =  0 
 nOST  (M-1  M)  vOS  =  0 
 nWST =  nOST (M-1)  (nOST  M-1)  (M    vOS)  =  0 
 (nOST  M-1)  vWS  =  0 
 nWST vWS  =  0 vWS is perpendicular to normal nWS: 
 nWS = (M-1)T nOS nOS 
vWS nWS vOS Dot product </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226;P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c 
&#8226; Condition to be barycentric coordinates: 
&#61537;+&#61538;+&#61543; =1 
&#8226; Condition to be inside the triangle: 
&#61537;, &#61538;, &#61543; &#61619; 0 
17 Barycentric Definition of a Triangle 
c 
a b P </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; When you read or, worse, write at an invalid address 
&#8226; Easiest segmentation fault: 
&#8211; float *px; // px is a memory address to a float 
&#8211; *px=5.0; //modify the value at the address px 
&#8211; Not 100% guaranteed, but you haven&#8217;t instantiated px, it 
could have any random memory address. 
&#8226; 2nd easiest seg fault 
&#8211; Vector&lt;float&gt; vx(3); 
&#8211; vx[9]=0; 
5 Segmentation Fault </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Ray Casting then Intersection 
54 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&#8226; Intro to rendering 
&#8211; Producing a picture based on scene description 
&#8211; Main variants: Ray casting/tracing vs. rasterization 
&#8211; Ray casting vs. ray tracing (secondary rays) 
&#8226; Ray Casting basics 
&#8211; Camera definitions 
&#8226; Orthographic, perspective 
&#8211; Ray representation 
&#8226;P(t) = origin + t * direction 
&#8211; Ray generation 
&#8211; Ray/plane intersection 
&#8211; Ray-sphere intersection 9 Thursday Recap 
This image is in the
public domain. Source:
openclipart
</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Ray Casting then Intersection 
55 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Two ways to create objects 
&#8211; The BAD way, on the stack 
&#8226; myObject *f() { 
&#8211; myObject x; 
&#8211;... 
&#8211; return &amp;x 
&#8226; will crash because x is defined only locally and the memory gets 
de-allocated when you leave function f 
&#8211; The GOOD way, on the heap 
&#8226; myObject *f() { 
&#8211; myObject *x=new myObject; 
&#8211;... 
&#8211; return x  
&#8226; but then you will probably eventually need to delete it  
4 Pointers, Heap, Stack </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Collect Intersections 
 
 
 
 
 
 
      Union               Intersection            Subtraction Each ray 
processed 
separately! 
38 </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; Values v1, v2, v3 defined at a, b, c 
&#8211; Colors, normal, texture coordinates, etc. 
&#8226;P(&#61537;,&#61538;,&#61543;) = &#61537;a + &#61538;b + &#61543;c is the point... 
&#8226; v(&#61537;,&#61538;,&#61543;) = &#61537;v1 + &#61538;v2 + &#61543;v3 is the 
barycentric interpolation of 
v1,v2,v3 at point P 
&#8211; Sanity check: v(1,0,0) = v1, etc.  
&#8226; I.e, once you know &#61537;, &#61538;,&#61543; 
you can interpolate values 
using the same weights. 
&#8211; Convenient! 
28 
Barycentric Interpolation 
v1 v2 
v3 P </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226;tOS =  tWS   &#61664;  convenient! 
&#8226; But you should not rely on tOS being true distance in 
intersection routines (e.g. a&#8800;1 in ray-sphere test) 
73 2. Do Not Normalize Direction 
Object Space World Space tWS tOS </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>CSG then Ray Casting 
49 
Reference 1 Reference 2 Desired </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Used to solve for one variable at a time in system of equations 
26 Cramer&#8217;s Rule 
A R R a b a R R a b a R R a b a 
dz oz z z z dy oy y y y dx ox x x x 
- - - - - 
= &#61543; 
A R a c a b a R a c a b a R a c a b a 
t oz z z z z z oy y y y y y ox x x x x x 
- - - - - - - - - 
= A R c a R a R c a R a R c a R a 
dz z z oz z dy y y oy y dx x x ox x - 
= &#61538; 
|   | denotes the 
determinant 
 
Can be copied 
mechanically  
into code - 
- 
- - 
- - </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Ray Casting then Intersection 
53 Reference 1 Reference 2 Desired 
</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Graphics Pipeline and Rasterization II (PDF - 2.2MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec22/</lecture_pdf_url>
      <lectureno>22</lectureno>
      <slides>
        <slide>
          <slideno>109</slideno>
          <text>Questions? 
110 </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Back to ray-triangle 
79 
</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Back to the basics: Barycentrics 
&#8226; Barycentric coordinates for a triangle ( a, b, c) 
 
 
&#8211; Remember,  
 
&#8226; Barycentrics are very general: 
&#8211; Work for x, y, z, u, v, r, g, b 
&#8211; Anything that varies linearly in object space 
&#8211; including z 
12 
</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>From Screen to Barycentrics 
 
 
 
 
&#8226; Notes:  
&#8211; matrix is inverted once per triangle 
&#8211; can be used to interpolate z, color, texture coordinates, etc.  
22 </text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>86 
</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>MIP Mapping Example 
MIP Mapped (Tri-Linear) Nearest Neighbor 
60 </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Good References 
&#8226;http://www.tomshardware.com/reviews/ray-tracing-
rasterization,2351.html  
&#8226;http://c0de517e.blogspot.com/2011/09/raytracing-
myths.html  
&#8226;htt
p://people.csail.mit.edu/fredo/tmp/rendering.pdf  
 
88 </text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Bad example 
75 Image removed due to copyright restrictions -- please see
https://blogs.intel.com/intellabs/2007/10/10/real_time_raytracing_the_end_o/ for further details.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Finding the MIP Level 
&#8226; Often we think of the 
pre-filter as a box 
&#8211; What is the projection 
of the square 
pixel &#8220;window&#8221; 
in texture space? 
Projected pre-filter 
64 </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Ray Casting 
For each pixel  
For each object  
- Whole scene must be in memory 
- Needs spatial acceleration to be 
efficient 
+ Depth complexity: no computation 
for hidden parts 
+ Atomic computation 
+ More general, more flexible 
&#8211; Primitives, lighting effects, 
adaptive antialiasing Rendering Pipeline 
For each triangle  
   For each pixel 
- Harder to get global illumination 
- Needs smarter techniques to address 
depth complexity (overdraw) 
+ Primitives processed one at a time 
+ Coherence: geometric transforms for 
vertices only 
+ Good bandwidth/computation ratio 
+ Minimal state required, good memory 
behavior Ray Casting vs. Rendering Pipeline 
73 </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Texture Filtering 
&#8226; Problem: Prefiltering is impossible when you can 
only take point samples 
&#8211; This is why visibility (edges) need supersampling 
&#8226; Texture mapping is simpler 
&#8211; Imagine again we are looking at an infinite textured plane 
43 </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Image Quality Comparison 
anisotropic filtering trilinear mipmapping 
(excessive blurring) 
69 </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>For each triangle 
  For each pixel  
    if pixel overlaps triangle 
      color=shade() // only once per pixel!  
      for each sub-pixel sample 
        compute edge equations &amp; z 
        if subsample passes edge equations  
           &amp;&amp; z &lt; zbuffer[subsample] 
          zbuffer[subsample]=z 
          framebuffer[subsample]=color 
At display time: //this is called &#8220;resolving&#8221;  
  For each pixel 
    color = average of subsamples Multisampling Pseudocode 
39 </text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>Questions? 
99 </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Questions? 
27 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Questions 
62 </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>MIP-Mapping 
&#8226; Simplest method: Pick the scale closest, 
then do usual reconstruction on that level 
(e.g. bilinear between 4 closest texture pixels) 
&#8226; Problem: discontinuity when switching scale 
Projected pre-filter 
closest-available  
filter in pyramid Corresponding  
pyramid level 
56 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Multisampling, Visually 
= sub-pixel visibility sample 
One pixel 
34 </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Multisampling vs. Supersampling 
&#8226; Supersampling 
&#8211; Compute an entire image at a higher resolution, then 
downsample (blur + resample at lower res) 
&#8226; Multisampling 
&#8211; Supersample visibility, compute expensive shading only 
once per pixel, reuse shading across visibility samples 
&#8226; But Why? 
&#8211; Visibility edges are where supersampling really works 
&#8211; Shading can be prefiltered more easily than visibility 
&#8226; This is how GPUs perform antialiasing these days 
40 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text> 
 
 
 
&#8226; Recipe 
&#8211; Compute projected homogeneous coordinates a&#8217;, b&#8217;, c&#8217; 
&#8211; Put them in the columns of a matrix, invert it 
&#8211; Multiply screen coordinates (x, y, 1) by inverse matrix 
&#8211;Then divide by the sum of the resulting coordinates 
&#8226; This ensures the result is sums to one like barycentrics should 
&#8211; Then interpolate value (e.g. Z) from vertices using them! From Screen to Barycentrics 
projective 
equivalence 
21 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>16 Samples / Pixel 
31 </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Multisampling Pseudocode 
For each triangle 
  For each pixel  
    if pixel overlaps triangle 
      color=shade() // only once per pixel!  
      for each sub-pixel sample 
        compute edge equations &amp; z 
        if subsample passes edge equations  
           &amp;&amp; z &lt; zbuffer[subsample] 
          zbuffer[subsample]=z 
          framebuffer[subsample]=color 
 
38 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Multisampling, Visually 
= sub-pixel visibility sample 
The color is only 
computed once 
per pixel per 
triangle  and 
reused for all the 
visibility samples 
that are covered 
by the triangle. 
One pixel 
36 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>Solution: Precomputation 
&#8226; We&#8217;ll precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
&#8211; Because it&#8217;s low-passed, we can also subsample 
51 </text>
        </slide>
        <slide>
          <slideno>102</slideno>
          <text>Pre z pass 
&#8226; Again, avoid shading hidden fragment 
&#8226; First pass: rasterize triangles, update only z buffer, 
not color buffer 
&#8226; Second pass: rasterize triangles again, but this time, 
do full shading 
 
&#8226; Advantage over deferred shading: less storage, less 
code modification, more general shading is possible, 
multisampling possible 
&#8226; Disadvantage: needs to rasterize twice 
103 </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>http://xkcd.com/386/ 
74 Image removed due to copyright restrictions &#8211; please see the link above for further details. </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Finding the MIP Level 
&#8226; Often we think of the 
pre-filter as a box 
&#8211; What is the projection 
of the square 
pixel &#8220;window&#8221; 
in texture space? 
&#8211; Answer is in the partial 
derivatives p x and py 
of (u,v) w.r.t. screen (x,y) 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
65 </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>MIP-Mapping 
&#8226; When a pixel wants an integral of the pre-filtered 
texture, we must find the &#8220;closest&#8221; results from the 
precomputed MIP-map pyramid 
&#8211; Must compute the &#8220;size&#8221; of 
the projected pre-filter in 
the texture UV domain 
Projected pre-filter 
54 </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Anisotropic filtering 
&#8226; Pick levels according  
to smallest partial 
&#8211; well, actually max of the  
smallest and the largest/5 
&#8226; Distribute circular  
&#8220;probes&#8221; along  
longest one 
&#8226; Weight them  
by a Gaussian 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
67 </text>
        </slide>
        <slide>
          <slideno>106</slideno>
          <text>Reyes - Pixar&#8217;s Renderman 
&#8226; Tile-based to save memory and maximize texture 
coherence 
&#8226; Order-independent transparency 
&#8211; stores list of fragments and depth per pixel 
&#8226; Micropolygons get rasterized in space, lens and time 
&#8211; frame buffer has multiple samples per pixel 
&#8211; each sample has lens coordinates and time value 
107 </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Projection 
&#8226; Let&#8217;s use simple formulation of projection going 
from 3D homogeneous coordinates to 2D 
homogeneous coordinates 
 
 
 
 
&#8226; No crazy near-far or storage of 1/z 
&#8226; We use &#8217; for screen space coordinates 
16 
</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Examples of Texture Aliasing 
point sampling 
Magnification 
Minification 
42 </text>
        </slide>
        <slide>
          <slideno>108</slideno>
          <text>REYES results 
109 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>Virtual Reality rasterization 
96 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>The infamous half pixel 
&#8226; I refuse to teach it, but it&#8217;s an annoying issue you 
should know about 
&#8226; Do a line drawing of a rectangle  
from [top, right] to [bottom,left] 
&#8226; Do we actually draw the columns/rows of pixels? 
25 Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Questions? 
90 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>Solution: Precomputation 
&#8226; We&#8217;ll precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
50 </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>The infamous half pixel 
&#8226; Displace by half a pixel so that top, right, bottom, left 
are in the middle of pixels 
&#8226; Just change the viewport transform 
26 Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Basic strategy 
&#8226; How to make it work 
&#8211; start by computing x&#8217;, y&#8217; given barycentrics 
&#8211; invert 
&#8226; Later: shortcut barycentrics, directly build interpolants 
14 
</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>Transparency  
&#8226; Triangles and pixels can have transparency (alpha) 
&#8226; But the result depends on the order in which triangles 
are sent 
 
&#8226; Big problem: visibility 
&#8211; There is only one depth stored per pixel/sample 
&#8211; transparent objects involve multiple depth 
&#8211; full solutions store a (variable-length) list of visible objects 
and depth at each pixel 
&#8226; see e.g. the A-buffer by Carpenter  
http://portal.acm.org/citation.cfm?id=808585  
101 </text>
        </slide>
        <slide>
          <slideno>103</slideno>
          <text>Tile-based rendering 
&#8226; Problem: framebuffer is a lot of memory, especially 
with antialiasing 
&#8226; Solution: render subsets of the screen at once 
&#8226; For each tile of pixels 
&#8211; For each triangle 
&#8226; for each pixel 
 
&#8226; Might need to handle a triangle in multiple tiles 
&#8211; redundant computation for projection and setup 
&#8226; Used in mobile graphics cards 
104 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>From screen-space to barycentric 
 
 
 
 
&#8226; It&#8217;s a projective mapping from 
the barycentrics onto screen coordinates! 
&#8211; Represented by a 3x3 matrix 
&#8226; We&#8217;ll take the inverse mapping to get from (x, y, 1) 
to the barycentrics! 
20 
</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>From barycentric to screen-space 
&#8226; From previous slides: 
 
 
&#8226; Seems to suggest it&#8217;s linear in screen 
space.  
But it&#8217;s homogenous coordinates 
&#8226; After division by w, the (x,y) screen coordinates are  a&#8217;, b&#8217;, c&#8217; are the 
projected 
homogeneous 
vertices 
18 
</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Ray Casting 
For each pixel 
For each object 
&#8226;Ray-centric 
&#8226; Needs to store scene in 
memory 
&#8226; (Mostly) Random access 
to scene Rendering Pipeline 
For each triangle 
For each pixel 
&#8226; Triangle centric 
&#8226; Needs to store image   
(and depth) into memory 
&#8226; (Mostly) random access to 
frame buffer Ray Casting vs. Rendering Pipeline 
Which is smaller? Scene or Frame? 
    Frame 
Which is easiest to access randomly? 
    Frame because regular sampling 
72 </text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Movies both rasterization and ray tracing 
91 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>85 
</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Games rasterization 
92 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>Visualization mostly rasterization, 
interactive ray-tracing is starting 
97 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Projected pre-filter Anisotropic filtering 
&#8226; Approximate Elliptical filter with multiple circular 
ones (usually 5) 
&#8226; Perform trilinear lookup at each one 
&#8226; i.e. consider five times eight values 
&#8211; fair amount of computation 
&#8211; this is why graphics hardware  
has dedicated units to compute  
trilinear mipmap reconstruction 
59 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Graphics Pipeline &amp; Rasterization II 
1 MIT EECS 6.837 
Computer Graphics 
Wojciech Matusik Image remov
ed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Texture Filtering 
&#8226; We should pre-filter image function before sampling 
&#8211; That means blurring the image function with a low-pass 
filter (convolution of image function and filter) 
Low-pass filter 
44 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
&#8211; For each pixel, 
test 3 edge equations 
&#8226; if all pass, draw pixel 
 
&#8226; Compute per-pixel color 
&#8226; Test visibility (Z-buffer), 
update frame buffer color 
3 &#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>Interpolation in Screen Space 
The farther region 
shrinks to a smaller 
area of the screen 
Two regions of same 
size in world space  
10 </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>MIP Mapping Example 
nearest neighbor/ 
point sampling 
mipmaps &amp; linear interpolation 
(tri-linear) 
61 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Recap: barycentric to screen-space 
19 
</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Texture Filtering 
&#8226; We can combine low-pass and sampling 
&#8211; The value of a sample is the integral of the product of the 
image f and the filter h centered at the sample location 
&#8226; &#8220;A local average of the image f weighted by the filter h&#8221; 
Low-pass filter 
45 </text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>Medical Imaging same as  
visualization 
98 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Main loops 
 
87 
</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Nope, Not the Same 
&#8226; Linear variation in world space does not yield linear 
variation in screen space due to projection 
&#8211; Think of looking at a checkerboard at a steep angle; all 
squares are the same size on the plane, but not on screen 
 linear screen-space 
(&#8220;Gouraud &#8221;) interpolation 
BAD Perspective-correct 
Interpolation Head -on view 
11 This image is in the public domain. Source: Wikipedia.</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>Architecture ray-tracing, rasterization with   
preprocessing  for complex lighting 
95 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Ray casting (Python) 
84 
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Modern Graphics Pipeline 
&#8226; Perform projection of vertices 
&#8226; Rasterize triangle: find which 
pixels should be lit 
&#8226; Compute per-pixel color 
&#8226; Test visibility, 
update frame buffer color 
&#8211; Store minimum distance to camera 
for each pixel in &#8220;Z-buffer&#8221; 
&#8226; ~same as t min in ray casting! 
&#8211;if new_z &lt; zbuffer [x,y] 
    zbuffer[ x,y]=new_z 
    framebuffer [x,y]=new_color  
Z buffer frame buffer 
4 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Modern Graphics Pipeline 
For each triangle  
   transform into eye space  
   (perform projection)  
   setup 3 edge equations  
   for each pixel x,y  
      if passes all edge equations  
         compute z 
         if z&lt;zbuffer [x,y] 
            zbuffer[x,y]=z 
            framebuffer [x,y]=shade()  
5 &#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>4 Samples / Pixel 
30 </text>
        </slide>
        <slide>
          <slideno>107</slideno>
          <text>Reyes - ignoring transparency 
&#8226; For each tile of pixels 
&#8211; For each geometry 
&#8226; Dice into micropolygons adaptively 
&#8226; For each micropolygon 
&#8211; compute shaded value 
&#8211; For each sample in tile at coordinates x, y, u, v, t 
&#187; reproject micropolygon to its position at time t, and lens position uv 
&#187; determine if micropolygon overlaps samples 
&#187; if yes, test visibility (z-buffer) 
&#187; if z buffer passes, update framebuffer 
108 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>From barycentric to screen-space 
&#8226; Barycentric coordinates for a triangle ( a, b, c) 
 
 
&#8211; Remember,  
 
&#8226; Let&#8217;s project point P by projection matrix C 
a&#8217;, b&#8217;, c&#8217; are the 
projected 
homogeneous 
vertices before 
division by w 
15 </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>How Are Partials Computed? 
&#8226; You can derive closed form formulas based on the uv 
and xyw coordinates of the vertices... 
&#8211; This is what used to be done 
&#8226; ..but shaders may compute texture coordinates 
programmatically, not necessarily interpolated 
&#8211; No way of getting analytic derivatives! 
 
&#8226;In practice, use finite differences 
&#8211; GPUs process pixels in blocks of (at least) 4 anyway 
&#8226; These 2x2 blocks are called quads  
68 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>From barycentric to screen-space 
&#8226; From previous slides: 
 
 
&#8226; Seems to suggest it&#8217;s linear in screen 
space.  
But it&#8217;s homogenous coordinates a&#8217;, b&#8217;, c&#8217; are the 
projected 
homogeneous 
vertices 
17 
</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; How do we get that Z value for each pixel? 
&#8211; We only know z at the vertices... 
&#8211; (Remember, screen-space z is actually z&#8217;/w&#8217;) 
&#8211; Must interpolate from vertices into triangle interior Interpolation in Screen Space 
For each triangle  
   for each pixel (x,y) 
      if passes all edge equations  
         compute z 
         if z&lt;zbuffer [x,y] 
            zbuffer [x,y]=z 
            framebuffer [x,y]=shade()  
7 </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>1 Sample / Pixel 
29 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Basic strategy 
&#8226; Given screen-space x&#8217;, y&#8217; 
&#8226; Compute barycentric coordinates 
&#8226;
Interpolate anything specified at the three vertices 
13 
</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>MIP-Mapping 
&#8226; Simplest method: Pick the scale closest, 
then do usual reconstruction on that level 
(e.g. bilinear between 4 closest texture pixels) 
Projected pre-filter 
closest-available  
filter in pyramid Corresponding  
pyramid level 
55 </text>
        </slide>
        <slide>
          <slideno>104</slideno>
          <text>Reyes - Pixar&#8217;s Renderman 
&#8226; Cook et al. http://graphics.pixar.com/library/Reyes/  
&#8226; Based on micropolygons 
&#8211; each primitive gets diced into polygons as small as a pixel 
&#8226; Enables antialiasing motion blur, depth of field 
&#8226; Shading is computed at the micropolygon level,  
not pixel 
&#8211; related to multisampling: shaded value will be used for 
multiple visibility sample 
 
105 </text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Ray-triangle 
 
 
 
 
&#8226; Cramer&#8217;s rule (where | | is the determinant) 
77 
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Interpolation in Screen Space 
Two regions of same 
size in world space  
9 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text> 
 
 
 
 
 
 
&#8226; Must still integrate product of projected filter and 
texture &#8211; That doesn&#8217;t sound any easier... Texture Pre-Filtering, Visuall
y 
image 
plane textured surface 
(texture map) 
image-space filter image-space filter 
projected onto plane 
Image adapted from 
McCormack et al. 
48 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>100 Samples / Pixel 
Even this 
sampling rate 
cannot get rid 
of all aliasing 
artifacts! 
 
We are really 
only pushing 
the problem 
farther. 
32 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>This is Called &#8220;MIP-Mapping&#8221; 
&#8226; Construct a pyramid  
of images that are  
pre-filtered and  
re-sampled at  
1/2, 1/4, 1/8, etc.,  
of the original  
image's sampling 
&#8226; During rasterization  
we compute the index of the decimated image that is sampled at 
a rate closest to the density of our desired sampling rate 
&#8226; MIP stands for multum in parvo  which means  
many in a small place 
53 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Pseudocode &#8211; Rasterization 
   For every triangle 
ComputeProjection 
Compute interpolation matrix 
Compute bbox, clip bbox to screen limits 
For all pixels x,y in bbox 
Test edge functions 
If all Ei&gt;0 
   compute barycentrics 
   interpolate z from vertices 
   if z &lt; zbuffer[x,y ] 
      interpolate UV coordinates from vertices 
      look up texture color k d 
      Framebuffer[x,y ] = kd 
 //or more complex shader 
23 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Solution: Precomputation 
&#8226; We&#8217;ll precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
&#8211; Because it&#8217;s low-passed, we can also subsample 
52 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Questions? 
41 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Texture Filtering 
&#8226; Well, we can just as well change variables and 
compute this integral on the textured plane instead 
&#8211; In effect, we are projecting the pre-filter onto the plane 
&#8211; It&#8217;s still a weighted average of the texture under filter 
Low-pass filter 
47 </text>
        </slide>
        <slide>
          <slideno>105</slideno>
          <text>Dicing and rasterization 
106 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Supersampling, Visually 
= sub-pixel visibility sample 
When 
supersampling, 
we compute 
colors 
independently for 
all the visibility 
samples. 
One pixel 
37 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Questions? 
71 Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>&#8226; Transparency 
&#8211; Difficult, pretty much unsolved! 
&#8226; Alternative  
&#8211; Reyes (Pixar&#8217;s Renderman) 
&#8211; deferred shading  
&#8211; pre-Z pass 
&#8211;tile-based rendering 
 
&#8226; Shadows 
&#8211; Next time 
&#8226; Reflections, global illumination More issues 
100 </text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Conclusions 
&#8226; Rasterization and ray casting do the same thing 
&#8226; Just swap the two loops 
&#8226; And cache what is independent of pixel location 
83 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Solution: Precomputation 
&#8226; We&#8217;ll precompute and store a set of prefiltered results 
from each texture with different sizes of prefilters 
49 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Projected pre-filter Tri-Linear MIP-Mapping 
&#8226; Use two closest scales,  
compute reconstruction results from both,  
and linearly interpolate between them 
&#8226; Problem: our filter might not be circular, because of 
foreshortening 
58 </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Texture Filtering 
&#8226; Well, we can just as well change variables and 
compute this integral on the textured plane instead 
&#8211; In effect, we are projecting the pre-filter onto the plane 
Low-pass filter 
46 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Ray-triangle recap 
 
 
 
 
 
&#8226; And 
 
 
&#8226; Intersection if 
 
80 
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Modern Graphics Pipeline 
For each triangle  
   transform into eye space  
   (perform projection)  
   setup 3 edge equations  
   for each pixel x,y 
      if passes all edge equations  
         compute z  
         if z&lt;zbuffer [x,y] 
            zbuffer [x,y]=z 
            framebuffer [x,y]=shade()  
6 Questions? &#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>110</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Determinant 
&#8226; Cross product and dot product 
&#8226; i.e., for a matrix with 3 columns vectors: M=UVW 
 
78 
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Interpolation in Screen Space 
8 &#8226; Also need to interpolate color, normals, texture coordinates, 
etc. between vertices 
&#8210; We did this with barycentrics in ray casting 
&#8226;Linear interpolation in object space 
&#8210; Is this the same as linear interpolation on the screen? </text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Graphics Hardware 
&#8226; High performance through  
&#8211; Parallelism  
&#8211; Specialization 
&#8211; No data dependency 
&#8211; Efficient pre-fetching 
 
&#8226; More next week G 
R 
T 
F 
D G 
R 
T 
F 
D G 
R 
T 
F 
D G 
R 
T 
F 
D task  
parallelism data parallelism 
89 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>For isotropic trilinear mipmapping 
&#8226; No right answer,  
circular approximation 
&#8226; Two most common 
approaches are 
&#8211; Pick level according to 
the length (in texels) of 
the longer partial 
 
&#8211; Pick level according to 
the length of their sum 
Projected pre-filter Projection of pixel center 
py = (du/dy, dv/dy) px = (du/dx, dv/dx) 
w x h 
66 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Ray-triangle intersection 
&#8226; Triangle ABC 
&#8226; Ray O+t*D 
&#8226; Barycentric coordinates &#945;, &#946;, &#947; 
&#8226; Ray-triangle intersection 
 
 
&#8226; or in matrix form 
76 
</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>CAD-CAM &amp; Design rasterization  for GUI, 
anything  for final image 
94 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Rasterization 
&#8226; Viewpoint is known and fixed 
&#8226; Let&#8217;s extract what varies per pixel 
 
 
 
 
&#8226; Only D! 
81 
</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Paul Heckbert published seminal work on texture 
mapping and filtering in his master&#8217;s thesis (!) 
&#8211; Including EWA 
&#8211; Highly recommended reading! 
&#8211; See http://www.cs.cmu.edu/~ph/texfund/texfund.pdf  
&#8226; More reading 
&#8211;Feline: Fast Elliptical Lines for  
Anisotropic Texture Mapping,  
McCormack, Perry, Farkas, Jouppi 
SIGGRAPH 1 999 
&#8211;Texram: A Smart Memory for Texturing  
Schilling, Knittel, Strasser,. IEEE CG&amp;A, 16(3): 32-4 1 Further Reading 
Arf! 
70 &#169; Marc Levoy. All rights reserved. This
content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Storing MIP Maps 
&#8226; Can be stored compactly: Only 1/3 more space! 
63 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>Simulation rasterization  
(painter for a long time) 
93 Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Rasterization 
 
 
 
&#8226; Cache redundant computation independent of D: 
 
 
 
&#8226; And for each pixel 
82 
Equivalent to the setup of edge equations and 
interpolants in rasterization 
Per-pixel calculation of 
edge equations and z (=t)  </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>2 closest-available  
filters in pyramid 
Tri-Linear MIP-Mapping 
&#8226; Use two closest scales,  
compute reconstruction results from both,  
and linearly interpolate between them 
Projected pre-filter 
Blurrier  
pyramid level 
Sharper  
pyramid level 
57 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>2 Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility (Z-buffer), 
update frame buffer color 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Supersampling 
&#10004; 
 &#10008; 
28 &#8226; Trivial to do with rasterization as well 
&#8226; Often rates of 2x to 8x 
&#8226; Requires to compute per-pixel average at the end 
&#8226; Most effective against edge jaggies 
&#8226; Usually with jittered sampling 
&#8211; pre-computed pattern for a big block of pixels </text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>Deferred shading 
&#8226; Avoid shading fragments that are eventually hidden 
&#8211; shading becomes more and more costly  
&#8226; First pass: rasterize triangles, store information such 
as normals, BRDF per pixel 
&#8226; Second pass: use stored information to compute 
shading 
 
&#8226;
Advantage: no useless shading 
&#8226; Disadvantage: storage, antialiasing is difficult 
102 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Problem  
&#8211; Shading is very expensive today (complicated shaders) 
&#8211; Full supersampling has linear cost in #samples (k*k) 
&#8226; Goal: High-quality edge antialiasing at lower cost 
&#8226; Solution 
&#8211; Compute shading only once per pixel for each primitive, 
but resolve visibility at &#8220;sub-pixel&#8221; level 
&#8226; Store (k*width, k*height) frame and z buffers, but share shading 
results between sub-pixels within a real pixel 
&#8211; When visibility samples within a pixel hit different 
primitives, we get an average of their colors 
&#8226; Edges get antialiased without large shading cost  Related Idea: Multisampling 
33 </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Pseudocode &#8211; Rasterization 
   For every triangle 
ComputeProjection 
Compute interpolation matrix 
Compute bbox, clip bbox to screen limits 
For all pixels x,y in bbox 
Test edge functions 
If all Ei&gt;0 
   compute barycentrics 
   interpolate z from vertices 
   if z &lt; zbuffer[x,y ] 
      interpolate UV coordinates from vertices 
      look up texture color k d 
      Framebuffer[x,y ] = kd 
 //or more complex shader 
24 Questions? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>One pixel Multisampling, Visually 
= sub-pixel visibility sample 
35 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Color (PDF - 3.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec05/</lecture_pdf_url>
      <lectureno>05</lectureno>
      <slides>
        <slide>
          <slideno>57</slideno>
          <text>&#8226;Meaning of these curves: a monochromatic 
wavelength &#955; can be reproduced with  
b(&#955;) amount of the 435.8nm primary, 
+g(&#955;) amount of the 546.1 primary, 
+r(&#955;) amount of the 700 nm primary 
 
&#8226;This fully specifies the color  
perceived by a human 
 
&#8226;Careful: this is not your usual rgb CIE color matching 
58 
</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>&#8226;The human visual system is more sensitive to ratios 
&#8211;Is a grey twice as bright as another one? 
&#8226;If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
&#8226;Ideal encoding? 
    Log 
&#8226;Problems with log? 
    Gets crazy around zero 
Solution: gamma  
 
 Color quantization gamma 
77 </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Color 
5 
Image courtesy of Z&#225;tonyi S&#225;ndor, (ifj.) Fizped on Wikimedia Commons.
License: CC-BY -SA. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226;Spectra 
&#8226;Cones and spectral response 
&#8226;Color blindness and metamers 
&#8226;Color matching  
&#8226;Color spaces Plan 
4 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>21  Big picture 
&#8226;It&#8217;s all linear! 
&#8211;multiply 
&#8211;add 
&#8226;But  
&#8211;non-orthogonal 
basis 
&#8211;infinite 
dimension 
&#8211;light must be 
positive 
&#8226;Depends on light 
source Light reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Other primaries 
&#8226;We want to use a new set of primaries 
&#8211;e.g. the spectra of R, G &amp; B in a projector or monitor 
&#8226;By linearity of color matching,  
can be obtained from XYZ by a 3x3 matrix 
&#8226;This matrix tells us how to match the 3 primary 
spectra from XYZ using the new 3 primaries 
one example RGB space 
70 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>XYZ to RGB &amp; back 
&#8226;e.g. 
http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html 
&#8226;sRGB to XYZ                        XYZ to sRGB 
 
 
&#8226;Adobe RGB to XYZ          XYZ to Adobe RGB 
 
 
&#8226;NTSC RGB to XYZ          XYZ to NTSC RGB 0.412424    0.212656    0.0193324 
0.357579    0.715158    0.119193 
0.180464    0.0721856   0.950444 3.24071    -0.969258    0.0556352 
 -1.53726     1.87599    -0.203996 
 0.498571    0.0415557   1.05707  
0.576700    0.297361    0.0270328 
0.185556    0.627355    0.0706879 
0.188212    0.0752847   0.991248 2.04148    -0.969258    0.0134455 
 -0.564977    1.87599    -0.118373 
 -0.344713    0.0415557   1.01527  
0.606734    0.298839    0.000000 
0.173564    0.586811    0.0661196 
0.200112    0.114350    1.11491  1.91049    -0.984310    0.0583744 
-0.532592    1.99845    -0.118518 
-0.288284   -0.0282980   0.898611 71 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>What is Color? 
12 
Light 
 
Object 
 
 Observer </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 
Image courtesy of Cpesacreta on Wikimedia Commons. License: CC-BY. This
content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .Image courtesy of Spigget  on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>How to build a measurement device? 
&#8226;Idea: 
&#8211;Start with light sensor sensitive to all wavelength 
&#8211;Use three filters with spectra b, r, g 
&#8211;measure 3 numbers 
&#8226;This is pretty much what the eyes do! 
63 
</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>22 Questions? 
reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate 22 </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Bad consequence: cloth matching 
&#8226;Clothes appear to match in store (e.g. under neon) 
&#8226;Don&#8217;t match outdoor 
38 </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Other primaries 
&#8226;We want to use a new set of primaries 
&#8211;e.g. the spectra of R, G &amp; B in a projector or monitor 
&#8226;By linearity of color matching,  
can be obtained from XYZ by a 3x3 matrix 
one example RGB space 
69 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>&#8226;Digital images are usually not encoded linearly 
&#8226;Instead, the value X 1/&#947; is stored 
 
 
 
&#8226;Need to be decoded if we want linear values Gamma encoding overview 
76 
</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Selected Bibliography 
Vision and Art : The Biology of Seeing  by Margaret Livingstone, David H. Hubel  Harry N 
Abrams; ISBN: 0810904063  
208 pages (May 2002)  Vision Science by Stephen E. Palmer 
MIT Press; ISBN: 0262161834   
760 pages (May 7, 1999)   
 
Billmeyer and Saltzman's Principles of Color Technology, 3rd Edition  
by Roy S. Berns, Fred W. Billmeyer, Max Saltzman  
Wiley-Interscience; ISBN: 047119459X   
304 pages 3 edition (March 31, 2000)  
83 The Reproduction of Color by R. W. G. Hunt 
Fountain Press, 1995 
Color Appearance Models by Mark Fairchild 
Addison Wesley, 1998 
Color for the Sciences, by Jan Koenderink  
MIT Press 2010 .  </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Questions? 
26 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Spectrum 
6 
Light is a wave 
Visible: between 450 and 700nm 
 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>&#8226;From Greg Ward 
&#8226;Only 6 bits for emphasis Gamma encoding 
80 
</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20  Big picture 
&#8226;It&#8217;s all linear! 
Light reflectance 
Cone responses Stimulus multiply 
Multiply wavelength by wavelength 
Integrate 20 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226;Spectra 
&#8226;Cones and spectral response 
&#8226;Color blindness and metamers 
&#8226;Color matching  
&#8226;Color spaces Plan 
27 </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226;Maze in subtle intensity contrast 
&#8226;Visible only to color blinds 
&#8226;Color contrast overrides intensity otherwise Color blindness test 
31 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>What&#8217;s going on?  
&#8226;The three cone responses are not orthogonal 
&#8226;i.e. they overlap and &#8220;pollute&#8221; each other 
46 </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Tricky thing with spectra &amp; color: 
&#8226;Spectrum for the stimulus / synthesis  
&#8211;Light, monitor, reflectance 
&#8226;Response curve for receptor /analysis 
&#8211;Cones, camera, scanner 
They are usually not the same 
There are good reasons for this Warning 
43 
This image is in the public domain.  Source:
http://openclipart.org/detail/3405
1/digicam-
by-thesaurus.
Image courtesy of Pengo  on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Questions? 
82 </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>&#8226;The human visual system is more sensitive to ratios 
&#8211;Is a grey twice as bright as another one? 
&#8226;If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
&#8226;This is why a non-linear gamma remapping of about 2.0 
is applied before encoding 
&#8226;True also of analog imaging to optimize signal-noise 
ratio 
 Color quantization gamma 
79 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Why not measure cone sensitivity? 
&#8226;Less directly measurable 
&#8211;electrode in photoreceptor? 
&#8211;not available when color spaces were defined 
&#8226;Most directly available measurement:  
&#8211;notion of metamers &amp; color matching 
&#8211;directly in terms of color reproduction:  
given an input color,  
how to reproduce it with 3 primary colors? 
&#8211;Commission Internationale de l&#8217;Eclairage 
(International Lighting Commission) 
&#8211;Circa 1920 
Spectral 
Sensibility 
of the  
L, M and S 
Cones S M L 
52 </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226;Some colors cannot be produced using only 
positively weighted primaries 
&#8226;Solution: add light on the other side! Color Matching Problem 
57 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Questions? 
75 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Spectrum 
7 Light is characterized by its 
spectrum:  
the amount of energy at each 
wavelength 
This is a full distribution:  
one value per wavelength 
(infinite number of values) 
 
</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Spectrum demo 
&#8226;Diffraction grating: 
&#8211;shifts light as a function of 
wavelength 
&#8211;Allows you to see spectra 
&#8211;In particular, using a slit light 
source, we get a nice band 
showing the spectrum 
&#8226;See the effect of filters 
&#8226;See different light source 
spectra 
9 
Image courtesy of Cmglee  on Wikimedia  Commons. License:
CC-BY-SA. This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-f ai
r-use/.
This image is in the public do mai
n. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226;Classical case: 1 type of cone is missing (e.g. red)  
&#8226;Makes it impossible to distinguish some spectra Color blindness 
differentiated Same responses 
28 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226;Different wavelength, different intensity 
&#8226;Same response A cone does not &#8220;see&#8221; colors  
23 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Cones 
&#8226;We focus on low-level aspects of color 
&#8211;Cones and early processing in the retina 
&#8226;We won&#8217;t talk about rods (night vision) 
15 
Spectral 
Sensibility 
of the  
L, M and S  
Cones S M L 
This image is in the public domain. Source: Wikimedia Commons.Image courtesy of Ivo Kruusam&#228;gi  on Wikimedia
Commons. License: CC- BY-SA. This content is
excluded from our Creative Commons license. For
more information, see htt
p://ocw.mit.edu/help/
faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226;Dalton  
&#8226;8% male, 0.6% female 
&#8226;Genetic 
&#8226;Dichromate (2% male) 
&#8211;One type of cone missing 
&#8211;L (protanope), M (deuteranope),  
S (tritanope) 
&#8226;Anomalous trichromat 
&#8211;Shifted sensitivity Color blindness &#8211; more general 
29 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226;If I have a given spectrum X 
&#8226;I compute its response to the 3 matching curves 
(multiply and integrate) 
&#8226;I use these 3 responses to  
scale my 3 primaries  
(435.8, 546.1 and 700nm) 
&#8226;I get a metamer  of X 
(perfect color reproduction) CIE color matching: what does it mean? 
60 
</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Questions? 
40 </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226;Take a given stimulus and the corresponding 
responses s, m, l (here 0.5, 0, 0) Additive Synthesis - wrong way 
44 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226;Metamers under a given light source 
&#8226;May not be metamers under a different lamp Metamerism &amp; light source 
36 </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226;Primaries (synthesis) at 435.8, 546.1 and 700nm  
&#8211;Chosen for robust reproduction, good separation in red-green 
&#8211;Don&#8217;t worry, we&#8217;ll be able to convert it to any other set of 
primaries (Linear algebra to the rescue!) 
&#8226;Resulting 3 numbers for each input wavelength are 
called tristimulus values CIE color matching 
54 
</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226;Spectra are infinite-dimensional 
&#8226;Only positive values are allowed 
&#8226;Cones are non-orthogonal/overlap Fundamental problems 
47 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>Answer 
&#8226;It&#8217;s all linear algebra 
3 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226;Physical color 
&#8211;Spectrum 
&#8211;multiplication of light &amp; reflectance spectrum 
&#8226;Perceptual color 
&#8211;Cone spectral response: 3 numbers  
&#8211;Metamers: different spectrum, same responses 
&#8226;Color matching, enables color reproduction with 3 primaries 
&#8226;Fundamental difficulty 
&#8211;Spectra are infinite-dimensional (full function) 
&#8211;Projected to only 3 types of cones 
&#8211;Cone responses overlap / they are non-orthogonal 
&#8226;Means different primaries for analysis and synthesis 
&#8211;Negative numbers are not physical Summary 
48 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226;Choose 3 synthesis primaries   
&#8226;Seek to match any monochromatic light (400 to 700nm) 
&#8211;Record the 3 values for each wavelength 
&#8226;By linearity, this tells us how to match any light CIE color matching 
53 
</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226;Meaning of these curves: a monochromatic 
wavelength &#955; can be reproduced with  
b(&#955;) amount of the 435.8nm primary, 
+g(&#955;) amount of the 546.1 primary, 
+r(&#955;) amount of the 700 nm primary 
 
&#8226;This fully specifies the color  
perceived by a human 
&#8226;However, note that one of  
the responses can be  
negative 
&#61485;Those colors cannot be  
reproduced by those 3 primaries.  CIE color matching 
59 
</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Metamers 
&#8226;We are all color blind! 
&#8226;These two different 
spectra elicit the same 
cone responses 
&#8226;Called metamers 
33 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Color gamut 
&#8226;Given 3 primaries 
&#8226;The realizable 
chromaticities lay in the 
triangle in xy 
chromaticity diagram 
&#8226;Because we can only 
add light, no negative 
light C 
&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .
This image is in the publ
ic domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>For matrix lovers 
&#8226;Spectrum: big long vector size N where N=&#8734; 
&#8226;Cone response: 3xN matrix of individual 
responses 
S 
L M cone spectral 
response 
kind of RGB observed  
spectrum 
19 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Good news: color reproduction 
&#8226;3 primaries are (to a first order) enough to 
reproduce all colors 
34 
Image courtesy of Martin Apolin  on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Does color puzzle you? 
2 </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226;THE standard for color specification 
&#8226;Lots of legacy decision - I wish it were LMS 
&#8226;Based on color matching  
&#8211;3 monochromatic primaries 
&#8211;Subjects matched every wavelength 
&#8211;Tricks to avoid negative numbers 
&#8211;These 3 values &#8220;measure&#8221;  
or describe a perceived color.  CIE XYZ -recap 
67 
</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>&#8226;It&#8217;s all about linear algebra 
&#8211;Projection from infinite-dimensional spectrum to a 3D 
response 
&#8211;Then any space based on color matching and 
metamerism can be converted by 3x3 matrix 
&#8226;Complicated because 
&#8211;Projection from infinite-dimensional space 
&#8211;Non-orthogonal basis (cone responses overlap) 
&#8211;No negative light 
&#8226;XYZ is the most standard color space 
&#8226;RGB has many flavors In summary 
74 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Recap 
&#8226;Spectra : infinite dimensional  
&#8226;Cones: 3 spectral responses 
&#8226;Metamers: spectra that look the same  
(same projection onto cone responses) 
&#8226;CIE measured color response: 
&#8211;chose 3 primaries 
&#8211;tristimulus curves to reproduce any wavelength 
 
&#8226;Questions? 
62 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Recap 
&#8226;Spectrum: infinite number of values 
&#8226;projected according to cone spectral response  
=&gt; 3 values 
&#8226;metamers: spectra that induce the same response 
(physically different but look the same) 
 
 
&#8226;Questions? 
35 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>CIE&#8217;s problem  
&#8226;Obvious solution:  
use cone response! 
&#8211;but unknown at the time 
&#8226;=&gt;new set of tristimulus curves 
&#8211;linear combinations of b, g, r 
&#8211;pretty much add enough b and g  
until r is positive 
65 
</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Analysis &amp; Synthesis 
&#8226;Focus on additive color synthesis 
&#8226;We&#8217;ll use 3 primaries (e.g. red green and blue) to 
match all colors 
 
 
 
 
&#8226;What should those primaries be? 
&#8226;How do we tell the amount of each primary 
needed to reproduce a given target color? 
42 
Image courtesy of Pengo on Wikimedia Commons. License: CC- BY-SA.
This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>&#8226;We need a principled color space 
&#8226;Many possible definition 
&#8211;Including cone response (LMS) 
&#8211;Unfortunately not really used,  
(because not known at the time) 
 
&#8226;The good news is that color vision is linear and  
3-dimensional, so any new color space based on 
color matching can be obtained using 3x3 matrix  
&#8211;But there are also non-linear color spaces  
(e.g. Hue Saturation Value, Lab) Standard color spaces 
50 </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>&#8226;Digital images are usually gamma encoded 
&#8211;Often &#947; = 2.2 (but 1.8 for Profoto RGB) 
&#8226;To get linear values, you must decode 
&#8211;apply x =&gt; x&#947; Important Message 
81 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Light-Matter Interaction 
8 Where spectra come from: 
- light source spectrum 
- object reflectance (aka spectral albedo) 
get multiplied wavelength by wavelength 
 
There are different physical processes that explain 
this multiplication 
e.g. absorption, interferences 
.* = 
Foundations of Vision, by Brian Wandell, Sinauer Assoc., 1995 &#169;  Sinauer Associates, Inc. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226;Different wavelength, different intensity  
&#8226;But different response for different cones Response comparison 
24 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226;Short, Medium and Long wavelength 
&#8226;Response for a cone  
= &#8747; &#955; stimulus(&#955;) * response(&#955;) d&#955; 
17 Cone spectral sensitivity 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Relation to cone curves 
&#8226;Project to the same subspace 
&#8211;b, g, and r are linear combinations of S, M and L  
&#8226;Related by 3x3 matrix.  
&#8226;Unfortunately unknown at that time. This would 
have made life a lot easier! 
61 
</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Color blindness test 
30 
&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
Image courtesy of Eddau processed File:  Ishihara 2.svg  by User:Sakurambo, with
http://www.vischeck.com/vischeck/vischeckURL.php  on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our Creative Commons license.
For more information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>So far, physical side of colors: spectra 
an infinite number of values  
(one per wavelength) Questions? 
10 
&#169;  Sinauer Associates, Inc. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226;Most standard color space: CIE XYZ 
&#8226;LMS and the various flavor of RGB are just 
linear transformations of the XYZ basis 
&#8211;3x3 matrices Overview 
51 </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Illuminant metamerism example 
&#8226;Two grey patches in Billmeyer &amp; Saltzman&#8217;s book 
look the same under daylight  
but different under neon or halogen  
(&amp; my camera agrees ;-) 
Daylight Scan (neon) 
Hallogen 37 &#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226;Colors as relative responses 
(ratios) von Helmholtz 1859: Trichromatic theory 
Violet 
Blue 
Green 
Yellow 
Orange 
Red 
Short wavelength receptors 
Medium wavelength receptors 
Long wavelength receptors 
Receptor Responses 
Wavelengths (nm) 400  500 600 700 Violet 
Blue 
Green 
Yellow 
Orange 
Red 
25 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>What is Color? 
13 
Illumination 
Reflectance Stimulus 
Cone 
responses </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Questions? 
&#8226;Links: 
&#8211;Vischeck shows you what an image looks like to 
someone who is colorblind. 
&#8211;http://www.vischeck.com/vischeck/ 
&#8211;Daltonize, changes the red/green variation to 
brightness and blue/yellow variations. 
&#8211;http://www.vischeck.com/dalton  
&#8211;http://www.vischeck.com/daltonize/runDaltonize.php 
32 </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>&#8226;The human visual system is more sensitive to ratios 
&#8211;Is a grey twice as bright as another one? 
&#8226;If we use linear encoding, we have tons of information 
between 128 and 255, but very little between 1 and 2! 
&#8226;This is why a non-linear gamma remapping of about 2.0 
is applied before encoding 
&#8226;True also of analog imaging to optimize signal-noise 
ratio 
 Color quantization gamma 
78 </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Cone response 
Start from infinite 
number of values  
(one per 
wavelength) 
 
 
 
 
 
 
 
 
End up with 3 
values (one per 
cone type) 
Cone responses Stimulus 
Multiply wavelength by wavelength 
Integrate 
1 number 1 number 1 number 
18 
&#169; source unknown. All rights reserved. This content is exclude
d from our Creative
Commons license. For more information, see  http://ocw.mit.edu/help/faq-fair-use/ .</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226;Spectra 
&#8226;Cones and spectral response 
&#8226;Color blindness and metamers 
&#8226;Color matching  
&#8226;Color spaces Plan 
11 </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Recap 
&#8226;Spectrum is an infinity of numbers  
&#8226;Projected to 3D cone-response space 
&#8211;for each cone, multiply per wavelength and integrate 
&#8211;a.k.a. dot product 
&#8226;Metamerism: infinite-D points projected to the 
same 3D point 
(different spectrum, same perceived color) 
&#8211;affected by illuminant 
&#8211;enables color reproduction with only 3 primaries 
39 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Questions? 
49 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Chromaticity diagrams 
&#8226;3D space are tough to visualize 
&#8226;Usually project to 2D for clarity 
&#8226;Chromaticity diagram: 
&#8211;normalize against X + Y + Z: 
 
 
&#8211;Perspective project
ion to plane  
X+Y+Z=1 
66 &#169; source unknown. All rights reserved. This content is
excluded from our C re
ative Commons license. For more
information, see http://ocw .
mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Questions? 
68 </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>CIE&#8217;s problem  
&#8226;Idea: 
&#8211;Start with light sensor sensitive to all wavelength 
&#8211;Use three filters with spectra b, r, g 
&#8211;measure 3 numbers 
&#8226;But for those primaries, we need negative spectra 
 
64 
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Color 
Wojciech Matusik MIT EECS 
Many slides courtesy of Victor Ostromoukhov, Leonard McMillan, Bill Freeman, Fredo Durand  
Image courtesy of Chevre  on Wikimedia Commons.  License: CC- BY-SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .1 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Now, our interactive 
feature! 
You are... 
THE LAB RAT 
55 </text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Questions? 
84 
Image courtesy of SharkD on Wikimedia Commons. License: CC-BY. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Analysis &amp; Synthesis 
&#8226;Now let&#8217;s switch to technology 
&#8226;We want to measure &amp; reproduce color  
as seen by humans 
&#8226;No need for full spectrum 
&#8226;Only need to match up to metamerism 
41 </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Additive Synthesis - wrong way 
&#8226;Use it to scale the cone spectra (here 0.5 * S) 
&#8226;You don&#8217;t get the same cone response!  
(here 0.5, 0.1, 0.1) 
45 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>What is Color? 
14 
Light 
Illumination Object 
Reflectance Final stimulus 
Spectral 
Sensibility 
of the  
L, M and S  
Cones S M L 
Then the cones in the eye interpret the stimulus </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Summary  (and time for questions) 
&#8226;Spectrum: infinite number of values 
&#8211;can be multiplied 
&#8211;can be added 
&#8226;Light spectrum multiplied by reflectance 
spectrum 
&#8211;spectrum depends on illuminant 
&#8226;Human visual system is complicated 
16 </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Acceleration Structures for Ray Casting (PDF)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec14/</lecture_pdf_url>
      <lectureno>14</lectureno>
      <slides>
        <slide>
          <slideno>71</slideno>
          <text>Kd-tree Traversal - Three Cases 
&#8226; Intersects only back, only front, or both 
&#8226; Can be tested by examining t, t start and tend 
72 </text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Split in the Middle 
83 &#8226; Does not conform to empty vs. dense areas 
&#8226; Inefficient traversal &#8211; Not so good! </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Important Details 
&#8226; For leaves, do NOT report 
intersection if t is not in [t near, tfar].  
&#8211; Important for primitives that overlap multiple nodes! 
 
&#8226; Need to take direction of ray into account 
&#8211; Reverse back and front if the direction has negative 
coordinate along the split dimension 
&#8226; Degeneracies when ray direction 
is parallel to one axis 
80 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; Find bounding box of objects/primitives 
&#8226; Split objects/primitives into two, compute child BVs 
&#8226; Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
48 </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Kd-tree Construction - Recurse 
&#8226; Stop when minimum number of primitives reached 
&#8226; Other stopping criteria possible 
67 </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Two main gains 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Wald&#8217;s thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
Only near line 
stop at first intersection 
79 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>&#8226; Motivation 
&#8211; You need LOTS of rays to generate nice pictures 
&#8211; Intersecting every ray with every primitive becomes the 
bottleneck 
&#8226; Bounding volumes 
&#8226; Bounding Volume Hierarchies, Kd-trees 
For every pixel  
 Construct a ray from the eye  
 For every object in the scene  
  Find intersection with the ray  
  Keep if closest  
     Shade Today 
10 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Accelerating Ray Casting 
&#8226; Goal: Reduce the number 
of ray/primitive 
intersections 
11 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Intersection with BVH 
58 </text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Is it Important to Optimize Splits? 
&#8226; Given the same traversal code, the quality of Kd-tree 
construction can have a big impact on performance, 
e.g. a factor of 2 compared to naive middle split 
&#8211; But then, you should consider carefully if you need that 
extra performance 
&#8211; Could you optimize something else for bigger gain? 
87 </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
24 </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Ray tree 
&#8226; Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray This gets pretty complicated 
pretty fast! 
7 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>BVH Discussion 
&#8226; Advantages 
&#8211; easy to construct 
&#8211; easy to traverse 
&#8211; binary tree (=simple structure) 
 
&#8226; Disadvantages 
&#8211; may be difficult to choose a good split for a node 
&#8211; poor split may result in minimal spatial pruning 
60 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Questions? 
8 </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Recap: Two main gains 
&#8226; Only intersect with triangles &#8220;near&#8221; the line 
&#8226; Stop at the first intersection 
78 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Then Intersect Intervals 
&#8226; Compute t 1 and t2 for Y... 
t1 t2 
y=Y2 
y=Y1 
x=X1 x=X2 
30 </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Ray-Box Intersection Summary 
&#8226; For each dimension,  
&#8211; If Rdx = 0  (ray is parallel)  AND   
    Rox &lt; X1 or Rox &gt; X2  &#8594;  no intersection  
&#8226; For each dimension, calculate intersection distances t1 and t2 
&#8211; t1 = (X1 - Rox) / Rdx                         t2 = (X2 - Rox) / Rdx 
&#8211; If t1 &gt; t2,   swap 
&#8211; Maintain an interval [tstart, tend], intersect with current 
dimension 
&#8211; If t1 &gt; tstart,  tstart = t1               If t2 &lt; tend,    tend    = t2 
&#8226; If tstart &gt; tend    &#8594; box is missed  
&#8226; If tend &lt; tmin    &#8594; box is behind  
&#8226; If tstart  &gt;  tmin  &#8594; closest intersection at tstart 
&#8226; Else                      &#8594; closest intersection at tend 
37 </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>Test if Parallel 
&#8226; If Rdx = 0  (ray is parallel)   AND 
    Rox &lt; X1 or Rox &gt; X2  &#8594;  no intersection  
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
 (The same 
for Y and Z, 
of course) 
18 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Conservative Bounding Volume 
&#8226; What does 
&#8220;conservative&#8221; mean? 
&#8211; Volume must be big 
enough to contain all 
geometry within 
13 </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Basic idea 
&#8211; Determine an interval along the ray for each dimension 
&#8211; The intersect these 1D intervals (remember CSG!) 
&#8211; Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
20 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Basic idea 
&#8211; Determine an interval along the ray for each dimension 
&#8211; The intersect these 1D intervals (remember CSG!) 
&#8211; Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
Interval 
between Y 1 
and Y 2 
21 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Kd-tree Construction 
&#8226; Start with scene axis-aligned bounding box 
&#8226; Decide which dimension to split (e.g. longest) 
&#8226; Decide at which distance to split (not so easy) 
65 </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
End= 
min of maxs 
25 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>BVH Discussion 
&#8226; Advantages 
&#8211; easy to construct 
&#8211; easy to traverse 
&#8211; binary tree (=simple structure) 
 
&#8226; Disadvantages 
&#8211; may be difficult to choose a good split for a node 
&#8211; poor split may result in minimal spatial pruning 
 
&#8226; Still one of the best methods 
&#8211;Recommended for your first hierarchy! 
62 Questions? </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Kd-tree Traversal, Smarter Version 
&#8226; Get main bbox intersection from parent  
&#8211; tnear, tfar 
&#8226; Intersect with splitting plane  
&#8211; easy because axis aligned 
tnear tfar 
t 
71 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Bounding Volume Hierarchy (BVH) 
&#8226; Find bounding box of objects/primitives 
&#8226; Split objects/primitives into two, compute child BVs 
&#8226; Recurse, build a binary tree 
47 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Is there an Intersection? 
&#8226; If tstart &gt; tend &#8594; box is missed  
y=Y2 
y=Y1 
x=X1 x=X2 tend tstart 
34 </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Ray-BVH Intersection 
55 </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Ray-BVH Intersection 
56 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>Conservative Bounding Volume 
12 &#8226; First check for an 
intersection with a 
conservative  
bounding volume 
&#8226; Early reject: If ray 
doesn&#8217;t hit volume, 
it doesn&#8217;t hit the 
triangles! </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Are Bounding Volumes Enough? 
&#8226; If ray hits bounding volume, 
must we test all primitives inside it? 
&#8211; Lots of work, think of a 1M-triangle mesh 
bounding 
sphere 
45 </text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Surface Area Heuristic 
&#8226; Probability that we need to intersect a child 
&#8211; Area of the bbox of that child  
(exact for uniformly distributed rays) 
&#8226; Cost of the traversal of that child 
&#8211; number of primitives (simplistic heuristic) 
&#8226; This heuristic likes to put big densities of primitives 
in small-area nodes 
86 </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Intersecting 1D Intervals 
Start= 
max of mins 
End= 
min of maxs If Start &gt; End, the intersection is empty! 
26 </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Important Details 
&#8226; For leaves, do NOT report 
intersection if t is not in [t near, tfar].  
&#8211; Important for primitives that overlap multiple nodes! 
 
&#8226; Need to take direction of ray into account 
&#8211; Reverse back and front if the direction has negative 
coordinate along the split dimension 
&#8226; Degeneracies when ray direction 
is parallel to one axis 
81 Questions? </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Bounding Box of a Transform 
(x'min, y'min, z'min) (x'max, y'max, z'max) 
= (min(x0,x1,x2,x3,x4,x5,x6,x7),  
     min( y0,y1,y2,y3,y4,x5,x6,x7),  
     min( z0,z1,z2,z3,z4,x5,x6,x7)) M 
(xmin, ymin, zmin) (x0,y0,z0) =  
M (xmin,ymin,zmin) = (max( x0,x1,x2,x3,x4,x5,x6,x7),  
     max(y0,y1,y2,y3,y4,x5,x6,x7),  
     max(z0,z1,z2,z3,z4,x5,x6,x7)) 
(x1,y1,z1) =  
M (xmax,ymin,zmin) (x2,y2,z2) =  
M (xmin,ymax,zmin) (x3,y3,z3) =   
M (xmax,ymax,zmin) (xmax, ymax, zmax) Bounding box of transformed object IS NOT 
the transformation of the bounding box! 
44 Questions? </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Efficiency Issues 
&#8226; 1/Rdx, 1/Rdy and 1/Rdz can be pre-computed  
and shared for many boxes 
38 </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Stopping criteria: 
&#8226; Recursion depth 
&#8211; Stop after a 
number  
of bounces 
&#8226; Ray contribution 
&#8211; Stop if reflected /  
transmitted 
contribution  
becomes too small trace ray  
   Intersect all objects  
   color = ambient term  
   For every light  
      cast shadow ray  
      color += local shading term  
   If mirror 
      color += colorrefl *  
                trace reflected ray  
   If transparent  
      color += colortrans *  
               trace transmitted ray  
 
&#8226;   Does it ever end? 
Recap: Ray Tracing 
2 </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>MIT EECS 6.837 Computer Graphics 
Wojciech Matusik, MIT EECS 
Acceleration 
Structures for Ray Casting 
Ha&#353;an  et al. 2007  1 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Kd-tree Traversal, Na&#239;ve Version 
&#8226; Could use bounding box test for each child 
&#8226; But redundant calculation: bbox similar to that of 
parent node, plus axis aligned, one single split 
70 </text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Early termination is powerful 
&#8226; If there is an intersection in the first node, don&#8217;t visit 
the second one 
&#8226; Allows ray casting to be reasonably independent of 
scene depth complexity 
77 </text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Important! 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Wald&#8217;s thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
75 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Recursion For Reflection: None 
0 recursion </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Recursion For Reflection: 2 
0 recursion 
5 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Early termination is powerful! 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Wald&#8217;s thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
76 </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Calculate intersection distance t1 and t2 
&#8211; t1 = (X1 - Rox) / Rdx 
&#8211; t2 = (X2 - Rox) / Rdx 
&#8211;[t1, t2] is the X interval 
t1 t2 
Ro Rd y=Y2 
y=Y1 
x=X1 x=X2 
28 </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Then Intersect Intervals 
&#8226; Update t start &amp; tend for each subsequent dimension 
&#8211;If t1 &gt; tstart,  tstart = t1 
&#8211;If t2 &lt; tend,    tend    = t2 
tend y=Y2 
y=Y1 
x=X1 x=X2 tstart 
t1 t2 
32 </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Na&#239;ve Ray-Box Intersection 
&#8226; 6 plane equations: Compute all intersections 
&#8226; Return closest intersection inside the box  
&#8211; Verify intersections are on the correct side  
of each plane: Ax+By+Cz+D &lt; 0  
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
16 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Bounding Box of a Plane 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
= (-&#8734;, -&#8734;, -&#8734;)* = (+&#8734;, +&#8734;, +&#8734;)*  
n = (a, b, c) 
ax + by + cz = d 
* unless n is exactly perpendicular to an axis 
41 </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Kd-tree traversal - three cases 
&#8226; If t&gt;t end =&gt; intersect only front 
&#8226; If t&lt;t start =&gt; intersect only back Note: &#8220;Back&#8221; and 
&#8220;Front&#8221; depend on 
ray direction! 
73 </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; Find bounding box of objects/primitives 
&#8226; Split objects/primitives into two, compute child BVs 
&#8226; Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
49 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Is the Box Behind the Eyepoint? 
&#8226; If tend &lt;  tmin   &#8594; box is behind  
y=Y2 
y=Y1 
x=X1 x=X2 tend 
tstart 
35 </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Bounding Box of a Triangle 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
(x0, y0, z0) 
(x1, y1, z1) 
(x2, y2, z2) 
= (min( x0,x1,x2),  
     min( y0,y1,y2),  
     min( z0,z1,z2)) = (max( x0,x1,x2), 
     max( y0,y1,y2), 
     max( z0,z1,z2)) 
39 </text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Optimizing Splitting Planes 
&#8226; Most people use the Surface Area Heuristic (SAH) 
&#8211;MacDonald and Booth 1990, &#8220;Heuristic for ray tracing 
using space subdivision&#8221;, Visual Computer  
&#8226; Idea: simple probabilistic prediction of traversal cost 
based on split distance 
&#8226; Then try different possible splits and keep the one 
with lowest cost 
&#8226; Further reading on efficient Kd-tree construction 
&#8211;Hunt, Mark &amp; Stoll, IRT 2006  
&#8211;Zhou et al., SIGGRAPH Asia 2008  
85 </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Bounding Box of a Group 
(xmin_b, ymin_b, zmin_b) 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
= (min(xmin_a,xmin_b),  
     min(ymin_a,ymin_b),  
     min(zmin_a,zmin_b)) = (max(xmax_a,xmax_b),  
     max(ymax_a,ymax_b),  
     max(zmax_a,zmax_b)) 
(xmin_a, ymin_a, zmin_a) (xmax_b, ymax_b, zmax_b) (xmax_a, ymax_a, zmax_a) 
42 </text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Where to split for construction? 
&#8226; Example for baseline 
&#8226; Note how this ray traverses easily: one leaf only 
82 </text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Questions? 
&#8226; For extensions to moving scenes, see Real-Time KD-
Tree Construction on Graphics Hardware, Zhou et  
al., SIGGRAPH 2008  
91 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Intersection with BVH 
57 </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Then Intersect Intervals 
&#8226; Init t start &amp; tend with X interval 
&#8226; Update t start &amp; tend for each subsequent dimension 
y=Y2 
y=Y1 
x=X1 x=X2 
tend tstart 
29 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>&#8226; Find bounding box of objects/primitives 
&#8226; Split objects/primitives into two, compute child BVs 
&#8226; Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
50 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Ray Tracing Algorithm Analysis 
&#8226; Lots of primitives 
&#8226; Recursive 
&#8226; Distributed Ray 
Tracing 
&#8211; Means using many 
rays for non-
ideal/non-pointlike 
phenomena  
&#8226; Soft shadows 
&#8226; Anti-aliasing 
&#8226; Glossy reflection 
&#8226; Motion blur 
&#8226; Depth of field cost  &#8776;   height * width *  
              num primitives *  
              intersection cost *  
              size of recursive ray tree *  
         num shadow rays * 
         num supersamples * 
              num glossy rays *               
              num temporal samples * 
              num aperture samples * 
              . . . 
Can we reduce this? 
9 </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Bounding Box of a Transform 
(x'min, y'min, z'min) (x'max, y'max, z'max) 
= (min(x0,x1,x2,x3,x4,x5,x6,x7),  
     min( y0,y1,y2,y3,y4,x5,x6,x7),  
     min( z0,z1,z2,z3,z4,x5,x6,x7)) M 
(xmin, ymin, zmin) (x0,y0,z0) =  
M (xmin,ymin,zmin) = (max( x0,x1,x2,x3,x4,x5,x6,x7),  
     max(y0,y1,y2,y3,y4,x5,x6,x7),  
     max(z0,z1,z2,z3,z4,x5,x6,x7)) 
(x1,y1,z1) =  
M (xmax,ymin,zmin) (x2,y2,z2) =  
M (xmin,ymax,zmin) (x3,y3,z3) =   
M (xmax,ymax,zmin) (xmax, ymax, zmax) Bounding box of transformed object IS NOT 
the transformation of the bounding box! 
43 </text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Then Intersect Intervals 
&#8226; Update t start &amp; tend for each subsequent dimension 
&#8211;If t1 &gt; tstart,  tstart = t1 
&#8211;If t2 &lt; tend,    tend    = t2 
y=Y2 
y=Y1 
x=X1 x=X2 t1 t2 
 tend tstart 
31 </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Kd-tree Traversal Pseudocode 
travers(orig, dir, t_start, t_end): 
#adapted from Ingo Wald&#8217;s thesis  
#assumes that dir[self.dimSplit] &gt;0 
if self.isLeaf:  
return intersect(self.listOfTriangles, orig, dir, t_start, t_end) 
t = (self.splitDist - orig[self.dimSplit]) / dir[self.dimSplit];  
if t &lt;= t_start:   
# case one, t &lt;= t_start &lt;= t_end -&gt; cull front side   
return self.backSideNode.traverse(orig, dir,t_start,t_end)  
elif t &gt;= t_end:  
# case two, t_start &lt;= t_end &lt;= t -&gt; cull back side   
return self.frontSideNode.traverse(orig, dir,t_start,t_end)  
else: 
# case three: traverse both sides in turn   
t_hit = self.frontSideNode.traverse(orig, dir, t_start, t)  
if t_hit &lt;= t: return t_hit; # early ray termination   
return self.backSideNode.traverse(orig, dir, t, t_end) 
 
74 </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>Efficient Implementation 
&#8226; Not so easy, need ability to sort primitives along the 
three axes very efficiently and split them into two 
groups 
&#8226; Plus primitives have an extent (bbox) 
&#8226; Extra tricks include smarter tests to check if a 
triangle is inside a box 
Node  bbox of triangle 
88 </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Calculate intersection distance t1 and t2 
t1 t2 
Ro Rd y=Y2 
y=Y1 
x=X1 x=X2 
27 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Intersecting 1D Intervals 
23 </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>Ray-BVH Intersection 
54 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Recursion For Reflection: 1 
0 recursion 
4 </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Kd-tree Construction - Split 
&#8226; Distribute primitives to each side 
&#8226; If a primitive overlaps split plane, assign to both 
sides 
66 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Where to Split Objects? 
&#8226; At midpoint of current volume    OR 
&#8226; Sort, and put half of the objects on each side    OR 
&#8226; Use modeling hierarchy 
53 Questions? </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>Ray-Box Intersection 
&#8226; Axis-aligned box 
&#8226; Box:   (X1, Y1, Z1) &#8594; (X2, Y2, Z2) 
&#8226; Ray:    P(t) = Ro + tRd 
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
15 </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Questions? 
&#8226; Further reading on efficient Kd-tree construction 
&#8211;Hunt, Mark &amp; Stoll, IRT 2006  
&#8211;Zhou et al., SIGGRAPH Asia 2008  
 Zhou et al. 
68 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Kd-tree Traversal - High Level 
&#8226; If leaf, intersect with list of primitives 
&#8226; If intersects back child, recurse 
&#8226; If intersects front child, recurse 
69 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Ray tree 
&#8226; Visualizing the ray tree for single image pixel 
incoming 
reflected ray 
shadow ray 
transmitted (refracted) ray 
6 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Basic idea 
&#8211; Determine an interval along the ray for each dimension 
&#8211; The intersect these 1D intervals (remember CSG!) 
&#8211; Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 
19 </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Find Intersections Per Dimension 
&#8226; Basic idea 
&#8211; Determine an interval along the ray for each dimension 
&#8211; The intersect these 1D intervals (remember CSG!) 
&#8211; Done! 
Ro y=Y2 
y=Y1 
x=X1 x=X2 Interval 
between X 1 
and X 2 
Interval 
between Y 1 
and Y 2 
Intersection 
22 </text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Split in the Median 
84 &#8226; Tries to balance tree, but does not conform to empty 
vs. dense areas 
&#8226; Inefficient traversal &#8211; Not good </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Data Structure 
KdTreeNode: 
KdTreeNode* backNode, frontNode //children 
int dimSplit // either x, y or z 
float splitDistance  
// from origin along split axis 
boolean isLeaf 
List of triangles //only for leaves 
 
here dimSplit = 0 (x axis) backNode frontNode 
X=splitDistance  
64 </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>BVH Discussion 
&#8226; Advantages 
&#8211; easy to construct 
&#8211; easy to traverse 
&#8211; binary tree (=simple structure) 
 
&#8226; Disadvantages 
&#8211; may be difficult to choose a good split for a node 
&#8211; poor split may result in minimal spatial pruning 
 
&#8226; Still one of the best methods 
&#8211;Recommended for your first hierarchy! 
61 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Intersection with BVH 
59 </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Kd-trees 
&#8226; Probably most popular acceleration structure  
&#8226; Binary tree, axis-aligned splits 
&#8211; Each node splits space 
in half along an axis-aligned plane 
&#8226; A space partition: The nodes do not overlap! 
&#8211; This is in contrast to BVHs 
63 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Return the Correct Intersection 
&#8226; If tstart  &gt;  tmin  &#8594; closest intersection at tstart 
&#8226; Else                      &#8594; closest intersection at tend 
&#8211; Eye is inside box 
y=Y2 
y=Y1 
x=X1 x=X2 tend 
tstart 
36 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; Find bounding box of objects/primitives 
&#8226; Split objects/primitives into two, compute child BVs 
&#8226; Recurse, build a binary tree Bounding Volume Hierarchy (BVH) 
51 </text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Stack Studios, Rendered using Maxwell  
Questions? 
92 &#169; Next Limit S.L. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>Where to Split Objects? 
&#8226; At midpoint of current volume    OR 
&#8226; Sort, and put half of the objects on each side    OR 
&#8226; Use modeling hierarchy 
52 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Then Intersect Intervals 
&#8226; Update t start &amp; tend for each subsequent dimension 
&#8211;If t1 &gt; tstart,  tstart = t1 
&#8211;If t2 &lt; tend,    tend    = t2 
y=Y2 
y=Y1 
x=X1 x=X2 
tend tstart :-) 
33 </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Bounding Box of a Sphere 
r 
(xmin, ymin, zmin) (xmax, ymax, zmax) 
(x, y, z ) 
= (x-r,  y-r,  z-r ) = (x+r,  y+r,  z+r ) 
40 </text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>Pros and Cons of Kd trees 
&#8226; Pros 
&#8211; Simple code 
&#8211; Efficient traversal 
&#8211; Can conform to data 
 
&#8226; Cons  
&#8211; costly construction, not great if you work with moving 
objects 
90 </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>Bounding Volume Hierarchies 
&#8226; If ray hits bounding volume, 
must we test all primitives inside it? 
&#8211; Lots of work, think of a 1M-triangle mesh 
&#8226; You guessed it already, we&#8217;ll split the primitives in 
groups and build recursive bounding volumes 
&#8211; Like collision detection, 
remember? 
bounding 
sphere 
hierarchy 
46 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Reducing Total Computation 
&#8226; Pairs of planes have the same normal 
&#8226; Normals have only one non-zero component 
&#8226; Do computations one dimension at a time 
y=Y2 
y=Y1 
x=X1 x=X2 
Ro Rd 
17 </text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>Hard-core efficiency considerations 
&#8226; See e.g. Ingo Wald&#8217;s PhD thesis  
&#8211;   
&#8226; Calculation 
&#8211; Optimized barycentric ray-triangle intersection 
&#8226; Memory 
&#8211; Make kd-tree node as small as possible 
(dirty bit packing, make it 8 bytes) 
&#8226; Parallelism 
&#8211; SIMD extensions, trace 4 rays at a time, mask results 
where they disagree 
89 http://www.sci.utah.edu/~wald/PhD/</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Conservative Bounding Regions 
14 &#8226; Desiderata 
&#8211; Tight &#8594; 
avoid false positives 
&#8211; Fast to intersect </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Particle Systems and ODE Solvers II, Mass Spring Modeling (PDF - 1.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec08/</lecture_pdf_url>
      <lectureno>08</lectureno>
      <slides>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Further reading 
&#8211;Stiff systems 
&#8211;Explicit vs. implicit solvers 
&#8211; Again, consult the 2001 course notes ! 
54 Questions? </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Pi Pj  Rest length L0 F 
L0 - ||Pj-Pi|| Spring Force &#8211; Hooke&#8217;s Law  </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226; Springs between mass n &amp; n+2 with rest length 2L 0 
&#8211; Wants to keep particles aligned 
32 Hair - Alternative Structural Forces 
Questions? </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; Moves along tangent; can leave solution curve, e.g.: 
 
 
&#8226; Exact solution is circle: 
 
 
&#8226; Euler spirals outward 
no matter how small h is 
&#8211; will just diverge more slowly 
7 Euler&#8217;s Method: Inaccurate 
Questions? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226; Limited step size! 
&#8211; When 
     things are fine, the solution decays 
&#8211; When  
 we get oscillation 
&#8211; When                                                         things explode 
 11 Euler&#8217;s Method: Not Always Stable 
Wikipedia user Berland 
This image is in the public domain. Source: Wikimedia</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Particle System Class 
  class ParticleSystem 
  { 
        virtual int getDimension() 
        virtual setDimension(int n) 
        virtual float* getStatePositions() 
        virtual setStatePositions(float* positions) 
        virtual float* getStateVelocities() 
        virtual setStateVelocities(float* velocities) 
        virtual float* getForces(float* positions, float* velocities) 
                        virtual setMasses(float* masses) 
                        virtual float* getMasses() 
 
        float* m_currentState  
  } </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 
MIT EECS 6.837 Computer Graphics 
Particle Systems 
and ODE Solvers II, 
Mass-Spring Modeling 
With slides from Jaakko Lehtinen 
and others 
Picture: A. Selle et al. 
MIT EECS 6.837 &#8211; Matusik  Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; Constrain length to increase by less than 10% 
&#8211; A little hacky 
43 One Solution  
Simple mass-spring system 
 Improved solution  
(see Provot Graphics Interface 1995) 
http://citeseer.ist.psu.edu/provot96deformation.html &#169; Xavier Provot . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226;Robert Bridson, Ronald Fedkiw &amp; John Anderson: 
Robust Treatment of Collisions, Contact  
and Friction for Cloth Animation
 
SIGGRAPH 2002 
&#8226;Selle. A, Su, J., Irving, G. and Fedkiw, R., "Robust 
High-Resolution Cloth Using Parallelism, History-
Based Collisions, and Accurate Friction," IEEE 
TVCG 15, 339-350 (2009).  
&#8226;Selle, A., Lentine, M. and Fedkiw, R., "A Mass 
Spring Model for Hair Simulation", SIGGRAPH 
2008, ACM TOG 27, 64.1-64.11 (2008).  
61 Cool Cloth/Hair Demos </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; This translates to... 
 
 
 
&#8226; and we get 
 
&#8226; This is the midpoint method 
&#8211; Analysis omitted again, 
but it&#8217;s not very complicated, see here. 
18 2nd Order Methods Cont&#8217;d 
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Euler&#8217;s Method: Not Always Stable 
&#8226; &#8220;Test equation&#8221; 
 </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; You bet! 
&#8226; You will implement Runge-Kutta  for assignment 3 
 
&#8226; Again, see Witkin, Baraff, Kass: Physically-based 
Modeling Course Notes, SIGGRAPH 2001  
 
 
 
&#8226; See eg 
http://www.youtube.com/watch?v=HbE3L5CIdQg   
21 Can We Do Even Better? Questions? </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; Gravity G 
&#8226; Friction 
&#8226; Wind, etc. 
36 External Forces 
Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Euler&#8217;s Method: Not Always Stable 
Wikipedia user Berland 
&#8226; Limited step size! 
&#8211; When 
     things are fine, the solution decays 
&#8211; When  
 we get oscillation 
&#8211; When                                                         things explode 
 
This image is in the public domain. Source: Wikimedia
If k is big, 
h must be small! </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; State of system (phase) : velocity &amp; position 
&#8211; similar to our X=(x v) to get 1st order 
55 Mass on a Spring, Phase Space 
Wikipedia user Mazemaster 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 
That&#8217;s All for Today! 
Bungie / ign.com 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 
Why Stiff Springs Are Difficult 
x1 x2 height=magnitude 
of spring force K=1 
x2 
x1 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; Each particle is linked to two particles (except ends) 
&#8226; Come up with forces that try to keep the distance 
between particles constant 
23 How Would You Simulate a String? </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; What happens if we discretize our cloth more finely?  
&#8226; Do we get the same behavior?  
&#8226; Usually not! It takes a lot of effort to design a 
scheme that is mostly oblivious to the discretization. 
44 The Discretization Problem </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; You bet! 
&#8226; You will implement Runge-Kutta  for assignment 3 
 
&#8226; Again, see Witkin, Baraff, Kass: Physically-based 
Modeling Course Notes, SIGGRAPH 2001  
 
 
 
&#8226; See eg 
http://www.youtube.com/watch?v=HbE3L5CIdQg   
20 Can We Do Even Better? </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Reduction to 1st Order 
2 unknowns ( x, v) 
instead of just x 
or 
&#8226; Point mass: 2nd order ODE 
 
 
 
 
&#8226; Corresponds to system of first 
order ODEs This image is in the public domain.
Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226; Midpoint : 
&#8211; &#189; Euler step 
&#8211; evaluate fm 
&#8211; full step using fm 
&#8226; Trapezoid: 
&#8211; Euler step (a) 
&#8211; evaluate f1 
&#8211; full step using f1 (b)  
&#8211; average (a) and (b) 
&#8226; Not exactly same result, 
but same order of accuracy 
19 Comparison 
fm f1 a 
b 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; 1D example, with two particles constrained to move 
along the x axis only, rest length L 0 = 1 
&#8226; Phase space is 4D: ( x1, v1, x2, v2) 
&#8211; But spring force only depends on x1, x2 and L 0. 
48 Why Stiff Springs Are Difficult 
x1 x2 
v1 v2 
L0 = 1 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; Expand exact solution X(t) 
 
 
&#8226; Euler&#8217;s method approximates: 
 
 
 
 
&#8226; First-order method: Accuracy varies with h 
&#8226; To get 100x better accuracy need 100x more steps 
14 Analysis: Taylor Series 
 Questions? </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; Linear set of particles 
&#8226; Length-preserving structural  springs like before 
&#8226;Deformation  forces proportional to the angle 
between segments 
&#8226;External forces 
30 Hair 
&#61672; </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Why Stiff Springs Are Difficult 
x1 x2 K=6 
x2 
x1 
height=magnitude 
of spring force 
Forces grow 
really big! </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Beyond pointlike objects: 
strings, cloth, hair, etc. 
&#8226; Interaction between particles 
&#8211; Create a network of spring 
forces that link pairs of particles 
 
&#8226; First, slightly hacky version of cloth simulation 
&#8226; Then, some motivation/intuition for implicit 
integration (NEXT LECTURE) 
22 Mass-Spring Modeling 
Michael Kass 
&#169; ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; Guess how well Euler will do... 
always diverge 
56 Mass on a Spring, Phase Space 
Wikipedia user Mazemaster 
This image is in the public domain. Source: Wikimedia Commons.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; Moves along tangent; can leave solution curve, e.g.: 
 
 
&#8226; Exact solution is circle: 
 
 
&#8226; Euler spirals outward 
no matter how small h is 
&#8211; will just diverge more slowly 
6 Euler&#8217;s Method: Inaccurate 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; What happens if we discretize our cloth more finely?  
&#8226; Do we get the same behavior?  
&#8226; Usually not! It takes a lot of effort to design a 
scheme that is mostly oblivious to the discretization. 
45 The Discretization Problem 
Questions? </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>69 Mid-Point Implementation 
  class MidPoint : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   midPositions = positions + 0.5*h*velocities 
   midVelocities = velocities  + 0.5*h*accelerations 
   midForces = ps-&gt;getForces(midPositions, midVelocities) 
   midAccelerations = midForces / masses 
   newPositions = positions + 0.5*h* midVelocities 
   newVelocities = velocities  + 0.5*h* midAccelerations      
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  } 
 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; How can we compute the external 
contact force? 
&#8211; Inverse dynamics! 
&#8211; Sum all other forces applied to point 
&#8211; Take negative 
&#8226; Do we really need to 
compute this force? 
&#8211; Not really, just ignore the other forces 
applied to this point! 
41 Contact Forces 
Questions? </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; Force in the direction of the spring and proportional 
to difference with rest length L0. 
 
 
&#8226; K is the stiffness of the spring 
&#8211; When K gets bigger, the spring really 
wants to keep its rest length 
27 Spring Force &#8211; Hooke&#8217;s Law  
Pi Pj L0 F This is the force on P j. 
Remember Newton:   
Pi experiences force of 
equal magnitude but 
opposite direction. </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 Forward Euler Implementation 
  class ForwardEuler : TimeStepper 
  { 
          void takeStep(ParticleSystem* ps, float h) 
           { 
   velocities = ps-&gt;getStateVelocities() 
   positions = ps-&gt;getStatePositions() 
   forces = ps-&gt;getForces(positions, velocities) 
   masses = ps-&gt;getMasses() 
   accelerations = forces / masses 
   newPositions = positions + h*velocities 
   newVelocities = velocities  + h*accelerations 
   ps-&gt;setStatePositions(newPositions) 
   ps-&gt;setStateVelocities(newVelocities) 
           }  
  } 
 </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text></text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; It pays off to abstract (as usual) 
&#8211; It&#8217;s easy to design your &#8220;Particle System&#8221; and &#8220;Time 
Stepper&#8221; to be unaware of each other 
 
&#8226; Basic idea 
&#8211; &#8220;Particle system&#8221; and &#8220;Time Stepper&#8221; communicate via 
floating-point vectors X and a function that computes 
f(X,t) 
&#8226; &#8220;Time Stepper&#8221; does not need to know anything else! 
64 Implementation Notes </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Euler&#8217;s Method: Not Always Stable 
&#8226; &#8220;Test equation&#8221; 
 
&#8226; Exact solution is a decaying exponential: 
 
 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 
Why Stiff Springs Are Difficult 
x1 x2 K=11 
x2 
x1 x2 
x1 Forces grow 
really big! The &#8220;admissible region&#8221; 
shrinks towards the line 
x1-x2=1 as K grows </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; Springs link the particles 
&#8226; Springs try to keep their rest lengths 
and preserve the length of the string 
&#8226; Not exactly preserved though, and we get oscillation 
&#8211; Rubber band approximation 
28 How Would You Simulate a String? </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Euler, Visually 
X(t) 
f(X,t) h f(X,t) 
X(t+h) 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226; In our mass-spring cloth, we have &#8220;encouraged&#8221; 
length preservation using springs that want to have a 
given length (unfortunately, they can refuse offer ;-) ) 
&#8226; Constrained dynamic simulation: 
force it to be constant!
 
&#8226; How it works &#8211; more in 6.839  
&#8211; Start with constraint equation 
&#8226; E.g., ( x2-x1)-1 
= 0 in the previous 1D example 
&#8211; Derive extra forces that will exactly enforce constraint 
&#8226; This means projecting  the external forces (like gravity) onto 
the &#8220;subspace&#8221; of phase space where constraints are satisfied 
&#8226; Fancy name for this: &#8220;Lagrange multipliers&#8221; 
&#8211; Again, see the SIGGRAPH 2001 Course Notes 
53 Constrained Dynamics 
&#169; David Baraff and Andrew Witkin. All
rights reserved. This content is excluded
from our Creative Commons license. For
more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>71 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new MidPoint() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render  
 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; Problem: f varies along our Euler step 
&#8226; Idea 1: look at f at the arrival of the step and 
compensate for variation 
15 Can We Do Better? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 
Why Stiff Springs Are Difficult 
x1 x2 K=11 
x2 
x1 x2 
x1 Forces grow 
really big! The &#8220;admissible region&#8221; 
shrinks towards the line 
x1-x2=1 as K grows </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 Cloth Simulation 
&#8226; Then, the all trick is to set 
the stiffness of all springs 
to get realistic motion! 
 
&#8226; Remember that forces 
depend on other particles 
(coupled system) 
&#8226; But it is sparse  
(only near neighbors) 
&#8211; This is in contrast to e.g. 
the N-body problem. Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&#8226; Expand exact solution X(t) 
 
 
&#8226; Euler&#8217;s method approximates: 
 
 
 
 
&#8226; First-order method: Accuracy varies with h 
&#8226; To get 100x better accuracy need 100x more steps 
13 Analysis: Taylor Series 
</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Springs link the particles 
&#8226; Springs try to keep their rest lengths 
and preserve the length of the string 
&#8226; Not exactly preserved though, and we get oscillation 
&#8211; Rubber band approximation 
29 How Would You Simulate a String? 
Questions? </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Force in the direction of the spring and proportional 
to difference with rest length L0. 
 
 
&#8226; K is the stiffness of the spring 
&#8211; When K gets bigger, the spring really 
wants to keep its rest length 
26 
Pi Pj L0 F Spring Force &#8211; Hooke&#8217;s Law  </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; How can we compute the external 
contact force? 
&#8211; Inverse dynamics! 
&#8211; Sum all other forces applied to point 
&#8211; Take negative 
&#8226; Do we really need to 
compute this force? 
&#8211; Not really, just ignore the other forces 
applied to this point! 
40 Contact Forces </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; Springs between mass n &amp; n+2 with rest length 2L 0 
&#8211; Wants to keep particles aligned 
31 Hair - Alternative Structural Forces </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226;x&#8217;=-kx is a true 1st order ODE 
&#8226; Energy gets dissipated 
 
&#8226; In contrast, a spring is a second order system 
&#8226; Energy does not get dissipated 
&#8211; It is just transferred between potential and kinetic energy 
&#8211; Unless you add damping 
&#8226; This is why people always add damping forces and 
results look too viscous 
57 Difference with x&#8217;=-kx </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; x&#8217;=-kx is a true 1st order ODE 
&#8226; Energy gets dissipated 
 
&#8226; In contrast, a spring is a second order system 
&#8226; Energy does not get dissipated 
&#8211; It is just transferred between potential and kinetic energy 
&#8211; Unless you add damping 
&#8226; This is why people always add damping forces and 
results look too viscous 
58 Difference with x&#8217;=-kx Questions? </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4 ODE: Path Through a Vector Field 
&#8220;When we are at 
state X at time t, 
where will X be after 
an infinitely small 
time interval d t ?&#8221; 
&#8226;X(t): path in multidimensional phase space 
 
 
 
 
 
 
 
&#8226;f=d/dt X is a vector that sits at each point in phase 
space, pointing the direction.   Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Time Stepper Class 
  class TimeStepper 
  { 
        virtual takeStep(ParticleSystem* ps, float h) 
  } 
 
 </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Particle System Simulation 
   
  ps = new MassSpringSystem(particleCount, masses, springs, externalForces) 
  stepper = new ForwardEuler() 
  time = 0 
  while time &lt; 1000 
        stepper-&gt;takeStep(ps, 0.0001) 
        time = time + 0.0001 
        // render  
 </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226; This translates to... 
 
 
 
&#8226; and we get 
 
&#8226; This is the trapezoid method 
&#8211; Analysis omitted (see 6.839) 
&#8226; Note: What we mean by &#8220;2nd order&#8221; is that the error 
goes down with h2 , not h &#8211; the equation is still 1st 
order! 16 2nd Order Methods 
</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226;h &gt; 1/k: oscillate. h &gt; 2/k: explode! 
47 Euler Has a Speed Limit! 
From the SIGGRAPH PBM notes &#8217; 
Image removed due to copyright restrictions -- please see slide 5 on "Implicit Methods" from
Online Siggraph '97 Course notes, available at http://www.cs.cmu.edu/~baraff/sigcourse/.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38 Forces: Structural vs. Deformation 
&#8226; Structural forces are here 
just to enforce a constraint 
&#8226; Ideally, the constraint 
would be enforced strictly 
&#8211; at least a lot more than we 
can afford 
&#8226; We&#8217;ll see that this is the 
root of a lot of problems 
&#8226; In contrast, deformation 
forces actually correspond 
to physical forces Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Euler&#8217;s Method: Not Always Stable 
&#8226; &#8220;Test equation&#8221; 
 
&#8226; Exact solution is a decaying exponential: 
 
 
&#8226; Let&#8217;s apply Euler&#8217;s method: </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>&#8226; Hanging curtain: 
&#8211; 2 contact points stay fixed 
&#8226; What does it mean? 
&#8211; Sum of the forces is zero 
&#8226; How so? 
&#8211; Because those point undergo an  
external force that balances the system 
&#8226; What is the force at the contact? 
&#8211; Depends on all other forces in the system 
&#8211; Gravity, wind, etc.  
39 Contact Forces 
Reaction force 
Forces from  
other particles,  
gravity </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text> 
 
&#8226; Given a function f(X,t) compute X(t) 
&#8226; Typically, initial value problems : 
&#8211; Given values X(t0)=X0 
&#8211; Find values X(t) for t &gt; t0 
 
&#8226; We can use lots of standard tools 
2 ODEs and Numerical Integration 
</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226;Structural  forces 
&#8211; Try to enforce invariant 
properties of the system 
&#8226; E.g. force the distance 
between two particles 
to be constant 
&#8211; Ideally, these should be constraints , not forces 
&#8226;Internal deformation  forces 
&#8211; E.g. a string deforms, a spring board tries to remain flat 
&#8226;External forces 
&#8211; Gravity, etc.  
34 Cloth &#8211; Three Types of Forces 
&#169; ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; Excessive rubbery deformation:  
the strings are not stiff enough 
42 Example 
Initial position After 200 iterations 
&#169; Xavier Provot . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 Questions? 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60 Collisions Robert Bridson, Ronald Fedkiw &amp; John Anderson  
Robust Treatment of Collisions, Contact  
and Friction for Cloth Animation  
SIGGRAPH 2002 
&#8226; Cloth has many points  
of contact 
&#8226; Need efficient collision 
detection and 
stable treatment 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Springs for Cloth 
&#8226; Network of masses and 
springs 
&#8226;Structural  springs:  
&#8211; link (i j) and (i+1, j);  
and (i, j) and (i, j +1) 
&#8226;Deformation:  
&#8211; Shear springs 
&#8226; (i j) and (i+1, j+1)  
&#8211; Flexion springs 
&#8226;  (i,j) and (i+2,j); 
(i,j) and (i,j+2) 
&#8226; See Provot&#8217;s Graphics 
Interface &#8217;95 paper  for 
details Provot 95 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; We use springs while we really mean constraint 
&#8211; Spring should be super stiff, which requires tiny &#61508; t 
&#8211; Remember x&#8217;=-kx system and Euler speed limit! 
&#8226; The story extends to N particles and springs (unfortunately) 
 
&#8226; Many numerical solutions 
&#8211; Reduce &#61508;t (well, not a great solution) 
&#8211; Actually use constraints (see 6.839) 
&#8211; Implicit integration scheme (more next Thursday) 
46 The Stiffness Issue </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; A cloth has many points of contact 
&#8226; Requires 
&#8211; Efficient collision detection 
&#8211; Efficient numerical 
treatment (stability) 
59 The Collision Problem 
Image from Bridson et al.   
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226; Problem: f has varied along our Euler step 
&#8226; Idea 2: look at f after a smaller step, use that value 
for a full step from initial position 
17 Can We Do Better? 
Image by MIT OpenCourseWare.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Basic idea 
&#8211; &#8220;Particle System&#8221; tells &#8220;Time Stepper&#8221; how many 
dimensions (N) the phase space has 
&#8211; &#8220;Particle System&#8221; has a function to write its state to an N-
vector of floating point numbers (and read state from it) 
&#8211; &#8220;Particle System&#8221; has a function that evaluates f( X,t), 
given a state vector X and time t 
 
&#8211; &#8220;Time Stepper&#8221; takes a &#8220;Particle System&#8221; as input and 
advances its state 
65 Implementation Notes </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Mass-Spring Cloth 
Michael Kass 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Springs 
Image courtesy of Jean-Jacques MILAN on Wikimedia Commons. License: CC- BY-SA. This content is excluded
from our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Global Illumination and Monte Carlo (PDF - 2.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec18/</lecture_pdf_url>
      <lectureno>18</lectureno>
      <slides>
        <slide>
          <slideno>73</slideno>
          <text>Importance Sampling Math 
 
 
 
 
&#8226; Like before, but now {x i} are not uniform but drawn 
according to a probability distribution p 
&#8211; Uniform case reduces to this with p(x) = const. 
&#8226; The problem is designing ps that are easy to sample 
from and mimic the behavior of f 
74 </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>Monte Carlo Integration 
&#8226; S is the integration domain 
&#8211; Vol(S) is the volume (measure) of S 
&#8226;{xi} are independent uniform random points in S 
60 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>3 Today 
&#8226; Global Illumination 
&#8211; Rendering Equation 
&#8211; Path tracing 
&#8226; Monte Carlo integration 
&#8226; Better sampling 
&#8211; importance 
&#8211; stratification 
3 &#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>Global Illumination 
&#8226; So far, we only used the BRDF for point lights 
&#8211; We just summed over all the point light sources 
&#8226; BRDF also describes how indirect illumination 
reflects off surfaces 
&#8211; Turns summation into integral over hemisphere 
&#8211; As if every direction had a light source 
7 </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Error/noise Results in Variance 
&#8226; We use random rays 
&#8211; Run the algorithm again &#61664; get different image 
&#8226; What is the noise/variance/standard deviation? 
&#8211; And what&#8217;s really going on anyway? 
56 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Smarter Sampling 
Sample a non-uniform probability 
Called &#8220;importance sampling&#8221; 
Intuitive justification: Sample more in places where there are 
likely to be larger contributions to the integral 
69 </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>Global Illumination (with Indirect) 
6 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; Rendering glossy reflections 
&#8226; Random reflection rays around mirror direction 
&#8211; 256 samples per pixel 
Motivational Eye Candy 
55 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Demo  
&#8226;http://madebyevan.com/webgl-path-tracing/  
31 Image removed due to copyright restrictions.  Please see the above link for further details.  </text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>Monte Carlo Computation of &#61552; 
&#8226; Take a square 
&#8226; Take a random point (x,y) in the square 
&#8226; Test if it is inside the &#188; disc (x2+y2 &lt; 1) 
&#8226; The probability is &#61552; /4  
x y Integral of the function that 
is one inside the circle, zero 
outside 
62 </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>Importance of Sampling the Light 
Without explicit  
light sampling With explicit  
light sampling 
1 path 
per pixel 
4 paths 
per pixel &#10004; 
&#10004; 
29 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>The Reflectance Equation 
 
 
 
&#8226; Where does L in come from? 
&#8211; It is the light reflected towards x from the surface point in 
direction l ==&gt; must compute similar integral there! 
&#8226; Recursive! 
 
x 
10 </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Irradiance Caching 
&#8226; Indirect illumination is smooth 
==&gt; Sample sparsely, interpolate nearby values 
39 </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>Questions? 
14 </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>Photon Map Results 
48 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>That&#8217;s All for today 
Image: Fournier and 
Reeves, SIGGRAPH 86 83 Image removed due to copyright restrictions -- please Fig. 13 in  Fournier A. and W.T. Reeves. "A Simple Model of Ocean Waves."
SI
GGRAPH '86 Proceedings of the 13th Annual Conference on Computer Graphics and Interactive Techniques; Pages 75-84.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>For more demo/experimentation 
&#8226;http://www.mitsuba-renderer.org/ 
&#8226;http://www.pbrt.org/  
&#8226;http://www.luxrender.net/en_GB/index  
32 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Reflectance Equation, Visually 
outgoing light to 
direction v incident light 
from direction 
omega the BRDF cosine term 
v 
Sum (integrate) 
over every 
direction on the 
hemisphere, 
modulate incident 
illumination by 
BRDF Lin Lin 
Lin 
Lin 
8 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Questions? 
&#8226; Image from the ARNOLD Renderer by Marcos Fajardo 
80 Images removed due to copyright restrictions -- Please see
http://www.3dluvr.com/marcosss/morearni/ for further details.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8220;Monte-Carlo Ray Tracing&#8221; 
&#8226; Cast a ray from the eye through each pixel 
&#8226; Cast random rays from the visible point  
&#8226; Recurse 
20 </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Monte Carlo Path Tracing 
&#8226; Trace only one secondary ray per recursion 
&#8211; Otherwise number of rays explodes! 
&#8226; But send many primary rays per pixel (antialiasing) 
Again, trace 
shadow rays 
from each 
intersection 
24 </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>Ray Tracing 
&#8226; Cast a ray from the eye through each pixel  
&#8226; Trace secondary rays (shadow, reflection, refraction) 
17 </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Monte Carlo Path Tracing 
&#8226; Trace only one secondary ray per recursion 
&#8211; Otherwise number of rays explodes! 
&#8226; But send many primary rays per pixel (antialiasing) 
23 </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>Photon Mapping - Rendering 
&#8226; Cast primary rays 
&#8226; For secondary rays 
&#8211; reconstruct irradiance using adjacent stored photon 
&#8211; Take the k closest photons 
&#8226; Combine with irradiance caching and a number of other techniques 
Shooting one bounce of 
secondary rays and 
using the density 
approximation at those 
hit points is called final 
gathering . 
47 </text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>Path Tracing is costly 
&#8226; Needs tons of rays per pixel! 
34 </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>What Else Can We Integrate? 
&#8226; Pixel: antialiasing 
&#8226; Light sources: Soft shadows 
&#8226; Lens: Depth of field 
&#8226; Time: Motion blur 
&#8226; BRDF: glossy reflection 
&#8226; (Hemisphere: indirect lighting) 
52 &#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.&#169; source unknown. All rights reserved.
This content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /. Courtesy of Henrik Wann Jensen.
Used with permission.
&#169; ACM. All rights reserved. This content is
excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Direct Illumination 
5 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Why Not Use Simpson Integration? 
&#8226; You&#8217;re right, Monte Carlo is not very efficient for 
computing &#61552; 
&#8226; When is it useful? 
&#8211; High dimensions: Convergence is independent of 
dimension! 
&#8211; For d dimensions, Simpson requires Nd domains (!!!) 
&#8211; Similar explosion for other quadratures (Gaussian, etc.) 
64 </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>How To Render Global 
Illumination? 
Lehtinen  et al. 2008  
15 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; 100 paths/pixel 
Path Tracing Results: Glossy Scene 
Henrik Wann Jensen 
28 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Rendering glossy reflections 
&#8226; Random reflection rays around mirror direction 
&#8211; 1 sample per pixel Motivational Eye Candy 
54 &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>Example: Glossy Reflection 
&#8226; Integral over hemisphere 
&#8226; BRDF times cosine times incoming light Slide courtesy of Jason Lawrence 
70 Image removed due to copyright restrictions &#8211; please see Jason Lawrence&#8217;s slide 9 -12 in  the talk slides on &#8220;Efficient BRDF
Importance Sampling Using a Factored Representation,&#8221; available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Stratified Sampling 
&#8226; With uniform sampling, we can get unlucky 
&#8211; E.g. all samples clump in a corner 
&#8211; If we don&#8217;t know anything of the integrand, 
we want a relatively uniform sampling 
&#8226; Not regular, though, because of aliasing! 
 
&#8226; To prevent clumping, subdivide domain &#61527;  
into non-overlapping regions &#61527;i 
&#8211; Each region is called a stratum 
&#8226; Take one random sample per &#61527;i 
77 </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>More Subsurface Scattering 
Photograph Rendering Weyrich et al. 2006  
50 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Monte Carlo Path Tracing 
http://www.youtube.com/watch?v=mYMkAnm -PWw 75 Video removed due to copyright restrictions &#8211; please see the link below for further details. </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
72 Image removed due to copyright restrictions &#8211; please see Jason Lawrence&#8217;s slide 9 -12 in  the talk slides on &#8220;Efficient BRDF
Importance Sampling Using a Factored Representation,&#8221; available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Today 
&#8226; Lots of randomness! 
Dunbar &amp; Humphreys 2 </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
73 Image removed due to copyright restrictions &#8211; please see Jason Lawrence&#8217;s slide 9 -12 in  the talk slides on &#8220;Efficient BRDF
Importance Sampling Using a Factored Representation,&#8221; available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Disadvantages of MC 
&#8226; Noisy 
&#8226; Slow convergence 
&#8226; Good implementation is hard 
&#8211; Debugging code 
&#8211; Debugging math 
&#8211; Choosing appropriate techniques 
66 </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; 10 paths/pixel 
Path Tracing Results 
Henrik Wann Jensen 
26 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Global Illumination and Monte Carlo 
MIT EECS 6.837 Computer Graphics 
Wojciech Matusik 
with many slides from Fredo Durand and Jaakko Lehtinen 
1 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Monte Carlo Path Tracing 
&#8226; We shoot one path from the eye at a time 
&#8211; Connect every surface point on the way to the light by a 
shadow ray 
&#8211; We are randomly sampling the space of all possible light 
paths between the source and the camera 
25 </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Integration 
&#8226; You know trapezoid, Simpson&#8217;s rule, etc. 
58 </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Stratified Sampling Example 
&#8226; When supersampling, instead of taking KxK regular 
sub-pixel samples, do random jittering within each 
KxK sub-pixel 
78 </text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Stratified Sampling Analysis 
&#8226; Cheap and effective 
&#8226; But mostly for low-dimensional domains 
&#8211; Again, subdivision of N-D needs Nd domains like 
trapezoid, Simpson&#8217;s, etc.! 
 
&#8226; With very high dimensions, Monte Carlo is pretty 
much the only choice 
79 </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8220;Monte-Carlo Ray Tracing&#8221; 
&#8226; Cast a ray from the eye through each pixel 
&#8226; Cast random rays from the hit point to evaluate 
hemispherical integral using random sampling 
18 </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>Irradiance Caching 
&#8226; Indirect illumination is smooth 
38 </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>Photon Mapping 
&#8226; Preprocess: cast rays from light sources, let them 
bounce around randomly in the scene 
&#8226; Store &#8220;photons&#8221; 
44 </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>Irradiance Caching 
&#8226; Store the indirect illumination 
&#8226; Interpolate existing cached values 
&#8226; But do full calculation for direct lighting 
40 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Monte Carlo Integration 
&#8226; Monte Carlo integration: use random samples and 
compute average 
&#8211; We don&#8217;t keep track of spacing between samples 
&#8211; But we kind of hope it will be 1/N on average 
59 </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>That Was Just the Beginning 
&#8226; Tons and tons of other Monte Carlo techniques 
&#8211; Bidirectional Path Tracing 
&#8226; Shoot random paths not just from camera but also light, connect 
the path vertices by shadow rays 
&#8211; Metropolis Light Transport 
&#8226; And Finite Element Methods 
&#8211; Use basis functions instead of random sampling 
&#8211; Radiosity (with hierarchies &amp; wavelets) 
&#8211;Precomputed Radiance Transfer  
 
&#8226; This would warrant a class of its own! 
51 </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> 
 
 
&#8226; Where does L in come from? 
&#8211; It is the light reflected towards x from the surface point in 
direction l ==&gt; must compute similar integral there! 
&#8226; Recursive! 
&#8211; AND if x happens 
to be a light source, 
we add its contribution 
directly 
 The Rendering Equation 
x 
11 </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>The Rendering Equation 
&#8226; Analytic solution is usually impossible 
&#8226; Lots of ways to solve it approximately 
&#8226; Monte Carlo techniques use random samples for 
evaluating the integrals 
&#8211; We&#8217;ll look at some simple method in a bit... 
&#8226; Finite element methods discretize the solution using 
basis functions (again!) 
&#8211; Radiosity, wavelets, precomputed radiance transfer, etc. 
13 </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>Radiance  by Greg Ward 
&#8226; The inventor of irradiance caching 
&#8226;http://radsite.lbl.gov/radiance/  
42 Image removed due to copyright restrictions.  Please see above link for further details. </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Hmmh... 
&#8226; Are uniform samples the best we can do? 
68 </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>Questions? 
Traditional importance function 
 Better importance by Lawrence et al.  1200 Samples/Pixel 
76 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>Questions? 
&#8226; Images by Veach and Guibas, SIGGRAPH 95  
Na&#239;ve sampling strategy Optimal sampling strategy 
67 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>Irradiance Caching 
&#8226; Indirect illumination is smooth 
37 </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>Domains of Integration 
&#8226; Pixel, lens (Euclidean 2D domain) 
&#8211; Antialiasing filters, depth of field 
&#8226; Time (1D) 
&#8211; Motion blur 
&#8226; Hemisphere 
&#8211; Indirect lighting 
&#8226; Light source 
&#8211; Soft shadows 
Famous motion blur image 
from Cook et al. 1984  
53 &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>Photon Mapping 
&#8226; Preprocess: cast rays from light sources 
&#8226; Store photons (position + light power + incoming direction) 
45 </text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Questions? 
&#8226; Vintage path tracing by Kajiya 
33 &#169; Jim Kajiya. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Integration 
&#8226; Compute integral of arbitrary function 
&#8211; e.g. integral over area light source, over hemisphere, etc. 
&#8226; Continuous problem &#61664; we need to discretize 
&#8211; Analytic integration never works because of visibility and other 
nasty details 
57 </text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>The Reflectance Equation 
 
 
 
&#8226; Where does L in come from? 
x 
9 </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Sampling a BRDF Slide courtesy of Jason Lawrence 
71 Image removed due to copyright restrictions &#8211; please see Jason Lawrence&#8217;s slide 9 -12 in  the talk slides on &#8220;Efficient BRDF
Importance Sampling Using a Factored Representation,&#8221; available at http://www.cs.virginia.edu/~jdl/ .</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Monte Carlo Integration 
&#8226; S is the integration domain 
&#8211; Vol(S) is the volume (measure) of S 
&#8226;{xi} are independent uniform random points in S 
&#8226; The integral is the average of f times the volume of S 
&#8226; Variance is proportional to 1/N 
&#8211; Avg. error is proportional 1/sqrt(N) 
&#8211; To halve error, need 4x samples 
61 </text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>References 
82 Images of the following book covers have been removed due to copyright restrictions:
-Advanced Global Illumination  by Philip Dutre, Philippe Bekaert, and Kavita Bala
-Realistic Ray Tracing  by Peter Shirley and R.  K. Morley
-Realistic Image Synthesis Using Photon Mapping  by Henrik Wann Jensen
Please check the books for further details.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Questions? 
Image: Pure 
43 Image of Y chair designed by H.J. Wegner has been removed due to copyright restrictions.  
Please see http://tora_2097.cgsociety.org/portfolio/project-detail/786738/  for further details.   </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8220;Monte-Carlo Ray Tracing&#8221; 
&#8226; Systematically sample light sources at each hit 
&#8211; Don&#8217;t just wait the rays will hit it by chance 
21 </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>Irradiance Caching 
&#8226; Yellow dots:  
indirect diffuse sample points 
The irradiance cache tries to 
adapt sampling density to 
expected frequency content of 
the indirect illumination (denser 
sampling near geometry) 
41 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>Ray Casting 
&#8226; Cast a ray from the eye through each pixel  
16 </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226; The rendering equation describes the appearance of 
the scene, including direct and indirect illumination 
&#8211; An &#8220;integral equation&#8221;, the unknown solution function L 
is both on the LHS and on the RHS inside the integral 
&#8226; Must either discretize or use Monte Carlo integration 
&#8211; Originally described by Kajiya and Immel et al. in 1986 
&#8211; More on 6.839 
&#8226; Also, see book references towards the end The Rendering Equation 
12 </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>Monte Carlo Computation of &#61552; 
&#8226; The probability is &#61552; /4  
&#8226; Count the inside ratio n = # inside / total # trials 
&#8226;  &#61552; &#61627; n * 4 
&#8226; The error depends on the number or trials 
Demo 
def piMC(n):     
   success = 0     
   for i in range(n):                       x=random.random()        
 y=random.random()         
 if x*x+y*y&lt;1: success = success+1         return 
4.0*float(success )/float(n) 
63 </text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>Advantages of MC Integration 
&#8226; Few restrictions on the integrand 
&#8211; Doesn&#8217;t need to be continuous, smooth, ... 
&#8211; Only need to be able to evaluate at a point 
&#8226; Extends to high-dimensional problems 
&#8211; Same convergence  
&#8226; Conceptually straightforward 
&#8226; Efficient for solving at just a few points 
65 </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8220;Monte-Carlo Ray Tracing&#8221; 
&#8226; Cast a ray from the eye through each pixel 
&#8226; Cast random rays from the visible point  
&#8226; Recurse 
19 </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Global Illumination 
&#8226; So far, we've seen only direct lighting (red here) 
&#8226; We also want indirect lighting 
&#8211; Full integral of all directions (multiplied by BRDF) 
&#8211; In practice, send tons of random rays 
4 </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Why Use Random Numbers? 
&#8226; Fixed random sequence 
&#8226; We see the structure in the error 
Henrik Wann Jensen 
30 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>&#8226; 6.839! 
&#8226; Eric Veach&#8217;s PhD dissertation 
http://graphics.stanford.edu/papers/veach_thesis/  
 
 
 
 
&#8226;Physically Based Rendering   
by Matt Pharr, Greg Humphreys For Further Information... 
81 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>Global Illumination (with Indirect) 
35 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Results 
Henrik Wann Jensen 
22 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; Many materials exhibit subsurface scattering  
&#8211; Light doesn&#8217;t just reflect off the surface 
&#8211; Light enters, scatters around, and exits at another point 
&#8211; Examples: Skin, marble, milk 
More Global Illumination Coolness 
Images: Jensen et al.  
49 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Note : More noise. This is not a coincidence; the integrand 
has higher variance (the BRDFs are &#8220;spikier&#8221;). &#8226; 10 paths/pixel Path Tracing Results: Glossy Scene 
Henrik Wann Jensen 
27 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>The Photon Map 
&#8226; Efficiently store photons for fast access 
&#8226; Use hierarchical spatial structure (kd-tree) 
46 </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Indirect Lighting is Mostly Smooth 
36 Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Curves Properties and Conversion, Surface Representation (PDF - 1.7MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec02/</lecture_pdf_url>
      <lectureno>02</lectureno>
      <slides>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; What if we want to transform each point on the 
curve with a linear transformation M? 
&#8211; Because everything is linear, it is the same as 
transforming only the control points Linear Transformations &amp; Cubics 
P&#8217;(t)=  
M 
= 
M 
7</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Tensor Product B&#233;zier Patches 
A bicubic B&#233;zier 
surface 
 
 
55</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>Corner Cutting 
79</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>MIT EECS 6.837, Popovi&#263; Converting between B&#233;zier &amp; B-Spline 
original 
control 
points as 
B&#233;zier 
original 
control 
points as 
B-Spline new B&#233;zier 
control 
points to 
match     
B-Spline new 
BSpline 
control 
points to 
match  
B&#233;zier 
37</text>
        </slide>
        <slide>
          <slideno>99</slideno>
          <text>&#8226; Need partial derivatives w.r.t. 
both u and v 
 
&#8211;Remember to normalize! 
&#8226; One given by tangent of profile 
curve, the other by tangent of                             
trajectory Normals for Swept Surfaces 
where M is a matrix that depends on the trajectory c s(u,v)=M(c (v))q(u) 
q c 
s s s 
100</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; You can stack the Gx, Gy, Gz matrices into a 
geometry tensor  of control points 
&#8211; I.e., Gki,j = the kth coordinate of control point Pi,j 
&#8211; A cube of numbers! 
 
 
&#8226; &#8220;Definitely not required, but nice! 
&#8211; See http://en.wikipedia.org/wiki/Multilinear_algebra Super Hardcore: Tensor Notation 
68</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; P(t) =  (1-t)&#179;  P1 
  + 3t(1-t) &#178; P2  
  + 3t&#178;(1-t)  P3 
  + t&#179;  P4  Smooth Surfaces? 
What&#8217;s the 
dimensionality of a 
curve? 1D! 
 
What about a 
surface? 
42</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226;In the previous, P is were just some curves 
&#8226;What if we make them B&#233;zier curves? Tensor Product B&#233;zier Patches 
53</text>
        </slide>
        <slide>
          <slideno>107</slideno>
          <text>Questions? 
108</text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>Subdivision + Displacement 
Original rough mesh Original mesh with  
subdivision Original mesh with 
subdivision and 
displacement 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
91</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>Cubic B-Splines 
&#8226; &#8805; 4 control points 
&#8226; Locally cubic 
&#8211; Cubics chained together, again. 
Courtesy of Seth Teller.  
25</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>6.837 &#8211; Durand  
Cubic B-Splines 
&#8226; &#8805; 4 control points 
&#8226; Locally cubic 
&#8211; Cubics chained together, again. 
&#8226; Curve is not constrained to pass through any 
control points 
29Courtesy of Seth Teller.  </text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>6.837 &#8211; Durand  Subdivision Surfaces 
&#8226; Start with polygonal mesh 
&#8226; Subdivide into larger number of polygons, 
smooth result after each subdivision 
&#8211; Lots of ways to do this. 
&#8226; The limit surface is smooth! 
&#169; IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
76</text>
        </slide>
        <slide>
          <slideno>105</slideno>
          <text>Point Set Surfaces 
Alexa et al. 2001 From Point Set Surfaces, used 
with permission from ACM, Inc 
&#169; IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
106</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>Displacement Mapping Example 
Smooth base surface Displaced Surface 
This image is in the public domain. Source: Wikimedia Commons.
74</text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>&#8226; Advantages 
&#8211; Arbitrary topology 
&#8211; Smooth at boundaries 
&#8211; Level of detail, scalable 
&#8211; Simple representation 
&#8211; Numerical stability, well-behaved meshes 
&#8211; Code simplicity 
&#8226; Little disadvantage: 
&#8211; Procedural definition 
&#8211; Not parametric 
&#8211; Tricky at special vertices 
Warren et al.  Subdivision Curves and Surfaces 
&#169; IEEE. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
89</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>Hardcore: Matrix Notation for Patches 
x coordinate of 
surface at ( u,v) 
Row vector of 
basis functions ( u) Column vector of 
basis functions ( v) 
4x4 matrix of x coordinates 
of the control points 
&#8226; Not required, 
but convenient! 
66</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>Questions? 
75</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; P(u) = (1-u)&#179;  P1 
  + 3u(1- u)&#178; P2  
  + 3u&#178;(1-u) P3 
 
 + u&#179;  P4   
 How to Build Them? Here&#8217;s an Idea 
(Note! We relabeled 
t to u) 
45</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 
47</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>B-Spline Curve Control Points 
Default B-Spline 
 B-Spline with 
derivative 
discontinuity B-Spline which passes 
through  
end points 
Repeat interior control 
point Repeat end points 
34</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; Differentiation is a linear operation 
&#8211; (f+g)&#8217;=f&#8217;+g&#8217; 
&#8211; (af)&#8217;=a f&#8217; 
&#8226; This means that the derivative of the basis is 
enough to know the derivative of any spline.  
&#8226; Can be done with matrices 
&#8211; Trivial in monomial basis 
&#8211; But get lower-order polynomials Linearity? 
14</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; P(u) = (1-u)&#179;  P1 
  + 3u(1- u)&#178; P2  
  + 3u&#178;(1-u) P3 
 
 + u&#179;  P4  
 How to Build Them? Here&#8217;s an Idea 
(Note! We relabeled 
t to u) 
43</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; Curves: 
 
 
&#8226; Surfaces: 
 
 
 
&#8226;T = power basis 
B = spline matrix 
G = geometry matrix Hardcore: Matrix Notation for Patches 
A separate 4x4 geometry 
matrix for x, y, z 
67</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>Corner Cutting 
78</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>Corner Cutting 
82</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Connecting Cubic B&#233;zier Curves 
&#8226; Where is this curve 
&#8211; C0 continuous? 
&#8211; G1 continuous? 
&#8211; C1 continuous? 
&#8226; What&#8217;s the relationship 
between:  
&#8211; the # of control points, and 
the # of cubic B&#233;zier 
subcurves? 
23</text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>Questions? 
92</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text>&#8226; Frame defined by 1st 
(tangent), 2nd and 3rd  
derivatives of a 3D curve 
&#8226; Looks like a good idea 
for swept surfaces... Frames on Curves: Frenet Frame 
Image courtesy of Kristian Molhave  on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative C
ommons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.
97</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; P(u) = (1-u)&#179;  P1 
  + 3u(1- u)&#178; P2  
  + 3u&#178;(1-u) P3 
 
 + u&#179;  P4  
 How to Build Them? Here&#8217;s an Idea 
(Note! We relabeled 
t to u) 
44</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>Questions? 
9</text>
        </slide>
        <slide>
          <slideno>108</slideno>
          <text>0
9 6.837 &#8211; Durand  That&#8217;s All for Today 
&#8226;Further reading 
&#8211;Buss, Chapters 7 &amp; 8 
 
&#8226;Subvision curves and surfaces 
&#8211;http://www.cs.nyu.edu/~dzorin/sig00course/ 
109</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226;In the previous, P is were just some curves 
&#8226;What if we make them B&#233;zier curves? 
&#8226;Each u=const. and v=const.                             
curve is a B&#233;zier curve! 
&#8226;Note that the boundary                                  
control points (except                                   
corners) are NOT                                     
interpolated! Tensor Product B&#233;zier Patches 
v=0 v=1 v=2/3 
54</text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>Corner Cutting 
(Well, not totally unexpected, 
remember de Casteljau) 
87</text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>&#8226; Catmull-Clark 
&#8211; Quads and triangles 
&#8211; Generalizes bicubics to 
arbitrary topology! 
&#8226; Loop, Butterfly 
&#8211; Triangles 
&#8226; Doo-Sabin, sqrt(3), biquartic... 
&#8211; and a whole host of others 
&#8226; Used everywhere  in movie and game modeling! 
&#8226; See http://www.cs.nyu.edu/~dzorin/sig00course/ Flavors of Subdivision Surfaces 
Image courtesy of Romainbehar on Wikimedia Commons.
License: CC- BY-SA. This content is excluded from our
Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
90</text>
        </slide>
        <slide>
          <slideno>101</slideno>
          <text>Implicit Surfaces 
&#8226; Surface defined implicitly by a function 
This image is in the public domain. Source: Wikimedia Commons.
102</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; P(u) = (1-u)&#179;  P1 
  + 3u(1- u)&#178; P2  
  + 3u&#178;(1-u) P3 
 
 + u&#179;  P4   
 How to Build Them? Here&#8217;s an Idea 
(Note! We relabeled 
t to u) 
46</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 v=1/3 
49</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 v=1/3 v=2/3 
50</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + 
B3(u) * P3(v) 
  + B4(u) * P4(v) 
&#8226; Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 Bicubics, Tensor Product 
P1,1 P1,2 P1,3 P1,4 P2,1 P2,2 P2,3 
P2,4 P3,1 P3,2 
P3,3 P3,4 P4,1 P4,2 
P4,3 P4,4 
57</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226;P(u,v) is a 3D point specified by u, v 
&#8226;The partial derivatives                  and                are 
3D vectors 
&#8226;Both are tangent to surface at P 
&#8226;Normal is perpendicular to both, i.e., 
 
 
n is usually not 
unit, so must 
normalize! Tangents and Normals for Patches 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
63</text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Corner Cutting 
83</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; P(t) =  (1-t)&#179;  P1 
  + 3t(1-t) &#178; P2  
  + 3t&#178;(1-t)  P3 
  + t&#179;  P4  Cubic Bezier Splines 
2</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226; Parametric surface P( u,v) is a bicubic polynomial 
of two variables u &amp; v 
&#8226; Defined by 4x4=16 control points P1,1, P1,2.... 
P4,4 
&#8226; Interpolates 4 corners, approximates others 
&#8226; Basis are product of two Bernstein polynomials: 
B1(u)B1(v); B1( u)B2(v);... B4( u)B4(v) 
 Recap: Tensor B&#233;zier Patches 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
60</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&#8226; Homogeneous coordinates also work 
&#8211; Means you can translate, rotate, shear, etc. 
&#8211; Note though that you need to normalize P&#8217; by 1/ w&#8217; Affine Transformations 
P&#8217;(t)=  
M 
= 
M 
1 1 1 1 
1 1 1 1 
8</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; The tangent to the curve P(t) can be defined as  
T(t)=P&#8217;(t)/||P&#8217;(t)|| 
&#8211; normalized velocity, ||T(t)|| = 1 
&#8226; This provides us with one orientation for swept 
surfaces later Tangent Vector 
15
Courtesy of Seth Teller.</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>&#8226; Differential Properties of Curves &amp; Continuity 
&#8226; B-Splines 
&#8226; Surfaces 
&#8211; Tensor Product Splines 
&#8211; Subdivision Surfaces 
&#8211; Procedural Surfaces 
&#8211; Other  The Plan for Today 
10</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>&#8226; P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + B3(u) * P3(v) 
  + B4(u) * P4(v) 
&#8226; Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 
Bicubics, Tensor Product 
16 control points Pi,j 
16 2D basis functions Bi,j 
59</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Connecting Cubic B&#233;zier Curves 
&#8226; How can we guarantee C0 continuity? 
&#8226; How can we guarantee G1 continuity?  
&#8226; How can we guarantee C1 continuity? 
&#8226; C2 and above gets difficult 
22</text>
        </slide>
        <slide>
          <slideno>109</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>Corner Cutting 
It turns out corner cutting 
(Chaikin&#8217;s Algorithm) 
produces a quadratic B-
Spline curve! (Magic!) 
86</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>&#8226; How do we get M? 
&#8211; Translation is easy, given by c(v) 
&#8211; What about orientation? 
&#8226; Orientation options: 
&#8211; Align profile curve with an axis. 
&#8211;Better : Align profile curve with 
frame that &#8220;follows&#8221; the curve General Swept Surfaces 
where M is a matrix that depends on the trajectory c s(u,v)= M(c(v)) q(u) 
q c 
s 
96</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>&#8226; Not all surfaces are smooth... Cool: Displacement Mapping 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
72</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226; Derivative of unit tangent 
&#8211; K(t)=T&#8217;(t) 
&#8211; Magnitude ||K(t)|| is constant for a circle 
&#8211; Zero for a straight line 
&#8226; Always orthogonal to tangent, ie. Curvature Vector 
16</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Geometry: control points coordinates assembled 
into a matrix (P1, P2, &#8230;, Pn+1) 
&#8226; Power basis:  the monomials 1, t, t2, ... 
&#8226; Cubic B&#233;zier: General Spline Formulation 
4</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>Cubic B-Splines 
&#8226; &#8805; 4 control points 
&#8226; Locally cubic 
&#8211; Cubics chained together, again. 
28
Courtesy of Seth Teller.  </text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>Specialized Procedural Definitions 
&#8226; Surfaces of 
revolution 
&#8211; Rotate given 2D 
profile curve 
&#8226; Generalized 
cylinders 
&#8211; Given 2D profile and 
3D curve, sweep the 
profile along the 3D 
curve 
&#8226;Assignment 1! 
93</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>B&#233;zier &#8800; B-Spline 
B&#233;zier B-Spline 
But both are cubics, so one can be converted into the other! 
35</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; For B&#233;zier curves, the  
    basis polynomials/vectors 
    are Bernstein polynomials 
 
&#8226; For cubic Bezier curve: 
    B 1(t)=(1- t)&#179;          B 2(t)=3t(1- t)&#178; 
    B 3(t)=3t&#178; (1-t) B 4(t)=t&#179; 
    (careful with indices, many authors start at 0) 
&#8226; Defined for any degree Bernstein Polynomials 
3</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Corner Cutting 
80</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>Velocity 
Sanity check: t=0; t=1 
&#8226; First derivative w.r.t. t 
&#8226; Can you compute this for Bezier curves? 
P(t) =  (1-t)&#179;  P1 
  + 3t(1-t) &#178; P2  
  + 3t&#178;(1-t)  P3 
  + t&#179;  P4  
&#8226;P&#8217;(t) =  -3(1-t)2  P1  
 + [3(1-t) 2 -6t(1-t)] P2 
 + [6t(1-t) -3t 2]        P3 
 + 3t 2    P4 
13</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; C0 = continuous 
&#8211; The seam can be a sharp kink 
&#8226; G1 = geometric continuity 
&#8211; Tangents point to the same 
direction  at the seam 
&#8226; C1 = parametric continuity 
&#8211; Tangents are the same at the 
seam, implies G1 
&#8226; C2 = curvature continuity 
&#8211; Tangents and their derivatives 
are the same Orders of Continuity 
C0 
G1 
C1 
20</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; G1 = geometric continuity 
&#8211; Tangents point to the same 
direction  at the seam 
&#8211; good enough for modeling 
&#8226; C1 = parametric continuity 
&#8211; Tangents are the same at the 
seam, implies G1 
&#8211; often necessary for animation Orders of Continuity 
G1 
C1 
21</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>Questions? 
24</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Cubic B-Splines: Basis 
B1 B4 B2 B3 These sum to 1, too! 
A B-Spline curve is also 
bounded by the convex  
hull of its control points.  
30</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>Questions? 
61</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; Not all surfaces are smooth... 
&#8226; &#8220;Paint&#8221; displacements on a smooth surface 
&#8211; For example, in the direction of normal 
&#8226; Tessellate smooth patch into fine grid, 
then add displacement D(u,v) to vertices 
&#8226; Heavily used in movies, more and more in games Cool: Displacement Mapping 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
73</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Normalized curvature: T&#8217;(t)/||T&#8217;(t)|| Curve Normal 
18</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; P(u,v) =   B1(u) * P1(v) 
  + B2(u) * P2(v)  
  + B3(u) * P3(v) 
  + B4(u) * P4(v) 
&#8226; Pi(v) =    B1(v) * Pi,1 
      +      B2(v) * Pi,2 
       +      B3(v) * Pi,3 
      +      B4(v) * Pi,4 
 
Bicubics, Tensor Product 
58</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; What if we want to transform each point on the 
curve with a linear transformation M?  Linear Transformations &amp; Cubics 
P&#8217;(t)=  
M 
6</text>
        </slide>
        <slide>
          <slideno>104</slideno>
          <text>Point Set Surfaces 
&#8226; Given only a noisy 3D point cloud (no 
connectivity), can you define a reasonable surface 
using only the points? 
&#8211; Laser range scans only give you points, 
so this is potentially useful 
From Point Set Surfaces, (Alexa et al. 2001).&#169; IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use/.
105</text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>&#8226; Idea: cut corners to smooth 
&#8226; Add points and compute  
weighted average of neighbors 
&#8226; Same for surfaces 
&#8211; Special case for irregular vertices  
&#8226; vertex with more or less than 6 neighbors in a triangle mesh Subdivision Curves and Surfaces 
Warren et al.  
&#169; IEEE. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
88</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 v=1/3 v=2/3 
51</text>
        </slide>
        <slide>
          <slideno>103</slideno>
          <text>Questions? 
104</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>B1 B4 B2 B3 
3
2 Cubic B-Splines: Basis 
32</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>&#8226; Rational cubics 
&#8211; Use homogeneous coordinates, just add w ! 
&#8226; Provides an extra weight parameter to control points 
 
&#8226; NURBS:  Non-Uniform Rational B-Spline 
&#8211;non-uniform = different spacing between the 
blending functions, a.k.a. &#8220;knots&#8221; 
&#8211;rational  = ratio of cubic polynomials 
(instead of just cubic) 
&#8226; implemented by adding the homogeneous coordinate w into 
the control points. NURBS (Generalized B-Splines) 
38</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Questions? 
19</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837 &#8211; Matusik  6.837 Computer Graphics 
 
Curve Properties &amp; Conversion, 
Surface Representations 
 
vectorportal.com 
1</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>Converting between B&#233;zier &amp; BSpline 
 
&#8226; Simple with the basis matrices! 
&#8211; Note that this only works for 
a single segment of 4 
control points 
&#8226; P(t) = G B1 T(t) = 
G B1 (B2-1B2) T(t)= 
(G B 1 B2-1) B2 T(t) 
&#8226;G B1 B2-1 are the control points 
for the segment in new basis. 
36</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>Questions? 
39</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226;P(u,v) is a 3D point specified by u, v 
&#8226;The partial derivatives                  and                are 
3D vectors 
&#8226;Both are tangent to surface at P 
 
Tangents and Normals for Patches 
&#169; Addison-Wesley. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
62</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Tensor Product B&#233;zier Patches 
The &#8220;Control Mesh&#8221; 
16 control points 
56</text>
        </slide>
        <slide>
          <slideno>98</slideno>
          <text>&#8226; Build triplet of vectors 
&#8211; include tangent (it is reliable) 
&#8211; orthonormal 
&#8211; coherent over the curve 
&#8226; Idea:  
&#8211; use cross product to create orthogonal vectors 
&#8211; exploit discretization of curve  
&#8211; use previous frame to bootstrap orientation 
&#8211;See Assignment 1 instructions! Smooth Frames on Curves 
99</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>Differential Properties of Curves 
&#8226; Motivation 
&#8211; Compute normal for surfaces 
&#8211; Compute velocity for animation  
&#8211; Analyze smoothness 
Image courtesy of Kristian Molhave on Wikimedia Commons. License: CC-
BY-SA. This content is excluded from our Creative Commons license. For
more information, see http://ocw.mit.edu/help/faq-fair-use/.
11</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>Corner Cutting 
81</text>
        </slide>
        <slide>
          <slideno>106</slideno>
          <text>&#8226; Modern take on implicit surfaces 
&#8226; Cool math: Moving Least Squares (MLS), 
partitions of unity, etc. 
 
 
 
 
 
&#8226; Not required in this class, but nice to know. Point Set Surfaces 
Ohtake et al. 2003From Multi-Level Partition 
of Unity Implicits
&#169; ACM, Inc.  All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
107</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>Cubic B-Splines 
&#8226; &#8805; 4 control points 
&#8226; Locally cubic 
&#8211; Cubics chained together, again. 
27
Courtesy of Seth Teller.  </text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Tensor Product B-Spline Patches 
&#8226; B&#233;zier and B-Spline curves are both cubics 
&#8211; Can change between representations using matrices 
 
&#8226; Consequently, you can build tensor product 
surface patches out of B-Splines just as well 
&#8211; Still 4x4 control points for each patch 
&#8211; 2D basis functions are pairwise 
products of B-Spline basis functions 
&#8211; Yes, simple! 
&#169; Addison-Wesley. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
69</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>&#8226; K is zero for a line, constant for circle 
&#8211; What constant? 1/r 
&#8226; 1/||K(t)|| is the radius of the circle that touches 
P(t) at t and has the same curvature as the curve Geometric Interpretation 
17</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Cubic B-Splines 
&#8226; Local control (windowing) 
&#8226; Automatically C2, and no need to match tangents! 
Courtesy of Seth Teller.  Used with permission. 
33</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>B1 B4 B2 B3 
3
1 Cubic B-Splines: Basis 
31</text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>Surface of Revolution 
v 
s(u,v)= R(v)q(u) 
where R is a matrix, 
q a vector, 
and s is a point on 
the surface s(u,v) &#8226; 2D curve q( u) provides one dimension 
&#8211; Note: works also with 3D curve 
&#8226; Rotation R(v ) provides 2nd dimension 
 
94</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; What you&#8217;ve used so far in Assignment 0 
&#8226; Triangle represented by 3 vertices 
&#8226;Pro: simple, can be rendered directly 
&#8226;Cons : not smooth, needs many triangles to 
approximate smooth surfaces (tessellation) 
 Triangle Meshes 
This image is in the public domain. Source: Wikimedia Commons.
41</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226; First derivative w.r.t. t 
&#8226; Can you compute this for Bezier curves? 
P(t) =  (1-t)&#179;  P1 
  + 3t(1-t) &#178; P2  
  + 3t&#178;(1-t)  P3 
  + t&#179;  P4  
&#8226; You know how to 
differentiate polynomials... Velocity 
12</text>
        </slide>
        <slide>
          <slideno>102</slideno>
          <text>&#8226; Pros:  
&#8211; Efficient check whether  point is inside 
&#8211; Efficient Boolean operations 
&#8211; Can handle weird topology for animation 
&#8211; Easy to do sketchy modeling 
&#8226; Cons: 
&#8211; Does not allow us to easily generate a  
point on the surface Implicit Surfaces 
Image courtesy of Anders Sandberg on Wikimedia Commons. License: CC-BY -
SA. This content is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.
103</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 v=1/3 v=2/3 A 2D surface patch! 
52</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; Triangle meshes 
&#8211; Surface analogue of polylines, this is what GPUs 
draw 
&#8226;Tensor Product Splines 
&#8211; Surface analogue of spline curves 
&#8226;Subdivision surfaces 
&#8226;  Implicit surfaces, e.g. f(x,y,z)=0 
&#8226;Procedural 
&#8211; e.g. surfaces of revolution, generalized cylinder 
&#8226; From volume data (medical images, etc.) Representing Surfaces 
40</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>Questions? 
64</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Questions? 
5</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Cubic B&#233;zier in matrix notation Recap: Matrix Notation for Curves 
point on curve 
(2x1 vector) 
&#8220;Geometry matrix&#8221; 
of control points P1..P4 
(2 x 4) &#8220;Spline matrix&#8221; 
(Bernstein) Canonical 
&#8220;power basis&#8221; 
65</text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>&#8226; Trace out surface by moving a  
profile curve along a trajectory. 
&#8211; profile curve q(u) provides one dim 
&#8211; trajectory c(u) provides the other 
&#8226; Surface of revolution can be seen  
as a special case where trajectory  
is a circle General Swept Surfaces 
where M is a matrix that depends on the trajectory c 
q c 
s 
s(u,v)= M(c(v)) q(u) 
95</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>Corner Cutting 
77</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>6.837 &#8211; Durand  Utah Teapot: Tensor B&#233;zier Splines 
&#8226; Designed by Martin Newell 
Image courtesy of Dhatfield  on Wikimedia Commons. License: CC-BY -SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
71</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; P(u, v) =  (1-u) &#179;  P1(v) 
  + 3u(1- u)&#178;       P2(v)  
  + 3u&#178;(1-u)  P3(v) 
 
 + u&#179;  P4(v)  
&#8226; Let&#8217;s make 
the Pis move along 
curves!
 Here&#8217;s an Idea 
v=0 v=1 
48</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Pros 
&#8211; Smooth  
&#8211; Defined by reasonably small set of points 
&#8226; Cons 
&#8211; Harder to render (usually converted to triangles) 
&#8211; Tricky to ensure continuity at patch boundaries 
&#8226; Extensions 
&#8211; Rational splines: Splines in homogeneous coordinates 
&#8211; NURBS: Non-Uniform Rational B-Splines 
&#8226; Like curves: ratio of polynomials, non-uniform location of 
control points, etc. Tensor Product Spline Patches 
70</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>Corner Cutting 
85</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Cubic B-Splines 
&#8226; &#8805; 4 control points 
&#8226; Locally cubic 
&#8211; Cubics chained together, again. 
26
Courtesy of Seth Teller.  </text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>Corner Cutting 
&#8734; 
84</text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>&#8226; Normal flips! 
&#8226; Bad to define a smooth swept surface Frenet: Problem at Inflection! 
An inflection is a point 
where curvature changes 
sign 
98</text>
        </slide>
        <slide>
          <slideno>100</slideno>
          <text>Questions? 
101</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Graphics Pipeline and Rasterization (PDF - 2.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec21/</lecture_pdf_url>
      <lectureno>21</lectureno>
      <slides>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; Henry Fuchs, Jack Goldfeather, Jeff Hultquist, Susan Spach, John 
Austin, Frederick Brooks, Jr., John Eyles and John Poulton, &#8220;Fast 
Spheres, Shadows, Textures, Transparencies, and Image 
Enhancements in Pixel-Planes&#8221;, Proceedings of SIGGRAPH &#8216;85 
(San Francisco, CA, July 22&#8211;26, 1985). In Computer Graphics , 
v19n3 (July 1985), ACM SIGGRAPH, New York, NY, 1985. 
&#8226; Juan Pineda, &#8220;A Parallel Algorithm for Polygon Rasterization&#8221;, 
Proceedings of SIGGRAPH &#8216;88 (Atlanta, GA, August 1&#8211;5, 1988). 
In Computer Graphics , v22n4 (August 1988), ACM SIGGRAPH, 
New York, NY, 1988. Figure 7: Image from the spinn
ing teapot 
performance test. 
&#8226; Marc Olano Trey Greer, &#8220;Triangle Scan Conversion using 2D 
Homogeneous Coordinates&#8221;, Graphics Hardware 97 
http://www.cs.unc.edu/~olano/papers/2dh-tri/2dh-tri.pdf  
66 Further References </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Rasterization Advantages Weiler, Atherton 1977  
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; For a really HC piece of rasterizer engineering, see 
the hierarchical Hilbert curve rasterizer by McCool, 
Wales and Moule.  
&#8211; (Hierarchical? We&#8217;ll look at that next..) 
61 Questions? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226; These projections matrices work perfectly in the 
sense that you get the proper 2D projections of 3D 
points. 
&#8226; However, since we are flattening the scene onto the 
z=1 plane, we&#8217;ve lost all information about the 
distance to camera. 
&#8211; We need the distance for Z buffering, i.e., figuring out 
what is in front of what! 
32 Caveat </text>
        </slide>
        <slide>
          <slideno>90</slideno>
          <text>&#8226; Maintain intersection with closest object 
91 Ray Casting 
</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
&#8211; For each pixel, 
test 3 edge equations 
&#8226; if all pass, draw pixel 
 
&#8226; Compute per-pixel color 
&#8226; Test visibility (Z-buffer), 
update frame buffer color 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 Rasterization (&#8220;Scan Conversion&#8221;) 
glBegin(GL_TRIANGLES)  
glNormal3f(...)  
glVertex3f(...)  
glVertex3f(...)  
glVertex3f(...)  
glEnd(); &#8226; Given a triangle&#8217;s vertices &amp;  
extra info for shading, figure 
out which pixels to "turn on"  
to render the primitive 
&#8226; Compute illumination values to 
"fill in" the pixels within the 
primitive 
&#8226; At each pixel, keep track of  
the closest primitive (z-buffer) 
&#8211; Only overwrite if triangle being 
drawn is closer than the previous 
triangle in that pixel 
&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; Trivial: Just ass another dimension y and treat it like x 
&#8226; Different fields of view and non-square image aspect 
ratios can be accomplished by simple scaling of the x 
and y axes. 
31 
Extension to 3D </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 What if the pz is &lt; eyez? 
(eyex, eyey, eyez) 
image plane z axis  &#8594; + </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Perspective in 2D 
The projected point in 
homogeneous 
coordinates 
(we just added w=1): 
This image is in the public domain. Source: openclipart
</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; We compute the line equation for many useless 
pixels 
&#8226; What could we do? 
62 Can We Do Even Better?  
</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 GPUs do Rasterization 
&#8226; The process of taking a 
triangle and figuring out 
which pixels it covers is 
called rasterization  
&#8226; We&#8217;ve seen acceleration 
structures for ray 
tracing; rasterization is 
not stupid either 
&#8211; We&#8217;re not actually going 
to test all pixels for each 
triangle 
Scene 
primitives Pixel raster Keep closest hit GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>25 Projection 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility (Z-buffer), 
update frame buffer 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>Homogeneous Rasterization 
2D rasterization 
80 </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Use graphics hardware, via OpenGL or DirectX 
&#8211; OpenGL is multi-platform, DirectX is MS only 
 
 
 
 
 
 
 
 
&#8226; Most global effects available in ray tracing will be 
sacrificed for speed, but some can be approximated 
3 How Do We Render Interactively? 
OpenGL rendering  Our ray tracer 
&#169; Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; Perform rotation/translation/other transforms to put 
viewpoint at origin and view direction along z axis 
&#8211; This is the OpenGL &#8220;modelview&#8221; matrix 
 
&#8226; Combine with projection matrix (perspective or 
orthographic) 
&#8211; Homogenization achieves foreshortening 
&#8211; This is the OpenGL &#8220;projection&#8221; matrix 
 
&#8226;Corollary : The entire transform from object space to 
canonical view volume [-1,1]3 is a single matrix 
43 Recap: Projection </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; Compute the boundary pixels using line rasterization 
67 Oldschool Rasterization 
</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Hierarchical rasterization! 
&#8211; Conservatively test blocks of pixels before 
going to per-pixel level (can skip large blocks at once) 
&#8211; Usually two levels 
65 Indeed, We Can Be Smarter 
Can also test if an entire 
block is inside the 
triangle; then, can skip 
edge functions tests for 
all pixels for even further 
speedups.(Must still test 
Z, because they might 
still be occluded.) </text>
        </slide>
        <slide>
          <slideno>94</slideno>
          <text>95 Works for hard cases! 
</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>&#8226; Replace 2D edge equation by 3D plane equation 
&#8211; Treat pixels as 3D points ( x, y, 1) on image plane, test for 
containment in 3 halfspaces just like edge functions 
82 Homogeneous Rasterization 
2D rasterization 3D (homogenous) 
rasterization </text>
        </slide>
        <slide>
          <slideno>89</slideno>
          <text>&#8226; How do we know which parts are visible/in front? 
90 Visibility 
</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Basic Idea: store 1/ z 
</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; The triangle&#8217;s 3D edges project to line segments in 
the image (thanks to planar perspective) 
&#8211; Lines map to lines, not curves 
48 Edge Functions 
</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 Graphics Pipeline &amp; Rasterization 
MIT EECS 6.837 &#8211; Matusik Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>19 Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Test visibility (Z-buffer), 
update frame buffer color 
 
&#8226; Compute per-pixel color 
 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>&#8226; Idea: avoid projection (and division by zero) by 
performing rasterization in 3D  
&#8211; Or equivalently, use 2D homogenous coordinates 
(w&#8217;=z after the projection matrix, remember) 
 
&#8226;Motivation: clipping is annoying 
 
&#8226;Marc Olano, Trey Greer: Triangle scan conversion 
using 2D homogeneous coordinates, Proc. ACM 
SIGGRAPH/Eurographics Workshop on Graphics 
Hardware 1997  
79 Homogeneous Rasterization </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>Edge Functions 
49 &#8226; The triangle&#8217;s 3D edges project to line segments in 
the image (thanks to planar perspective) 
&#8226; The interior of the triangle is the set of points that is 
inside all three halfspaces defined by these lines </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Use graphics hardware, via OpenGL or DirectX  
&#8211; OpenGL is multi-platform, DirectX is MS only 
 
 
 
 
 
 
 
 
2 How Do We Render Interactively? 
OpenGL rendering  Our ray tracer 
&#169; Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226; Modern scenes are more complicated than images 
&#8211; A 1920x1080 frame at 64-bit color and 32-bit depth per 
pixel is 24MB (not that much) 
&#8226; Of course, if we have more than one sample per pixel this gets 
larger, but e.g. 4x supersampling is still a relatively comfortable 
~100MB 
&#8211; Our scenes are routinely larger than this 
&#8226; This wasn&#8217;t always true 
12 Rasterization Advantages </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; Compute E1, E2 , E3 coefficients from projected 
vertices 
&#8211; Called &#8220;triangle setup&#8221;, yields ai, bi, ci for i=1,2,3 
51 Brute Force Rasterizer 
</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 
Questions? 
Call of Duty: Modern Warfare 2 by Infinity Ward Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Perspective in 2D 
This image is in the public domain. Source: openclipart
</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>The final image is obtained by merely 
dropping the z coordinate after 
projection (orthogonal projection) &#8226; We can transform the frustum by a modified 
projection in a way that makes it a square (cube in 
3D) after division by w&#8217;. 
36 The View Frustum in 2D 
x z 
x&#8217;/w&#8217; z&#8217;/w&#8217; </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text> 
 
 
 
 
 
 
&#8226; Details/more intuition in handout 
&#8211; &#8220;Understanding Projections and Homogenous 
Coordinates&#8221; 
42 OpenGL Form of the Projection 
</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text> 
 
 
 
 
 
 
 
&#8226;z&#8217; = 1 before homogenization 
&#8226;z&#8217;=1/z after homogenization 
34 Basic Idea: store 1/ z 
</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226; Compute E1, E2 , E3 coefficients from projected 
vertices 
&#8226; For each pixel (x, y) 
&#8211; Evaluate edge functions at pixel center 
&#8211; If all non-negative, pixel is in! 
 
53 Brute Force Rasterizer 
If the triangle is 
small, lots of useless  
computation if we 
really test all pixels </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions E i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
55 Rasterization Pseudocode 
Bounding box clipping is easy, 
just clamp the coordinates to 
the screen rectangle Note: No 
visibility </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; (In 3D this is a truncated pyramid.) 
37 The View Frustum in 2D 
image xmin image xmax </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226; Advantages 
&#8211; Generality: can render anything 
that can be intersected with a ray 
&#8211; Easily allows recursion (shadows, reflections, etc.) 
 
&#8226; Disadvantages 
&#8211; Hard to implement in hardware (lacks computation 
coherence, must fit entire scene in memory, bad memory 
behavior) 
&#8226; Not such a big point any more given general purpose GPUs 
&#8211; Has traditionally been too slow for interactive applications 
&#8211; Both of the above are changing rather rapidly right now! 
16 Ray Casting / Tracing </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Compute the boundary pixels using line rasterization  
&#8226; Fill the spans 
70 Oldschool Rasterization 
More annoying to 
implement than edge 
functions 
 
Not faster unless 
triangles are huge Questions? </text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Perform projection of vertices 
&#8226; Rasterize triangle: find which 
pixels should be lit 
&#8226; Compute per-pixel color 
&#8226; Test visibility, 
update frame buffer color 
&#8211; Store minimum distance to camera 
for each pixel in &#8220;Z-buffer&#8221; 
&#8226; ~same as tmin in ray casting! 
&#8211;if newz &lt;  zbuffer[x,y] 
    zbuffer[x,y] =new_z 
    framebuffer[x,y] =new_color 
21 Modern Graphics Pipeline 
Z buffer frame buffer &#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Hierarchical rasterization! 
&#8211; Conservatively test blocks of pixels before 
going to per-pixel level (can skip large blocks at once) 
&#8211; Usually two levels 
64 Indeed, We Can Be Smarter 
Conservative tests of 
axis-aligned blocks vs. 
edge functions are not 
very hard, thanks to 
linearity. See  Akenine-
M&#246;ller and Aila, Journal 
of Graphics Tools 10(3), 
2005.  </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? 
Scene 
primitives Scene 
primitives 
Pixel raster 
Pixel raster Keep closest hit Keep closest hit 
It&#8217;s just a different order of the loops!  </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text> 
 
 
 
 
 
 
&#8226; Point of the exercise: This gives screen coordinates 
and depth values for Z-buffering with unified math 
&#8211; Caveat: OpenGL and DirectX define Z differently [0,1] vs.[-1,1] 
39 The Canonical View Volume 
x = -1 x = 1 z = -1 z = 1 </text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>&#8226; Far and near are kind of arbitrary 
&#8226; They bound the depth storage precision 
38 The View Frustum in 2D 
image xmin image xmax </text>
        </slide>
        <slide>
          <slideno>87</slideno>
          <text>&#8226; Modern graphics hardware enables the execution of 
rather complex programs to compute the color of every 
single pixel 
&#8226; More later 
88 Pixel Shaders 
 iridescence Procedural texture,  
Anisotropic brdf 
Translucence 
Backlighting 
&#169; NVIDIA. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; Restricted to scan-convertible primitives 
&#8211; Pretty much: triangles  
&#8226; Faceting, shading artifacts 
&#8211; This is largely going away 
with programmable per-pixel 
shading, though 
&#8226; No unified handling of 
shadows, reflection, 
transparency 
&#8226; Potential problem of 
overdraw (high depth 
complexity) 
&#8211; Each pixel touched 
many times 
15 Rasterization Limitations 
scan conversion 
gouraud shading ray tracing 
scan conversion 
flat shading 
&#169; Khronos Group. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>83</slideno>
          <text>&#8226; Works for triangles behind eye 
&#8226; Still linear, can evaluate incrementally/hierarchically 
like 2D 
84 Homogeneous Rasterization 
3D triangle 2D pixel 
(x&#8217;, y&#8217;, 1) </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Edge Functions 
&#8226; The triangle&#8217;s 3D edges project to line segments in 
the image (thanks to planar perspective) 
&#8226; The interior of the triangle is the set of points that is 
inside all three halfspaces defined by these lines </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>For each triangle 
  transform into eye space 
  (perform projection) 
  setup 3 edge equations 
  for each pixel x,y 
    if passes all edge equations 
      compute z 
      if z&lt;zbuffer[x,y] 
        zbuffer[x,y]=z 
        framebuffer[x,y]=shade() 
22 Modern Graphics Pipeline 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>96</slideno>
          <text> 
 
 
 
 
 
 
 
&#8226; Next time: 
Screen-space interpolation, visibility, shading 
97 That&#8217;s All For Today! 
Uncharted 2 by Naughty Dog / Sony Screenshot from the video game Uncharted 2  has been removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text> 
 
 
 
&#8226; z&#8217;=(az+b)/z =a+b/z    
&#8211; where a &amp; b depend on near &amp; far 
&#8226; Similar enough to our basic idea: 
&#8211; z&#8217;=1/z 
41 OpenGL Form of the Projection 
</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>71 What if the pz is &gt; eyez? 
(eyex, eyey, eyez) 
image plane z axis  &#8594; + </text>
        </slide>
        <slide>
          <slideno>91</slideno>
          <text>&#8226; In ray casting, use intersection with closest t 
&#8226; Now we have swapped the loops (pixel, object) 
&#8226; What do we do? 
92 Visibility 
</text>
        </slide>
        <slide>
          <slideno>84</slideno>
          <text>&#8226; Rasterizes with plane tests instead of edge tests 
&#8226;Removes the need for clipping! 
85 Homogeneous Rasterization Recap 
3D triangle 2D pixel 
(x&#8217;, y&#8217;, 1) </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? 
Scene 
primitives 
Pixel raster Keep closest hit 
4 </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>&#8226; We can transform the frustum by a modified 
projection in a way that makes it a square (cube in 
3D) after division by w&#8217;. 
35 Full Idea: Remap the View Frustum 
x z 
x&#8217;/w&#8217; z&#8217;/w&#8217; 
viewpoint view frustum  
(visible part of the scene) </text>
        </slide>
        <slide>
          <slideno>82</slideno>
          <text>Given 3D triangle 
  setup plane equations 
  (plane through viewpoint &amp; triangle edge) 
  For each pixel x,y 
    compute plane equations for (x,y,1) 
    if all pass, draw pixel 
83 Homogeneous Rasterization 
3D triangle 2D pixel 
(x, y, 1) plane equation 
plane equation </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; Primitives are &#8220;continuous&#8221; geometric objects; 
screen is discrete (pixels) 
&#8226; Rasterization computes a discrete approximation in 
terms of pixels (how?) 
47 2D Scan Conversion 
</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Improvement: Scan over only the pixels that overlap 
the screen bounding box  of the triangle 
&#8226; How do we get such a bounding box? 
&#8211; Xmin, Xmax, Ymin, Ymax of the projected triangle vertices 
54 Easy Optimization 
</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 Perspective in 2D 
We&#8217;ll just copy z to w, and 
get the projected point 
after homogenization! 
This image is in the public domain. Source: openclipart
</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>&#8226; Primitives are &#8220;continuous&#8221; geometric objects; 
screen is discrete (pixels) 
46 2D Scan Conversion 
</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility (Z-buffer), 
update frame buffer 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 GPUs do Rasterization 
&#8226; The process of taking a 
triangle and figuring out 
which pixels it covers is 
called rasterization 
Scene 
primitives Pixel raster Keep closest hit GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? </text>
        </slide>
        <slide>
          <slideno>86</slideno>
          <text>87 Modern Graphics Pipeline 
&#8226; Perform projection of 
vertices 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility, update frame 
buffer 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see  http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions a ix + b iy + c i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
57 Can We Do Better?  
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text> 
 
 
 
 
 
&#8226; What needs to be stored in memory in each case? 
10 What are the Main Differences? 
Ray Casting 
For each pixel (ray)  
  For each triangle  
    Does ray hit triangle?  GPU 
For each triangle  
  For each pixel  
    Does triangle cover pixel?  
Keep closest hit Keep closest hit 
Ray-centric Triangle-centric </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Input 
&#8211; Geometric model 
&#8226; Triangle vertices, vertex normals, texture coordinates 
&#8211; Lighting/material model (shader) 
&#8226; Light source positions, colors, intensities, etc.  
&#8226; Texture maps, specular/diffuse coefficients, etc. 
&#8211; Viewpoint + projection plane 
 
&#8226; Output 
&#8211; Color (+depth) per pixel Modern Graphics Pipeline 
Colbert &amp; Krivanek 18 Image of Real-Time Rendering of the Stanford Bunny
with 40 Samples per Pixel removed due to copyright
restrictions -- please see Fig. 20-1 from http://http.
develop
er.nvidia.com/GPUGems3/gpugems3_ch20.html
for further details.&#169; Oscar Meruvia
-Pastor, Daniel Rypl.
All rights reserved. This content is
excluded from our Creative Commons
license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions E i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
56 Rasterization Pseudocode 
Bounding box clipping is easy, 
just clamp the coordinates to 
the screen rectangle Note: No 
visibility 
Questions? </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; Perform rotation/translation/other transforms to put 
viewpoint at origin and view direction along z axis 
&#8211; This is the OpenGL &#8220;modelview&#8221; matrix 
 
&#8226; Combine with projection matrix (perspective or 
orthographic) 
&#8211; Homogenization achieves foreshortening 
&#8211; This is the OpenGL &#8220;projection&#8221; matrix 
 
&#8226;Corollary : The entire transform from object space to 
canonical view volume [-1,1]3 is a single matrix 
44 Recap: Projection Questions? </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Brute Force Rasterizer 
Problem? &#8226; Compute E1, E2 , E3 coefficients from projected 
vertices 
&#8226; For each pixel (x, y) 
&#8211; Evaluate edge functions at pixel center 
&#8211; If all non-negative, pixel is in! </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Orthographic 
 
 
 
&#8226; Perspective 
26 Orthographic vs. Perspective 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226; Compute the boundary pixels using line rasterization  
&#8226; Fill the spans 
69 Oldschool Rasterization 
More annoying to 
implement than edge 
functions 
 
Not faster unless 
triangles are huge </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text> 
 
 
 
 
&#8226; In this basic form, ray tracing needs the entire scene 
description in memory at once 
&#8211; Then, can sample the image completely freely 
&#8226; The rasterizer only needs one triangle at a time, plus 
the entire image and associated depth information for 
all pixels  11 What are the Main Differences? 
Ray Casting 
For each pixel (ray)  
  For each triangle  
    Does ray hit triangle?  GPU 
For each triangle  
  For each pixel  
    Does triangle cover pixel?  
Keep closest hit Keep closest hit 
Ray-centric Triangle-centric </text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; Modern scenes are more complicated than images 
&#8211; A 1920x1080 frame (1080p) at 64-bit color and 32-bit 
depth per pixel is 24MB (not that much) 
&#8226; Of course, if we have more than one sample per pixel (later) this 
gets larger, but e.g. 4x supersampling is still a relatively 
comfortable ~100MB 
&#8211; Our scenes are routinely larger than this 
&#8226; This wasn&#8217;t always true 
 
&#8226; A rasterization-based renderer can stream over the 
triangles, no need to keep entire dataset around 
&#8211; Allows parallelism and optimization of memory systems 
14 Rasterization Advantages </text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; Compute the boundary pixels using line rasterization  
&#8226; Fill the spans 
68 Oldschool Rasterization 
</text>
        </slide>
        <slide>
          <slideno>95</slideno>
          <text>&#8226; How do we get Z? 
&#8226; Texture Mapping? 
96 More questions for next time 
</text>
        </slide>
        <slide>
          <slideno>92</slideno>
          <text>&#8226; In addition to frame buffer (R, G, B) 
&#8226; Store distance to camera ( z-buffer) 
&#8226; Pixel is updated only if newz is closer  
than z-buffer value 
93 Z buffer 
</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>For every triangle  
ComputeProjection  
Compute bbox, clip bbox to screen limits  
For all scanlines y in bbox  
Evaluate all E i&#8217;s at (x0,y): E i = aix0 + b iy + ci 
For all pixels x in bbox  
    If all E i&gt;0  
     Framebuffer[x,y ] = triangleColor 
    Increment line equations: E i += ai 
 
&#8226; We save ~two multiplications and 
two additions per pixel when the 
triangle is large 
60 Incremental Edge Functions 
Can also zig-zag to avoid 
reinitialization per scanline, 
just initialize once at x0, y0 </text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>&#8226; &#8220;View Frustum Culling&#8221; 
&#8211; Use bounding volumes/hierarchies to test whether any 
part of an object is within the view frustum 
&#8226; Need &#8220;frustum vs. bounding volume&#8221; intersection test 
&#8226; Crucial to do hierarchically when scene has lots of objects! 
&#8226; Early rejection (different from clipping) 
78 Related Idea 
See e.g. Optimized view 
frustum culling 
algorithms for bounding 
boxes , Ulf Assarsson 
and Tomas M&#246;ller, 
journal of graphics 
tools, 2000. Questions? 
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>63 Indeed, We Can Be Smarter 
? </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>For every triangle  
ComputeProjection  
Compute bbox, clip bbox to screen limits  
For all scanlines y in bbox  
Evaluate all E i&#8217;s at (x0,y): E i = aix0 + b iy + ci 
For all pixels x in bbox  
    If all E i&gt;0  
     Framebuffer[x,y ] = triangleColor 
    Increment line equations: E i += ai 
 
&#8226; We save ~two multiplications and 
two additions per pixel when the 
triangle is large 
59 Incremental Edge Functions </text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>74 A Solution: Clipping 
(eyex, eyey, eyez) 
image plane "clip" geometry to 
view frustum, discard 
outside parts 
z axis  &#8594; + 
z=near  z=far </text>
        </slide>
        <slide>
          <slideno>97</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 
Clipping 
bottom  top 
right left 
near far &#8226; Eliminate portions of objects 
outside the viewing frustum 
&#8226; View Frustum  
&#8211; boundaries of the image  
plane projected in 3D 
&#8211; a near &amp; far  
clipping plane 
&#8226; User may define  
additional clipping  
planes 
Leonard McMillan, Computer Science at the University of North Carolina in Chapel Hill.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Ray Casting vs. GPUs for Triangles 
Ray Casting 
For each pixel (ray) 
  For each triangle 
    Does ray hit triangle? GPU 
For each triangle 
  For each pixel 
    Does triangle cover pixel? 
Scene 
primitives Scene 
primitives 
Pixel raster 
Pixel raster Keep closest hit Keep closest hit </text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>For each triangle 
  transform into eye space 
  (perform projection) 
  setup 3 edge equations 
  for each pixel x,y 
    if passes all edge equations 
      compute z 
      if z&lt;zbuffer[x,y] 
        zbuffer[x,y]=z 
        framebuffer[x,y]=shade() 
23 Modern Graphics Pipeline 
Questions? &#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>75</slideno>
          <text>&#8226; Avoid degeneracies  
&#8211; Don&#8217;t draw stuff  
behind the eye 
&#8211; Avoid division  
by 0 and overflow 
76 
Why Clip? 
z=near  
z=far </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>For every triangle 
Compute projection for vertices, compute the E i 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Evaluate edge functions a ix + b iy + c i 
If all &gt; 0 
 Framebuffer[x,y ] = triangleColor 
58 Can We Do Better?  
These are linear functions of 
the pixel coordinates (x,y), i.e., 
they only change by a constant 
amount when we step from x to 
x+1 (resp. y to y+1) </text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>81 Homogeneous Rasterization 
2D rasterization 3D (homogenous) 
rasterization &#8226; Replace 2D edge equation by 3D plane equation 
&#8211; Plane going through 3D edge and viewpoint 
&#8211; Still a halfspace, just 3D </text>
        </slide>
        <slide>
          <slideno>88</slideno>
          <text>89 Modern Graphics Pipeline 
&#8226; Perform projection of 
vertices 
 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility, update frame 
buffer 
&#169; Khronos Group. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.&#169; source unknown. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>&#8226; &#8220;View Frustum Culling&#8221; 
&#8211; Use bounding volumes/hierarchies to test whether any 
part of an object is within the view frustum 
&#8226; Need &#8220;frustum vs. bounding volume&#8221; intersection test 
&#8226; Crucial to do hierarchically when scene has lots of objects! 
&#8226; Early rejection (different from clipping) 
77 Related Idea 
See e.g. Optimized view 
frustum culling 
algorithms for bounding 
boxes , Ulf Assarsson 
and Tomas M&#246;ller, 
journal of graphics 
tools, 2000. 
&#169; Oscar Meruvia-Pastor, Daniel Rypl. All rights reserved. This content is excluded from our
Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45 Modern Graphics Pipeline 
&#8226; Project vertices to 2D 
(image) 
&#8211; We now have screen 
coordinates 
&#8226; Rasterize triangle: find 
which pixels should be lit 
 
&#8226; Compute per-pixel color 
 
&#8226; Test visibility (Z-buffer), 
update frame buffer 
&#169; Khronos Group. All rights reserved. This  content is excluded
from our Creative Commons license. For more information,
see h t
tp://ocw.mit.edu/help/faq-fair-use/.&#169; source u n
known. All rights reserved. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Perspective in 2D 
Projectively 
equivalent 
This image is in the public domain. Source: openclipart
</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text> 
 
 
 
 
40 OpenGL Form of the Projection 
Input point in view 
coordinates Homogeneous coordinates 
within canonical view volume </text>
        </slide>
        <slide>
          <slideno>93</slideno>
          <text>For every triangle 
Compute Projection, color at vertices 
Setup line equations 
Compute bbox, clip bbox to screen limits 
For all pixels in bbox 
Increment line equations 
Compute curentZ 
Compute currentColor 
If all line equations&gt;0 //pixel [x,y] in triangle   
If currentZ&lt;zBuffer[x,y] //pixel is visible 
  Framebuffer[x,y]=currentColor 
zBuffer[x,y]=currentZ 
94 Z-buffer pseudo code </text>
        </slide>
        <slide>
          <slideno>85</slideno>
          <text>&#8226; Rasterizes with plane tests instead of edge tests 
&#8226;Removes the need for clipping! 
86 Homogeneous Rasterization Recap 
3D triangle 2D pixel 
(x&#8217;, y&#8217;, 1) 
Questions? </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>73 What if the pz = eyez? 
(eyex, eyey, eyez) 
image plane ??? z axis  &#8594; + When w&#8217; = 0, point projects to infinity 
(homogenization is division by w&#8217;) </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Basics of Computer Animation&#8212;Skinning/Enveloping (PDF - 2.4MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec06/</lecture_pdf_url>
      <lectureno>06</lectureno>
      <slides>
        <slide>
          <slideno>74</slideno>
          <text>75
MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>Motion Capture 
&#8226; Usually uses optical markers and multiple 
high-speed cameras 
&#8226; Triangulate to get marker 3D position 
&#8211; (Again, structure from motion and projective 
geometry, i.e., homogeneous coordinates) 
&#8226; Captures style, subtle nuances and realism 
&#8226; But need ability to record someone 
Courtesy Robert C. Duvall, Duke University. License CC BY-NC-SA.
21</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
&#8226; Weight properties 
&#8211; Usually want weights to be non-negative Vertex Weights 
34</text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226;Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. 
&#8226;Basic Idea 2 : Then blend the results using the 
weights. Linear Blend Skinning 
40</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>&#8226; Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. 
&#8211; Example: The joint angles (bone transformations) in a 
hierarchical character determine the pose 
&#8211; Example: A rigid motion is represented by 
changing the object- to-world transformation 
(rotation and translation). 
&#8220;Blendshapes&#8221; are 
keyframes that are just 
snapshots of the 
entire geometry. Because we are Lazy... 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA.
15</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>Bind Pose cont&#8217;d 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
57</text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; Do the usual forward kinematics  
&#8211; get a matrix Tj(t) per bone  
(full transformation from local to world) 
&#8226; For each skin vertex pi 
 
 
 
&#8226; Inverse transpose for normals! Skinning Pseudocode 
63</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>Many slides courtesy of Jovan 
Popovic, Ronen Barzel, and 
Jaakko Lehtinen Basics of Computer Animation 
Skinning/Enveloping 
 
 MIT EECS 6.837 Computer Graphics 
6.837 Matusik Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
1</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>Types of Animation: Keyframing 
&#8226; Specify scene only at 
some instants of time 
&#8226; Generate in-betweens automatically 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
8</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>Skinning Characters 
&#8226; Embed a skeleton into a 
detailed character mesh 
 
Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
19</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>Example 
James &amp; Twigg, Skinning Mesh Animations, 2005, used with permission from ACM, Inc . Colored 
triangles are 
attached to 1 
bone 
Black triangles 
are attached to 
more than 1 
 
Note how they 
are near joints 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
30</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226;Squash : flatten an object or character by pressure or by 
its own power 
 
&#8226;Stretch: used to increase the sense of speed and 
emphasize the squash by contrast Example: Squash and Stretch 
Image adapted from: Lasseter, John. "Principles of Traditional Animation applied to 3D Computer Animation."  ACM SIGGRAPH Com puter Graphics 21, no. 4 (July 1987): 35- 44. &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For mo
re information, see http://ocw.mit.edu/help/faq-fair-use/.
4</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; Types of Animation (overview) 
&#8211; Keyframing 
&#8211; Procedural 
&#8211; Physically-based 
 
&#8226; Animation Controls 
 
&#8226; Character Animation 
using skinning/enveloping Plan 
CERN 
7</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>Motion Capture 
&#8226; Motion capture records 
3D marker positions 
&#8211; But character is  
controlled using 
animation controls  
that affect bone 
transformations! 
&#8226; Marker positions must be 
translated into character 
controls (&#8220;retargeting&#8221;) 
 
This image is in the public domain. Source: Wikimedia Commons .
22</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>How to compute 
vertex positions? 
38</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226; Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
&#8226; Transform by 
T&#8217;1 and T&#8217;2 
yields p&#8217;01, p&#8217;02 
&#8226; the new position  
is p&#8217;0= 
0.5*p&#8217;1 +  
0.5*p&#8217;2 Rest (&#8220;bind&#8221;) pose  
After rotations p0 
p&#8217;0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
p&#8217;01 p&#8217;02 &#8220;Skin&#8221;  
&#8220;Skin&#8221;  
45</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>&#8226; When we animate the model, 
the bone transformations 
Tj change. Bind Pose cont&#8217;d 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
52</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; Do the usual forward kinematics  
&#8211; get a matrix Tj(t) per bone  
(full transformation from local to world) 
&#8226; For each skin vertex pi Skinning Pseudocode 
61</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; When we animate the model, 
the bone transformations 
Tj change. 
&#8211; What is Tj? It maps from the 
local coordinate system of 
bone j to world space. 
&#8226; To be able to deform pi according 
to Tj, we must first express pi in the local 
coordinate system of bone j. 
&#8211; This is where the bind pose 
bone transformations B j come in. Bind Pose cont&#8217;d 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
54</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>SSD is Not Perfect 
After rotations p0 q0 
46</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; Forward kinematics 
describes the positions of the 
body parts as a function of 
joint angles 
&#8211; Body parts are 
usually called &#8220;bones&#8221; 
&#8211; Angles are the low-
dimensional control. 
&#8226; Inverse kinematics specifies 
constraint locations for bones 
and solves for joint angles. Articulated Character Models 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA.
18</text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>5 Skinning/Enveloping 
25 Courtesy of Blender Foundation. License CC-BY. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use.
25
</text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>Vertex Weights 
&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
32</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226; When we animate the model, 
the bone transformations 
Tj change. 
&#8211; What is Tj? It maps from the 
local coordinate system of 
bone j to world space. 
&#8211; again, concatenates hierarchy matrices Bind Pose cont&#8217;d 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
53</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>&#8226; Usual approach: Paint them on the skin. 
&#8226; Can also find them by optimization from example 
poses and deformed skins. 
&#8211;Wang &amp; Phillips, SCA 2002 Figuring out the Weights 
From Automatic Rigging and Animation of 3D Characters.&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
70</text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; We are given a skeleton and a 
skin mesh in a default pose 
&#8211; Called &#8220;bind pose&#8221; 
&#8211; Undeformed vertices pi are  
given in the object space of  
the skin 
&#8226; Previously we conveniently 
forgot that in order for 
p&#8217;ij = Tj pi to make sense, 
coordinate systems must 
match up. Bind Pose 
GNU Free Documentation License. Some rights reserved. This content is
excluded from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
49</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>&#8226; Ken Perlin&#8217;s facial expression 
applet  
 
&#8226; Lower-level controls are 
mapped to semantically 
meaningful higher-level ones 
&#8211; &#8220;Frown/smile&#8221; etc. Example of Higher-Level Controls 
http://mrl.nyu.edu/~perlin/experiments/facedemo/ 
&#169; Ken Perlin. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
16</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 Rest (&#8220;bind&#8221;) pose  
p0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
&#8220;Skin&#8221;  
42</text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>&#8226; In the rigging phase, we 
line the skeleton up with the 
undeformed skin. 
&#8211; This gives some &#8220;rest pose&#8221; 
bone transformations Bj 
from local bone coordinates to global  
&#8211;Bj concatenates all hierarchy matrices  
from node j up to the root Bind Pose cont&#8217;d 
51</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; This is what we do to get deformed positions 
 
 
 
&#8226; But wait... Hmmh... 
66</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>Bind Pose cont&#8217;d 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
The 
identity! 
58</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>&#8226; From: Pose Space Deformation: A Unified Approach to Shape Interpolation and Skeleton-Driven 
Deformation, J. P. Lewis, Matt Cordner, Nickson Fong 
Indeed... Limitations 
&#8226; Rotations really need to be combined differently 
(quaternions!) 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
68</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>&#8226; We are given a skeleton and a 
skin mesh in a default pose 
&#8211; Called &#8220;bind pose&#8221; 
&#8211; Undeformed vertices pi are  
given in the object space of  
the skin 
&#8226; a &#8220;global&#8221; coordinate system, 
no hierarchy Bind Pose 
GNU Free Documentation License. Some rights reserved. This content i s
excluded from our Creative Commons license. For more i
nformation, see
http://ocw.mit.edu/help/faq-fair-use/.
48</text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Types of Animation (overview) 
&#8211; Keyframing 
&#8211; Procedural 
&#8211; Physically-based 
 
&#8226; Animation Controls 
 
&#8226;Character Animation 
using skinning/enveloping Plan 
CERN 
24</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>Super Cool: Automatic Rigging 
&#8226; When you just have some reference skeleton 
animation (perhaps from motion capture) and a 
skin mesh, figure out the bone transformations 
and vertex weights! 
&#8226; Ilya Baran, Jovan Popovic: Automatic Rigging 
and Animation of 3D Characters, 
SIGGRAPH 2007 
&#8226;
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
71</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; Need to infer how skin deforms 
from bone transformations. 
&#8226; Most popular technique: 
Skeletal Subspace Deformation 
(SSD), or simply Skinning 
&#8211; Other aliases 
&#8226; vertex blending 
&#8226; matrix palette skinning 
&#8226; linear blend skinning Skinning/Enveloping 
 This image is in the public domain. Source: Wikimedia Commons.
28</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>Example 
James &amp; Twigg, Skinning Mesh Animations.Colored 
triangles are 
attached to 1 
bone 
Black triangles 
are attached to 
more than 1 
 
Note how they 
are near joints 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
31</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>Questions? 
23</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>Traditional Animation 
 From ACM &#169; 1997 &#8220;Multiperspective panoramas for cel animation .&#8221;&#8226; Draw each frame by hand
 
&#8211; great control, but tedious 
&#8226; Reduce burden with cel animation 
&#8211; Layer, keyframe, inbetween, &#8230; 
&#8211; Example: Cel panoramas (Disney&#8217;s 
Pinocchio) 
Image courtesy of Garrett Albright on Wikimedia
Commons. License: CC-BY -SA. This content is
excluded from our Creative Commons license.
For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
2</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
&#8226; We&#8217;ll limit the number of bones N that can 
influence a single vertex 
&#8211;N=4 bones/vertex is a usual choice 
&#8211;Why? Vertex Weights cont&#8217;d 
36</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>Example: Timing 
&#8226; Timing affects weight: 
&#8211; Light object move quickly 
&#8211; Heavier objects move slower 
 
 
&#8226; Timing completely changes the interpretation of the 
motion. 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
5</text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>&#8226; Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. Because we are Lazy... 
Can you think of examples? 
13</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; Do the usual forward kinematics  
&#8211; get a matrix Tj(t) per bone  
(full transformation from local to world) 
&#8226; For each skin vertex pi Skinning Pseudocode 
Do you remember how to treat normals? 
62</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; We know how to animate a 
bone hierarchy 
&#8211; Change the joint angles, i.e., 
bone transformations, over 
time (keyframing) 
&#8226; Embed a skeleton into a 
detailed character mesh 
&#8226; Bind skin vertices to bones 
&#8211; Animate skeleton, skin will 
move with it 
&#8211; But how? Skinning 
Courtesy of Blender Foundation. License CC-BY. This content is
excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
27</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>Skinning 
&#8226; We know how to animate a 
bone hierarchy 
&#8211; Change the joint angles, i.e., 
bone transformations, over 
time (keyframing) 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA.Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
26</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
&#8226; Transform by 
T&#8217;1 and T&#8217;2 
yields p&#8217;01, 
p&#8217;02 Rest (&#8220;bind&#8221;) pose  
After rotations p0 
p&#8217;01 p&#8217;02 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
&#8220;Skin&#8221;  
43</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>Bind Pose cont&#8217;d 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. What is the 
transformation 
when the model 
is still in bind 
pose? 
The 
identity! 
Questions? 
59</text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>&#8226; Types of Animation (overview) 
&#8211; Keyframing 
&#8211; Procedural 
&#8211; Physically-based 
 
&#8226;Animation Controls 
 
&#8226; Character Animation 
using skinning/enveloping Plan 
CERN 
12</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>Vertex Weights 
&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
From Automatic Rigging and Animation of 3D Characters.  &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
33</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226; Vertex p0 has 
weights 
w01=0.5, 
w02=0.5 
&#8226; Transform by 
T&#8217;1 and T&#8217;2 
yields p&#8217;01, p&#8217;02 
&#8226; the new position  
is p&#8217;0= 
0.5*p&#8217;1 +  
0.5*p&#8217;2 Rest (&#8220;bind&#8221;) pose  
After rotations p0 
p&#8217;0 Bone 1: T1 Bone 2: T2 Computing Vertex Positions 
p&#8217;01 p&#8217;02 &#8220;Skin&#8221;  
44</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>&#8226; This is what we do to get deformed positions 
 
 
 
&#8226; But wait... 
 
 
 
&#8226;Rotations are not handled correctly (!!!) Hmmh... 
67</text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>&#8226;Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. Linear Blend Skinning 
39</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>&#8226; Assign physical properties to objects 
&#8211; Masses, forces, etc. 
&#8226; Also procedural forces (like wind) 
&#8226; Simulate physics by solving equations of motion 
&#8211; Rigid bodies, fluids, plastic deformation, etc. 
&#8226; Realistic but difficult to control Types of Animation: Physically-Based 
v0 
m g 
10</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&#8226; Describes the motion algorithmically 
&#8226; Express animation as a function of 
small number of parameters 
&#8226; Example 
&#8211; a clock/watch with second, minute and hour hands 
&#8211; express the clock motions in terms of 
a &#8220;seconds&#8221; variable 
&#8226; the clock is animated by 
changing this variable 
&#8226; Another example: Grass in the wind, 
tree canopies, etc. Types of Animation: Procedural 
9</text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>&#8226; Physically-Based Character Animation 
&#8211; Specify keyframes, solve for physically valid motion 
that interpolates them by &#8220;spacetime optimization&#8221; 
 
&#8226; Anthony C. Fang and Nancy S. Pollard, 2003. Efficient 
Synthesis of Physically Valid Human Motion , ACM 
Transactions on Graphics 22(3) 417-426, Proc. SIGGRAPH 
2003. http://graphics.cs.cmu.edu/nsp/projects/spacetime/space
time.html Another Example 
11</text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text> 
 
 
Building 3D models and their animation controls is 
a major component of every animation pipeline. 
 
Building the controls is called &#8220;rigging&#8221;. 
17</text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; Each bone has a deformation of 
the space around it (rotation, translation) 
&#8211; What if we attach each 
vertex of the skin to a single bone? 
&#8226; Skin will be rigid, except at joints where it will 
stretch badly 
&#8211; Let&#8217;s attach a vertex to many bones at once! 
&#8226; In the middle of a limb, 
the skin points follow the bone rotation (near-
rigidly) 
&#8226; At a joint, skin is deformed according to a 
&#8220;weighted combination&#8221; of the bones SSD / Skinning 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA. 
29</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>Bind Pose cont&#8217;d 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. &#8226; To be able to deform pi 
according to Tj, we must first 
express pi in the local 
coordinate system of bone j. 
&#8211; This is where the bind pose 
bone transformations Bj come 
in. 
55</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; Embed a skeleton into a 
detailed character mesh 
&#8226; Animate &#8220;bones&#8221; 
&#8211; Change the joint 
angles over time 
&#8211; Keyframing, procedural, etc. 
&#8226; Bind skin vertices to bones 
&#8211; Animate skeleton, skin will 
move with it Skinning Characters 
Courtesy Robert C. Duvall, Duke University. License CC BY- NC-SA. Courtesy of Blender Foundation. License CC-BY. This content
is excluded from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use.
20</text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226;Basic Idea 1 : Transform each vertex pi with each 
bone as if it was tied to it rigidly. 
&#8226;Basic Idea 2 : Then blend the results using the 
weights. 
&#8220;       &#8221; Computing Vertex Positions 
p&#8217;ij is the vertex i 
transformed using 
bone j. 
Tj is the current 
transformation of bone 
j. 
p&#8217;i is the new skinned 
position of vertex i. 
41</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
&#8226; Weight properties 
&#8211; Usually want weights to be non-negative 
&#8211; Also, want the sum over all bones 
to be 1 for each vertex Vertex Weights 
35</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>Super Cool: Automatic Rigging 
From Automatic Rigging and Animation 
of 3D Characters by Baran and Popovic, 
used with permission from ACM, Inc. &#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
72</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>&#8226; Animation is (usually) specified using some form 
of low-dimensional controls  as opposed to 
remodeling the actual geometry for each frame. 
&#8211; Example: The joint angles (bone transformations) in a 
hierarchical character determine the pose 
&#8211; Example: A rigid motion is represented by 
changing the object- to-world transformation 
(rotation and translation). 
Because we are Lazy... 
Courtesy Robert C. Duvall, Duke
University. License CC BY- NC-SA.
14</text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; We&#8217;ll assign a weight wij 
for each vertex pi for each bone Bj. 
&#8211; &#8220;How much vertex i should move with bone j&#8221; 
&#8211;wij = 1 means pi is rigidly attached to bone j. 
&#8226; We&#8217;ll limit the number of bones N that can 
influence a single vertex 
&#8211;N=4 bones/vertex is a usual choice 
&#8211; Why? You most often don&#8217;t need very many. 
&#8211; Also, storage space is an issue. 
&#8211; In practice, we&#8217;ll store N   (bone index j, weight wij) 
pairs per vertex. Vertex Weights cont&#8217;d 
37</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>SSD is Not Perfect 
After rotations p0 q0 Questions? 
47</text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226; We then figure out the vertex 
weights wij. 
&#8211; How? Usually paint by hand! 
&#8211; We&#8217;ll look at much cooler 
methods in a while. Bind Pose &amp; Weights 
From Automatic Rigging and Animation of 3D Characters.
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
60</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT EECS 6.837 - Duand  That&#8217;s All for Today! 
&#8226; Further reading 
&#8211;http://www.okino.com/
conv/skinning.htm 
 
&#8226; Take a look at any 
video game &#8211; 
basically all the 
characters are 
animated using 
SSD/skinning. 
74</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; The in-betweening, was once a job for apprentice animators. 
Splines accomplish these tasks automatically. However, the 
animator still has to draw the keyframes.  This is an art form and 
precisely why the experienced animators were spared the in-
betweening work even before automatic techniques. 
&#8226; The classical paper on animation by John Lasseter from Pixar 
surveys some the standard animation techniques:   
&#8226; "Principles of Traditional Animation Applied to 3D Computer  
Graphics ,&#8220; SIGGRAPH'87 , pp. 35 -44. 
&#8226; See also The Illusion of Life:  Disney Animation, by Frank 
Thomas and Ollie Johnston.  Traditional Animation Principles 
3</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>&#8226; Undeformed vertices pi are given 
in the object space of the skin 
&#8226;Tj is in local bone coordinate system 
&#8211; according to skeleton  
hierarchy Coordinate Systems 
GNU Free Documentation License. Some rights reserved. This content is
excluded from our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
50</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>Bind Pose cont&#8217;d 
This maps pi from bind pose to the local 
coordinate system of bone j using B-1j, and 
then to world space using Tj. 
What is Tj B-1j? It is the relative 
change between the bone 
transformations between the current 
and the bind pose. 
56</text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>The Other Direction 
From Skinning Mesh Animations.
73&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; How do we describe and generate motion of 
objects in the scene? 
 
 
 
&#8226; Two very different contexts:  
&#8211; Production (offline)  
&#8226; Can be hardcoded, entire sequence know beforehand 
&#8211; Interactive (e.g. games, simulators)  
&#8226; Needs to react to user interaction, sequence not known Computer Animation 
&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information, see
http://ocw.mit.edu/help/faq-fair-use/.
6</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>&#8226; Do the usual forward kinematics  
&#8226; For each skin vertex pi 
 
 
&#8226; Note that the weights &amp; bind pose vertices are 
constant over time 
&#8211; Only matrices change  
(small number of them, one per bone) 
&#8211; This enables implementation on GPU &#8220;vertex 
shaders&#8221; 
(little information to update for each frame) Skinning Pseudocode 
64</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; This is what we do to get deformed positions Hmmh... 
65</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>Real-time enveloping with rotational regression 
Wang, Pulli, Popovic 
We learn a fast model from exported examples. 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
69</text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Shading and Material Appearance (PDF - 1.8MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec15/</lecture_pdf_url>
      <lectureno>15</lectureno>
      <slides>
        <slide>
          <slideno>12</slideno>
          <text>13 BRDF fr </text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46 Phong Examples 
&#8226; The spheres illustrate 
specular reflections as 
the direction of the 
light source and the 
exponent q (amount of 
shininess) is varied. 
</text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>&#8226; Sum of three components: 
      ideal diffuse reflection + 
      specular reflection + 
      &#8220;ambient&#8221;. 
42 The Complete Phong Model 
Surface light source </text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Another possibility: Take pictures of spheres coated 
with material, rotate light around a 1D arc 
&#8211; This gives 3DOF =&gt; isotropic materials only 
22 How Do We Obtain BRDFs? 
Matusik et al. </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Questions? </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text> 
 
&#8226; Parameters 
&#8211;ks: specular reflection coefficient 
&#8211;q : specular reflection exponent 
39 The Phong Specular Model 
Surface &#952; &#952; Camera &#61537; r n 
l 
v 
light source </text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>&#8226; The ideal diffuse BRDF is a constant fr(l, v) = const. 
&#8211; What constant &#961;/&#960;, where &#961; is the albedo  
&#8226; Coefficient between 0 and 1 that says what fraction is reflected 
&#8211; Usually just called &#8220;diffuse color&#8221; kd 
&#8211; You have already implemented this by taking dot products 
with the normal and multiplying by the &#8220;color&#8221;!   
28 Ideal Diffuse Reflectance 
</text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226; Interpolate the average vertex normals across the 
face and use this in shading computations 
&#8211; Again, use barycentric interpolation! 
71 Phong Normal Interpolation (Not Phong  
Shading ) 
</text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>&#8226; Today, we only consider point light sources 
&#8211; Thus we do not need to care about solid angles 
&#8226; For multiple light sources, use linearity 
&#8211; We can add the solutions for two light sources 
&#8226; I(a+b) = I(a) + I(b) 
&#8211; We simply multiply the solution when we scale the light 
intensity 
&#8226; I(s a) = s I(a) 
4 Light Sources 
a b 
Yet again, linearity 
is our friend! </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 2D Slice at Constant Incidence 
Example: Plot of &#8220;PVC&#8221; BRDF at 55 &#176; incidence 
highlight incoming 
incoming &#8226; For a fixed incoming direction, 
view dependence is a 2D 
spherical function 
&#8211; Here a moderate specular 
component 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.&#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>&#8226;Phong Illumination Model 
44 Putting It All Together 
&#169; Leonard McMillan. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67 Observations 
Material &#8211; Red Christmas Ball Acquired data Cook-Torrance &#8226; Some materials impossible to represent with a 
single lobe 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48 Questions? </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>&#8226; This is the simplest possible parametric BRDF 
&#8211; One parameter: kd 
&#8226; (One for each RGB channel) 
29 Ideal Diffuse Reflectance 
</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>&#8226; How much light is reflected? 
&#8211; Depends on the angle &#61537;  between the ideal reflection 
direction r and the viewer direction v. 
38 The Phong Specular Model 
Surface &#952; &#952; Camera &#61537; r n 
l 
v light source </text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>&#8226; Example 
&#8211; Think of water surface as lots of tiny mirrors (microfacets) 
&#8211; &#8220;Bright&#8221; pixels are 
&#8226; Microfacets aligned with the vector between sun and eye 
&#8226; But not the ones in shadow 
&#8226; And not the ones that are occluded 
53 Microfacet Theory 
Image of sunset removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 That&#8217;s All for Today! 
Images from  the movie, &#8220;The Matrix,&#8221; removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; Single Point Light Source 
&#8211;kd: diffuse coefficient (color) 
&#8211;n: Surface normal. 
&#8211;l: Light direction. 
&#8211; Li: Light intensity  
&#8211; r: Distance to source 
&#8211; Lo: Shaded color 
31 Ideal Diffuse Reflectance Math 
Surface &#61672; 
l n r 
 We do not want light from below the 
surface! From now on we always 
assume (on this lecture) that dot 
products are clamped to zero and 
skip writing out the max(). Do not forget 
to normalize 
your n  and l! light source </text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>&#8226; Value of BRDF at (L,V) is a product of 
&#8211; number of mirrors oriented halfway between L and V 
57 Microfacet Theory </text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>1 MIT EECS 6.837 &#8211; Matusik  
Shading &amp; Material Appearance   
 
 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see  http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59 Microfacet Theory 
&#8226; Value of BRDF at (L,V) is a product of 
&#8211; number of mirrors oriented halfway between L and V 
&#8211; ratio of the un(shadowed/masked) mirrors 
&#8211; Fresnel coefficient </text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226; When keeping l and v fixed, if rotation of surface 
around the normal does not change the reflection, the 
material is called isotropic 
&#8226; Surfaces with strongly oriented microgeometry 
elements are anisotropic 
&#8226; Examples:  
&#8211; brushed metals, 
&#8211; hair, fur, cloth, velvet 
19 Isotropic vs. Anisotropic 
Westin et.al 92 </text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Spotlight Geometry 
Adapted from 
POVRAY documentation hotspot angle (direction d) </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>24 Questions? </text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; Value of BRDF at (L,V) is a product of 
&#8211; number of mirrors oriented halfway between L and V 
&#8211; ratio of the un(shadowed/masked) mirrors 
58 Microfacet Theory </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>&#8226; Some facets are hidden from viewpoint 
&#8226; Some are hidden from the light 
60 Shadowing and Masking 
hidden from viewpoint hidden from viewpoint 
</text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>&#8226; Ideal diffuse reflectors reflect light according to 
Lambert&#8217;s cosine law 
&#8211; The reflected light varies with cosine even if distance to 
light source is kept constant 
27 Ideal Diffuse Reflectance 
Remembering that incident irradiance depends on cosine, 
what is the BRDF of an ideally diffuse surface? </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; All materials seen so far are the same everywhere 
&#8211; In other words, we are assuming the BRDF is independent 
of the surface point x 
&#8211; No real reason to make that assumption 
&#8211; More next time 
73 Spatial Variation 
&#169; ACM. All rights reserved. This content is excluded
from our Creative Commons license. For more
information, see http://ocw.mit.edu/help/faq-fair-use /.Courtesy of Fredo Durand. Used with permission.&#169; source unknown. All rights reserved. This
content is excluded from our Creative
Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>&#8226; BRDFs can be measured from real data 
&#8211; But tabulated 4D data is too cumbersome for most uses 
&#8226; Therefore, parametric BRDF models represent the 
relationship between incident and outgoing light by 
some mathematical formula 
&#8211; The appearance can then be tuned by setting parameters 
&#8226; &#8220;Shininess&#8221;, &#8220;anisotropy&#8221;, etc. 
&#8211; Physically-based or Phenomenological 
&#8211; They can model with measured data (examples later) 
&#8226; Popular models: Diffuse, Blinn- Phong, Cook-
Torrance, Lafortune, Ward, Oren-Nayar, etc. 
23 Parametric BRDFs </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226; Assume surface reflects equally in all directions. 
&#8226; An ideal diffuse surface is, at the microscopic level, a 
very rough surface. 
&#8211; Example: chalk, clay, some paints 
25 Ideal Diffuse Reflectance 
Surface 
</text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 BRDF fr 
&#8226; Relates incident irradiance from 
every direction to outgoing light. 
How? 
 
 
&#8226; Let&#8217;s combine with what 
we know already of pointlights: 
l = light direction 
(incoming) 
v = view direction 
(outgoing)  
</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; One possibility: Gonioreflectometer 
&#8211; 4 degrees of freedom 
21 How do we obtain BRDFs? 
Source: Greg Ward 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>&#8226; Pointlights with non-uniform directional emission 
&#8226; Usually symmetric about a central 
direction d, with angular falloff 
&#8211; Often two angles 
&#8226; &#8220;Hotspot&#8221; angle: 
No attenuation within the central cone  
&#8226; &#8220;Falloff&#8221; angle: Light attenuates 
from full intensity to zero intensity 
between the hotspot and falloff 
angles 
 
&#8226; Plus your favorite distance 
falloff curve 9 Spotlights 
d </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>&#8226; The specular reflection distribution 
is usually called a &#8220;lobe&#8221; 
&#8211; For Phong, its shape is  
41 Terminology: Specular Lobe 
Surface 
light source </text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>20 Demo </text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Ideal diffuse reflectors reflect light according to 
Lambert&#8217;s cosine law 
&#8211; The reflected light varies with cosine even if distance to 
light source is kept constant 
26 Ideal Diffuse Reflectance 
</text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>&#8226; Model surface by tiny mirrors 
[Torrance &amp; Sparrow 1967]  
54 Microfacet Theory </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Quantifying Reflection &#8211; BRDF 
&#8226; Bidirectional Reflectance 
Distribution Function 
&#8226; Ratio of light coming from one 
direction that gets reflected in 
another direction 
&#8211; Pure reflection, assumes no 
light scatters into the 
material 
 
&#8226; Focuses on angular aspects, not 
spatial variation of the material 
&#8226;How many dimensions? 
Incoming  
direction 
Outgoing  
direction &#169; ACM. All rights reserved. This content is excluded from
our Creative Commons license. For more information,
see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 BRDF fr 
</text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>&#8226; The amount of light energy received by a surface 
depends on incoming angle 
&#8211; Bigger at normal incidence, even if distance is const. 
&#8226; Similar to winter/summer difference 
&#8226; How exactly? 
&#8211; Cos &#952; law 
&#8211; Dot product with normal 
6 Incoming Irradiance 
Surface &#952; n 
</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
6.837 Computer Graphics
Fall 2012
For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; Real glossy materials usually deviate significantly 
from ideal mirror reflectors 
&#8211; Highlight is blurry 
&#8226; They are not ideal diffuse surfaces either &#8230; 
36 Non-ideal Reflectors 
</text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>&#8226; Represents the reflection of all indirect illumination. 
&#8226; This is a total hack! 
&#8226; Avoids the complexity of 
indirect (&#8220;global&#8221;) illumination 
43 Ambient Illumination 
</text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>&#8226; Develop BRDF models by imposing simplifications 
[Torrance-Sparrow 67 ], [Blinn 77], [Cook-Torrance 
81], [Ashikhmin et al. 2000 ] 
 
&#8226; Model the distribution p(H) of 
microfacet normals 
&#8211; Also, statistical models 
for shadows and masking 
61 
Microfacet Theory-based Models 
spherical plot of a 
Gaussian-like p(H) </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>&#8226; Uses the &#8220;halfway vector&#8221; h between l and v. 
49 Blinn-Torrance Variation of Phong 
Surface l n 
Camera 
v h 
&#61538; 
Light source </text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>&#8226; Value of BRDF at (L,V) is a product of 
&#8211; number of mirrors oriented halfway between L and V 
56 Microfacet Theory </text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>66 Dark Blue Paint 
Acquired data Cook-Torrance 
Material &#8211; Dark blue paint Finding the BRDF model parameters that best reproduce the real material Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Input for realistic rendering 
&#8211; Geometry, Lighting and Materials 
&#8226; Material appearance 
&#8211; Intensity and shape of highlights 
&#8211; Glossiness 
&#8211; Color 
&#8211; Spatial variation, i.e., texture (next Tuesday) 
2 Lighting and Material Appearance 
Slide Addy Ngan &#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>68 Adding a Second Lobe 
Material &#8211; Red Christmas Ball 
&#8226; Some materials impossible to represent with a 
single lobe 
Cook-Torrance 2 lobes Acquired data 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15 BRDF fr 
&#8226; Relates incident irradiance from 
every direction to outgoing light. 
How? 
l = light direction 
(incoming) 
v = view direction 
(outgoing)  </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51 
Half Vector Lobe is Better 
&#8226; More consistent with what is observed in 
measurements ( Ngan, Matusik, Durand 
2005) 
Example: Plot of &#8220;PVC&#8221; BRDF at 55 &#176; incidence Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>65 Dark Blue Paint 
Blinn-Phong 
Material &#8211; Dark blue paint Acquired data 
Finding the BRDF model parameters that best reproduce the real material Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>&#8226; Increasing specularity near grazing angles. 
&#8211; Most BRDF models account for this. 
47 Fresnel Reflection 
Source: Lafortune et al. 97 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Questions? T. Weyrich  et al., Fabricating 
Microgeometry  for Custom Surface 
Reflectance, SIGGRAPH 2009  
Images of Fig. 1 and Fig. 6 in Weyrich T. et al, "Fabricating Microgeometry for Custom Surface Reflectance."
SIGGRAPH '09 ACM SIGGRAPH 2009 papers; Article No. 32 --removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>&#8226; 1/r2 fall-off for isotropic point lights 
&#8211; Why? An isotropic point light 
outputs constant power per solid 
angle (&#8220;into all directions&#8221;) 
&#8211; Must have same power in all 
concentric spheres 
&#8226; Sphere&#8217;s surface area grows with r2 =&gt; energy obeys 1/r2 
&#8226; &#8230; but in graphics we often cheat with or ignore this.  
&#8211; Why? Ideal point lights are kind of harsh 
&#8226; Intensity goes to infinity when you get close &#8211; not great! 
&#8211; In particular, 1/(ar2+br+c) is popular 
5 Intensity as Function of Distance 
r1 r2 </text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>&#8226; &#8220;Pointlights that are infinitely far&#8221; 
&#8211; No falloff, just one direction and one intensity 
 
 
&#8211;Iin is the irradiance at surface point x 
from the directional light 
&#8211;Ilight is the &#8220;intensity&#8221; of the light 
&#8211; &#952; is the angle between light direction l  
and surface normal n 
&#8226; Only depends on n, not x! 
8 Directional Lights 
Surface &#952; n 
x l 
</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>&#8226; &#961;s is the specular coefficient (3 numbers RGB) 
&#8226; D is the microfacet distribution  
&#8211; &#948; is the angle between the half vector H and the normal N 
&#8211; m defines the roughness (width of lobe) 
&#8226; G is the shadowing and masking term 
&#8226; Need to add a diffuse term 
62 Full Cook-Torrance Lobe 
</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226; Reflection angle = light angle 
&#8211; Both R &amp; L have to lie on one plane  
&#8226;R = &#8211; L + 2 (L &#183; N) N 
34 Recap: How to Get Mirror Direction 
R L 
&#952; L &#952; R N 
L N N L N N 
-L light source </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>&#8226; Simple Empirical Reasoning for Glossy Materials 
&#8211; We expect most of the reflected light to travel in the 
direction of the ideal mirror ray. 
&#8211; However, because of microscopic surface variations we 
might expect some of the light to be reflected just slightly 
offset from the ideal reflected ray.  
&#8211; As we move farther and farther, in the angular sense, from 
the reflected ray, we expect to see less light reflected.  
37 Non-ideal Reflectors 
</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>&#8226; Reflection is only at mirror angle 
&#8226; View dependent 
&#8211; Microscopic surface elements are usually oriented in the 
same direction as the surface itself. 
&#8211; Examples: mirrors, highly polished metals. 
33 Ideal Specular Reflectance 
Surface &#952; l n 
r &#952; 
light source </text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52 Questions? </text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64 BRDF Examples from Ngan et al.  
Acquired data 
Material &#8211; Dark blue paint 
Lighting 
Courtesy of Mitsubishi Electric Researh Laboratories, Inc. Used with permission.</text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>&#8226; Let&#8217;s combine this with the 1/r2 fall-off: 
 
 
&#8211;Iin is the irradiance (&#8220;intensity&#8221;) at 
surface point x 
&#8211;Ilight is the &#8220;intensity&#8221; of the light 
&#8211; &#952; is the angle between light direction l  
and surface normal n 
&#8211; r is the distance between light and x. 
7 Incoming Irradiance for Pointlights 
Surface &#952; n 
x l 
</text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>&#8226; Light only reflects to the mirror direction 
&#8226; A Dirac delta multiplied by a specular coefficient ks 
 
&#8226; Not very useful for point lights, only for reflections 
of other surfaces 
&#8211; Why? You cannot really see a mirror reflection of an 
infinitely small light! 
35 Ideal Specular BRDF </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>&#8226; Effect of q &#8211; the specular reflection exponent 
40 The Phong Model 
</text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>&#8226;Phong Illumination Model 
 
 
 
&#8226;Is it physically based? 
&#8211;No, does not even conserve energy, 
may well reflect more energy than what goes in 
&#8211;Furthermore, it does not even conform to the BRDF model 
directly (we are taking the proper cosine for diffuse, but 
not for specular) 
&#8211;And ambient was a total hack 
45 Putting It All Together 
</text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>&#8226; Value of BRDF at (L,V) is a product of 
&#8211; number of mirrors oriented halfway between L and V 
55 Microfacet Theory </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>32 Questions? </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; &#8220;Designer BRDFs&#8221; by Ashikhmin et al.  
63 Questions? 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226;A Data-Driven Reflectance Model, SIGGRAPH 
2003 
&#8211; The data is available 
http://people.csail.mit.edu/wojciech/BRDFDatabase/ 
69 Image-Based Acquisition 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>&#8226; Single Point Light Source 
&#8211;kd: diffuse coefficient (color) 
&#8211;n: Surface normal. 
&#8211;l: Light direction. 
&#8211; Li: Light intensity  
&#8211; r: Distance to source 
&#8211; Lo: Shaded color 
30 Ideal Diffuse Reflectance Math 
Surface &#952; 
l n r 
light source </text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50 
Lobe Comparison 
Half vector lobe Mirror lobe &#8226; Half vector lobe 
&#8211; Gradually narrower when approaching grazing 
&#8226; Mirror lobe 
&#8211; Always circular </text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>18 Demo </text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; We will not be too formal in this class 
&#8226; Issues we will not really care about 
&#8211; Directional quantities vs. integrated over all directions 
&#8211; Differential terms: per solid angle, per area 
&#8211; Power? Intensity? Flux? 
 
&#8226; Color 
&#8211; All math here is for a single wavelength only; we will 
perform computations for R, G, B separately 
&#8226; Do not panic, that just means 
we will perform every operation three times, that is all 
3 Unit Issues - Radiometry </text>
        </slide>
      </slides>
    </lecture>
    <lecture>
      <lecture_title>Introduction and Course Overview (PDF - 2.5MB)</lecture_title>
      <lecture_pdf_url>https://ocw.mit.edu/courses/6-837-computer-graphics-fall-2012/resources/mit6_837f12_lec00/</lecture_pdf_url>
      <lectureno>00</lectureno>
      <slides>
        <slide>
          <slideno>75</slideno>
          <text>76 OpenGL high-level pseudocode 
&#8226;Initialize  
&#8211;(get graphics context, etc.) 
&#8226;For each frame 
&#8211;Manage UI 
&#8211;Set appropriate viewpoint 
&#8211;Set light source directions 
&#8211;For each triangle  
 For i=0 to 2 
 Send vertex data  </text>
        </slide>
        <slide>
          <slideno>6</slideno>
          <text>7 Video Games 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>76</slideno>
          <text>77 OpenGL is a state machine 
&#8226; Each command changes the state 
&#8211; But glVertex  also &#8220;pushes&#8221; data 
&#8226; For example, glColor3f changes the current color.  
&#8211; The color remains valid until we call glColor xx again 
&#8211; Use it before each vertex to get per-vertex color.  
&#8226; Other state to manage lighting and other 
rendering aspects 
&#8226; Can make it hard to debug 
&#8226;(Note: This is conceptually simple, but not quite how you write 
efficient code these days.) </text>
        </slide>
        <slide>
          <slideno>41</slideno>
          <text>42 Animation: Keyframing 
ACM &#169; 1987 &#8220;Principles of traditional animation 
applied to 3D computer animation&#8221;  
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>77</slideno>
          <text>78 Assignment 0 
&#8226; Read a file with triangle mesh data 
&#8211; Including mesh normals 
&#8226; Display it using OpenGL 
&#8211; Colors, simple movement 
 
&#8226; Due next Wednesday! 
</text>
        </slide>
        <slide>
          <slideno>68</slideno>
          <text>&#8226; You need to tell OpenGL 
&#8211; The geometry of the object 
&#8226; Vertex positions 
&#8226; Vertex normals 
&#8226; 3 x vertex makes a triangle! 
&#8211; Camera parameters 
&#8226; Field of view, aspect ratio, (depth range) 
&#8226; The &#8220;projection matrix&#8221; How to Draw? 
69Object coordinates 
World coordinates 
View coordinates 
Image coordinates Modelview 
Projection </text>
        </slide>
        <slide>
          <slideno>34</slideno>
          <text>35 Questions? </text>
        </slide>
        <slide>
          <slideno>4</slideno>
          <text>5 Movies/special effects 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>80</slideno>
          <text>&#8226; Very interdisciplinary 
&#8211; Within CS: systems, compilers, 
languages, computer architecture, 
algorithms, numerical techniques 
&#8211; Math, physics, art, perception, 
architecture, manufacturing 
&#8226; Helps you understand why the 
world looks the way it does 
&#8226; You can &#8220;see&#8221; the result 
81
What Makes Graphics Fun? 
visualparadox.com Image removed due to copyright restrictions. </text>
        </slide>
        <slide>
          <slideno>38</slideno>
          <text>39Overview of the Semester 
&#8226; Modeling, Transformations 
&#8226; Animation, Color 
&#8226; Ray Casting / Ray Tracing 
&#8226; The Graphics Pipeline 
&#8226; Textures, Shadows 
&#8226; Sampling, Global Illumination </text>
        </slide>
        <slide>
          <slideno>42</slideno>
          <text>Character Animation: Skinning 
&#8226; Animate simple &#8220;skeleton&#8221; 
&#8226; Attach &#8220;skin&#8221; to skeleton 
&#8211; Skin deforms smoothly with skeleton  
&#8226; Used everywhere (games, movies) 
43Image removed due to 
copyright restrictions. 
Ilya Baran 
&#169; Ilya Baran . All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>45</slideno>
          <text>46Color 
saturation 
hue 
Courtesy of Victor Ostromoukhov.</text>
        </slide>
        <slide>
          <slideno>32</slideno>
          <text>33 Assignments 
0: Warm up (mesh display with OpenGL) 
1: Curves &amp; surfaces 
2: Hierarchical modeling, skinning 
3: Physically-based simulation 
4: Ray casting 
5: Ray tracing 
 
(more in later slides) </text>
        </slide>
        <slide>
          <slideno>72</slideno>
          <text>&#8226; What information do we need at each vertex? 
&#8211; Coordinates (3 floats) 
&#8211; Color (optional, 3 floats) 
&#8211; Normal information (optional, 3 floats) 
&#8211; Transparency (optional, 1 float) 
&#8211; More to come (texture information, shininess) 
73 Vertex data </text>
        </slide>
        <slide>
          <slideno>26</slideno>
          <text>27 Administrivia: Grading Policy 
&#8226; Assignments: 75% 
&#8211; Two-week programming assignments 
&#8211; Must be completed individually 
&#8211;No final project 
&#8226; Quiz: 10% 
&#8211; in class  
&#8226; Final Exam: 10% 
&#8211; TBA during finals week 
&#8226; Participation: 5% </text>
        </slide>
        <slide>
          <slideno>43</slideno>
          <text>44Particle system (PDE) 
&#169; ACM. All rights reserved. This content is excluded from our Creative Commons
license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>56</slideno>
          <text>57Questions? </text>
        </slide>
        <slide>
          <slideno>29</slideno>
          <text>30 The deadline is absolute 
&#8226; I mean it.  
&#8226; I do regularly give 0 for, 
&#8211;  an assignment turned in half an hour late 
&#8211; turning in the wrong file 
&#8226;  Submit early, even before you might be fully 
done </text>
        </slide>
        <slide>
          <slideno>1</slideno>
          <text>&#8226; Pixar Animation Studios, 1986 
&#8226; Director: John Lasseter 
2 Luxo Jr. 
Image of Pixar's Luxo Jr. removed due to copyright restrictions -- please see
http://www.computerhistory.org/atchm/pixars-luxo-jr/ for further details.</text>
        </slide>
        <slide>
          <slideno>49</slideno>
          <text>50Textures and Shading 
Courtesy of Jeremy Birn.</text>
        </slide>
        <slide>
          <slideno>2</slideno>
          <text>&#8226; Overview of computer graphics 
&#8226; Administrivia 
&#8226; Overview of the semester 
&#8226; Overview of assignments 
&#8226; Intro to OpenGL &amp; assignment 0 
 
3 Plan </text>
        </slide>
        <slide>
          <slideno>66</slideno>
          <text>67Assignment 0 
&#8226; Read a file with triangle mesh data 
&#8211; Including mesh normals 
&#8226; Display it using OpenGL 
&#8211; Colors, simple movement 
 
&#8226; Due next Wednesday! 
</text>
        </slide>
        <slide>
          <slideno>71</slideno>
          <text>72 OpenGL Example: Viewing 
// Current matrix affects objects positions  
glMatrixMode( GL_MODELVIEW ); 
// Initialize to the identity 
glLoadIdentity();               
// Position the camera at [0,0,5], looking at 
// [0,0,0], with [0,1,0] as the up direction. 
gluLookAt(0.0, 0.0, 5.0, 
          0.0, 0.0, 0.0, 
          0.0, 1.0, 0.0); 
// Rotate by -20 degrees about [0,1,0] 
glRotated(-20.0, 0.0, 1.0, 0.0); 
     
// Draw a teapot. 
glutSolidTeapot(1.0);  </text>
        </slide>
        <slide>
          <slideno>28</slideno>
          <text>29 Administrivia: Assignments 
&#8226; Turn in code and executable (Linux) 
&#8226; Always turn in a README file 
&#8211; Describe problems, explain partially-working code 
Say how long the assignment took 
&#8226; Coding style important 
&#8211; Some assignments are cumulative 
&#8226; Collaboration policy: 
&#8211; You can chat, but code on your own 
&#8211; Acknowledge your collaboration! (in readme file) 
&#8226; Late policy: 
&#8211;The deadline is absolute: 0 if not on time 
&#8211; Due Wednesday @ 8pm 
&#8211; Extensions only considered if requested 1 week before due date 
&#8211; Medical problems must be documented </text>
        </slide>
        <slide>
          <slideno>54</slideno>
          <text>55The Graphics Pipeline 
Ray Casting 
 
For each pixel 
For each object 
 Send pixels to scene Rendering Pipeline 
 
For each triangle 
   For each projected pixel 
     Project scene to pixels 
</text>
        </slide>
        <slide>
          <slideno>18</slideno>
          <text>&#8226; Fundamentals of computer graphics algorithms 
&#8211; Will give a pretty good idea of how to implement lots 
of the things just shown 
&#8226; We will concentrate on 3D, 
not 2D illustration or image processing 
&#8226; Basics of real-time rendering 
and graphics hardware 
&#8226; Basic OpenGL 
&#8211; Not the focus, though: Means, not the end. 
&#8226; You will get C++ programming experience 
19 What you will learn in 6.837 </text>
        </slide>
        <slide>
          <slideno>58</slideno>
          <text>59Assignment 1: curves &amp; surfaces 
Bezier curves Surfaces of revolution 
Sweep surfaces </text>
        </slide>
        <slide>
          <slideno>12</slideno>
          <text>13 Visualization 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>25</slideno>
          <text>&#8226; Course website 
&#8211; Announcements 
&#8211; Slides (posted soon after each lecture) 
&#8211; Assignments, both instructions and turn- in 
&#8226; Message Board 
&#8226; Staff Email 
&#8211; Reaches all of us, preferred method of communication 
26 Administrivia: Website, Staff Email </text>
        </slide>
        <slide>
          <slideno>3</slideno>
          <text>4 What are the applications of graphics? </text>
        </slide>
        <slide>
          <slideno>60</slideno>
          <text>61Assignment 3: physics 
&#8226; Simulate cloth as a mass-spring network 
&#8211; ODE integration 
</text>
        </slide>
        <slide>
          <slideno>67</slideno>
          <text>Simple 3D with OpenGL 
68&#8226; Scene represented as 
triangles 
&#8211; A triangle is a set of 3 vertices 
&#8211; A vertex is a set of 3 floating 
point numbers (x, y, z) 
&#8226; We will use OpenGL to send 
this to the graphics card 
(GPU) 
&#8211; The GPU will do its magic to 
display the scene from the 
current viewpoint (Later, we 
will get to see how this 
happens) 
</text>
        </slide>
        <slide>
          <slideno>74</slideno>
          <text>75 OpenGL Code 
glBegin(GL_TRIANGLES); //what follows describes triangles 
glColor3d (1,1,0); //red, green and blue components=&gt;(yellow)   
glNormal3d (0, 0, 1); //normal pointing up 
glVertex3d (2,3,3); //3D position x, y, z 
glColor3d (1,0,0); 
glNormal3d (0, 0, 1);  
glVertex3d (5,3,3);  
glColor3d (1,0,1); 
glNormal3d (0, 0, 1);  
glVertex3d (3,6,3);  
glEnd();  </text>
        </slide>
        <slide>
          <slideno>5</slideno>
          <text>6 More than you would expect 
 
 
Video clip removed due to copyright restrictions -- please
see http://vimeo.com/9553622 for further details.</text>
        </slide>
        <slide>
          <slideno>81</slideno>
          <text>MIT OpenCourseWare
http://ocw.mit.edu
  6.837 Computer Graphics
   Fall 2012
  For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms .</text>
        </slide>
        <slide>
          <slideno>17</slideno>
          <text>&#8226; And why? 
18 What do you expect to learn? </text>
        </slide>
        <slide>
          <slideno>39</slideno>
          <text>40Transformations 
&#8226; Yep, good old linear algebra 
&#8226; Homogeneous coordinates 
&#8211; (Adding dimensions to make life harder) 
&#8226; Perspective 
</text>
        </slide>
        <slide>
          <slideno>9</slideno>
          <text>10 Architecture 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>7</slideno>
          <text>8 Simulation 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>37</slideno>
          <text>38Questions? </text>
        </slide>
        <slide>
          <slideno>35</slideno>
          <text>&#8226; Overview of computer graphics 
&#8226; Administrivia 
&#8226;Overview of the semester 
&#8226; Overview of assignments 
&#8226; Intro to OpenGL &amp; assignment 0 
 
36 Plan </text>
        </slide>
        <slide>
          <slideno>47</slideno>
          <text>48
Ray Tracing 
&#8226; Shade (interaction of light and material) 
&#8226; Secondary rays (shadows, reflection, refraction) 
</text>
        </slide>
        <slide>
          <slideno>63</slideno>
          <text>64Questions? </text>
        </slide>
        <slide>
          <slideno>24</slideno>
          <text>&#8226; Instructor 
&#8211; Wojciech Matusik 
25 Team </text>
        </slide>
        <slide>
          <slideno>59</slideno>
          <text>60Assignment 2: hierarchical modeling 
&#8226; Animate character skeleton  
as tree of transformations 
 
 
 
&#8226; Skinning: smooth surface deformation 
</text>
        </slide>
        <slide>
          <slideno>30</slideno>
          <text>&#8226; You can chat, but code on your own 
(we use automated plagiarism detection 
software!) 
&#8226; Use Piazza message board 
&#8226; Help others on Piazza message board (will help 
your grade!) 
&#8226; Acknowledge your collaboration (in README) 
&#8226; Talk to each other, get a community going 
&#8211; Graphics is fun! 
31 Collaboration policy </text>
        </slide>
        <slide>
          <slideno>53</slideno>
          <text>54 Global Illumination 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>57</slideno>
          <text>&#8226; Overview of computer graphics 
&#8226; Administrivia 
&#8226; Overview of the semester 
&#8226;Overview of assignments 
&#8226; Intro to OpenGL &amp; assignment 0 
 
58Plan </text>
        </slide>
        <slide>
          <slideno>44</slideno>
          <text>45&#8220;Physics&#8221; (ODEs) 
&#8226; Fire, smoke 
&#8226; Cloth 
 
&#8226; Quotes because 
we do &#8220;visual 
simulation&#8221; 
&#169; David E. Breen. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>13</slideno>
          <text>14 Medical Imaging 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>0</slideno>
          <text>6.837 &#8211; Durand  
Welcome to 
6.837 Computer Graphics 
 
Wojciech Matusik 
MIT CSAIL 
Picture: Alexis Rufatt 
Image courtesy of Nicolas Desprez on Wikipedia. License: CC-BY -SA. This content is excluded from
our Creative Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>8</slideno>
          <text>9 CAD-CAM &amp; Design 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>21</slideno>
          <text>&#8226; Many of the mathematical and algorithmic tools 
are useful in other engineering and scientific 
context 
&#8226; Linear algebra 
&#8226; Splines 
&#8226; Differential equations 
&#8226; Monte-Carlo integration 
&#8226; &#8230; 
22 Beyond computer graphics </text>
        </slide>
        <slide>
          <slideno>50</slideno>
          <text>51Sampling &amp; Antialiasing 
&#10004; 
&#10006; 
&#169; source unknown . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>55</slideno>
          <text>56The Graphics Pipeline 
&#8226; Transformations 
 
&#8226; Clipping 
 
&#8226; Rasterization 
 
&#8226; Visibility </text>
        </slide>
        <slide>
          <slideno>14</slideno>
          <text>15 Education 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>19</slideno>
          <text>&#8226; OpenGL and DirectX hacks 
&#8211; Most become obsolete every 18 months anyway! 
&#8211; Does not really matter either: Graphics is becoming all 
software again (OpenCL , Larrabee, etc.) 
&#8226; Software packages 
&#8211; CAD-CAM, 3D Studio MAX, Maya 
&#8211; Photoshop and other painting tools 
&#8226; Artistic skills 
&#8226; Game design 
20 What you will NOT learn in 6.837 </text>
        </slide>
        <slide>
          <slideno>79</slideno>
          <text>&#8226; Vertices are 3-vectors 
&#8226; Normals are 3-vectors 
&#8211; Orthogonal to surface tangent plane 
&#8211; Cross product 
&#8226; Colors are 3-vectors 
&#8226; Diffuse shading is a dot product 
&#8226; A non-bending object moving in a scene 
undergoes a rigid transformation 
&#8226; Changing the viewpoint is a linear transformation 
of the scene coordinate 
&#8226; Brush up in the review session! 
80 Linear Algebra is Everywhere </text>
        </slide>
        <slide>
          <slideno>46</slideno>
          <text>47
Ray Casting 
&#8226; For every pixel  
construct a ray from the eye  
&#8211; For every object in the scene 
&#8226; Find intersection with the ray  
&#8226; Keep if closest </text>
        </slide>
        <slide>
          <slideno>70</slideno>
          <text>&#8226;Initialize  
&#8211;(get graphics context, etc.) 
&#8226;For each frame 
&#8211;Manage UI 
&#8211;Set appropriate viewpoint 
&#8211;Set light source directions 
&#8211;For each triangle  
 For i=0 to 2 
 Send vertex data  
71 OpenGL high-level pseudocode </text>
        </slide>
        <slide>
          <slideno>16</slideno>
          <text>17 Any display 
&#8226; Computers go through OpenGL and DirectX to 
display anything 
&#8226; 2D graphics, Illustrator, Flash, Fonts 
 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>20</slideno>
          <text>&#8226; Lots of simple linear algebra 
&#8211; Get it right, it will help you a lot! 
&#8226; Some more advanced concepts 
&#8211; Homogeneous coordinates 
&#8211; Ordinary differential equations (ODEs) 
and their numerical solution 
&#8211; Sampling, antialiasing (some gentle Fourier analysis) 
&#8211; Monte-Carlo integration 
&#8226; Always in a concrete and visual context 
21 How much Math? </text>
        </slide>
        <slide>
          <slideno>11</slideno>
          <text>12 Virtual Reality 
Images removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>73</slideno>
          <text>&#8226; To compute color as a function of light direction 
&#8226; Simplest: Diffuse or Lambert model 
&#8211; Intensity = dot product (normal, light direction) 
74 Why normals? 
Surface 
Normal 
Light direction Light 
source </text>
        </slide>
        <slide>
          <slideno>62</slideno>
          <text>&#8226; Shadows, reflection, refraction 
 
&#8226; + flexible extension 
63Assignment 5: ray tracing 
</text>
        </slide>
        <slide>
          <slideno>22</slideno>
          <text>23 Questions? </text>
        </slide>
        <slide>
          <slideno>15</slideno>
          <text>16 Geographic Info Systems &amp; GPS 
Image removed due to copyright restrictions.</text>
        </slide>
        <slide>
          <slideno>33</slideno>
          <text>&#8226; No textbook is required 
&#8226; Recommendations 
&#8211;3D Computer Graphics  (Watt) 
&#8211;3D Computer Graphics: A Mathematical 
Introduction with OpenGL  (Buss) 
&#8226;There is a free online version  available 
from Books24x7 
&#8211;Real-Time Rendering, 3rd ed.  (Akenine-
M&#246;ller, Haines, Hoffman) 
&#8211;Fundamentals of Computer Graphics, 3rd 
ed. (Shirley, Marschner) 
34 Textbooks </text>
        </slide>
        <slide>
          <slideno>23</slideno>
          <text>&#8226; Overview of computer graphics 
&#8226;Administrivia 
&#8226; Overview of the semester 
&#8226; Overview of assignments 
&#8226; Intro to OpenGL &amp; assignment 0 
 
24 Plan </text>
        </slide>
        <slide>
          <slideno>40</slideno>
          <text>41Modeling 
&#8226; Curves and surfaces 
&#8226; Subdivision surfaces 
</text>
        </slide>
        <slide>
          <slideno>51</slideno>
          <text>52Shadows 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/.
</text>
        </slide>
        <slide>
          <slideno>64</slideno>
          <text>&#8226; Overview of computer graphics 
&#8226; Administrivia 
&#8226; Overview of the semester 
&#8226; Overview of assignments 
&#8226;Intro to OpenGL &amp; assignment 0 
 
65Plan </text>
        </slide>
        <slide>
          <slideno>10</slideno>
          <text>11 Video removed due to copyright restrictions --  please see "The Light of Mies van der Rohe "
for further details, available at http://graphics.ucsd.edu/~henrik/animations/.</text>
        </slide>
        <slide>
          <slideno>61</slideno>
          <text>62Assignment 4: ray casting 
&#8226; Cast rays from the viewpoint 
&#8226; Intersect with scene primitives 
</text>
        </slide>
        <slide>
          <slideno>78</slideno>
          <text>&#8226; Shadows 
&#8226; Shininess 
&#8226; Texture 
&#8226; Etc.  
 
&#8226; Be patient, you will have plenty enough 
79 What is missing? </text>
        </slide>
        <slide>
          <slideno>69</slideno>
          <text>70 Questions? </text>
        </slide>
        <slide>
          <slideno>36</slideno>
          <text>37 How do you make this picture? 
&#8226; Modeling 
&#8211; Geometry 
&#8211; Materials 
&#8211; Lights 
&#8226; Animation 
&#8211; Make it move 
&#8226; Rendering 
&#8211; I.e., draw the picture! 
&#8211; Lighting, shadows, textures... Semester 
&#169; Remedy Enterainment . All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use /.</text>
        </slide>
        <slide>
          <slideno>65</slideno>
          <text>&#8226; OpenGL is an API that allows you to send 
commands to the graphics card to draw 2D or 3D 
scenes 
&#8226; At the beginning of the semester, we will use 
OpenGL as a black box to display 3D content 
&#8226; Later, we will see what is under the hood 
66Simple 3D with OpenGL </text>
        </slide>
        <slide>
          <slideno>31</slideno>
          <text>&#8226;The assignments are a lot of work. Really. 
&#8211; Start early! 
 
32 Administrivia: Assignments </text>
        </slide>
        <slide>
          <slideno>48</slideno>
          <text>49 Ray Tracing 
&#8226; Original Ray-traced 
image by Whitted 
 
 
 
 
&#8226; Image computed using 
the Dali ray tracer by 
Henrik Wann Jensen 
&#8226; Environment map by 
Paul Debevec 
&#169; source unknown. All rights reserved. This content is excluded from our Creative
Commons license. For more information, see http://ocw.mit.edu/help/faq-fair-use/ .
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>52</slideno>
          <text>53 Traditional Ray Tracing 
Courtesy of Henrik Wann Jensen. Used with permission.</text>
        </slide>
        <slide>
          <slideno>27</slideno>
          <text>28 Administrivia: Prerequisites 
&#8226; Not strictly enforced 
&#8226; All assignments are in C++ 
&#8211;Optional review/introductory session 
 
&#8226; Calculus, Linear Algebra 
&#8211; Solving equations, derivatives, integral 
&#8211; vectors, matrices, basis, solving systems of equations 
&#8211;Optional review/introductory session 
    
     
 </text>
        </slide>
      </slides>
    </lecture>
    <videos>
      <video>
        <video_url/>
        <video_title/>
        <transcript>
          <slice>
            <text_slice/>
            <time_slice/>
          </slice>
        </transcript>
      </video>
    </videos>
  </lectures>
</doc>
